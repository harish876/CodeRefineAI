[
    {
        "question_id": 131,
        "optimized_code": "```python\nclass Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        n = len(s)\n        dp = [[False] * n for _ in range(n)]\n\n        for i in range(n - 1, -1, -1):\n            for j in range(i, n):\n                if s[i] == s[j] and (j - i <= 2 or dp[i + 1][j - 1]):\n                    dp[i][j] = True\n\n        res = []\n\n        def backtrack(i, curr):\n            if i == n:\n                res.append(curr[:])\n                return\n\n            for j in range(i, n):\n                if dp[i][j]:\n                    curr.append(s[i:j + 1])\n                    backtrack(j + 1, curr)\n                    curr.pop()\n\n        backtrack(0, [])\n        return res\n```"
    },
    {
        "question_id": 132,
        "optimized_code": "```python\nfrom functools import lru_cache\n\nclass Solution:\n    def minCut(self, s: str) -> int:\n        n = len(s)\n        is_palindrome = [[False] * n for _ in range(n)]\n\n        for i in range(n):\n            is_palindrome[i][i] = True\n\n        for i in range(n - 1):\n            if s[i] == s[i + 1]:\n                is_palindrome[i][i + 1] = True\n\n        for length in range(3, n + 1):\n            for i in range(n - length + 1):\n                j = i + length - 1\n                if s[i] == s[j] and is_palindrome[i + 1][j - 1]:\n                    is_palindrome[i][j] = True\n\n        @lru_cache(None)\n        def f(i):\n            if i == n:\n                return -1\n            \n            min_cuts = float('inf')\n            for j in range(i, n):\n                if is_palindrome[i][j]:\n                    min_cuts = min(min_cuts, 1 + f(j + 1))\n            return min_cuts\n\n        return f(0)\n```"
    },
    {
        "question_id": 135,
        "optimized_code": "```python\nclass Solution:\n    def candy(self, ratings: List[int]) -> int:\n        n = len(ratings)\n        candies = [1] * n\n\n        # Left to right pass\n        for i in range(1, n):\n            if ratings[i] > ratings[i - 1]:\n                candies[i] = candies[i - 1] + 1\n\n        # Right to left pass\n        for i in range(n - 2, -1, -1):\n            if ratings[i] > ratings[i + 1]:\n                candies[i] = max(candies[i], candies[i + 1] + 1)\n\n        return sum(candies)\n```"
    },
    {
        "question_id": 137,
        "optimized_code": "```python\nclass Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        result = 0\n        for num in nums:\n            result ^= num\n        return result\n```"
    },
    {
        "question_id": 138,
        "optimized_code": "```python\n\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        old_to_new = {None:None}\n        \n        old = head\n        while old:\n            new = Node(old.val)\n            old_to_new[old] = new\n            old = old.next\n        \n        old = head\n        while old:\n            new = old_to_new[old]\n            new.next = old_to_new[old.next]\n            new.random = old_to_new[old.random]\n            old = old.next\n        \n        return old_to_new[head]\n```"
    },
    {
        "question_id": 140,
        "optimized_code": "```python\nfrom typing import List\n\nclass Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\n        word_set = set(wordDict)\n        dp = [[] for _ in range(len(s) + 1)]\n        dp[0] = [\"\"]\n\n        for i in range(1, len(s) + 1):\n            for j in range(i):\n                word = s[j:i]\n                if word in word_set and dp[j]:\n                    for sentence in dp[j]:\n                        dp[i].append((sentence + \" \" + word).strip())\n\n        return dp[len(s)]\n```"
    },
    {
        "question_id": 134,
        "optimized_code": "```python\nclass Solution:\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\n        n = len(gas)\n        total_gas = 0\n        curr_gas = 0\n        start_index = 0\n\n        for i in range(n):\n            total_gas += gas[i] - cost[i]\n            curr_gas += gas[i] - cost[i]\n\n            if curr_gas < 0:\n                curr_gas = 0\n                start_index = i + 1\n        \n        return start_index if total_gas >= 0 else -1\n```"
    },
    {
        "question_id": 228,
        "optimized_code": "```python\nclass Solution:\n    def summaryRanges(self, nums: List[int]) -> List[str]:\n        result = []\n        if not nums:\n            return result\n\n        def format_range(arr):\n            if len(arr) == 1:\n                return str(arr[0])\n            else:\n                return f\"{arr[0]}->{arr[-1]}\"\n\n        small_arr = [nums[0]]\n        prev = nums[0]\n\n        for num in nums[1:]:\n            if num == prev + 1:\n                small_arr.append(num)\n            else:\n                result.append(format_range(small_arr))\n                small_arr = [num]\n\n            prev = num\n\n        result.append(format_range(small_arr))\n\n        return result\n```"
    },
    {
        "question_id": 229,
        "optimized_code": "```python\nclass Solution:\n    def majorityElement(self, nums: List[int]) -> List[int]:\n        n1=None\n        c1=0\n        n2=None\n        c2=0\n        for num in nums:\n            if n1==num:\n                c1+=1\n            elif n2==num:\n                c2+=1\n            elif c1==0:\n                n1=num\n                c1=1\n            elif c2==0:\n                n2=num\n                c2=1\n            else:\n                c1-=1\n                c2-=1\n        c1=0\n        c2=0\n        for num in nums:\n            if num==n1:\n                c1+=1\n            if num==n2:\n                c2+=1\n        ans=[]\n        if c1>len(nums)//3:\n            ans.append(n1)\n        if c2>len(nums)//3 and n1!=n2:\n            ans.append(n2)\n        return ans\n```"
    },
    {
        "question_id": 230,
        "optimized_code": "```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:\n        stack = []\n        cur = root\n        while stack or cur:\n            while cur:\n                stack.append(cur)\n                cur = cur.left\n            cur = stack.pop()\n            k-=1\n            if k==0:\n                return cur.val\n            cur = cur.right\n        return -1\n```"
    },
    {
        "question_id": 231,
        "optimized_code": "```python\nclass Solution:\n    def isPowerOfTwo(self, n: int) -> bool:\n        return n > 0 and (n & (n - 1)) == 0\n```"
    },
    {
        "question_id": 123,
        "optimized_code": "```python\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        n = len(prices)\n        dp = [[[0 for _ in range(3)] for _ in range(2)] for _ in range(2)]\n\n        for i in range(n - 1, -1, -1):\n            for j in range(2):\n                for k in range(1, 3):\n                    if j == 0:\n                        dp[i % 2][j][k] = max(-prices[i] + dp[(i + 1) % 2][1][k], 0 + dp[(i + 1) % 2][0][k])\n                    else:\n                        dp[i % 2][j][k] = max(+prices[i] + dp[(i + 1) % 2][0][k - 1], 0 + dp[(i + 1) % 2][1][k])\n\n        return dp[0][0][2]\n```"
    },
    {
        "question_id": 125,
        "optimized_code": "```python\nclass Solution:\n    def isPalindrome(self, s: str) -> bool:\n        l, r = 0, len(s) - 1\n        while l < r:\n            while l < r and not s[l].isalnum():\n                l += 1\n            while l < r and not s[r].isalnum():\n                r -= 1\n            if s[l].casefold() != s[r].casefold():\n                return False\n            l += 1\n            r -= 1\n        return True\n```"
    },
    {
        "question_id": 128,
        "optimized_code": "```python\nclass Solution:\n    def longestConsecutive(self, nums: List[int]) -> int:\n        numset = set(nums)\n        res = 0\n        for n in nums:\n            # check if n is a start of  seq\n            if (n-1) not in numset:\n                op = 0\n                while (n+op) in numset:\n                    op+=1\n                res = max(res,op)\n        return res\n```"
    },
    {
        "question_id": 130,
        "optimized_code": "```python\nclass Solution:\n    def solve(self, board: List[List[str]]) -> None:\n        \"\"\"\n        Do not return anything, modify board in-place instead.\n        \"\"\"\n        if not board:\n            return\n\n        M, N = len(board), len(board[0])\n\n        def dfs(i, j):\n            if i < 0 or i >= M or j < 0 or j >= N or board[i][j] != 'O':\n                return\n            \n            board[i][j] = 'T'  # Temporarily mark as visited\n\n            dfs(i + 1, j)\n            dfs(i - 1, j)\n            dfs(i, j + 1)\n            dfs(i, j - 1)\n\n        # 1. Mark 'O's connected to the boundaries as 'T'\n        for i in range(M):\n            if board[i][0] == 'O':\n                dfs(i, 0)\n            if board[i][N - 1] == 'O':\n                dfs(i, N - 1)\n\n        for j in range(N):\n            if board[0][j] == 'O':\n                dfs(0, j)\n            if board[M - 1][j] == 'O':\n                dfs(M - 1, j)\n\n        # 2. Flip remaining 'O's to 'X' and 'T's back to 'O'\n        for i in range(M):\n            for j in range(N):\n                if board[i][j] == 'O':\n                    board[i][j] = 'X'\n                elif board[i][j] == 'T':\n                    board[i][j] = 'O'\n```"
    },
    {
        "question_id": 82,
        "optimized_code": "```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        fake = ListNode(-1)\n        fake.next = head\n        prev, curr = fake, head\n        while curr:\n            while curr.next and curr.val == curr.next.val:\n                curr = curr.next\n            if prev.next == curr:\n                prev = prev.next\n                curr = curr.next\n            else:\n                prev.next = curr.next\n                curr = prev.next\n        return fake.next\n```"
    },
    {
        "question_id": 84,
        "optimized_code": "```python\nclass Solution:\n    def largestRectangleArea(self, heights: List[int]) -> int:\n        st = []\n        area = 0\n        heights = [0] + heights + [0]\n\n        for i,a in enumerate(heights):\n            while(st and heights[st[-1]] > a):\n                rr = i\n                k = st.pop()\n                ll = st[-1]\n                h = heights[k]\n                length = rr - ll - 1 \n                area = max(area, h * length)\n\n            st.append(i)\n\n        return area\n```"
    },
    {
        "question_id": 85,
        "optimized_code": "```python\nclass Solution:\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\n        if not matrix:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        heights = [0] * n\n        max_area = 0\n        \n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == '1':\n                    heights[j] += 1\n                else:\n                    heights[j] = 0\n            \n            max_area = max(max_area, self.largestRectangleArea(heights))\n        \n        return max_area\n    \n    def largestRectangleArea(self, heights: List[int]) -> int:\n        stack = []\n        max_area = 0\n        i = 0\n        while i < len(heights):\n            if not stack or heights[i] > heights[stack[-1]]:\n                stack.append(i)\n                i += 1\n            else:\n                top = stack.pop()\n                area = heights[top] * (i if not stack else i - stack[-1] - 1)\n                max_area = max(max_area, area)\n        \n        while stack:\n            top = stack.pop()\n            area = heights[top] * (i if not stack else i - stack[-1] - 1)\n            max_area = max(max_area, area)\n        \n        return max_area\n```"
    },
    {
        "question_id": 87,
        "optimized_code": "```python\nclass Solution:\n    def isScramble(self, s1: str, s2: str) -> bool:\n        n = len(s1)\n        if n != len(s2):\n            return False\n        if s1 == s2:\n            return True\n        if sorted(s1) != sorted(s2):\n            return False\n\n        memo = {}\n\n        def solve(s1, s2):\n            if (s1, s2) in memo:\n                return memo[(s1, s2)]\n\n            if s1 == s2:\n                memo[(s1, s2)] = True\n                return True\n\n            if sorted(s1) != sorted(s2):\n                memo[(s1, s2)] = False\n                return False\n\n            n = len(s1)\n            for i in range(1, n):\n                if (solve(s1[:i], s2[:i]) and solve(s1[i:], s2[i:])) or \\\n                   (solve(s1[:i], s2[n-i:]) and solve(s1[i:], s2[:n-i])):\n                    memo[(s1, s2)] = True\n                    return True\n\n            memo[(s1, s2)] = False\n            return False\n\n        return solve(s1, s2)\n```"
    },
    {
        "question_id": 88,
        "optimized_code": "```python\nclass Solution:\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\n        \"\"\"\n        Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        p1 = m-1\n        p2 = n-1\n        p = m+n-1\n        while p2 >= 0:\n            if p1 >= 0 and nums1[p1] > nums2[p2]:\n                nums1[p] = nums1[p1]\n                p1 -= 1\n            else:\n                nums1[p] = nums2[p2]\n                p2 -= 1\n            p -= 1\n```"
    },
    {
        "question_id": 89,
        "optimized_code": "```python\nclass Solution:\n    def grayCode(self, n: int) -> List[int]:\n        result = [0]\n        for i in range(n):\n            mask = 1 << i\n            for j in range(len(result) - 1, -1, -1):\n                result.append(result[j] | mask)\n        return result\n```"
    },
    {
        "question_id": 90,
        "optimized_code": "```python\nclass Solution:\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\n        ans=[]\n        ds=[]\n\n        def findSubsets(ind:int):\n            ans.append(ds[:])\n            for i in range(ind,len(nums)):\n                if i != ind and nums[i] == nums[i-1]:\n                    continue\n                ds.append(nums[i])\n                findSubsets(i+1)\n                ds.pop()\n        nums.sort()\n        findSubsets(0)\n        return ans\n```"
    },
    {
        "question_id": 144,
        "optimized_code": "```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        ans = []\n        def solve(root):\n            if root is None:\n                return\n\n            ans.append(root.val)\n            solve(root.left)\n            solve(root.right)\n        solve(root)\n        return ans\n```"
    },
    {
        "question_id": 148,
        "optimized_code": "```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        def merge(head1, head2):\n            resultHead = ListNode(0)\n            cur = resultHead\n            while head1 and head2:\n                if head1.val < head2.val:\n                    cur.next = head1\n                    head1 = head1.next\n                else:\n                    cur.next = head2\n                    head2 = head2.next\n                cur = cur.next\n            \n            if head1:\n                cur.next = head1\n            if head2:\n                cur.next = head2\n            return resultHead.next\n\n        def findOneBeforeMiddle(head):\n            slow = head\n            fast = head.next\n            while fast and fast.next:\n                slow = slow.next\n                fast = fast.next.next\n            return slow\n        \n        if not head or not head.next:\n            return head\n\n        mid = findOneBeforeMiddle(head)\n        temp = mid.next\n        mid.next = None\n\n        head1 = self.sortList(head)\n        head2 = self.sortList(temp)\n\n        return merge(head1, head2)\n```"
    },
    {
        "question_id": 149,
        "optimized_code": "```python\nclass Solution:\n    def maxPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        if n <= 2:\n            return n\n\n        max_points = 0\n        for i in range(n):\n            slopes = {}\n            duplicates = 1\n            for j in range(i + 1, n):\n                if points[i] == points[j]:\n                    duplicates += 1\n                    continue\n\n                x1, y1 = points[i]\n                x2, y2 = points[j]\n\n                if x1 == x2:\n                    slope = float('inf')\n                else:\n                    slope = (y2 - y1) / (x2 - x1)\n\n                if slope not in slopes:\n                    slopes[slope] = 0\n                slopes[slope] += 1\n\n            max_slopes = 0\n            for slope in slopes:\n                max_slopes = max(max_slopes, slopes[slope])\n\n            max_points = max(max_points, max_slopes + duplicates)\n\n        return max_points\n```"
    },
    {
        "question_id": 150,
        "optimized_code": "```python\nclass Solution:\n    def evalRPN(self, tokens):\n        stack = []\n        for token in tokens:\n            if token == '+':\n                num2 = stack.pop()\n                num1 = stack.pop()\n                stack.append(num1 + num2)\n            elif token == '-':\n                num2 = stack.pop()\n                num1 = stack.pop()\n                stack.append(num1 - num2)\n            elif token == '*':\n                num2 = stack.pop()\n                num1 = stack.pop()\n                stack.append(num1 * num2)\n            elif token == '/':\n                num2 = stack.pop()\n                num1 = stack.pop()\n                stack.append(int(num1 / num2))\n            else:\n                stack.append(int(token))\n        return stack[0]\n```"
    },
    {
        "question_id": 153,
        "optimized_code": "```python\nclass Solution:\n    def findMin(self, arr: List[int]) -> int:\n        n = len(arr)\n        l = 0\n        h = n - 1\n\n        while l < h:\n            m = (l + h) // 2\n\n            if arr[m] > arr[h]:\n                l = m + 1\n            else:\n                h = m\n        return arr[l]\n```"
    },
    {
        "question_id": 160,
        "optimized_code": "```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        pA=headA\n        pB=headB\n        while pA!=pB:\n            pA=pA.next if pA else headB\n            pB=pB.next if pB else headA\n        return pA\n```"
    },
    {
        "question_id": 238,
        "optimized_code": "```python\nclass Solution:\n    def productExceptSelf(self, List, nums: List[int]) -> List[int]:\n        res = [1] * len(nums)\n\n        prefix = 1\n        for i in range(len(nums)):\n            res[i] = prefix\n            prefix *= nums[i]\n\n        postfix = 1\n        for i in range(len(nums) -1, -1, -1):\n            res[i] *= postfix\n            postfix *= nums[i]\n        return res\n```"
    },
    {
        "question_id": 239,
        "optimized_code": "```python\nfrom collections import deque\nclass Solution:\n    def maxSlidingWindow(self, nums: list[int], k: int) -> list[int]:\n        d = deque()\n        result = []\n\n        for i, num in enumerate(nums):\n            # Remove elements out of the window\n            while d and d[0] <= i - k:\n                d.popleft()\n\n            # Remove elements smaller than the current element\n            while d and nums[d[-1]] <= num:\n                d.pop()\n\n            d.append(i)\n\n            # Add the maximum to the result\n            if i >= k - 1:\n                result.append(nums[d[0]])\n\n        return result\n```"
    },
    {
        "question_id": 241,
        "optimized_code": "```python\nclass Solution:\n    def diffWaysToCompute(self, expression: str) -> List[int]:\n        memo = {}\n        def compute(exp):\n            if exp in memo:\n                return memo[exp]\n            \n            if exp.isdigit():\n                return [int(exp)]\n            \n            res = []\n            for i, s in enumerate(exp):\n                if s in \"+-*\":\n                    left = compute(exp[:i])\n                    right = compute(exp[i+1:])\n                    \n                    for l in left:\n                        for r in right:\n                            if s == '+':\n                                res.append(l + r)\n                            elif s == '-':\n                                res.append(l - r)\n                            else:\n                                res.append(l * r)\n            memo[exp] = res\n            return res\n\n        return compute(expression)\n```"
    },
    {
        "question_id": 242,
        "optimized_code": "```python\nclass Solution:\n    def isAnagram(self, s: str, t: str) -> bool:\n        if len(s) != len(t):\n            return False\n        sa = [0]*26\n        ta = [0]*26\n        for i in range(len(s)):\n            sa[ord(s[i])-ord('a')] += 1\n            ta[ord(t[i])-ord('a')] += 1\n        return sa==ta\n```"
    },
    {
        "question_id": 31,
        "optimized_code": "```python\nclass Solution:\n    def swap(self, nums, i, j):\n        nums[i], nums[j] = nums[j], nums[i]\n    def reverse(self, nums, i, j):\n        while i < j:\n            self.swap(nums, i, j)\n            i += 1\n            j -= 1\n            \n    def nextPermutation(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        i = len(nums) - 2\n        while i >= 0 and nums[i] >= nums[i + 1]:\n            i -= 1\n        if i >= 0:\n            j = len(nums) - 1\n            while nums[j] <= nums[i]:\n                j -= 1\n            self.swap(nums, i, j)\n        self.reverse(nums, i+1, len(nums) - 1)\n\n        return nums\n```"
    },
    {
        "question_id": 32,
        "optimized_code": "```python\nclass Solution:\n    def longestValidParentheses(self, s: str) -> int:\n        max_len = 0\n        stack = [-1]\n        for i in range(len(s)):\n            if s[i] == '(':\n                stack.append(i)\n            else:\n                stack.pop()\n                if not stack:\n                    stack.append(i)\n                else:\n                    max_len = max(max_len, i - stack[-1])\n        return max_len\n```"
    },
    {
        "question_id": 33,
        "optimized_code": "```python\nclass Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        l = 0\n        r = len(nums) - 1\n        while l <= r:\n            mid = (l + r) // 2\n            if nums[mid] == target:\n                return mid\n\n            if nums[l] <= nums[mid]:\n                if nums[l] <= target <= nums[mid]:\n                    r = mid - 1\n                else:\n                    l = mid + 1\n            else:\n                if nums[mid] <= target <= nums[r]:\n                    l = mid + 1\n                else:\n                    r = mid - 1\n        return -1\n```"
    },
    {
        "question_id": 34,
        "optimized_code": "```python\nfrom typing import List\nfrom bisect import bisect_left, bisect_right\n\nclass Solution:\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\n        l = bisect_left(nums, target)\n        if l == len(nums) or nums[l] != target:\n            return [-1, -1]\n        r = bisect_right(nums, target)\n        return [l, r - 1]\n```"
    },
    {
        "question_id": 191,
        "optimized_code": "```python\nclass Solution:\n    def hammingWeight(self, n: int) -> int:\n        count = 0\n        while n:\n            n &= (n - 1)\n            count += 1\n        return count\n```"
    },
    {
        "question_id": 198,
        "optimized_code": "```python\nclass Solution:\n    def rob(self, nums: List[int]) -> int:\n        \n        if (len(nums) == 0):\n            return 0\n        elif (len(nums) == 1):\n            return nums[0]\n        \n        rob1, rob2 = 0, 0\n        \n        for n in nums:\n            temp = max(rob1 + n, rob2)\n            rob1 = rob2\n            rob2 = temp\n        \n        return rob2\n```"
    },
    {
        "question_id": 199,
        "optimized_code": "```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\n        def dfs(root, level):\n            if not root:\n                return\n            if len(res) == level:\n                res.append(root.val)\n            dfs(root.right, level + 1)\n            dfs(root.left, level + 1)\n        res = []\n        dfs(root, 0)\n        return res\n```"
    },
    {
        "question_id": 201,
        "optimized_code": "```python\nclass Solution:\n    def rangeBitwiseAnd(self, left: int, right: int) -> int:\n        while left < right:\n            right &= (right - 1)\n        return right\n```"
    },
    {
        "question_id": 205,
        "optimized_code": "```python\nclass Solution:\n    def isIsomorphic(self, s: str, t: str) -> bool:\n        stot = {}\n        ttos = {}\n        for s_, t_ in zip(s, t):\n            if s_ in stot and stot.get(s_)!=t_:\n                return False\n            if t_ in ttos and ttos.get(t_)!=s_:\n                return False\n\n            stot[s_] = t_\n            ttos[t_] = s_\n        return True\n```"
    },
    {
        "question_id": 210,
        "optimized_code": "```python\nclass Solution:\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\n        graph = [[] for _ in range(numCourses)]\n        indegree = [0] * numCourses\n        \n        for a, b in prerequisites:\n            graph[b].append(a)\n            indegree[a] += 1\n            \n        queue = [i for i in range(numCourses) if indegree[i] == 0]\n        result = []\n        \n        while queue:\n            course = queue.pop(0)\n            result.append(course)\n            \n            for neighbor in graph[course]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    queue.append(neighbor)\n        \n        if len(result) == numCourses:\n            return result\n        else:\n            return []\n```"
    },
    {
        "question_id": 214,
        "optimized_code": "```python\nclass Solution:\n    def shortestPalindrome(self, s: str) -> str:\n        n = len(s)\n        if not s:\n            return \"\"\n        \n        combined = s + \"#\" + s[::-1]\n        n_combined = len(combined)\n        \n        lps = [0] * n_combined\n        \n        length = 0\n        i = 1\n        \n        while i < n_combined:\n            if combined[i] == combined[length]:\n                length += 1\n                lps[i] = length\n                i += 1\n            else:\n                if length != 0:\n                    length = lps[length-1]\n                else:\n                    lps[i] = 0\n                    i += 1\n                    \n        longest_palindrome_prefix_len = lps[n_combined - 1]\n        return s[longest_palindrome_prefix_len:][::-1] + s\n```"
    },
    {
        "question_id": 216,
        "optimized_code": "```python\nclass Solution:\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\n        if 45-(9-k)*(10-k)/2 < n or k*(k+1)/2 > n:\n            return []\n\n        def backtrack(comb, s, n):\n            if n == 0 and len(comb) == k:\n                output.append(comb.copy())\n                return\n            if len(comb) > k or n < 0:\n                return\n            for i in range(s, 10):\n                comb.append(i)\n                backtrack(comb, i+1, n-i)\n                comb.pop()\n\n        output = []\n        backtrack([], 1, n)\n        return output\n```"
    },
    {
        "question_id": 93,
        "optimized_code": "```python\nclass Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        path = []\n        result = []\n\n        len_s = len(s)\n\n        def is_valid_ip(s):\n            if (s[0] == '0' and len(s) > 1) or int(s) > 255:\n                return False \n            else:\n                return True\n\n        def backtracking(start_idx, point_count):\n            if point_count == 4:\n                if start_idx == len_s:\n                    result.append(\".\".join(path))\n                return\n\n            if len_s - start_idx < (4 - point_count) or len_s - start_idx > (4 - point_count) * 3:\n                return\n\n            for i in range(start_idx, min(start_idx + 3, len_s)):\n                temp = s[start_idx:i + 1]\n                if is_valid_ip(temp):\n                    path.append(temp)\n                    backtracking(i + 1, point_count + 1)\n                    path.pop()\n        \n        backtracking(0, 0)\n        return result\n```"
    },
    {
        "question_id": 127,
        "optimized_code": "```python\nfrom collections import deque\nfrom typing import List\n\nclass Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\n        wordList = set(wordList)\n\n        if endWord not in wordList:\n            return 0\n        \n        def offByOne(s, t):\n            diff = 0\n            for i in range(len(s)):\n                if s[i] != t[i]:\n                    diff += 1\n                    if diff > 1:\n                        return False\n            return diff == 1\n\n        queue = deque([(beginWord, 1)])\n        seen = {beginWord}\n        while queue:\n            word, length = queue.popleft()\n            if word == endWord:\n                return length\n\n            for nextWord in wordList:\n                if nextWord not in seen and offByOne(word, nextWord):\n                    queue.append((nextWord, length + 1))\n                    seen.add(nextWord)\n        return 0\n```"
    },
    {
        "question_id": 81,
        "optimized_code": "```python\nclass Solution:\n    def search(self, nums: List[int], target: int) -> bool:\n        left = 0\n        right = len(nums) - 1\n        while left <= right:\n            middle = (left + right) // 2\n            if nums[middle] == target:\n                return True\n            if nums[left] == nums[middle] and nums[middle] == nums[right]:\n                left += 1\n                right -= 1\n            elif nums[left] <= nums[middle]:\n                if nums[left] <= target and target < nums[middle]:\n                    right = middle - 1\n                else:\n                    left = middle + 1\n            else:\n                if target > nums[middle] and target <= nums[right]:\n                    left = middle + 1\n                else:\n                    right = middle - 1\n        return False\n```"
    },
    {
        "question_id": 151,
        "optimized_code": "```python\nclass Solution:\n    def reverseWords(self, s: str) -> str:\n        words = []\n        word = \"\"\n        for char in s:\n            if char == \" \":\n                if word:\n                    words.append(word)\n                    word = \"\"\n            else:\n                word += char\n        if word:\n            words.append(word)\n\n        result = \"\"\n        for i in range(len(words) - 1, -1, -1):\n            result += words[i]\n            if i > 0:\n                result += \" \"\n        return result\n```"
    },
    {
        "question_id": 152,
        "optimized_code": "```python\nclass Solution:\n    def maxProduct(self, nums: List[int]) -> int:\n        max_prod = float('-inf')\n        prefix, suffix = 1, 1\n        n = len(nums)\n        for i in range(n):\n            if prefix == 0: prefix = 1\n            if suffix == 0: suffix = 1\n\n            prefix *= nums[i]\n            suffix *= nums[n - i - 1]\n            max_prod = max(max_prod, prefix, suffix)\n        return max_prod\n```"
    },
    {
        "question_id": 95,
        "optimized_code": "```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def generateTrees(self, n: int) -> List[TreeNode]:\n        def dfs(l, r, memo):\n            if (l, r) in memo:\n                return memo[(l, r)]\n            if r < l:\n                return [None]\n            arr = []\n            for m in range(l, r + 1):\n                left = dfs(l, m - 1, memo)\n                right = dfs(m + 1, r, memo)\n                for lNode in left:\n                    for rNode in right:\n                        new = TreeNode(m)\n                        new.left = lNode\n                        new.right = rNode\n                        arr.append(new)\n            memo[(l, r)] = arr\n            return arr\n\n        if n == 0:\n            return []\n        memo = {}\n        res = dfs(1, n, memo)\n        return res\n```"
    },
    {
        "question_id": 96,
        "optimized_code": "```python\nclass Solution:\n    def numTrees(self, n: int) -> int:\n\n        list_ = [0]*(n + 1)\n        list_[0], list_[1] = 1,1\n        for i in range(2, n+1):\n            for j in range(1,i+1):\n                list_[i] += list_[j-1]*list_[i-j]\n\n        return list_[n]\n```"
    },
    {
        "question_id": 97,
        "optimized_code": "```python\nclass Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n\n        if len(s1) + len(s2) != len(s3):\n            return False\n\n        dp = [[False] * (len(s2) + 1) for _ in range((len(s1) + 1))]\n\n        dp[0][0] = True\n\n        for i in range(len(s1) + 1):\n            for j in range(len(s2) + 1):\n                if i == 0 and j == 0:\n                    continue\n                elif i == 0:\n                    dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\n                elif j == 0:\n                    dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\n                else:\n                    dp[i][j] = (dp[i][j - 1] and s2[j - 1] == s3[j + i - 1]) or \\\n                               (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1])\n\n        return dp[len(s1)][len(s2)]\n```"
    },
    {
        "question_id": 1,
        "optimized_code": "```python\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        num_map = {}\n        for index, num in enumerate(nums):\n            complement = target - num\n            if complement in num_map:\n                return [num_map[complement], index]\n            num_map[num] = index\n```"
    },
    {
        "question_id": 5,
        "optimized_code": "```python\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        n = len(s)\n        if n < 2:\n            return s\n        \n        longest = s[0]\n        dp = [[False] * n for _ in range(n)]\n        \n        for i in range(n):\n            dp[i][i] = True\n\n        for i in range(n - 1):\n            if s[i] == s[i+1]:\n                dp[i][i+1] = True\n                longest = s[i:i+2]\n\n        for length in range(3, n + 1):\n            for i in range(n - length + 1):\n                j = i + length - 1\n                if s[i] == s[j] and dp[i+1][j-1]:\n                    dp[i][j] = True\n                    if length > len(longest):\n                        longest = s[i:j+1]\n        \n        return longest\n```"
    },
    {
        "question_id": 6,
        "optimized_code": "```python\nclass Solution:\n    def convert(self, s: str, numRows: int) -> str:\n        if numRows <= 1:\n            return s\n\n        result = \"\"\n        n = len(s)\n        cycleLen = 2 * numRows - 2\n\n        for row in range(numRows):\n            for j in range(0, n + cycleLen, cycleLen):\n                idx1 = j + row\n                if idx1 < n:\n                    result += s[idx1]\n                \n                if row != 0 and row != numRows - 1:\n                    idx2 = j + cycleLen - row\n                    if idx2 < n:\n                        result += s[idx2]\n\n        return result\n```"
    },
    {
        "question_id": 8,
        "optimized_code": "```python\nclass Solution:\n    def myAtoi(self, s: str) -> int:\n        negative = False\n        start_digit = False\n        result = 0\n        INT_MAX = 2**31 - 1\n        INT_MIN = -2**31\n        \n        for char in s:\n            if char == \" \" and not start_digit:\n                continue\n            \n            if char == \"-\" and not start_digit:\n                negative = True\n                start_digit = True\n                continue\n            elif char == \"+\" and not start_digit:\n                start_digit = True\n                continue\n            \n            if char.isdigit():\n                digit = int(char)\n                if result > INT_MAX // 10 or (result == INT_MAX // 10 and digit > 7):\n                    return INT_MAX if not negative else INT_MIN\n                result = result * 10 + digit\n                start_digit = True\n                continue\n            \n            # If a non-digit character is encountered after starting to read digits\n            if start_digit:\n                break\n            \n            # If the character is invalid at the start (non-digit and not a sign)\n            if not char.isdigit() and not start_digit:\n                return 0\n        \n        if negative:\n            result = -result\n        \n        # Clamp the result to the 32-bit integer range\n        if result < INT_MIN:\n            return INT_MIN\n        if result > INT_MAX:\n            return INT_MAX\n        return result\n```"
    },
    {
        "question_id": 309,
        "optimized_code": "```python\nclass Solution:\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        max_profit = 0\n        min_price = float('inf')\n        for price in prices:\n            min_price = min(min_price, price)\n            profit = price - min_price\n            max_profit = max(max_profit, profit)\n        return max_profit\n```"
    },
    {
        "question_id": 299,
        "optimized_code": "```python\nclass Solution:\n    def getHint(self, secret: str, guess: str) -> str:\n        counts = {}\n        bulls = 0\n        cows = 0\n\n        for i in range(len(secret)):\n            if secret[i] == guess[i]:\n                bulls += 1\n            else:\n                counts[secret[i]] = counts.get(secret[i], 0) + 1\n\n        for i in range(len(secret)):\n            if secret[i] != guess[i]:\n                if guess[i] in counts and counts[guess[i]] > 0:\n                    cows += 1\n                    counts[guess[i]] -= 1\n\n        return f'{bulls}A{cows}B'\n```"
    },
    {
        "question_id": 301,
        "optimized_code": "```python\nfrom typing import List\n\nclass Solution:\n    def removeInvalidParentheses(self, s: str) -> List[str]:\n        def is_valid(s):\n            count = 0\n            for char in s:\n                if char == '(':\n                    count += 1\n                elif char == ')':\n                    count -= 1\n                if count < 0:\n                    return False\n            return count == 0\n\n        def bfs(s):\n            visited = {s}\n            queue = [s]\n            result = []\n            found = False\n\n            while queue:\n                curr = queue.pop(0)\n                if is_valid(curr):\n                    result.append(curr)\n                    found = True\n\n                if found:\n                    continue\n\n                for i in range(len(curr)):\n                    if curr[i] in ('(', ')'):\n                        next_s = curr[:i] + curr[i+1:]\n                        if next_s not in visited:\n                            visited.add(next_s)\n                            queue.append(next_s)\n            return result\n\n        return bfs(s)\n```"
    },
    {
        "question_id": 162,
        "optimized_code": "```python\nclass Solution:\n    def findPeakElement(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n == 1:\n            return 0\n        \n        for i in range(n):\n            if i == 0:\n                if nums[i] > nums[i+1]:\n                    return i\n            elif i == n-1:\n                if nums[i] > nums[i-1]:\n                    return i\n            else:\n                if nums[i] > nums[i-1] and nums[i] > nums[i+1]:\n                    return i\n        \n        return 0\n```"
    },
    {
        "question_id": 164,
        "optimized_code": "```python\nclass Solution:\n    def maximumGap(self, nums: List[int]) -> int:\n        if len(nums) < 2:\n            return 0\n        if len(nums) == 2:\n            return abs(nums[0] - nums[1])\n        nmax, nmin = max(nums), min(nums)\n        if nmax == nmin:\n            return 0\n        num_buckets = len(nums) - 1\n        bucket_size = (nmax - nmin) / num_buckets\n        buckets = [[float('inf'), -1] for _ in range(num_buckets)]\n        for num in nums:\n            bucket_num = min(int((num - nmin) // bucket_size), num_buckets - 1)\n            buckets[bucket_num][0] = min(buckets[bucket_num][0], num)\n            buckets[bucket_num][1] = max(buckets[bucket_num][1], num)\n        prev_bucket = None\n        ret = 0\n        for i in range(len(buckets)):\n            if buckets[i][1] != -1:\n                if prev_bucket is None:\n                    prev_bucket = buckets[i]\n                else:\n                    ret = max(ret, buckets[i][0] - prev_bucket[1])\n                    prev_bucket = buckets[i]\n        return ret\n```"
    },
    {
        "question_id": 166,
        "optimized_code": "```python\nclass Solution:\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\n        if numerator==0:\n            return \"0\"\n        if denominator == 0:\n            return\n        string = []\n        if numerator * denominator < 0 :\n            string.append(\"-\")\n        numerator, denominator = abs(numerator), abs(denominator)\n        quo = numerator//denominator\n        string.append(str(quo))\n        rem = numerator%denominator\n\n        if rem==0:\n            return ''.join(string)\n        else:\n            string.append(\".\")\n        seen = {}\n        while rem:\n            if rem in seen:\n                ind = seen[rem]\n                string.insert(ind, \"(\")\n                string.append(\")\")\n                return ''.join(string)\n            seen[rem] = len(string)\n            rem *= 10\n            quo = rem//denominator\n            rem = rem%denominator\n            string.append(str(quo))\n        return ''.join(string)\n```"
    },
    {
        "question_id": 168,
        "optimized_code": "```python\nclass Solution:\n    def convertToTitle(self, columnNumber: int) -> str:\n        result = \"\"\n        while columnNumber > 0:\n            columnNumber -= 1\n            remainder = columnNumber % 26\n            result = chr(65 + remainder) + result\n            columnNumber //= 26\n        return result\n```"
    },
    {
        "question_id": 43,
        "optimized_code": "```python\nclass Solution:\n    def multiply(self, num1: str, num2: str) -> str:\n        if num1 == \"0\" or num2 == \"0\":\n            return \"0\"\n\n        n1 = len(num1)\n        n2 = len(num2)\n        product = [0] * (n1 + n2)\n\n        for i in range(n1 - 1, -1, -1):\n            carry = 0\n            for j in range(n2 - 1, -1, -1):\n                digit1 = ord(num1[i]) - ord('0')\n                digit2 = ord(num2[j]) - ord('0')\n                \n                product[i + j + 1] += digit1 * digit2 + carry\n                carry = product[i + j + 1] // 10\n                product[i + j + 1] %= 10\n\n            product[i] += carry\n\n        result = \"\".join(map(str, product))\n\n        while result[0] == '0' and len(result) > 1:\n            result = result[1:]\n\n        return result\n```"
    },
    {
        "question_id": 50,
        "optimized_code": "```python\nclass Solution:\n    def myPow(self, x: float, n: int) -> float:\n        res = 1.0\n        abs_n = abs(n)\n        while abs_n > 0:\n            if abs_n & 1:\n                res *= x\n            x *= x\n            abs_n >>= 1\n        if n < 0:\n            return 1 / res\n        return res\n```"
    },
    {
        "question_id": 221,
        "optimized_code": "```python\nclass Solution:\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\n        if not matrix:\n            return 0\n\n        rows, cols = len(matrix), len(matrix[0])\n        dp = [[0] * cols for _ in range(rows)]\n        max_side = 0\n\n        for i in range(rows):\n            for j in range(cols):\n                if matrix[i][j] == '1':\n                    if i == 0 or j == 0:\n                        dp[i][j] = 1\n                    else:\n                        dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n                    max_side = max(max_side, dp[i][j])\n\n        return max_side * max_side\n```"
    },
    {
        "question_id": 223,
        "optimized_code": "```python\nclass Solution:\n    def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -> int:\n        area_a = (ax2 - ax1) * (ay2 - ay1)\n        area_b = (bx2 - bx1) * (by2 - by1)\n\n        overlap_width = max(0, min(ax2, bx2) - max(ax1, bx1))\n        overlap_height = max(0, min(ay2, by2) - max(ay1, by1))\n        \n        overlap_area = overlap_width * overlap_height\n\n        return area_a + area_b - overlap_area\n```"
    },
    {
        "question_id": 107,
        "optimized_code": "```python\nfrom collections import deque\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n\n        if not root:\n            return []\n\n        queue = deque([root])\n        solutions = []\n\n        while queue:\n            level = []\n            level_size = len(queue)\n\n            for _ in range(level_size):\n                node = queue.popleft()\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n\n\n            solutions.append(level)\n\n        return solutions[::-1]\n```"
    },
    {
        "question_id": 109,
        "optimized_code": "```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        def findSize(head):\n            size = 0\n            while head:\n                size += 1\n                head = head.next\n            return size\n\n        size = findSize(head)\n\n        def buildTree(start, end):\n            nonlocal head\n            if start > end:\n                return None\n\n            mid = (start + end) // 2\n\n            left = buildTree(start, mid - 1)\n\n            node = TreeNode(head.val)\n            node.left = left\n\n            head = head.next\n            node.right = buildTree(mid + 1, end)\n\n            return node\n\n        return buildTree(0, size - 1)\n```"
    },
    {
        "question_id": 268,
        "optimized_code": "```python\nclass Solution:\n    def missingNumber(self, nums: List[int]) -> int:\n        n = len(nums)\n        expected_sum = n * (n + 1) // 2\n        actual_sum = sum(nums)\n        return expected_sum - actual_sum\n```"
    },
    {
        "question_id": 172,
        "optimized_code": "```python\nclass Solution:\n    def trailingZeroes(self, n: int) -> int:\n        ans = 0\n        i = 5\n        while n//i >= 1:\n            ans += n//i\n            i *= 5\n        return ans\n```"
    },
    {
        "question_id": 179,
        "optimized_code": "```python\nclass Solution:\n    def largestNumber(self, nums: List[int]) -> str:\n        nums_str = [str(num) for num in nums]\n        nums_str.sort(key=lambda x: x * 3, reverse=True)\n        return str(int(\"\".join(nums_str)))\n```"
    },
    {
        "question_id": 187,
        "optimized_code": "```python\nclass Solution:\n    def findRepeatedDnaSequences(self, s: str) -> List[str]:\n        if len(s) < 10:\n            return []\n\n        mapping = {'A': 0, 'C': 1, 'G': 2, 'T': 3}\n        n = len(s)\n        seen = set()\n        repeated = set()\n        ans = []\n\n        for i in range(n - 9):\n            num = 0\n            for j in range(10):\n                num = (num << 2) | mapping[s[i + j]]\n\n            if num in seen:\n                if num not in repeated:\n                    repeated.add(num)\n                    ans.append(s[i:i+10])\n\n            else:\n                seen.add(num)\n\n        return ans\n```"
    },
    {
        "question_id": 12,
        "optimized_code": "```python\nclass Solution:\n    def intToRoman(self, num: int) -> str:\n        dictionary = {1000:'M', 900:'CM', 500:'D', 400:'CD', 100:'C', 90:'XC', 50:'L', 40:'XL', 10:'X', 9:'IX', 5:'V', 4:'IV', 1:'I'}\n        ans=''\n        for key, val in dictionary.items():\n            while num>=key:\n                ans+=val\n                num-=key\n            if num==0:break\n        return ans\n```"
    },
    {
        "question_id": 13,
        "optimized_code": "```python\nclass Solution:\n    def romanToInt(self, s: str) -> int:\n        m = {\n            'I': 1,\n            'V': 5,\n            'X': 10,\n            'L': 50,\n            'C': 100,\n            'D': 500,\n            'M': 1000\n        }\n        \n        ans = 0\n        \n        for i in range(len(s)):\n            if i < len(s) - 1 and m[s[i]] < m[s[i+1]]:\n                ans -= m[s[i]]\n            else:\n                ans += m[s[i]]\n        \n        return ans\n```"
    },
    {
        "question_id": 113,
        "optimized_code": "```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:\n        res=[]\n        def helper(root,sm,gen):\n            if root is None:\n                return \n            \n            sm+=root.val\n            gen.append(root.val)\n\n            if root.left is None and root.right is None:\n                if sm==targetSum:\n                    res.append(gen[:])\n            else:\n                helper(root.left,sm,gen)\n                helper(root.right,sm,gen)\n            \n            gen.pop()\n        helper(root,0,[])\n        return res\n```"
    },
    {
        "question_id": 117,
        "optimized_code": "```python\n\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.next = next\n\"\"\"\n\nclass Solution:\n    def connect(self, root: 'Node') -> 'Node':\n        if not root:\n            return root\n\n        level_start = root\n\n        while level_start:\n            curr = level_start\n            while curr:\n                if curr.left:\n                    curr.left.next = curr.right\n                if curr.right and curr.next:\n                    curr.right.next = curr.next.left\n                \n                curr = curr.next\n            level_start = level_start.left\n\n        return root\n```"
    },
    {
        "question_id": 118,
        "optimized_code": "```python\nclass Solution:\n    def generate(self, numRows: int) -> List[List[int]]:\n        \n        result = []\n        for i in range(numRows):\n            row = [1] * (i + 1)\n            if i > 1:\n                for j in range(1, i):\n                    row[j] = result[i-1][j-1] + result[i-1][j]\n            result.append(row)\n        return result\n```"
    },
    {
        "question_id": 119,
        "optimized_code": "```python\nclass Solution:\n    def getRow(self, rowIndex: int) -> List[int]:\n        row = [0] * (rowIndex + 1)\n        row[0] = 1\n        for i in range(1, rowIndex + 1):\n            for j in range(i, 0, -1):\n                row[j] += row[j - 1]\n        return row\n```"
    },
    {
        "question_id": 260,
        "optimized_code": "```python\nclass Solution:\n    def singleNumber(self, nums: List[int]) -> List[int]:\n        counts = {}\n        for num in nums:\n            counts[num] = counts.get(num, 0) + 1\n        \n        L = []\n        for num, count in counts.items():\n            if count == 1:\n                L.append(num)\n        \n        return L\n```"
    },
    {
        "question_id": 264,
        "optimized_code": "```python\nfrom heapq import heappush, heappop\n\nclass Solution:\n    def nthUglyNumber(self, n: int) -> int:\n        \n        heap = [1]\n        seen = {1}\n        count=1\n        while count<n:\n            smal = heappop(heap)\n            \n            if smal*2 not in seen:\n                heappush(heap,smal*2)\n                seen.add(smal*2)\n            if smal*3 not in seen:\n                heappush(heap,smal*3)\n                seen.add(smal*3)\n            if smal*5 not in seen:\n                heappush(heap,smal*5)\n                seen.add(smal*5)\n            count+=1\n        return heappop(heap)\n```"
    },
    {
        "question_id": 71,
        "optimized_code": "```python\nclass Solution:\n    def simplifyPath(self, path: str) -> str:\n        components = path.split('/')\n        stack = []\n        \n        for component in components:\n            if component == '' or component == '.':\n                continue\n            elif component == '..':\n                if stack:\n                    stack.pop()\n            else:\n                stack.append(component)\n        \n        simplified_path = '/' + '/'.join(stack)\n        return simplified_path\n```"
    },
    {
        "question_id": 75,
        "optimized_code": "```python\nclass Solution:\n    def sortColors(self, nums: List[int]) -> None:\n        low = 0\n        mid = 0\n        high = len(nums) - 1\n\n        while mid <= high:\n            if nums[mid] == 0:\n                nums[low], nums[mid] = nums[mid], nums[low]\n                low += 1\n                mid += 1\n            elif nums[mid] == 1:\n                mid += 1\n            else:\n                nums[mid], nums[high] = nums[high], nums[mid]\n                high -= 1\n```"
    },
    {
        "question_id": 77,
        "optimized_code": "```python\nclass Solution:\n    def combine(self, n: int, k: int) -> List[List[int]]:\n        res = []\n        combination = []\n\n        def backtrack(start):\n            if len(combination) == k:\n                res.append(combination.copy())\n                return\n\n            for i in range(start, n + 1):\n                combination.append(i)\n                backtrack(i + 1)\n                combination.pop()\n\n        backtrack(1)\n        return res\n```"
    },
    {
        "question_id": 80,
        "optimized_code": "```python\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n\n        a = 1\n        c = 1\n        for i in range(1, len(nums)):\n            if nums[i] == nums[i-1]:\n                if c < 2:\n                    nums[a] = nums[i]\n                    a += 1\n                    c += 1\n            else:\n                nums[a] = nums[i]\n                a += 1\n                c = 1\n        return a\n```"
    },
    {
        "question_id": 21,
        "optimized_code": "```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\n        cur = ListNode()\n        d = cur\n        while list1 and list2:\n            if list1.val < list2.val:\n                cur.next = list1\n                list1 = list1.next\n            else:\n                cur.next = list2\n                list2 = list2.next\n\n            cur = cur.next\n        if list1:\n            cur.next = list1\n        else:\n            cur.next = list2\n        return d.next\n```"
    },
    {
        "question_id": 27,
        "optimized_code": "```python\nclass Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        i = 0\n        for j in range(len(nums)):\n            if nums[j] != val:\n                nums[i] = nums[j]\n                i += 1\n        return i\n```"
    },
    {
        "question_id": 28,
        "optimized_code": "```python\nclass Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        if not needle:\n            return 0\n        \n        n = len(haystack)\n        m = len(needle)\n        \n        if m > n:\n            return -1\n        \n        for i in range(n - m + 1):\n            if haystack[i:i+m] == needle:\n                return i\n        \n        return -1\n```"
    },
    {
        "question_id": 29,
        "optimized_code": "```python\nclass Solution:\n    def divide(self, dividend: int, divisor: int) -> int:\n        # Constants for 32-bit signed integer limits\n        INT_MAX, INT_MIN = 2**31 - 1, -2**31\n        \n        # Edge case for overflow\n        if dividend == INT_MIN and divisor == -1:\n            return INT_MAX\n        \n        # Determine the sign of the result\n        sign = (dividend < 0) != (divisor < 0)\n        \n        # Work with absolute values\n        dividend, divisor = abs(dividend), abs(divisor)\n        \n        # Initialize the result\n        quotient = 0\n        \n        # The power of two divisor\n        power = 31\n        \n        # Subtract divisor multiples from dividend\n        while dividend >= divisor:\n            divisor_power = divisor << power\n            while divisor_power > dividend:\n                divisor_power >>= 1\n                power -= 1\n            dividend -= divisor_power\n            quotient += 1 << power\n        \n        # Apply the sign\n        if sign:\n            quotient = -quotient\n        \n        # Clamp the result within the 32-bit signed integer range\n        return min(max(quotient, INT_MIN), INT_MAX)\n```"
    },
    {
        "question_id": 30,
        "optimized_code": "```python\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        n = len(words)\n        k = len(words[0])\n        l = n * k\n        indices = []\n        word_counts = Counter(words)\n\n        for i in range(len(s) - l + 1):\n            seen_words = Counter()\n            words_found = 0\n            for j in range(n):\n                word = s[i + j * k: i + (j + 1) * k]\n                if word in word_counts:\n                    seen_words[word] += 1\n                    if seen_words[word] <= word_counts[word]:\n                        words_found += 1\n                    else:\n                        break\n                else:\n                    break\n            if words_found == n:\n                indices.append(i)\n\n        return indices\n```"
    },
    {
        "question_id": 62,
        "optimized_code": "```python\nclass Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        row = [1] * n\n\n        for i in range(1, m):\n            newRow = [1] * n\n            for j in range(1, n):\n                newRow[j] = newRow[j-1] + row[j]\n            row = newRow\n\n        return row[-1]\n```"
    },
    {
        "question_id": 64,
        "optimized_code": "```python\nclass Solution:\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        if not grid or not grid[0]:\n            return 0\n        \n        m, n = len(grid), len(grid[0])\n        \n        dp = [0] * n\n        \n        dp[0] = grid[0][0]\n        \n        for j in range(1, n):\n            dp[j] = dp[j-1] + grid[0][j]\n            \n        for i in range(1, m):\n            dp[0] = dp[0] + grid[i][0]\n            for j in range(1, n):\n                dp[j] = grid[i][j] + min(dp[j-1], dp[j])\n                \n        return dp[n-1]\n```"
    },
    {
        "question_id": 65,
        "optimized_code": "```python\nimport re\n\nclass Solution:\n    def isNumber(self, s: str) -> bool:\n        s = s.strip()\n        pattern = r\"^[-+]?(\\d+\\.?\\d*|\\.\\d+)([eE][-+]?\\d+)?$\"\n        return bool(re.match(pattern, s))\n```"
    },
    {
        "question_id": 66,
        "optimized_code": "```python\nclass Solution:\n    def plusOne(self, digits: List[int]) -> List[int]:\n        n=len(digits)\n        for i  in range(n-1,-1,-1):\n            if digits[i]<9:\n                digits[i]+=1\n                return digits\n            else:\n                digits[i]=0\n        return [1]+digits\n```"
    },
    {
        "question_id": 67,
        "optimized_code": "```python\nclass Solution:\n    def addBinary(self, a: str, b: str) -> str:\n        i= len(a)-1\n        j= len(b)-1\n\n        car=0\n        sol=[]\n        while i >= 0 or j >= 0 or car:\n            digit_a = int(a[i]) if i >= 0 else 0\n            digit_b = int(b[j]) if j >= 0 else 0\n            \n            total = digit_a + digit_b + car\n            sol.append(str(total % 2))\n            car = total // 2  \n\n            i-=1\n            j-=1\n        return \"\".join(sol[::-1])\n```"
    },
    {
        "question_id": 69,
        "optimized_code": "```python\nclass Solution:\n    def mySqrt(self, x: int) -> int:\n        if x == 0 or x == 1:\n            return x\n        \n        low = 1\n        high = x\n        \n        while low <= high:\n            mid = (low + high) // 2\n            \n            if mid * mid == x:\n                return mid\n            elif mid * mid < x:\n                low = mid + 1\n            else:\n                high = mid - 1\n                \n        return high\n```"
    },
    {
        "question_id": 70,
        "optimized_code": "```python\nclass Solution:\n    def climbStairs(self, n: int) -> int:\n        if n <= 1:\n            return 1\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        dp[1] = 1\n        for i in range(2, n + 1):\n            dp[i] = dp[i - 1] + dp[i - 2]\n        return dp[n]\n```"
    },
    {
        "question_id": 51,
        "optimized_code": "```python\nclass Solution:\n    def solveNQueens(self, n: int) -> List[List[str]]:\n        def is_safe(board, row, col, n):\n            # Check same column\n            for i in range(row):\n                if board[i][col] == 'Q':\n                    return False\n\n            # Check upper left diagonal\n            i = row - 1\n            j = col - 1\n            while i >= 0 and j >= 0:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j -= 1\n\n            # Check upper right diagonal\n            i = row - 1\n            j = col + 1\n            while i >= 0 and j < n:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j += 1\n\n            return True\n\n        def solve_n_queens_util(board, row, n, solutions):\n            if row == n:\n                solution = [\"\".join(row) for row in board]\n                solutions.append(solution)\n                return\n\n            for col in range(n):\n                if is_safe(board, row, col, n):\n                    board[row][col] = 'Q'\n                    solve_n_queens_util(board, row + 1, n, solutions)\n                    board[row][col] = '.'  # Backtrack\n\n        solutions = []\n        board = [['.' for _ in range(n)] for _ in range(n)]\n        solve_n_queens_util(board, 0, n, solutions)\n        return solutions\n```"
    },
    {
        "question_id": 52,
        "optimized_code": "```python\nclass Solution:\n    def totalNQueens(self, n: int) -> int:\n        cols = set()\n        pos_diags = set()  # (row + col)\n        neg_diags = set()  # (row - col)\n\n        count = 0\n\n        def backtrack(row):\n            nonlocal count\n            if row == n:\n                count += 1\n                return\n\n            for col in range(n):\n                if col in cols or (row + col) in pos_diags or (row - col) in neg_diags:\n                    continue\n\n                cols.add(col)\n                pos_diags.add(row + col)\n                neg_diags.add(row - col)\n\n                backtrack(row + 1)\n\n                cols.remove(col)\n                pos_diags.remove(row + col)\n                neg_diags.remove(row - col)\n\n        backtrack(0)\n        return count\n```"
    },
    {
        "question_id": 53,
        "optimized_code": "```python\nclass Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        maxSum = float('-inf')\n        currentSum = 0\n        \n        for num in nums:\n            currentSum += num\n            \n            if currentSum > maxSum:\n                maxSum = currentSum\n            \n            if currentSum < 0:\n                currentSum = 0\n        \n        return maxSum\n```"
    },
    {
        "question_id": 55,
        "optimized_code": "```python\nclass Solution:\n    def canJump(self, nums: List[int]) -> bool:\n        reachable = 0\n        for i, num in enumerate(nums):\n            if i > reachable:\n                return False\n            reachable = max(reachable, i + num)\n        return True\n```"
    },
    {
        "question_id": 58,
        "optimized_code": "```python\nclass Solution:\n    def lengthOfLastWord(self, s: str) -> int:\n        s = s.rstrip()\n        if not s:\n            return 0\n        return len(s.split()[-1])\n```"
    },
    {
        "question_id": 60,
        "optimized_code": "```python\nclass Solution:\n    def getPermutation(self, n: int, k: int) -> str:\n        numbers = list(range(1, n + 1))\n        permutation = ''\n        k -= 1\n        import math\n        for i in range(n, 0, -1):\n            index = k // math.factorial(i - 1)\n            permutation += str(numbers[index])\n            numbers.pop(index)\n            k %= math.factorial(i - 1)\n        return permutation\n```"
    },
    {
        "question_id": 282,
        "optimized_code": "```python\nclass Solution:\n    def addOperators(self, num: str, target: int) -> List[str]:\n        n = len(num)\n        res = []\n\n        def backtrack(index, current_expression, current_value, previous_operand):\n            if index == n:\n                if current_value == target:\n                    res.append(\"\".join(current_expression))\n                return\n\n            for i in range(index, n):\n                if i > index and num[index] == '0':\n                    break  # Skip leading zeros\n\n                current_string = num[index:i + 1]\n                current_num = int(current_string)\n\n                if index == 0:\n                    current_expression.append(current_string)\n                    backtrack(i + 1, current_expression, current_num, current_num)\n                    current_expression.pop()\n                else:\n                    # Addition\n                    current_expression.append('+')\n                    current_expression.append(current_string)\n                    backtrack(i + 1, current_expression, current_value + current_num, current_num)\n                    current_expression.pop()\n                    current_expression.pop()\n\n                    # Subtraction\n                    current_expression.append('-')\n                    current_expression.append(current_string)\n                    backtrack(i + 1, current_expression, current_value - current_num, -current_num)\n                    current_expression.pop()\n                    current_expression.pop()\n\n                    # Multiplication\n                    current_expression.append('*')\n                    current_expression.append(current_string)\n                    backtrack(i + 1, current_expression, current_value - previous_operand + previous_operand * current_num, previous_operand * current_num)\n                    current_expression.pop()\n                    current_expression.pop()\n\n        backtrack(0, [], 0, 0)\n        return res\n```"
    },
    {
        "question_id": 283,
        "optimized_code": "```python\nclass Solution:\n    def moveZeroes(self, nums: List[int]) -> None:\n        n = len(nums)\n        left = 0\n        for right in range(n):\n            if nums[right] != 0:\n                nums[left], nums[right] = nums[right], nums[left]\n                left += 1\n```"
    },
    {
        "question_id": 336,
        "optimized_code": "```python\nfrom typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\n        word_map = {word: i for i, word in enumerate(words)}\n        result = []\n        for i, word in enumerate(words):\n            n = len(word)\n            for j in range(n + 1):\n                prefix = word[:j]\n                suffix = word[j:]\n\n                if prefix[::-1] in word_map and word_map[prefix[::-1]] != i and suffix == suffix[::-1]:\n                    result.append([i, word_map[prefix[::-1]]])\n\n                if j > 0 and suffix[::-1] in word_map and word_map[suffix[::-1]] != i and prefix == prefix[::-1]:\n                    result.append([word_map[suffix[::-1]], i])\n        return result\n```"
    },
    {
        "question_id": 338,
        "optimized_code": "```python\nclass Solution:\n    def countBits(self, n: int) -> List[int]:\n        dp = [0] * (n + 1)\n        for i in range(1, n + 1):\n            dp[i] = dp[i >> 1] + (i & 1)\n        return dp\n```"
    },
    {
        "question_id": 342,
        "optimized_code": "```python\nclass Solution:\n    def isPowerOfFour(self, n: int) -> bool:\n        if n <= 0:\n            return False\n        while n % 4 == 0:\n            n //= 4\n        return n == 1\n```"
    },
    {
        "question_id": 345,
        "optimized_code": "```python\nclass Solution:\n    def reverseVowels(self, s: str) -> str:\n        buf = list(s)\n        myset = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        vowels = []\n        indexs = []\n\n        for i in range(len(s)):\n            if s[i] in myset:\n                vowels.append(s[i])\n                indexs.append(i)\n        \n        vowels.reverse()\n        \n        for i in range(len(indexs)):\n            buf[indexs[i]] = vowels[i]\n        \n        answer = ''.join(buf)\n        return answer\n```"
    },
    {
        "question_id": 389,
        "optimized_code": "```python\nclass Solution:\n    def findTheDifference(self, s: str, t: str) -> str:\n        s_sum = sum(ord(c) for c in s)\n        t_sum = sum(ord(c) for c in t)\n        return chr(t_sum - s_sum)\n```"
    },
    {
        "question_id": 391,
        "optimized_code": "```python\nclass Solution:\n    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\n        x1 = y1 = 10 ** 5 + 1\n        x2 = y2 = -10 ** 5 - 1\n        area = 0\n        points = set()\n        for x, y, a, b in rectangles:\n            x1 = min(x1, x)\n            y1 = min(y1, y)\n            x2 = max(x2, a)\n            y2 = max(y2, b)\n            area += (a - x) * (b - y)\n\n            points.add((x, y))\n            points.add((x, b))\n            points.add((a, y))\n            points.add((a, b))\n\n        if (x2 - x1) * (y2 - y1) != area:\n            return False\n\n        expected_corners = [(x1, y1), (x1, y2), (x2, y1), (x2, y2)]\n        actual_corners = 0\n\n        for point in expected_corners:\n            if point in points:\n                actual_corners += 1\n                points.remove(point)\n\n        if actual_corners != 4:\n            return False\n\n        return not points\n```"
    },
    {
        "question_id": 392,
        "optimized_code": "```python\nclass Solution:\n    def isSubsequence(self, s: str, t: str) -> bool:\n        i, j = 0, 0\n        while i < len(s) and j < len(t):\n            if s[i] == t[j]:\n                i += 1\n            j += 1\n        return i == len(s)\n```"
    },
    {
        "question_id": 479,
        "optimized_code": "```python\nclass Solution:\n    def largestPalindrome(self, n: int) -> int:\n        if n == 1:\n            return 9\n        upper_bound = 10 ** n - 1\n        lower_bound = 10 ** (n - 1)\n        \n        for a in range(upper_bound, lower_bound - 1, -1):\n            palindrome = int(str(a) + str(a)[::-1])\n            for x in range(upper_bound, int(palindrome**0.5) - 1, -1):\n                if palindrome % x == 0 and palindrome // x <= upper_bound:\n                    return palindrome % 1337\n        return 0\n```"
    },
    {
        "question_id": 483,
        "optimized_code": "```python\nclass Solution:\n    def smallestGoodBase(self, n: str) -> str:\n        n = int(n)\n        m_max = int((n - 1)**(1/1))\n        for m in range(int(n**0.5), 0, -1):\n            k = int(round(n**(1/m)))\n            if k <= 1:\n                continue\n            if k** (m + 1) > 2 * n:\n                continue\n            num = n - 1\n            den = k - 1\n            if num % den == 0:\n                q = num // den\n                sum_val = 1\n                pow_k = 1\n                valid = True\n                for _ in range(m):\n                    pow_k *= k\n                    sum_val += pow_k\n                if sum_val == n:\n                    return str(k)\n\n        return str(n - 1)\n```"
    },
    {
        "question_id": 485,
        "optimized_code": "```python\nclass Solution:\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\n        maxLength = 0\n        length = 0\n        for i in range(len(nums)):\n            if nums[i] == 0:\n                length = 0\n            else: \n                length += 1\n            maxLength = max(maxLength, length)\n\n        return maxLength\n```"
    },
    {
        "question_id": 410,
        "optimized_code": "```python\nclass Solution:\n    def splitArray(self, nums: List[int], k: int) -> int:\n        def check(x):\n            cnt = 1\n            cur = 0\n            for num in nums:\n                if num > x:\n                    return False\n                cur += num\n                if cur > x:\n                    cnt += 1\n                    cur = num\n            return cnt <= k\n\n        l, r = max(nums), sum(nums)\n        ans = r\n        while l <= r:\n            mid = (l + r) // 2\n            if check(mid):\n                ans = mid\n                r = mid - 1\n            else:\n                l = mid + 1\n        return ans\n```"
    },
    {
        "question_id": 414,
        "optimized_code": "```python\nclass Solution:\n    def thirdMax(self, nums: List[int]) -> int:\n        nums = sorted(list(set(nums)), reverse=True)\n        if len(nums) >= 3:\n            return nums[2]\n        else:\n            return nums[0]\n```"
    },
    {
        "question_id": 472,
        "optimized_code": "```python\nclass Solution:\n    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\n        word_set = set(words)\n        result = []\n\n        def can_form(word):\n            if not word:\n                return False\n            \n            dp = [False] * (len(word) + 1)\n            dp[0] = True\n\n            for i in range(1, len(word) + 1):\n                for j in range(i):\n                    if dp[j] and word[j:i] in word_set:\n                        dp[i] = True\n                        break\n            return dp[len(word)]\n\n        for word in words:\n            if can_form(word):\n                word_set.remove(word)  # Important optimization: Prevent self-concatenation\n                if can_form(word):\n                  result.append(word)\n                word_set.add(word) # add back to set\n        return result\n```"
    },
    {
        "question_id": 476,
        "optimized_code": "```python\nclass Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        bits = num.bit_length()\n        mask = (1 << bits) - 1\n        return num ^ mask\n```"
    },
    {
        "question_id": 440,
        "optimized_code": "```python\nclass Solution(object):\n    def findKthNumber(self, n, k):\n        curr = 1\n        k -= 1\n        \n        while k > 0:\n            step = self.countSteps(n, curr, curr + 1)\n            if step <= k:\n                curr += 1\n                k -= step\n            else:\n                curr *= 10\n                k -= 1\n\n        return curr\n\n    def countSteps(self, n, prefix1, prefix2):\n        steps = 0\n        while prefix1 <= n:\n            steps += min(n + 1, prefix2) - prefix1\n            prefix1 *= 10\n            prefix2 *= 10\n        return steps\n```"
    },
    {
        "question_id": 441,
        "optimized_code": "```python\nclass Solution:\n    def arrangeCoins(self, n: int) -> int:\n        left, right = 0, n\n        while left <= right:\n            mid = left + (right - left) // 2\n            coins_needed = mid * (mid + 1) // 2\n            if coins_needed == n:\n                return mid\n            elif coins_needed < n:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return right\n```"
    },
    {
        "question_id": 401,
        "optimized_code": "```python\nclass Solution:\n    def readBinaryWatch(self, num: int) -> list[str]:\n        times = []\n\n        for i in range(1024):\n            h = i >> 6\n            m = i & 63\n            if h < 12 and m < 60 and bin(i).count('1') == num:\n                times.append(f\"{h}:{m:02d}\")\n\n        return times\n```"
    },
    {
        "question_id": 404,
        "optimized_code": "```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sumOfLeftLeaves(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n\n        stack = [(root, False)]  # (node, is_left)\n        total_sum = 0\n\n        while stack:\n            node, is_left = stack.pop()\n\n            if not node:\n                continue\n\n            if is_left and not node.left and not node.right:\n                total_sum += node.val\n\n            if node.right:\n                stack.append((node.right, False))\n            if node.left:\n                stack.append((node.left, True))\n\n        return total_sum\n```"
    },
    {
        "question_id": 363,
        "optimized_code": "```python\nimport numpy as np\nfrom sortedcontainers import SortedList\nfrom typing import List\n\nclass Solution:\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\n        m, n = len(matrix), len(matrix[0])\n        max_sum = float('-inf')\n\n        for left in range(n):\n            row_sums = [0] * m\n            for right in range(left, n):\n                for i in range(m):\n                    row_sums[i] += matrix[i][right]\n\n                prefix_sums = SortedList([0])\n                curr_sum = 0\n                for row_sum in row_sums:\n                    curr_sum += row_sum\n                    target = curr_sum - k\n                    idx = prefix_sums.bisect_left(target)\n                    if idx < len(prefix_sums):\n                        max_sum = max(max_sum, curr_sum - prefix_sums[idx])\n                    prefix_sums.add(curr_sum)\n                    if max_sum == k:\n                        return k\n\n        return max_sum\n```"
    },
    {
        "question_id": 459,
        "optimized_code": "```python\nclass Solution:\n    def repeatedSubstringPattern(self, s: str) -> bool:\n        n = len(s)\n        for i in range(1, n // 2 + 1):\n            if n % i == 0:\n                sub = s[:i]\n                k = n // i\n                new = sub * k\n                if new == s:\n                    return True\n        return False\n```"
    },
    {
        "question_id": 461,
        "optimized_code": "```python\nclass Solution:\n    def hammingDistance(self, x: int, y: int) -> int:\n        xor_result = x ^ y\n        hamming_distance = 0\n        while xor_result:\n            hamming_distance += xor_result & 1\n            xor_result >>= 1\n        return hamming_distance\n```"
    },
    {
        "question_id": 463,
        "optimized_code": "```python\nclass Solution:\n    def islandPerimeter(self, grid: List[List[int]]) -> int:\n        rows, cols = len(grid), len(grid[0])\n        perimeter = 0\n        for i in range(rows):\n            for j in range(cols):\n                if grid[i][j] == 1:\n                    # Check up\n                    if i == 0 or grid[i-1][j] == 0:\n                        perimeter += 1\n                    # Check down\n                    if i == rows - 1 or grid[i+1][j] == 0:\n                        perimeter += 1\n                    # Check left\n                    if j == 0 or grid[i][j-1] == 0:\n                        perimeter += 1\n                    # Check right\n                    if j == cols - 1 or grid[i][j+1] == 0:\n                        perimeter += 1\n        return perimeter\n```"
    },
    {
        "question_id": 685,
        "optimized_code": "```python\nfrom collections import defaultdict\n\nclass Solution:\n    def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:\n        n = len(edges)\n        in_degree = [0] * (n + 1)\n        \n        for u, v in edges:\n            in_degree[v] += 1\n        \n        # Type 1: There is a node with two parents\n        type1_candidates = []\n        for i in range(len(edges) - 1, -1, -1):\n            if in_degree[edges[i][1]] > 1:\n                type1_candidates.append(edges[i])\n                \n        if type1_candidates:\n            # Remove the last candidate and check for cycle\n            temp_edges = [edge for edge in edges if edge != type1_candidates[-1]]\n            \n            parent = list(range(n + 1))\n            \n            def find(i):\n                if parent[i] == i:\n                    return i\n                parent[i] = find(parent[i])\n                return parent[i]\n            \n            def union(i, j):\n                root_i = find(i)\n                root_j = find(j)\n                if root_i != root_j:\n                    parent[root_i] = root_j\n                    return False\n                return True  # Cycle detected\n\n            if not any(union(u, v) for u, v in temp_edges):\n                return type1_candidates[-1]\n            else:\n                 # The earlier edge is the answer\n                return type1_candidates[0]\n\n        # Type 2: There is a cycle but no node with two parents\n        parent = list(range(n + 1))\n\n        def find(i):\n            if parent[i] == i:\n                return i\n            parent[i] = find(parent[i])\n            return parent[i]\n        \n        def union(i, j):\n            root_i = find(i)\n            root_j = find(j)\n            if root_i != root_j:\n                parent[root_i] = root_j\n                return False\n            return True  # Cycle detected\n\n        for i in range(len(edges) - 1, -1, -1):\n            u, v = edges[i]\n            if union(u, v):\n                return edges[i]\n        return None\n```"
    },
    {
        "question_id": 736,
        "optimized_code": "```python\nfrom collections import deque\n\nclass Solution:\n    def evaluate(self, expression: str) -> int:\n        \"\"\"\n        expr := (let [string expr]*)\n        expr := (add  expr expr)\n        expr := (mult expr expr)\n        expr := var \n        \"\"\"\n\n        def tokenize(s):\n            Q = deque()\n            cur = 0\n            n = len(s)\n            while cur < n:\n                c = s[cur]\n                if c in ('(', ')'):\n                    Q.append(c)\n                    cur += 1\n                    continue\n                if c.isdigit() or c == '-':\n                    res = 0\n                    sign = 1\n                    if c == '-':\n                        sign = -1\n                        cur += 1\n                    while cur < n and s[cur].isdigit():\n                        res = res*10 + int(s[cur])\n                        cur += 1\n                    Q.append(sign * res)\n                    continue\n                if c.isalpha():\n                    res = []\n                    while cur < n and (s[cur].isalpha() or s[cur].isdigit()):\n                        res.append(s[cur])\n                        cur += 1\n                    Q.append(''.join(res))\n                    continue\n                cur += 1\n            return Q\n\n        tokens = tokenize(expression)  #TODO\n\n        def string():\n            return tokens.popleft()\n\n        def var(mp):\n            s = tokens.popleft()\n            if s in mp:\n                return mp[s]\n            return int(s)\n\n        def expr(mp):\n            if tokens[0] == '(':\n                tokens.popleft()  # '('\n                op = tokens.popleft()\n                if op == 'let':\n                    new_vars = {}\n                    while tokens[0] != ')':\n                        variable_name = string()\n                        expression = expr(mp)\n                        new_vars[variable_name] = expression\n                        mp[variable_name] = expression\n                    tokens.popleft()  # ')'\n                    result = expr(mp)\n                    for var_name in new_vars:\n                        del mp[var_name]\n                    return result\n\n                elif op == 'mult':\n                    expr1 = expr(mp)\n                    expr2 = expr(mp)\n                    tokens.popleft()  # ')'\n                    return expr1 * expr2\n                elif op == 'add':\n                    expr1 = expr(mp)\n                    expr2 = expr(mp)\n                    tokens.popleft()  # ')'\n                    return expr1 + expr2\n            else:\n                return var(mp)\n\n        return expr({})\n```"
    },
    {
        "question_id": 973,
        "optimized_code": "```python\nclass Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        m, n = len(stamp), len(target)\n        target = list(target)\n        result = []\n        stars = [0] * n\n        for i in range(n - m + 1):\n            for j in range(m):\n                if target[i+j] == stamp[j]:\n                    stars[i+j] += 1\n\n        queue = []\n        for i in range(n):\n            if stars[i] == m:\n                queue.append(i)\n\n        stamped = [False] * n\n        while queue:\n            i = queue.pop(0)\n            for j in range(max(0, i - m + 1), min(n - m, i) + 1):\n                if not stamped[j]:\n                    stamped[j] = True\n                    result.append(j)\n                    for k in range(m):\n                        if target[j+k] != '?':\n                            stars[j+k] -= 1\n                            if stars[j+k] == 0:\n                                queue.append(j+k)\n\n        return result[::-1] if all(c == '?' for c in target) else []\n```"
    },
    {
        "question_id": 975,
        "optimized_code": "```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\n        total = 0\n\n        def dfs(node: TreeNode) -> None:\n            nonlocal total\n\n            if not node:\n                return\n            \n            if low <= node.val <= high:\n                total += node.val\n            \n            if node.val > low:\n                dfs(node.left)\n            \n            if node.val < high:\n                dfs(node.right)\n        \n        dfs(root)\n        return total\n```"
    },
    {
        "question_id": 977,
        "optimized_code": "```python\nclass Solution:\n    \"\"\"\n    @param S: The string s\n    @return: The number of distinct, non-empty subsequences of S.\n    \"\"\"\n    def distinctSubseqII(self, S):\n        MOD = 10 ** 9 + 7\n        n = len(S)\n        \n        last = {}\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        \n        for i in range(1, n + 1):\n            dp[i] = (2 * dp[i - 1]) % MOD\n            if S[i - 1] in last:\n                dp[i] = (dp[i] - dp[last[S[i - 1]] -1 ]) % MOD\n            dp[i] = (dp[i] + MOD) % MOD\n            last[S[i - 1]] = i\n            \n        return (dp[n] - 1 + MOD) % MOD\n```"
    },
    {
        "question_id": 1013,
        "optimized_code": "```python\nclass Solution:\n    def fib(self, n: int) -> int:\n        if n < 2:\n            return n\n        \n        memo = {}\n        \n        def fib_memo(n):\n            if n in memo:\n                return memo[n]\n            if n < 2:\n                return n\n            memo[n] = fib_memo(n-1) + fib_memo(n-2)\n            return memo[n]\n        \n        return fib_memo(n)\n```"
    },
    {
        "question_id": 514,
        "optimized_code": "```python\nclass Solution:\n    def findRotateSteps(self, ring: str, key: str) -> int:\n        n = len(ring)\n        m = len(key)\n\n        pos = [[] for _ in range(26)]\n        for i, c in enumerate(ring):\n            pos[ord(c) - ord('a')].append(i)\n\n        dp = [[float('inf')] * n for _ in range(m + 1)]\n        dp[m][0] = 0\n\n        for i in reversed(range(m)):\n            for j in range(n):\n                for k in pos[ord(key[i]) - ord('a')]:\n                    dist = min(abs(j - k), n - abs(j - k))\n                    dp[i][j] = min(dp[i][j], dp[i + 1][k] + dist + 1)\n\n        return dp[0][0]\n```"
    },
    {
        "question_id": 920,
        "optimized_code": "```python\nclass Solution:\n    def uncommonFromSentences(self, s1: str, s2: str) -> List[str]:\n        d=Counter(s1.split())+Counter(s2.split())\n        return [x for x in d if d[x]==1]\n```"
    },
    {
        "question_id": 35,
        "optimized_code": "```python\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        low = 0\n        high = len(nums) - 1\n        \n        while low <= high:\n            mid = (low + high) // 2\n            \n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                low = mid + 1\n            else:\n                high = mid - 1\n        \n        return low\n```"
    },
    {
        "question_id": 10,
        "optimized_code": "```python\nclass Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        m, n = len(s), len(p)\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\n        dp[0][0] = True\n\n        for i in range(n):\n            if p[i] == '*' and dp[0][i - 1]:\n                dp[0][i + 1] = True\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if p[j - 1] == '*':\n                    dp[i][j] = dp[i][j - 2] or (s[i - 1] == p[j - 2] or p[j - 2] == '.') and dp[i - 1][j]\n                elif s[i - 1] == p[j - 1] or p[j - 1] == '.':\n                    dp[i][j] = dp[i - 1][j - 1]\n\n        return dp[m][n]\n```"
    },
    {
        "question_id": 218,
        "optimized_code": "```python\nclass Solution:\n    def getSkyline(self, buildings: List[List[int]]) -> List[List[int]]:\n        import heapq\n\n        events = []\n        for l, r, h in buildings:\n            events.append((l, -h, r))  # Use negative height for start events\n            events.append((r, 0, 0))   # End events have height 0\n\n        events.sort()\n\n        result = []\n        live_buildings = []  # Use a max-heap to store live buildings\n        heapq.heappush(live_buildings, 0)  # Initialize with a height of 0\n        prev_height = 0\n\n        for pos, neg_h, r in events:\n            # Add/remove buildings from the live buildings heap\n            while events and events[0][0] == pos:\n                p, neg_h, rr = events.pop(0)\n                if neg_h < 0:\n                    heapq.heappush(live_buildings, neg_h)\n                else:\n                    # Remove the building by delaying the removal until it's at the top\n                    live_buildings = [h for h in live_buildings if h != -rr] # Delayed removal using list comprehension\n\n            # Get the current max height\n            max_height = -live_buildings[0]\n\n            # If the height changes, add it to the result\n            if max_height != prev_height:\n                result.append([pos, max_height])\n                prev_height = max_height\n\n        return result\n```"
    },
    {
        "question_id": 226,
        "optimized_code": "```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        if root is None:\n            return root\n            \n        root.left, root.right = root.right, root.left\n\n        if root.left:\n            self.invertTree(root=root.left)\n        if root.right:\n            self.invertTree(root=root.right)\n        \n        return root\n```"
    },
    {
        "question_id": 273,
        "optimized_code": "```python\nclass Solution:\n    def numberToWords(self, num: int) -> str:\n        if num == 0:\n            return \"Zero\"\n\n        less_than_20 = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\",\n                         \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n        tens = [\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n        thousands = [\"\", \"Thousand\", \"Million\", \"Billion\"]\n\n        def helper(n):\n            if n < 20:\n                return less_than_20[n]\n            elif n < 100:\n                return tens[n // 10] + (\" \" + less_than_20[n % 10]) if n % 10 else tens[n // 10]\n            else:\n                return less_than_20[n // 100] + \" Hundred \" + helper(n % 100)\n\n        result = []\n        for i in range(4):\n            if num % 1000 != 0:\n                result.append(helper(num % 1000) + \" \" + thousands[i])\n            num //= 1000\n\n        return \" \".join(result[::-1]).strip()\n```"
    },
    {
        "question_id": 14,
        "optimized_code": "```python\nclass Solution:\n    def longestCommonPrefix(self, strs: List[str]) -> str:\n        if not strs:\n            return \"\"\n        \n        prefix = strs[0]\n        for i in range(1, len(strs)):\n            while strs[i].find(prefix) != 0:\n                prefix = prefix[:-1]\n                if not prefix:\n                    return \"\"\n        return prefix\n```"
    },
    {
        "question_id": 258,
        "optimized_code": "```python\nclass Solution:\n    def addDigits(self, num: int) -> int:\n        if num == 0: \n            return 0\n        mod = num % 9 \n        if mod == 0:\n            return 9 \n        else: return mod\n```"
    },
    {
        "question_id": 76,
        "optimized_code": "```python\nfrom collections import Counter\n\nclass Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        if not t or not s:\n            return \"\"\n\n        t_count = Counter(t)\n        window_count = {}\n        \n        required = len(t_count)\n        formed = 0\n        \n        left, right = 0, 0\n        min_len = float('inf')\n        min_start = 0\n\n        while right < len(s):\n            char = s[right]\n            window_count[char] = window_count.get(char, 0) + 1\n\n            if char in t_count and window_count[char] == t_count[char]:\n                formed += 1\n\n            while left <= right and formed == required:\n                char = s[left]\n\n                if right - left + 1 < min_len:\n                    min_len = right - left + 1\n                    min_start = left\n\n                window_count[char] -= 1\n                if char in t_count and window_count[char] < t_count[char]:\n                    formed -= 1\n\n                left += 1\n            \n            right += 1\n\n        if min_len == float('inf'):\n            return \"\"\n        else:\n            return s[min_start : min_start + min_len]\n```"
    },
    {
        "question_id": 68,
        "optimized_code": "```python\nclass Solution:\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\n        \n        n=len(words)\n        output,line,width=[],[],0\n        \n        for w in words:\n            if width + len(w) +len(line) > maxWidth:\n                if len(line) > 1:\n                    spaces_needed = maxWidth - width\n                    spaces_between = spaces_needed // (len(line) - 1)\n                    extra_spaces = spaces_needed % (len(line) - 1)\n                    \n                    for i in range(len(line) - 1):\n                        line[i] += ' ' * spaces_between\n                        if i < extra_spaces:\n                            line[i] += ' '\n                else:\n                    line[0] += ' ' * (maxWidth - width)\n\n                output += [''.join(line)]\n                line=[]\n                width=0\n            line += [w]\n            width += len(w)\n        \n        return output + [' '.join(line).ljust(maxWidth)]\n```"
    },
    {
        "question_id": 332,
        "optimized_code": "```python\nclass Solution:\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\n        self.graph = {}\n        for src, dst in tickets:\n            self.graph.setdefault(src, []).append(dst)\n        \n        for src_dst in self.graph.values():\n            src_dst.sort()\n        \n        self.res = []\n        self.dfs(\"JFK\")\n        return self.res[::-1]\n    \n    def dfs(self, src):\n        destinations = self.graph.get(src, [])\n        while destinations:\n            dst = destinations.pop(0)\n            self.dfs(dst)\n        self.res.append(src)\n```"
    },
    {
        "question_id": 689,
        "optimized_code": "```python\nclass Solution:\n    def maxSumOfThreeSubarrays(self, nums: List[int], k: int) -> List[int]:\n        n = len(nums)\n        sums = [0] * (n - k + 1)\n        current_sum = sum(nums[:k])\n        sums[0] = current_sum\n        for i in range(1, n - k + 1):\n            current_sum = current_sum - nums[i - 1] + nums[i + k - 1]\n            sums[i] = current_sum\n\n        left = [0] * (n - k + 1)\n        best = 0\n        for i in range(n - k + 1):\n            if sums[i] > sums[best]:\n                best = i\n            left[i] = best\n\n        right = [n - k] * (n - k + 1)\n        best = n - k\n        for i in range(n - k, -1, -1):\n            if sums[i] >= sums[best]:\n                best = i\n            right[i] = best\n\n        result = []\n        max_sum = 0\n        for mid in range(k, n - 2 * k + 1):\n            l, r = left[mid - k], right[mid + k]\n            cur_sum = sums[l] + sums[mid] + sums[r]\n            if cur_sum > max_sum:\n                max_sum = cur_sum\n                result = [l, mid, r]\n        return result\n```"
    },
    {
        "question_id": 953,
        "optimized_code": "```python\nclass Solution:\n\n\n    def reverseOnlyLetters(self, s: str) -> str:\n        left = 0\n        right = len(s) - 1\n        s_list = list(s)\n        while (left < right):\n            if not s_list[left].isalpha():\n                left += 1\n                continue\n            if not s_list[right].isalpha():\n                right -= 1\n                continue\n            temp = s_list[left]\n            s_list[left] = s_list[right]\n            s_list[right] = temp\n            left += 1\n            right -=1\n        \n        return \"\".join(s_list)\n```"
    },
    {
        "question_id": 923,
        "optimized_code": "```python\nclass Solution:\n    from functools import cache\n    @cache\n    def superEggDrop(self, k: int, n: int) -> int:\n        \n        # base condition\n\n        if n==0:\n            return 0\n        if n==1:\n            return 1\n        if k==1:\n            return n\n        ans = float('inf')\n        s, e = 1, n\n        while (s <= e):\n            x = (s+e)//2\n            low = self.superEggDrop(k-1, x-1)\n            high = self.superEggDrop(k, n-x)\n            if low > high:\n                ans = min(ans, low )\n                e = x-1\n            else:\n                ans = min(ans, high )\n                s = x+1\n        # for x in range(1, n+1):\n        #     ans  = min(ans, max(self.superEggDrop(k-1, x-1), self.superEggDrop(k, n-x)))\n        \n        return ans +1\n```"
    },
    {
        "question_id": 924,
        "optimized_code": "```python\nclass Solution:\n    def fairCandySwap(self, aliceSizes: List[int], bobSizes: List[int]) -> List[int]:\n        sum_alice = sum(aliceSizes)\n        sum_bob = sum(bobSizes)\n        half = (sum_alice + sum_bob) // 2\n        bob_set = set(bobSizes)\n        for i in aliceSizes:\n            bob_needed = half - (sum_alice - i)\n            if bob_needed in bob_set:\n                return [i, bob_needed]\n```"
    },
    {
        "question_id": 632,
        "optimized_code": "```python\nfrom typing import List\nimport heapq\n\nclass Solution:\n    def smallestRange(self, nums: List[List[int]]) -> List[int]:\n        k = len(nums)\n        pq = []\n        max_val = float('-inf')\n        for i in range(k):\n            heapq.heappush(pq, (nums[i][0], i, 0))\n            max_val = max(max_val, nums[i][0])\n\n        min_range = float('inf')\n        result = [-10**5, 10**5]\n\n        while len(pq) == k:\n            min_val, list_index, element_index = heapq.heappop(pq)\n            if max_val - min_val < min_range:\n                min_range = max_val - min_val\n                result = [min_val, max_val]\n\n            if element_index + 1 < len(nums[list_index]):\n                next_val = nums[list_index][element_index + 1]\n                heapq.heappush(pq, (next_val, list_index, element_index + 1))\n                max_val = max(max_val, next_val)\n            else:\n                break\n\n        return result\n```"
    },
    {
        "question_id": 637,
        "optimized_code": "```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nfrom collections import deque\nclass Solution:\n    def averageOfLevels(self, root: Optional[TreeNode]) -> List[float]:\n        levelsAverageList = []\n        if root != None:\n            queue = deque()\n            queue.append(root)\n            while queue:\n                size = len(queue)\n                level_sum = 0\n                level_count = 0\n                for _ in range(size):\n                    treeNode = queue.popleft()\n                    level_sum += treeNode.val\n                    level_count += 1\n                    if treeNode.left != None:\n                        queue.append(treeNode.left)\n                    if treeNode.right != None:\n                        queue.append(treeNode.right)\n                levelsAverageList.append(float(level_sum/level_count))\n        return levelsAverageList\n```"
    },
    {
        "question_id": 979,
        "optimized_code": "```python\nclass Solution:\n    def diStringMatch(self, s: str) -> List[int]:\n        n = len(s)\n        low = 0\n        high = n\n        result = []\n        for c in s:\n            if c == \"I\":\n                result.append(low)\n                low += 1\n            else:\n                result.append(high)\n                high -= 1\n        result.append(low)\n        return result\n```"
    },
    {
        "question_id": 981,
        "optimized_code": "```python\nclass Solution:\n    def minDeletionSize(self, strs: List[str]) -> int:\n        count = 0\n        for col in range(len(strs[0])):\n            last = strs[0][col]\n            for row in range(1, len(strs)):\n                if strs[row][col] < last:\n                    count += 1\n                    break\n                last = strs[row][col]\n        return count\n```"
    },
    {
        "question_id": 927,
        "optimized_code": "```python\nclass Solution:\n    def sumSubseqWidths(self, nums: List[int]) -> int:\n        nums.sort()\n        n = len(nums)\n        mod = 10**9 + 7\n        total = 0\n        for i in range(n):\n            total = (total + (pow(2, i, mod) - pow(2, n - 1 - i, mod)) * nums[i]) % mod\n        return total\n```"
    },
    {
        "question_id": 933,
        "optimized_code": "```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def increasingBST(self, root: TreeNode) -> TreeNode:\n        def increasingBSTHelper(root: TreeNode, tail: TreeNode) -> TreeNode:\n            if not root:\n                return tail\n            \n            res = increasingBSTHelper(root.left, root)\n            root.left = None\n            root.right = increasingBSTHelper(root.right, tail)\n            return res\n\n        return increasingBSTHelper(root, None)\n```"
    },
    {
        "question_id": 488,
        "optimized_code": "```python\nfrom functools import cache\n\nclass Solution:\n    def compress(self, s):\n        stack = []\n        for c in s:\n            if stack and stack[-1][0] != c and stack[-1][1] >= 3:\n                stack.pop()\n            if not stack or stack[-1][0] != c:\n                stack.append([c, 1])\n            else:\n                stack[-1][1] += 1\n        if stack and stack[-1][1] >= 3:\n            stack.pop()\n        return ''.join(a*b for a, b in stack)\n\n    def findMinStep(self, board: str, hand: str) -> int:\n        n = len(hand)\n        hand = ''.join(sorted(hand))\n\n        @cache\n        def solve(board_tuple, hand_tuple):\n            board = ''.join(board_tuple)\n            hand = ''.join(hand_tuple)\n            \n            board = self.compress(board)\n            if board == '': return n - len(hand)\n            if hand == '': return float('inf')\n\n            ans = float('inf')\n            for i in range(len(hand)):\n                if i > 0 and hand[i] == hand[i-1]: continue\n    \n                for j in range(len(board)):\n                    if board[j] == hand[i] or j > 0 and board[j] == board[j-1] and board[j] != hand[i]:\n                        new_board = list(board)\n                        new_board.insert(j, hand[i])\n                        new_hand = list(hand)\n                        del new_hand[i]\n                        ans = min(ans, solve(tuple(new_board), tuple(new_hand)))\n            return ans\n        \n        res = solve(tuple(board), tuple(hand))\n        if res == float('inf'): return -1\n        else: return res\n```"
    },
    {
        "question_id": 493,
        "optimized_code": "```python\nclass BIT:\n\n    def __init__(self, n):\n        self.n = n+1\n        self.lt = [0]*self.n\n\n    def search(self, indx):\n        res = 0\n        while indx>0:\n            res += self.lt[indx]\n            indx -= indx&(-indx)\n        return res\n\n    def update(self, indx, val):\n        while indx<self.n:\n            self.lt[indx] += val\n            indx += indx&(-indx)\n\n\nclass Solution:\n    def reversePairs(self, nums: List[int]) -> int:\n        n = len(nums)\n        unique_nums = sorted(list(set(nums + [2 * x for x in nums])))\n        num_map = {num: i + 1 for i, num in enumerate(unique_nums)}\n        bit = BIT(len(unique_nums))\n        count = 0\n\n        for i in range(n - 1, -1, -1):\n            count += bit.search(num_map[nums[i]])\n            bit.update(num_map[2 * nums[i]], 1)\n\n        return count\n```"
    },
    {
        "question_id": 495,
        "optimized_code": "```python\nclass Solution:\n    def findPoisonedDuration(self, timeSeries: List[int], duration: int) -> int:\n        n = len(timeSeries)\n        res = 0\n        if n == 0:\n            return 0\n        \n        for i in range(n - 1):\n            res += min(duration, timeSeries[i + 1] - timeSeries[i])\n        return res + duration\n```"
    },
    {
        "question_id": 496,
        "optimized_code": "```python\nclass Solution:\n    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        next_greater = {}\n        stack = []\n        for num in nums2:\n            while stack and num > stack[-1]:\n                next_greater[stack.pop()] = num\n            stack.append(num)\n\n        while stack:\n            next_greater[stack.pop()] = -1\n\n        res_out = [next_greater[num] for num in nums1]\n        return res_out\n```"
    },
    {
        "question_id": 830,
        "optimized_code": "```python\nclass Solution:\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\n        res = 0\n        n = len(points)\n        for i in range(n):\n            for j in range(i + 1, n):\n                for k in range(j + 1, n):\n                    x1, y1 = points[i]\n                    x2, y2 = points[j]\n                    x3, y3 = points[k]\n                    area = 0.5 * abs(x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2))\n                    res = max(res, area)\n        return res\n```"
    },
    {
        "question_id": 861,
        "optimized_code": "```python\nclass Solution:\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\n        for i in range(len(image)):\n            l, r = 0, len(image[i]) - 1\n            while l <= r:\n                if l == r:\n                    image[i][l] = 1 - image[i][l]\n                else:\n                    image[i][l], image[i][r] = 1 - image[i][r], 1 - image[i][l]\n                l += 1\n                r -= 1\n        return image\n```"
    },
    {
        "question_id": 741,
        "optimized_code": "```python\nclass Solution:\n    def cherryPickup(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        dp = {}\n\n        def solve(r1, c1, r2):\n            c2 = r1 + c1 - r2\n\n            if r1 >= n or c1 >= n or r2 >= n or c2 >= n or \\\n               grid[r1][c1] == -1 or grid[r2][c2] == -1:\n                return -float('inf')\n            \n            if (r1, c1, r2) in dp:\n                return dp[(r1, c1, r2)]\n\n            if r1 == n - 1 and c1 == n - 1:\n                return grid[r1][c1]\n\n            ans = -float('inf')\n            ans = max(ans, solve(r1 + 1, c1, r2 + 1))\n            ans = max(ans, solve(r1 + 1, c1, r2))\n            ans = max(ans, solve(r1, c1 + 1, r2 + 1))\n            ans = max(ans, solve(r1, c1 + 1, r2))\n\n            if ans == -float('inf'):\n                dp[(r1, c1, r2)] = -float('inf')\n                return -float('inf')\n\n            if r1 == r2 and c1 == c2:\n                ans += grid[r1][c1]\n            else:\n                ans += grid[r1][c1] + grid[r2][c2]\n            \n            dp[(r1, c1, r2)] = ans\n            return ans\n\n        result = solve(0, 0, 0)\n        return max(0, result)\n```"
    },
    {
        "question_id": 750,
        "optimized_code": "```python\nclass Solution:\n    def containVirus(self, mat: List[List[int]]) -> int:\n        m, n = len(mat), len(mat[0])\n        DIRECTIONS = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\n        def get_regions(matrix):\n            regions = []\n            visited = set()\n            for i in range(m):\n                for j in range(n):\n                    if matrix[i][j] == 1 and (i, j) not in visited:\n                        infected, walls, future_infection = dfs(matrix, i, j, visited)\n                        regions.append((infected, walls, future_infection))\n            return regions\n\n        def dfs(matrix, i, j, visited):\n            if not (0 <= i < m and 0 <= j < n) or (i, j) in visited or matrix[i][j] != 1:\n                return set(), 0, set()\n            \n            visited.add((i, j))\n            infected = {(i, j)}\n            walls = 0\n            future_infection = set()\n\n            for dx, dy in DIRECTIONS:\n                ni, nj = i + dx, j + dy\n                if 0 <= ni < m and 0 <= nj < n:\n                    if matrix[ni][nj] == 0:\n                        walls += 1\n                        future_infection.add((ni, nj))\n                    elif matrix[ni][nj] == 1 and (ni, nj) not in visited:\n                        next_infected, next_walls, next_future_infection = dfs(matrix, ni, nj, visited)\n                        infected |= next_infected\n                        walls += next_walls\n                        future_infection |= next_future_infection\n            \n            return infected, walls, future_infection\n\n        def quarantine(matrix, region):\n            for i, j in region:\n                matrix[i][j] = 2\n\n        def spread(matrix, future_infections):\n            for i, j in future_infections:\n                matrix[i][j] = 1\n                \n        ans = 0\n        while True:\n            regions = get_regions(mat)\n            if not regions:\n                break\n\n            regions.sort(key=lambda x: len(x[2]), reverse=True)\n\n            max_infected, max_walls, _ = regions[0]\n            ans += max_walls\n            quarantine(mat, max_infected)\n\n            future_infections = set()\n            for _, _, future_infection in regions[1:]:\n                future_infections |= future_infection\n                \n            spread(mat, future_infections)\n            \n        return ans\n```"
    },
    {
        "question_id": 699,
        "optimized_code": "```python\nclass Node:\n    def __init__(self, l, r):\n        self.l = l\n        self.r = r\n        self.mid = (l + r) // 2\n        self.v = 0\n        self.add = 0\n        self.left = None\n        self.right = None\n\nclass SegmentTree:\n    def __init__(self):\n        self.root = Node(1, int(1e9))\n\n    def modify(self, l, r, v):\n        nodes = [(self.root, 1, int(1e9))]\n        while nodes:\n            node, nl, nr = nodes.pop()\n            if l > nr or r < nl:\n                continue\n            if nl >= l and nr <= r:\n                node.v = v\n                node.add = v\n                continue\n\n            if node.left is None:\n                node.left = Node(node.l, node.mid)\n            if node.right is None:\n                node.right = Node(node.mid + 1, node.r)\n\n            self.pushdown(node)\n\n            nodes.append((node.right, node.mid + 1, node.r))\n            nodes.append((node.left, node.l, node.mid))\n\n            self.pushup(node)\n\n    def query(self, l, r):\n        nodes = [(self.root, 1, int(1e9))]\n        res = 0\n        while nodes:\n            node, nl, nr = nodes.pop()\n            if l > nr or r < nl:\n                continue\n            if nl >= l and nr <= r:\n                res = max(res, node.v)\n                continue\n\n            self.pushdown(node)\n            \n            if node.right is not None:\n                nodes.append((node.right, node.mid + 1, node.r))\n            if node.left is not None:\n                nodes.append((node.left, node.l, node.mid))\n\n        return res\n\n    def pushup(self, node):\n        if node.left and node.right:\n            node.v = max(node.left.v, node.right.v)\n\n    def pushdown(self, node):\n        if node.left is None:\n            node.left = Node(node.l, node.mid)\n        if node.right is None:\n            node.right = Node(node.mid + 1, node.r)\n        if node.add != 0:\n            node.left.add = node.add\n            node.right.add = node.add\n            node.left.v = node.add\n            node.right.v = node.add\n            node.add = 0\n\nclass Solution:\n    def fallingSquares(self, positions):\n        ans = []\n        tree = SegmentTree()\n        mx = 0\n        for pos in positions:\n            l, w = pos\n            r = l + w - 1\n            h = tree.query(l, r) + w\n            mx = max(mx, h)\n            ans.append(mx)\n            tree.modify(l, r, h)\n        return ans\n```"
    },
    {
        "question_id": 779,
        "optimized_code": "```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        max_so_far = 0\n        chunks = 0\n        for i, num in enumerate(arr):\n            max_so_far = max(max_so_far, num)\n            if max_so_far == i:\n                chunks += 1\n        return chunks\n```"
    },
    {
        "question_id": 759,
        "optimized_code": "```python\nclass Solution:\n    def intersectionSizeTwo(self, intervals: List[List[int]]) -> int:\n        intervals.sort(key=lambda x: x[1])\n        res = 0\n        cover = []\n\n        for interval in intervals:\n            start, end = interval\n            count = 0\n            for num in cover:\n                if start <= num <= end:\n                    count += 1\n\n            if count == 2:\n                continue\n            elif count == 1:\n                res += 1\n                cover.append(end)\n            else:\n                res += 2\n                cover.append(end - 1)\n                cover.append(end)\n            cover.sort()\n            cover = cover[-2:]\n\n        return res\n```"
    },
    {
        "question_id": 854,
        "optimized_code": "```python\nclass Solution:\n    def largestIsland(self, grid: List[List[int]]) -> int:\n        \n        def bfs(row, col, island_id):\n            area = 0\n            q = [(row, col)]\n            grid[row][col] = island_id\n            area += 1\n            \n            while q:\n                r, c = q.pop(0)\n                for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                    nr, nc = r + dr, c + dc\n                    if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and grid[nr][nc] == 1:\n                        grid[nr][nc] = island_id\n                        q.append((nr, nc))\n                        area += 1\n            return area\n\n        island_id = 2\n        island_sizes = {}\n        for r in range(len(grid)):\n            for c in range(len(grid[0])):\n                if grid[r][c] == 1:\n                    area = bfs(r, c, island_id)\n                    island_sizes[island_id] = area\n                    island_id += 1\n\n        max_area = 0\n        for area in island_sizes.values():\n            max_area = max(max_area, area)\n\n        for r in range(len(grid)):\n            for c in range(len(grid[0])):\n                if grid[r][c] == 0:\n                    neighboring_islands = set()\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = r + dr, c + dc\n                        if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and grid[nr][nc] > 1:\n                            neighboring_islands.add(grid[nr][nc])\n\n                    area_with_this_zero = 1\n                    for island_id in neighboring_islands:\n                        area_with_this_zero += island_sizes[island_id]\n                    max_area = max(max_area, area_with_this_zero)\n\n        return max_area\n```"
    },
    {
        "question_id": 855,
        "optimized_code": "```python\nimport collections\n\nclass Solution:\n    def uniqueLetterString(self, s: str) -> int:\n        index = collections.defaultdict(list)\n        for i, c in enumerate(s):\n            index[c].append(i)\n        \n        ans = 0\n        for c in index:\n            arr = index[c]\n            for i in range(len(arr)):\n                prev = arr[i-1] if i > 0 else -1\n                next_ = arr[i+1] if i < len(arr) - 1 else len(s)\n                ans += (arr[i] - prev) * (next_ - arr[i])\n        return ans % (10**9 + 7)\n```"
    },
    {
        "question_id": 856,
        "optimized_code": "```python\nclass Solution:\n    def consecutiveNumbersSum(self, n: int) -> int:\n        w = 0\n        k = 1\n        while k * (k + 1) / 2 <= n:\n            if (n - k * (k - 1) / 2) % k == 0:\n                w += 1\n            k += 1\n\n        return w\n```"
    },
    {
        "question_id": 552,
        "optimized_code": "```python\nclass Solution:\n    def checkRecord(self, n: int) -> int:\n        MOD = 10**9 + 7\n        dp = [[[0] * 3 for _ in range(2)] for _ in range(2)]\n        \n        dp[0][0][0] = 1\n        \n        for i in range(1, n + 1):\n            curr_dp = [[[0] * 3 for _ in range(2)] for _ in range(2)]\n            \n            # Add 'A'\n            curr_dp[1][0][0] = (dp[0][0][0] + dp[0][0][1] + dp[0][0][2] + dp[0][1][0] + dp[0][1][1] + dp[0][1][2]) % MOD\n            \n            # Add 'L'\n            curr_dp[0][0][1] = dp[0][0][0]\n            curr_dp[0][1][1] = dp[0][1][0]\n            \n            curr_dp[0][0][2] = dp[0][0][1]\n            curr_dp[0][1][2] = dp[0][1][1]\n            \n            # Add 'P'\n            curr_dp[0][0][0] = (dp[0][0][0] + dp[0][0][1] + dp[0][0][2]) % MOD\n            curr_dp[0][1][0] = (dp[0][1][0] + dp[0][1][1] + dp[0][1][2]) % MOD\n            \n            dp = curr_dp\n        \n        total = 0\n        for a in range(2):\n            for l in range(3):\n                total = (total + dp[0][a][l] + dp[1][a][l]) % MOD\n        \n        return total\n```"
    },
    {
        "question_id": 939,
        "optimized_code": "```python\nfrom collections import defaultdict\n\nclass Solution:\n    def numPermsDISequence(self, s: str) -> int:\n        n = len(s)\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        dp[0][0] = 1\n        mod = 10**9 + 7\n\n        for i in range(1, n + 1):\n            new_dp = [[0] * (n + 1) for _ in range(n + 1)]\n            prefix_sum = 0\n            for j in range(i):\n                if s[i - 1] == 'D':\n                    new_dp[i][j] = (prefix_sum + dp[i - 1][j]) % mod\n                    prefix_sum = new_dp[i][j]\n                else:\n                    new_dp[i][j] = (sum(dp[i - 1][k] for k in range(j, i))) % mod\n            dp = new_dp\n\n        return sum(dp[n]) % mod\n```"
    }
]