[
    {
        "question_id": 131,
        "optimized_code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        n = len(s)\n        dp = [[False] * n for _ in range(n)]\n\n        for i in range(n - 1, -1, -1):\n            for j in range(i, n):\n                if s[i] == s[j] and (j - i <= 2 or dp[i + 1][j - 1]):\n                    dp[i][j] = True\n\n        res = []\n        def backtrack(i, curr):\n            if i == n:\n                res.append(curr[:])\n                return\n\n            for j in range(i, n):\n                if dp[i][j]:\n                    curr.append(s[i:j+1])\n                    backtrack(j+1, curr)\n                    curr.pop()\n\n        backtrack(0, [])\n        return res"
    },
    {
        "question_id": 132,
        "optimized_code": "class Solution:\n    def minCut(self, s: str) -> int:\n        n = len(s)\n        is_palindrome = [[False] * n for _ in range(n)]\n\n        for i in range(n):\n            is_palindrome[i][i] = True\n\n        for i in range(n - 1):\n            if s[i] == s[i+1]:\n                is_palindrome[i][i+1] = True\n\n        for length in range(3, n + 1):\n            for i in range(n - length + 1):\n                j = i + length - 1\n                if s[i] == s[j] and is_palindrome[i+1][j-1]:\n                    is_palindrome[i][j] = True\n\n        dp = [0] * n\n        for i in range(n):\n            if is_palindrome[0][i]:\n                dp[i] = 0\n            else:\n                dp[i] = i\n                for j in range(i):\n                    if is_palindrome[j+1][i]:\n                        dp[i] = min(dp[i], dp[j] + 1)\n\n        return dp[n-1]"
    },
    {
        "question_id": 135,
        "optimized_code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        n = len(ratings)\n        candies = [1] * n\n\n        # First pass: From left to right\n        for i in range(1, n):\n            if ratings[i] > ratings[i - 1]:\n                candies[i] = candies[i - 1] + 1\n\n        # Second pass: From right to left\n        for i in range(n - 2, -1, -1):\n            if ratings[i] > ratings[i + 1]:\n                candies[i] = max(candies[i], candies[i + 1] + 1)\n\n        return sum(candies)"
    },
    {
        "question_id": 137,
        "optimized_code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        result = 0\n        for num in nums:\n            result ^= num\n        return result"
    },
    {
        "question_id": 138,
        "optimized_code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        old_to_new = {None:None}\n        \n        old = head\n        while old:\n            new = Node(old.val)\n            old_to_new[old] = new\n            old = old.next\n        \n        old = head\n        while old:\n            new = old_to_new[old]\n            new.next = old_to_new[old.next]\n            new.random = old_to_new[old.random]\n            old = old.next\n        \n        return old_to_new[head]"
    },
    {
        "question_id": 140,
        "optimized_code": "from typing import List\n\nclass Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\n        word_set = set(wordDict)\n        n = len(s)\n        dp = [[] for _ in range(n + 1)]\n        dp[0] = [\"\"]\n\n        for i in range(1, n + 1):\n            for j in range(i):\n                word = s[j:i]\n                if word in word_set and dp[j]:\n                    for sentence in dp[j]:\n                        dp[i].append((sentence + \" \" + word).strip())\n\n        return dp[n]"
    },
    {
        "question_id": 134,
        "optimized_code": "class Solution:\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\n        n = len(gas)\n        total_gas = 0\n        curr_gas = 0\n        start_index = 0\n\n        for i in range(n):\n            total_gas += gas[i] - cost[i]\n            curr_gas += gas[i] - cost[i]\n\n            if curr_gas < 0:\n                curr_gas = 0\n                start_index = i + 1\n        \n        return start_index if total_gas >= 0 else -1"
    },
    {
        "question_id": 228,
        "optimized_code": "class Solution:\n    def summaryRanges(self, nums: List[int]) -> List[str]:\n        result = []\n        if not nums:\n            return result\n\n        start = nums[0]\n        end = nums[0]\n\n        for i in range(1, len(nums)):\n            if nums[i] == end + 1:\n                end = nums[i]\n            else:\n                if start == end:\n                    result.append(str(start))\n                else:\n                    result.append(f\"{start}->{end}\")\n                start = nums[i]\n                end = nums[i]\n\n        if start == end:\n            result.append(str(start))\n        else:\n            result.append(f\"{start}->{end}\")\n\n        return result"
    },
    {
        "question_id": 229,
        "optimized_code": "class Solution:\n    def majorityElement(self, nums: List[int]) -> List[int]:\n        n1=None\n        c1=0\n        n2=None\n        c2=0\n        for num in nums:\n            if n1==num:\n                c1+=1\n            elif n2==num:\n                c2+=1\n            elif c1==0:\n                n1=num\n                c1=1\n            elif c2==0:\n                n2=num\n                c2=1\n            else:\n                c1-=1\n                c2-=1\n        c1=0\n        c2=0\n        for num in nums:\n            if num==n1:\n                c1+=1\n            if num==n2:\n                c2+=1\n        ans=[]\n        if c1>len(nums)//3:\n            ans.append(n1)\n        if c2>len(nums)//3 and n1 != n2:\n            ans.append(n2)\n        return ans"
    },
    {
        "question_id": 230,
        "optimized_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def helper(self, root, res):\n        if root:\n            self.helper(root.left, res)\n            res.append(root.val)\n            self.helper(root.right, res)\n        return\n\n\n    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:\n        stack = []\n        cur = root\n        while stack or cur:\n            while cur:\n                stack.append(cur)\n                cur = cur.left\n            cur = stack.pop()\n            k-=1\n            if k==0:\n                return cur.val\n            cur = cur.right\n        return -1"
    },
    {
        "question_id": 231,
        "optimized_code": "class Solution:\n    def isPowerOfTwo(self, n: int) -> bool:\n        return n > 0 and (n & (n - 1) == 0)"
    },
    {
        "question_id": 123,
        "optimized_code": "class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        n = len(prices)\n        dp = [[[0 for _ in range(3)] for _ in range(2)] for _ in range(2)]\n\n        for i in range(n - 1, -1, -1):\n            for j in range(2):\n                for k in range(1, 3):\n                    if j == 0:\n                        dp[i % 2][j][k] = max(-prices[i] + dp[(i + 1) % 2][1][k], 0 + dp[(i + 1) % 2][0][k])\n                    else:\n                        dp[i % 2][j][k] = max(+prices[i] + dp[(i + 1) % 2][0][k - 1], 0 + dp[(i + 1) % 2][1][k])\n\n        return dp[0][0][2]"
    },
    {
        "question_id": 125,
        "optimized_code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        l, r = 0, len(s) - 1\n        while l < r:\n            while l < r and not s[l].isalnum():\n                l += 1\n            while l < r and not s[r].isalnum():\n                r -= 1\n            if s[l].casefold() != s[r].casefold():\n                return False\n            l += 1\n            r -= 1\n        return True"
    },
    {
        "question_id": 128,
        "optimized_code": "class Solution:\n    def longestConsecutive(self, nums: List[int]) -> int:\n        numset = set(nums)\n        res = 0\n        for n in nums:\n            # check if n is a start of  seq\n            if (n-1) not in numset:\n                op = 0\n                while (n+op) in numset:\n                    op+=1\n                res = max(res,op)\n        return res"
    },
    {
        "question_id": 130,
        "optimized_code": "class Solution:\n    def solve(self, board: List[List[str]]) -> None:\n        \"\"\"\n        Do not return anything, modify board in-place instead.\n        \"\"\"\n        if not board:\n            return\n\n        M, N = len(board), len(board[0])\n\n        def dfs(i, j):\n            if i < 0 or i >= M or j < 0 or j >= N or board[i][j] != 'O':\n                return\n            \n            board[i][j] = '#'\n            dfs(i + 1, j)\n            dfs(i - 1, j)\n            dfs(i, j + 1)\n            dfs(i, j - 1)\n\n        # Mark 'O's connected to the boundary\n        for i in range(M):\n            if board[i][0] == 'O':\n                dfs(i, 0)\n            if board[i][N - 1] == 'O':\n                dfs(i, N - 1)\n\n        for j in range(N):\n            if board[0][j] == 'O':\n                dfs(0, j)\n            if board[M - 1][j] == 'O':\n                dfs(M - 1, j)\n\n        # Replace remaining 'O's with 'X's and restore '#'s to 'O's\n        for i in range(M):\n            for j in range(N):\n                if board[i][j] == 'O':\n                    board[i][j] = 'X'\n                elif board[i][j] == '#':\n                    board[i][j] = 'O'"
    },
    {
        "question_id": 82,
        "optimized_code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        fake = ListNode(-1)\n        fake.next = head\n        prev, curr = fake, head\n        while curr:\n            while curr.next and curr.val == curr.next.val:\n                curr = curr.next\n            if prev.next == curr:\n                prev = prev.next\n                curr = curr.next\n            else:\n                prev.next = curr.next\n                curr = prev.next\n        return fake.next"
    },
    {
        "question_id": 84,
        "optimized_code": "class Solution:\n    def largestRectangleArea(self, heights: List[int]) -> int:\n        st = []\n        area = 0\n        heights = [0] + heights + [0]\n\n        for i,a in enumerate(heights):\n            while(st and heights[st[-1]] > a):\n                rr = i\n                k = st.pop()\n                ll = st[-1]\n                h = heights[k]\n                length = rr - ll - 1 \n                area = max(area, h * length)\n\n            st.append(i)\n\n        return area"
    },
    {
        "question_id": 85,
        "optimized_code": "class Solution:\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\n        if not matrix:\n            return 0\n\n        m, n = len(matrix), len(matrix[0])\n        heights = [0] * n\n        max_area = 0\n\n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == '1':\n                    heights[j] += 1\n                else:\n                    heights[j] = 0\n\n            max_area = max(max_area, self.largestRectangleArea(heights))\n\n        return max_area\n\n    def largestRectangleArea(self, heights: List[int]) -> int:\n        stack = []\n        max_area = 0\n        n = len(heights)\n\n        for i in range(n + 1):\n            while stack and (i == n or heights[stack[-1]] >= heights[i]):\n                height = heights[stack.pop()]\n                width = i if not stack else i - stack[-1] - 1\n                max_area = max(max_area, height * width)\n            stack.append(i)\n\n        return max_area"
    },
    {
        "question_id": 87,
        "optimized_code": "class Solution:\n    def isScramble(self, s1: str, s2: str) -> bool:\n        n = len(s1)\n        if n != len(s2):\n            return False\n        if s1 == s2:\n            return True\n        if sorted(s1) != sorted(s2):\n            return False\n\n        memo = {}\n\n        def solve(s1, s2):\n            if (s1, s2) in memo:\n                return memo[(s1, s2)]\n\n            if s1 == s2:\n                return True\n\n            if sorted(s1) != sorted(s2):\n                memo[(s1, s2)] = False\n                return False\n\n            n = len(s1)\n            for i in range(1, n):\n                if (solve(s1[:i], s2[:i]) and solve(s1[i:], s2[i:])) or \\\n                   (solve(s1[:i], s2[n-i:]) and solve(s1[i:], s2[:n-i])):\n                    memo[(s1, s2)] = True\n                    return True\n\n            memo[(s1, s2)] = False\n            return False\n\n        return solve(s1, s2)"
    },
    {
        "question_id": 88,
        "optimized_code": "class Solution:\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\n        \"\"\"\n        Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        p1 = m-1\n        p2 = n-1\n        p = m+n-1\n        while p2 >= 0:\n            if p1 >= 0 and nums1[p1] > nums2[p2]:\n                nums1[p] = nums1[p1]\n                p1 -= 1\n            else:\n                nums1[p] = nums2[p2]\n                p2 -= 1\n            p -= 1"
    },
    {
        "question_id": 89,
        "optimized_code": "class Solution:\n    def grayCode(self, n: int) -> List[int]:\n        result = [0]\n        for i in range(n):\n            mask = 1 << i\n            for j in range(len(result) - 1, -1, -1):\n                result.append(result[j] | mask)\n        return result"
    },
    {
        "question_id": 90,
        "optimized_code": "class Solution:\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\n        ans=[]\n        ds=[]\n\n        def findSubsets(ind:int):\n            ans.append(ds[:])\n            for i in range(ind,len(nums)):\n                if i != ind and nums[i] == nums[i-1]:\n                    continue\n                ds.append(nums[i])\n                findSubsets(i+1)\n                ds.pop()\n        nums.sort()\n        findSubsets(0)\n        return ans"
    },
    {
        "question_id": 144,
        "optimized_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        ans = []\n        def solve(root):\n            if root is None:\n                return\n\n            ans.append(root.val)\n            solve(root.left)\n            solve(root.right)\n        solve(root)\n        return ans"
    },
    {
        "question_id": 148,
        "optimized_code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        def merge(head1, head2):\n            resultHead = ListNode(0)\n            cur = resultHead\n            while head1 and head2:\n                if head1.val < head2.val:\n                    cur.next = head1\n                    head1 = head1.next\n                else:\n                    cur.next = head2\n                    head2 = head2.next\n                cur = cur.next\n            \n            if head1:\n                cur.next = head1\n            if head2:\n                cur.next = head2\n            \n            return resultHead.next\n\n\n        def findOneBeforeMiddle(head):\n            slow = head\n            fast = head.next\n            while fast and fast.next:\n                slow = slow.next\n                fast = fast.next.next\n            return slow\n        \n        if not head or not head.next:\n            return head\n\n        middle = findOneBeforeMiddle(head)\n        temp = middle.next\n        middle.next = None\n\n        return merge(self.sortList(head), self.sortList(temp))"
    },
    {
        "question_id": 149,
        "optimized_code": "from typing import List\nfrom collections import defaultdict\nfrom math import gcd\n\nclass Solution:\n\n    def maxPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        if n <= 2:\n            return n\n        \n        max_count = 0\n        for i in range(n):\n            lines = defaultdict(int)\n            same_point = 1\n            for j in range(i + 1, n):\n                if points[i] == points[j]:\n                    same_point += 1\n                else:\n                    dx = points[j][0] - points[i][0]\n                    dy = points[j][1] - points[i][1]\n                    \n                    g = gcd(dx, dy)\n                    dx //= g\n                    dy //= g\n                    \n                    lines[(dx, dy)] += 1\n            \n            max_count = max(max_count, same_point)\n            for slope in lines:\n                max_count = max(max_count, lines[slope] + same_point)\n        \n        return max_count"
    },
    {
        "question_id": 150,
        "optimized_code": "class Solution:\n    def evalRPN(self, tokens):\n        stack = []\n        for token in tokens:\n            if token == '+':\n                operand2 = stack.pop()\n                operand1 = stack.pop()\n                stack.append(operand1 + operand2)\n            elif token == '-':\n                operand2 = stack.pop()\n                operand1 = stack.pop()\n                stack.append(operand1 - operand2)\n            elif token == '*':\n                operand2 = stack.pop()\n                operand1 = stack.pop()\n                stack.append(operand1 * operand2)\n            elif token == '/':\n                operand2 = stack.pop()\n                operand1 = stack.pop()\n                stack.append(int(operand1 / operand2))\n            else:\n                stack.append(int(token))\n        return stack[0]"
    },
    {
        "question_id": 153,
        "optimized_code": "class Solution:\n    def findMin(self, arr: List[int]) -> int:\n        n = len(arr)\n        l = 0\n        h = n - 1\n\n        while l <= h:\n            if arr[l] < arr[h]:\n                return min(arr[l], arr[l]) # already min, no need to compare with ans\n            \n            m = (l + h) // 2\n\n            if arr[l] <= arr[m]:\n                \n                l = m + 1\n            else:\n                \n                h = m - 1\n\n        return arr[l] if l < n else arr[0]"
    },
    {
        "question_id": 160,
        "optimized_code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        pA=headA\n        pB=headB\n        while pA!=pB:\n            pA=pA.next if pA else headB\n            pB=pB.next if pB else headA\n        return pA"
    },
    {
        "question_id": 238,
        "optimized_code": "class Solution:\n    def productExceptSelf(self, List, nums: List[int]) -> List[int]:\n        res = [1] * len(nums)\n\n        prefix = 1\n        for i in range(len(nums)):\n            res[i] = prefix\n            prefix *= nums[i]\n\n        postfix = 1\n        for i in range(len(nums) -1, -1, -1):\n            res[i] *= postfix\n            postfix *= nums[i]\n        return res"
    },
    {
        "question_id": 239,
        "optimized_code": "from collections import deque\n\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        d = deque()\n        result = []\n\n        for i, num in enumerate(nums):\n            # Remove elements out of the window\n            while d and d[0] <= i - k:\n                d.popleft()\n\n            # Remove elements smaller than the current element\n            while d and nums[d[-1]] <= num:\n                d.pop()\n\n            d.append(i)\n\n            if i >= k - 1:\n                result.append(nums[d[0]])\n\n        return result"
    },
    {
        "question_id": 241,
        "optimized_code": "class Solution:\n    def diffWaysToCompute(self, expression: str) -> List[int]:\n        memo = {}\n\n        def compute(expr):\n            if expr in memo:\n                return memo[expr]\n\n            if expr.isdigit():\n                return [int(expr)]\n\n            res = []\n            for i, s in enumerate(expr):\n                if s in \"+-*\":\n                    left = compute(expr[:i])\n                    right = compute(expr[i+1:])\n                    for l in left:\n                        for r in right:\n                            if s == '+':\n                                res.append(l + r)\n                            elif s == '-':\n                                res.append(l - r)\n                            else:\n                                res.append(l * r)\n\n            memo[expr] = res\n            return res\n\n        return compute(expression)"
    },
    {
        "question_id": 242,
        "optimized_code": "class Solution:\n    def isAnagram(self, s: str, t: str) -> bool:\n        if len(s) != len(t):\n            return False\n        sa = [0]*26\n        ta = [0]*26\n        for i in range(len(s)):\n            sa[ord(s[i])-ord('a')] += 1\n            ta[ord(t[i])-ord('a')] += 1\n        return sa==ta"
    },
    {
        "question_id": 31,
        "optimized_code": "class Solution:\n    def swap(self, nums, i, j):\n        nums[i], nums[j] = nums[j], nums[i]\n    def reverse(self, nums, i, j):\n        while i < j:\n            self.swap(nums, i, j)\n            i += 1\n            j -= 1\n            \n    def nextPermutation(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        i = len(nums) - 2\n        while i >= 0 and nums[i] >= nums[i + 1]:\n            i -= 1\n        if i >= 0:\n            j = len(nums) - 1\n            while nums[j] <= nums[i]:\n                j -= 1\n            self.swap(nums, i, j)\n        self.reverse(nums, i+1, len(nums) - 1)"
    },
    {
        "question_id": 32,
        "optimized_code": "class Solution:\n    def longestValidParentheses(self, s: str) -> int:\n        max_len = 0\n        stack = [-1]\n        for i in range(len(s)):\n            if s[i] == '(':\n                stack.append(i)\n            else:\n                stack.pop()\n                if not stack:\n                    stack.append(i)\n                else:\n                    max_len = max(max_len, i - stack[-1])\n        return max_len"
    },
    {
        "question_id": 33,
        "optimized_code": "class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        l = 0\n        r = len(nums) - 1\n        while l <= r:\n            mid = (l + r) // 2\n            if nums[mid] == target:\n                return mid\n\n            if nums[l] <= nums[mid]:\n                if nums[l] <= target <= nums[mid]:\n                    r = mid - 1\n                else:\n                    l = mid + 1\n            else:\n                if nums[mid] <= target <= nums[r]:\n                    l = mid + 1\n                else:\n                    r = mid - 1\n\n        return -1"
    },
    {
        "question_id": 34,
        "optimized_code": "from typing import List\nfrom bisect import bisect_left, bisect_right\n\nclass Solution:\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\n        l = bisect_left(nums, target)\n        if l == len(nums) or nums[l] != target:\n            return [-1, -1]\n        r = bisect_right(nums, target)\n        return [l, r - 1]"
    },
    {
        "question_id": 191,
        "optimized_code": "class Solution:\n    def hammingWeight(self, n: int) -> int:\n        count = 0\n        while n:\n            count += n & 1\n            n >>= 1\n        return count"
    },
    {
        "question_id": 198,
        "optimized_code": "class Solution:\n    def rob(self, nums: List[int]) -> int:\n        \n        if (len(nums) == 0):\n            return 0\n        elif (len(nums) == 1):\n            return nums[0]\n        \n        rob1, rob2 = 0, 0\n        \n        for n in nums:\n            temp = max(n + rob1, rob2)\n            rob1 = rob2\n            rob2 = temp\n            \n        return rob2"
    },
    {
        "question_id": 199,
        "optimized_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\n        def dfs(root, level):\n            if not root:\n                return\n            if len(res) == level:\n                res.append(root.val)\n            dfs(root.right, level + 1)\n            dfs(root.left, level + 1)\n        res = []\n        dfs(root, 0)\n        return res"
    },
    {
        "question_id": 201,
        "optimized_code": "class Solution:\n    def rangeBitwiseAnd(self, left: int, right: int) -> int:\n        while left < right:\n            right &= (right - 1)\n        return right"
    },
    {
        "question_id": 205,
        "optimized_code": "class Solution:\n    def isIsomorphic(self, s: str, t: str) -> bool:\n        stot = {}\n        ttos = {}\n        for s_, t_ in zip(s, t):\n            if s_ in stot and stot.get(s_)!=t_:\n                return False\n            if t_ in ttos and ttos.get(t_)!=s_:\n                return False\n\n            stot[s_] = t_\n            ttos[t_] = s_\n        return True"
    },
    {
        "question_id": 210,
        "optimized_code": "class Solution:\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\n        graph = [[] for _ in range(numCourses)]\n        in_degree = [0] * numCourses\n        \n        for course, pre in prerequisites:\n            graph[pre].append(course)\n            in_degree[course] += 1\n        \n        queue = [i for i in range(numCourses) if in_degree[i] == 0]\n        result = []\n        \n        while queue:\n            course = queue.pop(0)\n            result.append(course)\n            \n            for next_course in graph[course]:\n                in_degree[next_course] -= 1\n                if in_degree[next_course] == 0:\n                    queue.append(next_course)\n        \n        if len(result) == numCourses:\n            return result\n        else:\n            return []"
    },
    {
        "question_id": 214,
        "optimized_code": "class Solution:\n    def shortestPalindrome(self, s: str) -> str:\n        n = len(s)\n        combined = s + \"#\" + s[::-1]\n        m = len(combined)\n        lps = [0] * m\n        \n        for i in range(1, m):\n            length = lps[i - 1]\n            while length > 0 and combined[i] != combined[length]:\n                length = lps[length - 1]\n            if combined[i] == combined[length]:\n                length += 1\n            lps[i] = length\n        \n        return s[lps[-1]:][::-1] + s"
    },
    {
        "question_id": 216,
        "optimized_code": "class Solution:\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\n        if 45-(9-k)*(10-k)/2 < n or k*(k+1)/2 > n:\n            return []\n\n        def backtrack(comb, s, n):\n            if n == 0 and len(comb) == k:\n                output.append(comb.copy())\n                return\n            if len(comb) > k or n < 0:\n                return\n            for i in range(s, min(n+1, 10)):\n                comb.append(i)\n                backtrack(comb, i+1, n-i)\n                comb.pop()\n        \n        output = []\n        backtrack([], 1, n)\n        return output"
    },
    {
        "question_id": 93,
        "optimized_code": "class Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        path = []\n        result = []\n        len_s = len(s)\n\n        def is_valid_ip(s):\n            if not s:\n                return False\n            if (s[0] == '0' and len(s) > 1) or int(s) > 255:\n                return False\n            else:\n                return True\n\n        def backtracking(start_idx, point_count):\n            if point_count == 4:\n                if start_idx == len_s:\n                    result.append(\".\".join(path))\n                return\n\n            if len_s - start_idx < (4 - point_count) or len_s - start_idx > (4 - point_count) * 3:\n                return\n            \n\n            for i in range(start_idx, min(start_idx + 3, len_s)):\n                temp = s[start_idx:i + 1]\n                if is_valid_ip(temp):\n                    path.append(temp)\n                    backtracking(i + 1, point_count + 1)\n                    path.pop()\n\n        backtracking(0, 0)\n        return result"
    },
    {
        "question_id": 127,
        "optimized_code": "from collections import deque\nfrom typing import List\n\nclass Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\n        wordList = set(wordList)\n\n        if endWord not in wordList:\n            return 0\n        \n        def offByOne(s, t):\n            diff = 0\n            for i in range(len(s)):\n                if s[i] != t[i]:\n                    diff += 1\n                if diff > 1:\n                    return False\n            return diff == 1\n\n        queue = deque([(beginWord, 1)])\n        seen = {beginWord}\n        while queue:\n            word, length = queue.popleft()\n            if word == endWord:\n                return length\n\n            for nextWord in wordList:\n                if nextWord not in seen and offByOne(word, nextWord):\n                    queue.append((nextWord, length + 1))\n                    seen.add(nextWord)\n        return 0"
    },
    {
        "question_id": 81,
        "optimized_code": "class Solution:\n    def search(self, nums: List[int], target: int) -> bool:\n        left = 0\n        right = len(nums) - 1\n        while left <= right:\n            middle = (left + right) // 2\n            if nums[middle] == target:\n                return True\n            if (nums[left] == nums[middle] and nums[middle] == nums[right]):\n                left += 1\n                right -= 1\n            elif nums[left] <= nums[middle]:\n                if nums[left] <= target and target < nums[middle]:\n                    right = middle - 1\n                else:\n                    left = middle + 1\n            else:\n                if target > nums[middle] and target <= nums[right]:\n                    left = middle + 1\n                else:\n                    right = middle - 1\n        return False"
    },
    {
        "question_id": 151,
        "optimized_code": "class Solution:\n    def reverseWords(self, s: str) -> str:\n        words = []\n        word = \"\"\n        for char in s:\n            if char == \" \":\n                if word:\n                    words.append(word)\n                    word = \"\"\n            else:\n                word += char\n        if word:\n            words.append(word)\n        \n        reversed_words = []\n        for i in range(len(words) - 1, -1, -1):\n            reversed_words.append(words[i])\n        \n        return \" \".join(reversed_words)"
    },
    {
        "question_id": 152,
        "optimized_code": "class Solution:\n    def maxProduct(self, nums: List[int]) -> int:\n        max_prod = float('-inf')\n        prefix, suffix = 1, 1\n        n = len(nums)\n        for i in range(n):\n            prefix *= nums[i]\n            suffix *= nums[n - i - 1]\n            max_prod = max(max_prod, prefix, suffix)\n            if prefix == 0: prefix = 1\n            if suffix == 0: suffix = 1\n        return max_prod"
    },
    {
        "question_id": 95,
        "optimized_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def generateTrees(self, n: int) -> List[TreeNode]:\n        def dfs(l, r, memo):\n            if (l, r) in memo:\n                return memo[(l, r)]\n            if r < l:\n                return [None]\n            arr = []\n            for m in range(l, r + 1):\n                left = dfs(l, m - 1, memo)\n                right = dfs(m + 1, r, memo)\n                for lNode in left:\n                    for rNode in right:\n                        new = TreeNode(m)\n                        new.left = lNode\n                        new.right = rNode\n                        arr.append(new)\n            memo[(l, r)] = arr\n            return arr\n\n        if n == 0:\n            return []\n\n        res = dfs(1, n, {})\n        return res if res != [None] else []"
    },
    {
        "question_id": 96,
        "optimized_code": "class Solution:\n    def numTrees(self, n: int) -> int:\n\n        list_ = [0]*(n + 1)\n        list_[0], list_[1] = 1,1\n        for i in range(2, n+1):\n            for j in range(1,i+1):\n                list_[i] += list_[j-1]*list_[i-j]\n\n        return list_[n]"
    },
    {
        "question_id": 97,
        "optimized_code": "class Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n\n        # dp[i][j] represents whether the first i characters in s1\n        # and the first j characters in s2\n        # can form the first i + j characters of s3\n\n        if len(s1) + len(s2) != len(s3):\n            return False\n\n        dp = [[False] * (len(s2) + 1) for _ in range((len(s1) + 1))]\n\n        # true for empty string\n        dp[0][0] = True\n\n        for i in range(len(s1) + 1):\n            for j in range(len(s2) + 1):\n                if i == 0 and j == 0:\n                    continue\n                # initialise base cases i and j\n                elif i == 0:\n                    dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\n                elif j == 0:\n                    dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\n                # interleave using either s1 OR s2\n                else:\n                    dp[i][j] = (dp[i][j - 1] and s2[j - 1] == s3[j + i - 1]) or \\\n                               (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1])\n\n        return dp[len(s1)][len(s2)]"
    },
    {
        "question_id": 1,
        "optimized_code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        num_map = {}\n        for index, num in enumerate(nums):\n            complement = target - num\n            if complement in num_map:\n                return [num_map[complement], index]\n            num_map[num] = index"
    },
    {
        "question_id": 5,
        "optimized_code": "class Solution:\n    def longestPalindrome(self, s: str) -> str:\n        longest = \"\"\n        n = len(s)\n        dp = [[False] * n for _ in range(n)]\n\n        for i in range(n):\n            dp[i][i] = True\n            if len(longest) == 0:\n                longest = s[i]\n\n        for i in range(n - 1):\n            if s[i] == s[i + 1]:\n                dp[i][i + 1] = True\n                if len(longest) < 2:\n                    longest = s[i:i+2]\n\n        for length in range(3, n + 1):\n            for i in range(n - length + 1):\n                j = i + length - 1\n                if s[i] == s[j] and dp[i + 1][j - 1]:\n                    dp[i][j] = True\n                    if length > len(longest):\n                        longest = s[i:j+1]\n\n        return longest"
    },
    {
        "question_id": 6,
        "optimized_code": "class Solution:\n    def convert(self, s: str, numRows: int) -> str:\n        if numRows <= 1 or numRows >= len(s):\n            return s\n\n        result = \"\"\n        cycle_len = 2 * numRows - 2\n\n        for row in range(numRows):\n            for j in range(0, len(s), cycle_len):\n                index = j + row\n                if index < len(s):\n                    result += s[index]\n                if row != 0 and row != numRows - 1 and j + cycle_len - row < len(s):\n                    result += s[j + cycle_len - row]\n\n        return result"
    },
    {
        "question_id": 8,
        "optimized_code": "class Solution:\n    def myAtoi(self, s: str) -> int:\n        negative = False\n        start_digit = False\n        result = 0\n        INT_MAX = 2**31 - 1\n        INT_MIN = -2**31\n        \n        for char in s:\n            if char == \" \" and not start_digit:\n                continue\n            \n            if char == \"-\" and not start_digit:\n                negative = True\n                start_digit = True\n                continue\n            elif char == \"+\" and not start_digit:\n                start_digit = True\n                continue\n            \n            if char.isdigit():\n                digit = int(char)\n                if result > INT_MAX // 10 or (result == INT_MAX // 10 and digit > 7):\n                    return INT_MAX if not negative else INT_MIN\n                result = result * 10 + digit\n                start_digit = True\n                continue\n            \n            # If a non-digit character is encountered after starting to read digits\n            if start_digit:\n                break\n            \n            # If the character is invalid at the start (non-digit and not a sign)\n            if not char.isdigit() and not start_digit:\n                return 0\n        \n        if negative:\n            result = -result\n        \n        return result"
    },
    {
        "question_id": 309,
        "optimized_code": "class Solution:\n    def maxProfit(self, prices: list[int]) -> int:\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        max_profit = 0\n        min_price = float('inf')\n\n        for price in prices:\n            min_price = min(min_price, price)\n            profit = price - min_price\n            max_profit = max(max_profit, profit)\n\n        return max_profit"
    },
    {
        "question_id": 299,
        "optimized_code": "class Solution:\n    def getHint(self, secret: str, guess: str) -> str:\n        counts = {}\n        bulls = 0\n        cows = 0\n\n        for i in range(len(secret)):\n            if secret[i] == guess[i]:\n                bulls += 1\n            else:\n                counts[secret[i]] = counts.get(secret[i], 0) + 1\n\n        for i in range(len(secret)):\n            if secret[i] != guess[i]:\n                if guess[i] in counts and counts[guess[i]] > 0:\n                    cows += 1\n                    counts[guess[i]] -= 1\n\n        return f'{bulls}A{cows}B'"
    },
    {
        "question_id": 301,
        "optimized_code": "class Solution:\n    def removeInvalidParentheses(self, s: str) -> List[str]:\n        def is_valid(s):\n            count = 0\n            for char in s:\n                if char == '(':\n                    count += 1\n                elif char == ')':\n                    count -= 1\n                    if count < 0:\n                        return False\n            return count == 0\n\n        level = {s}\n        while True:\n            valid = list(filter(is_valid, level))\n            if valid:\n                return valid\n\n            next_level = set()\n            for item in level:\n                for i in range(len(item)):\n                    if item[i] in '()':\n                        next_level.add(item[:i] + item[i+1:])\n            level = next_level"
    },
    {
        "question_id": 162,
        "optimized_code": "class Solution:\n    def findPeakElement(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n == 1:\n            return 0\n        if nums[0] > nums[1]:\n            return 0\n        if nums[n-1] > nums[n-2]:\n            return n-1\n        \n        for i in range(1, n-1):\n            if nums[i] > nums[i-1] and nums[i] > nums[i+1]:\n                return i\n        return 0"
    },
    {
        "question_id": 164,
        "optimized_code": "class Solution:\n    def maximumGap(self, nums: List[int]) -> int:\n        if len(nums) < 2:\n            return 0\n        if len(nums) == 2:\n            return abs(nums[0] - nums[1])\n        nmax, nmin = max(nums), min(nums)\n        if nmax == nmin:\n            return 0\n        num_buckets = len(nums) - 1\n        bucket_size = (nmax - nmin) / num_buckets\n        buckets = [[float('inf'), -1] for _ in range(num_buckets)]\n        for num in nums:\n            bucket_num = min(int((num - nmin) // bucket_size), num_buckets - 1)\n            buckets[bucket_num][0] = min(buckets[bucket_num][0], num)\n            buckets[bucket_num][1] = max(buckets[bucket_num][1], num)\n        prev_bucket = [float('inf'), nmin] # Changed initialization to include nmin\n        ret = 0 # Changed initialization to 0\n        for i in range(len(buckets)):\n            cur_bucket = buckets[i]\n            if cur_bucket[1] != -1:\n                ret = max(ret, cur_bucket[0] - prev_bucket[1])\n                prev_bucket = cur_bucket\n        ret = max(ret, nmax - prev_bucket[1]) # Handle the gap between last non-empty bucket and nmax\n        return ret"
    },
    {
        "question_id": 166,
        "optimized_code": "class Solution:\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\n        if numerator==0:\n            return \"0\"\n        if denominator == 0:\n            return\n        string = []\n        if numerator * denominator < 0 :\n            string.append(\"-\")\n        numerator, denominator = abs(numerator), abs(denominator)\n        quo = numerator//denominator\n        string.append(str(quo))\n        rem = numerator%denominator\n\n        if rem==0:\n            return ''.join(string)\n        else:\n            string.append(\".\")\n        seen = {}\n        while rem:\n            if rem in seen:\n                ind = seen[rem]\n                return ''.join(string[:ind]) + \"(\" + ''.join(string[ind:]) + \")\"\n            seen[rem] = len(string)\n            rem *= 10\n            quo = rem//denominator\n            rem = rem%denominator\n            string.append(str(quo))\n        return ''.join(string)"
    },
    {
        "question_id": 168,
        "optimized_code": "class Solution:\n    def convertToTitle(self, columnNumber: int) -> str:\n        result = ''\n        while columnNumber > 0:\n            columnNumber -= 1\n            remainder = columnNumber % 26\n            result = chr(65 + remainder) + result\n            columnNumber //= 26\n        return result"
    },
    {
        "question_id": 43,
        "optimized_code": "class Solution:\n    def multiply(self, num1: str, num2: str) -> str:\n        if num1 == \"0\" or num2 == \"0\":\n            return \"0\"\n\n        n1, n2 = len(num1), len(num2)\n        product = [0] * (n1 + n2)\n\n        for i in range(n1 - 1, -1, -1):\n            carry = 0\n            for j in range(n2 - 1, -1, -1):\n                product[i + j + 1] += int(num1[i]) * int(num2[j]) + carry\n                carry = product[i + j + 1] // 10\n                product[i + j + 1] %= 10\n            product[i] += carry\n\n        result = \"\".join(map(str, product))\n        while result[0] == '0' and len(result) > 1:\n            result = result[1:]\n        return result"
    },
    {
        "question_id": 50,
        "optimized_code": "class Solution:\n    def myPow(self, x: float, n: int) -> float:\n        ans = 1\n        abs_n = abs(n)\n        while abs_n > 0:\n            if abs_n & 1:\n                ans *= x\n            x *= x\n            abs_n >>= 1\n\n        if n < 0:\n            return 1 / ans\n        else:\n            return ans"
    },
    {
        "question_id": 221,
        "optimized_code": "class Solution:\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\n        if not matrix:\n            return 0\n\n        rows, cols = len(matrix), len(matrix[0])\n        dp = [[0] * cols for _ in range(rows)]\n        max_side = 0\n\n        for i in range(rows):\n            for j in range(cols):\n                if matrix[i][j] == '1':\n                    if i == 0 or j == 0:\n                        dp[i][j] = 1\n                    else:\n                        dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n                    max_side = max(max_side, dp[i][j])\n\n        return max_side * max_side"
    },
    {
        "question_id": 223,
        "optimized_code": "class Solution:\n    def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -> int:\n        area_a = (ax2 - ax1) * (ay2 - ay1)\n        area_b = (bx2 - bx1) * (by2 - by1)\n\n        intersect_width = max(0, min(ax2, bx2) - max(ax1, bx1))\n        intersect_height = max(0, min(ay2, by2) - max(ay1, by1))\n\n        return area_a + area_b - intersect_width * intersect_height"
    },
    {
        "question_id": 107,
        "optimized_code": "from collections import deque\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n\n        if not root:\n            return []\n\n        queue = deque([root])\n        solutions = []\n\n        while queue:\n            level = []\n            level_size = len(queue)\n\n            for _ in range(level_size):\n                node = queue.popleft()\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n\n\n            solutions.append(level)\n\n        return solutions[::-1]"
    },
    {
        "question_id": 109,
        "optimized_code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        def find_size(head):\n            size = 0\n            curr = head\n            while curr:\n                size += 1\n                curr = curr.next\n            return size\n\n        def to_bst(start, end):\n            if start > end:\n                return None\n\n            mid = (start + end) // 2\n\n            left = to_bst(start, mid - 1)\n\n            nonlocal head\n            node = TreeNode(head.val)\n            node.left = left\n            head = head.next\n\n            node.right = to_bst(mid + 1, end)\n\n            return node\n\n        size = find_size(head)\n        return to_bst(0, size - 1)"
    },
    {
        "question_id": 268,
        "optimized_code": "class Solution:\n    def missingNumber(self, nums: List[int]) -> int:\n        n = len(nums)\n        expected_sum = n * (n + 1) // 2\n        actual_sum = sum(nums)\n        return expected_sum - actual_sum"
    },
    {
        "question_id": 172,
        "optimized_code": "class Solution:\n    def trailingZeroes(self, n: int) -> int:\n        ans = 0\n        while n > 0:\n            n //= 5\n            ans += n\n        return ans"
    },
    {
        "question_id": 179,
        "optimized_code": "class Solution:\n    def largestNumber(self, nums: List[int]) -> str:\n        nums = [str(num) for num in nums]\n        nums.sort(key=lambda x: x * 3, reverse=True)\n        return str(int(\"\".join(nums)))"
    },
    {
        "question_id": 187,
        "optimized_code": "class Solution:\n    def findRepeatedDnaSequences(self, s: str) -> List[str]:\n        if len(s) < 10:\n            return []\n\n        mapping = {'A': 0, 'C': 1, 'G': 2, 'T': 3}\n        seen = set()\n        repeated = set()\n        ans = []\n\n        for i in range(len(s) - 9):\n            num = 0\n            for j in range(i, i + 10):\n                num <<= 2\n                num |= mapping[s[j]]\n\n            if num in seen:\n                if num not in repeated:\n                    ans.append(s[i:i+10])\n                    repeated.add(num)\n            else:\n                seen.add(num)\n\n        return ans"
    },
    {
        "question_id": 12,
        "optimized_code": "class Solution:\n    def intToRoman(self, num: int) -> str:\n        dictionary = {1000:'M', 900:'CM', 500:'D', 400:'CD', 100:'C', 90:'XC', 50:'L', 40:'XL', 10:'X', 9:'IX', 5:'V', 4:'IV', 1:'I'}\n        ans=''\n        for key, val in dictionary.items():\n            while num>=key:\n                ans+=val\n                num-=key\n            if num==0:break\n        return ans"
    },
    {
        "question_id": 13,
        "optimized_code": "class Solution:\n    def romanToInt(self, s: str) -> int:\n        m = {\n            'I': 1,\n            'V': 5,\n            'X': 10,\n            'L': 50,\n            'C': 100,\n            'D': 500,\n            'M': 1000\n        }\n        \n        ans = 0\n        \n        for i in range(len(s)):\n            if i < len(s) - 1 and m[s[i]] < m[s[i+1]]:\n                ans -= m[s[i]]\n            else:\n                ans += m[s[i]]\n        \n        return ans"
    },
    {
        "question_id": 113,
        "optimized_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:\n        res = []\n\n        def helper(root, sm, path):\n            if not root:\n                return\n\n            sm += root.val\n            path.append(root.val)\n\n            if not root.left and not root.right:\n                if sm == targetSum:\n                    res.append(path[:])  # Append a copy to avoid modification\n\n            helper(root.left, sm, path)\n            helper(root.right, sm, path)\n\n            path.pop()  # Backtrack\n\n        helper(root, 0, [])\n        return res"
    },
    {
        "question_id": 117,
        "optimized_code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.next = next\n\"\"\"\n\nclass Solution:\n    def connect(self, root: 'Node') -> 'Node':\n        if not root:\n            return root\n\n        leftmost = root\n\n        while leftmost:\n            head = leftmost\n            leftmost = None\n            prev = None\n\n            while head:\n                if head.left:\n                    if not leftmost:\n                        leftmost = head.left\n                    if prev:\n                        prev.next = head.left\n                    prev = head.left\n\n                if head.right:\n                    if not leftmost:\n                        leftmost = head.right\n                    if prev:\n                        prev.next = head.right\n                    prev = head.right\n                head = head.next\n\n        return root"
    },
    {
        "question_id": 118,
        "optimized_code": "class Solution:\n    def generate(self, numRows: int) -> List[List[int]]:\n        \n        result = []\n        for i in range(numRows):\n            row = [None for _ in range(i+1)]\n            row[0], row[-1] = 1, 1\n            for j in range(1, len(row)-1):\n                row[j] = result[i-1][j-1] + result[i-1][j]\n            result.append(row)\n        return result"
    },
    {
        "question_id": 119,
        "optimized_code": "class Solution:\n    def getRow(self, rowIndex: int) -> List[int]:\n        row = [0] * (rowIndex + 1)\n        row[0] = 1\n\n        for i in range(1, rowIndex + 1):\n            for j in range(i, 0, -1):\n                row[j] = row[j] + row[j - 1]\n        return row"
    },
    {
        "question_id": 260,
        "optimized_code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> List[int]:\n        counts = {}\n        for num in nums:\n            counts[num] = counts.get(num, 0) + 1\n\n        L = []\n        for num, count in counts.items():\n            if count == 1:\n                L.append(num)\n\n        return L"
    },
    {
        "question_id": 264,
        "optimized_code": "from heapq import heappop, heappush\n\nclass Solution:\n    def nthUglyNumber(self, n: int) -> int:\n        \n        heap = [1]\n        seen = {1}\n        count=1\n        while count<n:\n            smal = heappop(heap)\n            \n            if smal*2 not in seen:\n                heappush(heap,smal*2)\n                seen.add(smal*2)\n            if smal*3 not in seen:\n                heappush(heap,smal*3)\n                seen.add(smal*3)\n            if smal*5 not in seen:\n                heappush(heap,smal*5)\n                seen.add(smal*5)\n            count+=1\n        return heappop(heap)"
    },
    {
        "question_id": 71,
        "optimized_code": "class Solution:\n    def simplifyPath(self, path: str) -> str:\n        components = path.split('/')\n        stack = []\n        \n        for component in components:\n            if not component or component == '.':\n                continue\n            elif component == '..':\n                if stack:\n                    stack.pop()\n            else:\n                stack.append(component)\n        \n        simplified_path = '/' + '/'.join(stack)\n        return simplified_path"
    },
    {
        "question_id": 75,
        "optimized_code": "class Solution:\n    def sortColors(self, nums: List[int]) -> None:\n        low = 0\n        mid = 0\n        high = len(nums) - 1\n        \n        while mid <= high:\n            if nums[mid] == 0:\n                nums[low], nums[mid] = nums[mid], nums[low]\n                low += 1\n                mid += 1\n            elif nums[mid] == 1:\n                mid += 1\n            else:\n                nums[mid], nums[high] = nums[high], nums[mid]\n                high -= 1"
    },
    {
        "question_id": 77,
        "optimized_code": "class Solution:\n    def combine(self, n: int, k: int) -> List[List[int]]:\n        res = []\n        combination = [0] * k\n\n        def backtrack(index, start):\n            if index == k:\n                res.append(combination[:])\n                return\n\n            for i in range(start, n + 1):\n                combination[index] = i\n                backtrack(index + 1, i + 1)\n\n        backtrack(0, 1)\n        return res"
    },
    {
        "question_id": 80,
        "optimized_code": "class Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n        \n        k = 0  # Index for the modified array\n        count = 0  # Count of occurrences of the current number\n        \n        for i in range(len(nums)):\n            if i == 0 or nums[i] != nums[i-1]:\n                nums[k] = nums[i]\n                k += 1\n                count = 1\n            elif nums[i] == nums[i-1] and count < 2:\n                nums[k] = nums[i]\n                k += 1\n                count += 1\n                \n        return k"
    },
    {
        "question_id": 21,
        "optimized_code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\n        cur = ListNode()\n        d = cur\n        while list1 and list2:\n            if list1.val < list2.val:\n                cur.next = list1\n                list1 = list1.next\n            else:\n                cur.next = list2\n                list2 = list2.next\n\n            cur = cur.next\n        if list1:\n            cur.next = list1\n        else:\n            cur.next = list2\n        return d.next"
    },
    {
        "question_id": 27,
        "optimized_code": "class Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        i = 0\n        for j in range(len(nums)):\n            if nums[j] != val:\n                nums[i] = nums[j]\n                i += 1\n        return i"
    },
    {
        "question_id": 28,
        "optimized_code": "class Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        if not needle:\n            return 0\n        n = len(haystack)\n        m = len(needle)\n        \n        for i in range(n - m + 1):\n            if haystack[i:i+m] == needle:\n                return i\n        return -1"
    },
    {
        "question_id": 29,
        "optimized_code": "class Solution:\n    def divide(self, dividend: int, divisor: int) -> int:\n        # Constants for 32-bit signed integer limits\n        INT_MAX, INT_MIN = 2**31 - 1, -2**31\n        \n        # Edge case for overflow\n        if dividend == INT_MIN and divisor == -1:\n            return INT_MAX\n        \n        # Determine the sign of the result\n        sign = (dividend < 0) != (divisor < 0)\n        \n        # Work with absolute values\n        dividend, divisor = abs(dividend), abs(divisor)\n        \n        # Initialize the result\n        quotient = 0\n        \n        # The power of two divisor\n        power = 31\n        # The value of divisor shifted left\n        \n        while dividend >= divisor:\n            divisor_power = divisor << power\n            while divisor_power > dividend:\n                divisor_power >>= 1\n                power -= 1\n            dividend -= divisor_power\n            quotient += 1 << power\n        \n        # Apply the sign\n        if sign:\n            quotient = -quotient\n        \n        # Clamp the result within the 32-bit signed integer range\n        return min(max(quotient, INT_MIN), INT_MAX)"
    },
    {
        "question_id": 30,
        "optimized_code": "class Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        if not s or not words:\n            return []\n\n        n = len(s)\n        num_words = len(words)\n        word_len = len(words[0])\n        substring_len = num_words * word_len\n        word_counts = Counter(words)\n        result_indices = []\n\n        for i in range(n - substring_len + 1):\n            seen_words = defaultdict(int)\n            words_found = 0\n            for j in range(num_words):\n                word_start = i + j * word_len\n                word = s[word_start:word_start + word_len]\n\n                if word in word_counts:\n                    seen_words[word] += 1\n                    if seen_words[word] <= word_counts[word]:\n                        words_found += 1\n                    else:\n                        break\n                else:\n                    break\n            if words_found == num_words:\n                result_indices.append(i)\n\n        return result_indices"
    },
    {
        "question_id": 62,
        "optimized_code": "class Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        row = [1] * n\n        \n        for i in range(1, m):\n            new_row = [1] * n\n            for j in range(1, n):\n                new_row[j] = new_row[j-1] + row[j]\n            row = new_row\n        \n        return row[-1]"
    },
    {
        "question_id": 64,
        "optimized_code": "class Solution:\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        if not grid or not grid[0]:\n            return 0\n        \n        m, n = len(grid), len(grid[0])\n        \n        dp = [0] * n\n        \n        dp[0] = grid[0][0]\n        \n        for j in range(1, n):\n            dp[j] = dp[j-1] + grid[0][j]\n            \n        for i in range(1, m):\n            dp[0] = dp[0] + grid[i][0]\n            for j in range(1, n):\n                dp[j] = grid[i][j] + min(dp[j-1], dp[j])\n        \n        return dp[n-1]"
    },
    {
        "question_id": 65,
        "optimized_code": "import re\n\nclass Solution:\n    def isNumber(self, s: str) -> bool:\n        s = s.strip()\n        pattern = r'^[-+]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?$'\n        return bool(re.match(pattern, s))"
    },
    {
        "question_id": 66,
        "optimized_code": "class Solution:\n    def plusOne(self, digits: List[int]) -> List[int]:\n        n=len(digits)\n        for i  in range(n-1,-1,-1):\n            if digits[i]<9:\n                digits[i]+=1\n                return digits\n            else:\n                digits[i]=0\n        return [1]+digits"
    },
    {
        "question_id": 67,
        "optimized_code": "class Solution:\n    def addBinary(self, a: str, b: str) -> str:\n        i= len(a)-1\n        j= len(b)-1\n\n        car=0\n        sol=[]\n        while i >= 0 or j >= 0 or car:\n            digit_a = int(a[i]) if i >= 0 else 0\n            digit_b = int(b[j]) if j >= 0 else 0\n            \n            total = digit_a + digit_b + car\n            sol.append(str(total % 2))\n            car = total // 2  \n\n            i-=1\n            j-=1\n        return \"\".join(sol[::-1])"
    },
    {
        "question_id": 69,
        "optimized_code": "class Solution:\n    def mySqrt(self, x: int) -> int:\n        if x == 0 or x == 1:\n            return x\n        \n        low = 1\n        high = x\n        \n        while low <= high:\n            mid = (low + high) // 2\n            \n            if mid * mid == x:\n                return mid\n            elif mid * mid < x:\n                low = mid + 1\n            else:\n                high = mid - 1\n        \n        return high"
    },
    {
        "question_id": 70,
        "optimized_code": "class Solution:\n    def climbStairs(self, n: int) -> int:\n        if n <= 2:\n            return n\n        dp = [0] * (n + 1)\n        dp[1] = 1\n        dp[2] = 2\n        for i in range(3, n + 1):\n            dp[i] = dp[i - 1] + dp[i - 2]\n        return dp[n]"
    },
    {
        "question_id": 51,
        "optimized_code": "class Solution:\n    def solveNQueens(self, n: int) -> List[List[str]]:\n        def backtrace(row, cols, diag1, diag2, queens, sols):\n            if row == n:\n                sol = [''.join(row) for row in queens]\n                sols.append(sol)\n                return\n\n            for col in range(n):\n                if col in cols or (row + col) in diag1 or (row - col) in diag2:\n                    continue\n\n                queens[row][col] = 'Q'\n                cols.add(col)\n                diag1.add(row + col)\n                diag2.add(row - col)\n\n                backtrace(row + 1, cols, diag1, diag2, queens, sols)\n\n                queens[row][col] = '.'\n                cols.remove(col)\n                diag1.remove(row + col)\n                diag2.remove(row - col)\n\n\n        sols = []\n        queens = [['.' for _ in range(n)] for _ in range(n)]\n        cols = set()\n        diag1 = set()\n        diag2 = set()\n        backtrace(0, cols, diag1, diag2, queens, sols)\n        return sols"
    },
    {
        "question_id": 52,
        "optimized_code": "class Solution:\n    def totalNQueens(self, n: int) -> int:\n        cols = set()\n        pos_diags = set()  # (row + col)\n        neg_diags = set()  # (row - col)\n\n        count = 0\n\n        def backtrack(row):\n            nonlocal count\n\n            if row == n:\n                count += 1\n                return\n\n            for col in range(n):\n                if col in cols or (row + col) in pos_diags or (row - col) in neg_diags:\n                    continue\n\n                cols.add(col)\n                pos_diags.add(row + col)\n                neg_diags.add(row - col)\n\n                backtrack(row + 1)\n\n                cols.remove(col)\n                pos_diags.remove(row + col)\n                neg_diags.remove(row - col)\n\n        backtrack(0)\n        return count"
    },
    {
        "question_id": 53,
        "optimized_code": "class Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        maxSum = float('-inf')\n        currentSum = 0\n        \n        for num in nums:\n            currentSum += num\n            \n            if currentSum > maxSum:\n                maxSum = currentSum\n            \n            if currentSum < 0:\n                currentSum = 0\n        \n        return maxSum"
    },
    {
        "question_id": 55,
        "optimized_code": "class Solution:\n    def canJump(self, nums: List[int]) -> bool:\n        reachable = 0\n        for i, num in enumerate(nums):\n            if i > reachable:\n                return False\n            reachable = max(reachable, i + num)\n            if reachable >= len(nums) - 1:\n                return True\n        return True"
    },
    {
        "question_id": 58,
        "optimized_code": "class Solution:\n    def lengthOfLastWord(self, s: str) -> int:\n        s = s.rstrip()\n        if not s:\n            return 0\n        return len(s.split(\" \")[-1])"
    },
    {
        "question_id": 60,
        "optimized_code": "class Solution:\n    def getPermutation(self, n: int, k: int) -> str:\n        fact = [1] * (n + 1)\n        for i in range(2, n + 1):\n            fact[i] = fact[i - 1] * i\n\n        nums = list(range(1, n + 1))\n        k -= 1\n        result = \"\"\n\n        for i in range(n - 1, -1, -1):\n            index = k // fact[i]\n            result += str(nums[index])\n            nums.pop(index)\n            k %= fact[i]\n\n        return result"
    },
    {
        "question_id": 282,
        "optimized_code": "class Solution:\n    def addOperators(self, num: str, target: int) -> List[str]:\n        n = len(num)\n        res = []\n\n        def backtrack(index, current_expression, current_value, previous_operand):\n            if index == n:\n                if current_value == target:\n                    res.append(current_expression)\n                return\n\n            for i in range(index, n):\n                if i > index and num[index] == '0':\n                    break  # Avoid leading zeros\n\n                current_string = num[index:i + 1]\n                current_num = int(current_string)\n\n                if index == 0:\n                    backtrack(i + 1, current_string, current_num, current_num)\n                else:\n                    backtrack(i + 1, current_expression + \"+\" + current_string, current_value + current_num, current_num)\n                    backtrack(i + 1, current_expression + \"-\" + current_string, current_value - current_num, -current_num)\n                    backtrack(i + 1, current_expression + \"*\" + current_string, current_value - previous_operand + previous_operand * current_num, previous_operand * current_num)\n\n        backtrack(0, \"\", 0, 0)\n        return res"
    },
    {
        "question_id": 283,
        "optimized_code": "class Solution:\n    def moveZeroes(self, nums: List[int]) -> None:\n        n = len(nums)\n        left = 0\n        for right in range(n):\n            if nums[right] != 0:\n                nums[left], nums[right] = nums[right], nums[left]\n                left += 1"
    },
    {
        "question_id": 336,
        "optimized_code": "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\n        dct = {word: i for i, word in enumerate(words)}\n        n = len(words)\n        result = []\n\n        for i in range(n):\n            word = words[i]\n            for j in range(len(word) + 1):\n                prefix = word[:j]\n                suffix = word[j:]\n\n                if prefix[::-1] in dct and dct[prefix[::-1]] != i and suffix == suffix[::-1]:\n                    result.append([i, dct[prefix[::-1]]])\n\n                if j > 0 and suffix[::-1] in dct and dct[suffix[::-1]] != i and prefix == prefix[::-1]:\n                    result.append([dct[suffix[::-1]], i])\n\n        return result"
    },
    {
        "question_id": 338,
        "optimized_code": "class Solution:\n    def countBits(self, n: int) -> List[int]:\n        dp = [0] * (n + 1)\n        for i in range(1, n + 1):\n            dp[i] = dp[i >> 1] + (i & 1)\n        return dp"
    },
    {
        "question_id": 342,
        "optimized_code": "class Solution:\n    def isPowerOfFour(self, n: int) -> bool:\n        if n <= 0:\n            return False\n        while n % 4 == 0:\n            n //= 4\n        return n == 1"
    },
    {
        "question_id": 345,
        "optimized_code": "class Solution:\n    def reverseVowels(self, s: str) -> str:\n        buf = list(s)\n        myset = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        vowels = []\n        indexs = []\n\n        for i in range(len(s)):\n            if s[i] in myset:\n                vowels.append(s[i])\n                indexs.append(i)\n        \n        vowels.reverse()\n        \n        for i in range(len(indexs)):\n            buf[indexs[i]] = vowels[i]\n        \n        answer = ''.join(buf)\n        return answer"
    },
    {
        "question_id": 389,
        "optimized_code": "class Solution:\n    def findTheDifference(self, s: str, t: str) -> str:\n        s_sum = sum(ord(c) for c in s)\n        t_sum = sum(ord(c) for c in t)\n        return chr(t_sum - s_sum)"
    },
    {
        "question_id": 391,
        "optimized_code": "class Solution:\n    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\n        x1 = float('inf')\n        y1 = float('inf')\n        x2 = float('-inf')\n        y2 = float('-inf')\n        area = 0\n        points = set()\n        for x, y, a, b in rectangles:\n            x1 = min(x1, x)\n            y1 = min(y1, y)\n            x2 = max(x2, a)\n            y2 = max(y2, b)\n            area += (a - x) * (b - y)\n            \n            points.add((x, y))\n            points.add((x, b))\n            points.add((a, y))\n            points.add((a, b))\n            \n        expected_area = (x2 - x1) * (y2 - y1)\n        if expected_area != area:\n            return False\n        \n        corners = [(x1, y1), (x1, y2), (x2, y1), (x2, y2)]\n        corner_count = 0\n        for corner in corners:\n            if corner in points:\n                corner_count += 1\n                points.remove(corner)\n        \n        if corner_count != 4:\n            return False\n\n        return not points"
    },
    {
        "question_id": 392,
        "optimized_code": "class Solution:\n    def isSubsequence(self, s: str, t: str) -> bool:\n        s_ptr = 0\n        t_ptr = 0\n        while s_ptr < len(s) and t_ptr < len(t):\n            if s[s_ptr] == t[t_ptr]:\n                s_ptr += 1\n            t_ptr += 1\n        return s_ptr == len(s)"
    },
    {
        "question_id": 479,
        "optimized_code": "class Solution:\n    def largestPalindrome(self, n: int) -> int:\n        if n == 1:\n            return 9\n\n        max_num = 10**n - 1\n        min_num = 10**(n - 1)\n\n        for a in range(max_num, min_num - 1, -1):\n            palindrome = int(str(a) + str(a)[::-1])\n\n            for x in range(max_num, int(palindrome**0.5) - 1, -1):\n                if palindrome % x == 0 and palindrome // x <= max_num:\n                    return palindrome % 1337\n        return 0"
    },
    {
        "question_id": 483,
        "optimized_code": "class Solution:\n    def smallestGoodBase(self, n: str) -> str:\n        n = int(n)\n        m_max = int((n + 1)**(0.5))\n\n        for m in range(int(n**0.3333333333333333) + 1, int(n**0.5) + 2):\n\n            k = int(round(n**(1/m)))\n            if k <= 1:\n              continue\n\n            num = k**(m+1) - 1\n            den = k - 1\n\n            if num % den == 0:\n              if num // den == n:\n                return str(k)\n        \n        for m in range(62, 0, -1):\n            k = int(round(n**(1/m)))\n            if k <= 1:\n              continue\n            if k > (1 << 31): continue\n                \n            num = k**(m+1) - 1\n            den = k - 1\n\n            if num % den == 0:\n                if num // den == n:\n                    return str(k)\n\n        return str(n - 1)"
    },
    {
        "question_id": 485,
        "optimized_code": "class Solution:\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\n        maxLength = 0\n        length = 0\n        for i in range(len(nums)):\n            if nums[i] == 0:\n                length = 0\n            else: \n                length += 1\n            maxLength = max(maxLength, length)\n\n        return maxLength"
    },
    {
        "question_id": 410,
        "optimized_code": "class Solution:\n    def splitArray(self, nums: List[int], k: int) -> int:\n        def is_valid(mid):\n            count = 1\n            current_sum = 0\n            for num in nums:\n                if num > mid:\n                    return False\n                current_sum += num\n                if current_sum > mid:\n                    count += 1\n                    current_sum = num\n            return count <= k\n\n        left = max(nums)\n        right = sum(nums)\n        ans = right\n        while left <= right:\n            mid = (left + right) // 2\n            if is_valid(mid):\n                ans = mid\n                right = mid - 1\n            else:\n                left = mid + 1\n        return ans"
    },
    {
        "question_id": 414,
        "optimized_code": "class Solution:\n    def thirdMax(self, nums: List[int]) -> int:\n        nums = sorted(list(set(nums)), reverse=True)\n        if len(nums) >= 3:\n            return nums[2]\n        else:\n            return nums[0]"
    },
    {
        "question_id": 472,
        "optimized_code": "class Solution:\n    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\n        word_set = set(words)\n        result = []\n        \n        def can_form(word):\n            if not word:\n                return False\n            dp = [False] * (len(word) + 1)\n            dp[0] = True\n            \n            for i in range(1, len(word) + 1):\n                for j in range(i):\n                    if dp[j] and word[j:i] in word_set:\n                        dp[i] = True\n                        break\n            \n            return dp[len(word)]\n\n        for word in words:\n            word_set.remove(word)\n            if can_form(word):\n                result.append(word)\n            word_set.add(word)\n            \n        return result"
    },
    {
        "question_id": 476,
        "optimized_code": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        bits = num.bit_length()\n        mask = (1 << bits) - 1\n        return num ^ mask"
    },
    {
        "question_id": 440,
        "optimized_code": "class Solution(object):\n    def findKthNumber(self, n, k):\n        curr = 1\n        k -= 1\n        \n        while k > 0:\n            step = self.countSteps(n, curr, curr + 1)\n            if step <= k:\n                curr += 1\n                k -= step\n            else:\n                curr *= 10\n                k -= 1\n\n        return curr\n\n    def countSteps(self, n, prefix1, prefix2):\n        steps = 0\n        while prefix1 <= n:\n            steps += min(n + 1, prefix2) - prefix1\n            prefix1 *= 10\n            prefix2 *= 10\n        return steps"
    },
    {
        "question_id": 441,
        "optimized_code": "class Solution:\n    def arrangeCoins(self, n: int) -> int:\n        left, right = 0, n\n        while left <= right:\n            mid = left + (right - left) // 2\n            coins_needed = mid * (mid + 1) // 2\n            if coins_needed == n:\n                return mid\n            elif coins_needed < n:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return right"
    },
    {
        "question_id": 401,
        "optimized_code": "class Solution:\n    def readBinaryWatch(self, num: int) -> list[str]:\n        times = []\n\n        def count_set_bits(n):\n            count = 0\n            while n > 0:\n                n &= (n - 1)\n                count += 1\n            return count\n\n        for h in range(12):\n            for m in range(60):\n                if count_set_bits(h) + count_set_bits(m) == num:\n                    times.append(f\"{h}:{m:02d}\")\n\n        return times"
    },
    {
        "question_id": 404,
        "optimized_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sumOfLeftLeaves(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        \n        stack = [(root, False)]  # (node, is_left)\n        total_sum = 0\n        \n        while stack:\n            node, is_left = stack.pop()\n            \n            if node:\n                if is_left and not node.left and not node.right:\n                    total_sum += node.val\n                \n                if node.left:\n                    stack.append((node.left, True))\n                if node.right:\n                    stack.append((node.right, False))\n        \n        return total_sum"
    },
    {
        "question_id": 363,
        "optimized_code": "import bisect\nfrom typing import List\n\nclass Solution:\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\n        m = len(matrix)\n        n = len(matrix[0])\n        max_sum = float('-inf')\n\n        for left in range(n):\n            row_sums = [0] * m\n            for right in range(left, n):\n                for i in range(m):\n                    row_sums[i] += matrix[i][right]\n\n                cur_sum = 0\n                prefix_sums = [0]\n                current_max = float('-inf')\n\n                for row_sum in row_sums:\n                    cur_sum += row_sum\n                    target = cur_sum - k\n                    idx = bisect.bisect_left(prefix_sums, target)\n                    if idx < len(prefix_sums):\n                        current_max = max(current_max, cur_sum - prefix_sums[idx])\n\n                    bisect.insort(prefix_sums, cur_sum)\n\n                max_sum = max(max_sum, current_max)\n\n        return max_sum"
    },
    {
        "question_id": 459,
        "optimized_code": "class Solution:\n    def repeatedSubstringPattern(self, s: str) -> bool:\n        n = len(s)\n        for i in range(1, n // 2 + 1):\n            if n % i == 0:\n                sub = s[:i]\n                k = n // i\n                new = sub * k\n                if new == s:\n                    return True\n        return False"
    },
    {
        "question_id": 461,
        "optimized_code": "class Solution:\n    def hammingDistance(self, x: int, y: int) -> int:\n        xor_result = x ^ y\n        hamming_distance = 0\n        while xor_result:\n            hamming_distance += xor_result & 1\n            xor_result >>= 1\n        return hamming_distance"
    },
    {
        "question_id": 463,
        "optimized_code": "class Solution:\n    def islandPerimeter(self, grid: List[List[int]]) -> int:\n        rows, cols = len(grid), len(grid[0])\n        perimeter = 0\n        for i in range(rows):\n            for j in range(cols):\n                if grid[i][j] == 1:\n                    # Check top\n                    if i == 0 or grid[i-1][j] == 0:\n                        perimeter += 1\n                    # Check bottom\n                    if i == rows - 1 or grid[i+1][j] == 0:\n                        perimeter += 1\n                    # Check left\n                    if j == 0 or grid[i][j-1] == 0:\n                        perimeter += 1\n                    # Check right\n                    if j == cols - 1 or grid[i][j+1] == 0:\n                        perimeter += 1\n        return perimeter"
    },
    {
        "question_id": 685,
        "optimized_code": "from collections import defaultdict\n\nclass Solution:\n    def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[List[int]]:\n        n = len(edges)\n        parent = list(range(n + 1))\n\n        def find(i):\n            if parent[i] == i:\n                return i\n            parent[i] = find(parent[i])\n            return parent[i]\n\n        def union(i, j):\n            root_i = find(i)\n            root_j = find(j)\n            if root_i != root_j:\n                parent[root_i] = root_j\n                return True\n            return False\n\n        in_degree = defaultdict(int)\n        node_with_multiple_parents = None\n\n        for u, v in edges:\n            in_degree[v] += 1\n            if in_degree[v] > 1:\n                node_with_multiple_parents = v\n                break\n\n        if node_with_multiple_parents is None:\n            # No node with multiple parents, so there must be a cycle\n            for u, v in edges:\n                if not union(u, v):\n                    return [u, v]\n            return []  # Should never happen\n        else:\n            # Node with multiple parents exists\n            edges1 = []\n            edges2 = []\n            target_node = node_with_multiple_parents\n            for u, v in edges:\n                if v == target_node:\n                    edges2.append([u,v])\n                else:\n                    edges1.append([u,v])\n            parent = list(range(n + 1))\n            for u, v in edges1:\n                union(u, v)\n            for u,v in edges2:\n                if not union(u,v):\n                    return [u,v]\n            return edges2[0]"
    },
    {
        "question_id": 736,
        "optimized_code": "from collections import deque\n\nclass Solution:\n    def evaluate(self, expression: str) -> int:\n        \"\"\"\n        expr := (let [string expr]*)\n        expr := (add  expr expr)\n        expr := (mult expr expr)\n        expr := var \n        \"\"\"\n\n        def tokenize(s):\n            Q = deque()\n            cur = 0\n            n = len(s)\n            while cur < n:\n                c = s[cur]\n                if c in ('(', ')'):\n                    Q.append(c)\n                    cur += 1\n                    continue\n                if c.isdigit() or c == '-':\n                    res = 0\n                    sign = 1\n                    if c == '-':\n                        sign = -1\n                        cur += 1\n                    while cur < n and s[cur].isdigit():\n                        res = res*10 + int(s[cur])\n                        cur += 1\n                    Q.append(sign * res)\n                    continue\n                if c.isalpha():\n                    res = []\n                    while cur < n and (s[cur].isalpha() or s[cur].isdigit()):\n                        res.append(s[cur])\n                        cur += 1\n                    Q.append(''.join(res))\n                    continue\n                cur += 1\n            return Q\n\n        tokens = tokenize(expression)\n\n        def string():\n            return tokens.popleft()\n\n        def var(mp):\n            s = tokens.popleft()\n            if s in mp:\n                return mp[s]\n            return int(s)\n\n        def expr(mp):\n            if tokens[0] == '(':\n                tokens.popleft()\n                op = tokens.popleft()\n                if op == 'let':\n                    new_vars = {}\n                    while tokens[0] != ')':\n                        variable_name = string()\n                        if tokens[0] == '(':\n                            expression = expr(mp)\n                        else:\n                            try:\n                                expression = int(tokens[0])\n                                tokens.popleft()\n                            except ValueError:\n                                expression = var(mp)\n                        new_vars[variable_name] = expression\n                        mp[variable_name] = expression\n                    tokens.popleft()\n                    expression = expr(mp)\n\n                    for k in new_vars:\n                        del mp[k]\n                    return expression\n                elif op == 'mult':\n                    expr1 = expr(mp)\n                    expr2 = expr(mp)\n                    expression = expr1 * expr2\n                elif op == 'add':\n                    expr1 = expr(mp)\n                    expr2 = expr(mp)\n                    expression = expr1 + expr2\n                tokens.popleft()\n                return expression\n            else:\n                return var(mp)\n\n        return expr({})"
    },
    {
        "question_id": 973,
        "optimized_code": "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        m, n = len(stamp), len(target)\n        A = [0] * (n - m + 1)\n        todo = []\n        stars = [0] * n\n        for i in range(n - m + 1):\n            for j in range(m):\n                if target[i + j] == stamp[j]:\n                    A[i] += 1\n                else:\n                    A[i] = -1\n                    stars[i + j] += 1\n        \n        res = []\n        q = [i for i in range(n) if stars[i] == 0]\n        seen = [False] * n\n\n        while q:\n            i = q.pop(0)\n            for j in range(max(0, i - m + 1), min(n - m + 1, i + 1)):\n                if A[j] >= 0:\n                    A[j] -= 1\n                    if A[j] == 0:\n                        res.append(j)\n                        for k in range(m):\n                            neighbor = j + k\n                            stars[neighbor] -= 1\n                            if stars[neighbor] == 0:\n                                q.append(neighbor)\n        \n        return res[::-1] if all(s == 0 for s in stars) else []"
    },
    {
        "question_id": 975,
        "optimized_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\n        total = 0\n\n        def dfs(node: TreeNode) -> None:\n            nonlocal total\n\n            if not node:\n                return\n            \n            if low <= node.val <= high:\n                total += node.val\n            \n            if node.val > low:\n                dfs(node.left)\n            if node.val < high:\n                dfs(node.right)\n        \n        dfs(root)\n        return total"
    },
    {
        "question_id": 977,
        "optimized_code": "class Solution:\n    \"\"\"\n    @param S: The string s\n    @return: The number of distinct, non-empty subsequences of S.\n    \"\"\"\n    def distinctSubseqII(self, S):\n        MOD = 10 ** 9 + 7\n        n = len(S)\n        \n        dp = 0\n        last = {}\n        \n        for i in range(n):\n            new_dp = (2 * dp + 1) % MOD\n            if S[i] in last:\n                new_dp = (new_dp - dp) % MOD\n                if new_dp < 0:\n                    new_dp += MOD\n            \n            dp = new_dp\n            last[S[i]] = dp\n            \n        return dp % MOD"
    },
    {
        "question_id": 1013,
        "optimized_code": "class Solution:\n    def fib(self, n: int) -> int:\n        if n < 2:\n            return n\n        \n        memo = {}\n        \n        def fib_memo(n):\n            if n in memo:\n                return memo[n]\n            if n < 2:\n                return n\n            memo[n] = fib_memo(n-1) + fib_memo(n-2)\n            return memo[n]\n        \n        return fib_memo(n)"
    },
    {
        "question_id": 514,
        "optimized_code": "class Solution:\n    def findRotateSteps(self, ring: str, key: str) -> int:\n        n, m = len(ring), len(key)\n        pos = [[] for _ in range(26)]\n        for i, c in enumerate(ring):\n            pos[ord(c) - ord('a')].append(i)\n        \n        dp = [[float('inf')] * n for _ in range(m + 1)]\n        dp[m][0] = 0\n        \n        for i in reversed(range(m)):\n            for j in range(n):\n                for k in pos[ord(key[i]) - ord('a')]:\n                    diff = abs(j - k)\n                    min_dist = min(diff, n - diff)\n                    dp[i][j] = min(dp[i][j], dp[i + 1][k] + min_dist + 1)\n        \n        return dp[0][0]"
    },
    {
        "question_id": 920,
        "optimized_code": "class Solution:\n    def uncommonFromSentences(self, s1: str, s2: str) -> List[str]:\n        d=Counter(s1.split())+Counter(s2.split())\n        return [x for x in d if d[x]==1]"
    },
    {
        "question_id": 35,
        "optimized_code": "class Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left"
    },
    {
        "question_id": 10,
        "optimized_code": "class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        m, n = len(s), len(p)\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\n        dp[0][0] = True\n\n        for j in range(1, n + 1):\n            if p[j - 1] == '*':\n                dp[0][j] = dp[0][j - 2]\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if p[j - 1] == '*':\n                    dp[i][j] = dp[i][j - 2]\n                    if p[j - 2] == '.' or p[j - 2] == s[i - 1]:\n                        dp[i][j] = dp[i][j] or dp[i - 1][j]\n                elif p[j - 1] == '.' or p[j - 1] == s[i - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n\n        return dp[m][n]"
    },
    {
        "question_id": 218,
        "optimized_code": "class Solution:\n    def getSkyline(self, buildings: List[List[int]]) -> List[List[int]]:\n        import heapq\n\n        skyline = []\n        events = [(L, -H, R) for L, R, H in buildings]\n        events += [(R, 0, 0) for _, R, _ in buildings]\n        events.sort()\n\n        heap = [(0, float('inf'))]\n        current_height = 0\n\n        for x, neg_h, r in events:\n            # Remove processed buildings from heap\n            while heap and heap[0][1] <= x:\n                heapq.heappop(heap)\n\n            # Add current building to heap\n            if neg_h != 0:\n                heapq.heappush(heap, (neg_h, r))\n\n            # Check if current height changes\n            peak_height = -heap[0][0]\n            if skyline and skyline[-1][1] == peak_height:\n                continue\n\n            if peak_height != current_height:\n                skyline.append([x, peak_height])\n                current_height = peak_height\n\n        return skyline"
    },
    {
        "question_id": 226,
        "optimized_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        if root is None:\n            return root\n            \n        root.left, root.right = root.right, root.left\n\n        if root.left:\n            self.invertTree(root=root.left)\n        if root.right:\n            self.invertTree(root=root.right)\n        \n        return root"
    },
    {
        "question_id": 273,
        "optimized_code": "class Solution:\n    def numberToWords(self, num: int) -> str:\n        if num == 0:\n            return \"Zero\"\n\n        less_than_20 = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\",\n                           \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\",\n                           \"Eighteen\", \"Nineteen\"]\n        tens = [\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n        thousands = [\"\", \"Thousand\", \"Million\", \"Billion\"]\n\n        def helper(n):\n            if n < 20:\n                return less_than_20[n]\n            elif n < 100:\n                return tens[n // 10] + (\" \" + less_than_20[n % 10]) if n % 10 else tens[n // 10]\n            else:\n                return less_than_20[n // 100] + \" Hundred \" + helper(n % 100)\n\n        result = []\n        for i in range(4):\n            if num % 1000 != 0:\n                result.append(helper(num % 1000) + \" \" + thousands[i])\n            num //= 1000\n\n        return \" \".join(result[::-1]).strip()"
    },
    {
        "question_id": 14,
        "optimized_code": "class Solution:\n    def longestCommonPrefix(self, strs: List[str]) -> str:\n        if not strs:\n            return \"\"\n        \n        prefix = strs[0]\n        for i in range(1, len(strs)):\n            while strs[i].find(prefix) != 0:\n                prefix = prefix[:-1]\n                if not prefix:\n                    return \"\"\n        return prefix"
    },
    {
        "question_id": 258,
        "optimized_code": "class Solution:\n    def addDigits(self, num: int) -> int:\n        if num == 0: \n            return 0\n        mod = num % 9 \n        if mod == 0:\n            return 9 \n        else: return mod"
    },
    {
        "question_id": 76,
        "optimized_code": "from collections import Counter\n\nclass Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        if not s or not t:\n            return \"\"\n\n        t_count = Counter(t)\n        window_count = {}\n        required = len(t_count)\n        formed = 0\n        left = 0\n        right = 0\n        min_length = float('inf')\n        min_window = \"\"\n\n        while right < len(s):\n            character = s[right]\n            window_count[character] = window_count.get(character, 0) + 1\n\n            if character in t_count and window_count[character] == t_count[character]:\n                formed += 1\n\n            while left <= right and formed == required:\n                character = s[left]\n\n                if right - left + 1 < min_length:\n                    min_length = right - left + 1\n                    min_window = s[left:right + 1]\n\n                window_count[character] -= 1\n                if character in t_count and window_count[character] < t_count[character]:\n                    formed -= 1\n\n                left += 1\n            right += 1\n        return min_window"
    },
    {
        "question_id": 68,
        "optimized_code": "class Solution:\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\n        \n        n=len(words)\n        output,line,width=[],[],0\n        \n        for w in words:\n            if width + len(w) + len(line) > maxWidth:\n                if len(line) > 1:\n                    spaces_needed = maxWidth - width\n                    spaces_between = spaces_needed // (len(line) - 1)\n                    extra_spaces = spaces_needed % (len(line) - 1)\n                    \n                    for i in range(len(line) - 1):\n                        line[i] += ' ' * spaces_between\n                        if i < extra_spaces:\n                            line[i] += ' '\n                output += [''.join(line)]\n                line=[]\n                width=0\n            line += [w]\n            width += len(w)\n        \n        return output + [' '.join(line).ljust(maxWidth)]"
    },
    {
        "question_id": 332,
        "optimized_code": "class Solution:\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\n        self.graph = {}\n        for src, dst in tickets:\n            self.graph.setdefault(src, []).append(dst)\n        \n        for src_dst in self.graph.values():\n            src_dst.sort() # sort destinations by increasing lexical order\n        \n        self.res = []\n        self.dfs(\"JFK\")\n        return self.res[::-1]\n    \n    def dfs(self, src):\n        destinations = self.graph.get(src, [])\n        while destinations:\n            dst = destinations.pop(0)\n            self.dfs(dst)\n        self.res.append(src)"
    },
    {
        "question_id": 689,
        "optimized_code": "class Solution:\n    def maxSumOfThreeSubarrays(self, nums: List[int], k: int) -> List[int]:\n        n = len(nums)\n        sums = [0] * (n - k + 1)\n        current_sum = sum(nums[:k])\n        sums[0] = current_sum\n        for i in range(1, n - k + 1):\n            current_sum = current_sum - nums[i - 1] + nums[i + k - 1]\n            sums[i] = current_sum\n\n        left = [0] * (n - k + 1)\n        best = 0\n        for i in range(n - k + 1):\n            if sums[i] > sums[best]:\n                best = i\n            left[i] = best\n\n        right = [n - k] * (n - k + 1)\n        best = n - k\n        for i in range(n - k, -1, -1):\n            if sums[i] >= sums[best]:\n                best = i\n            right[i] = best\n\n        result = []\n        max_sum = 0\n        for mid in range(k, n - 2 * k + 1):\n            l, r = left[mid - k], right[mid + k]\n            cur_sum = sums[l] + sums[r] + sums[mid]\n            if cur_sum > max_sum:\n                max_sum = cur_sum\n                result = [l, mid, r]\n        return result"
    },
    {
        "question_id": 953,
        "optimized_code": "class Solution:\n\n\n    def reverseOnlyLetters(self, s: str) -> str:\n        left = 0\n        right = len(s) - 1\n        s_list = list(s)\n        while (left < right):\n            if not s_list[left].isalpha():\n                left += 1\n                continue\n            if not s_list[right].isalpha():\n                right -= 1\n                continue\n            temp = s_list[left]\n            s_list[left] = s_list[right]\n            s_list[right] = temp\n            left += 1\n            right -=1\n        \n        return \"\".join(s_list)"
    },
    {
        "question_id": 923,
        "optimized_code": "class Solution:\n    from functools import cache\n    @cache\n    def superEggDrop(self, k: int, n: int) -> int:\n        \n        # base condition\n\n        if n==0:\n            return 0\n        if n==1:\n            return 1\n        if k==1:\n            return n\n        ans = float('inf')\n        s, e = 1, n\n        while (s <= e):\n            x = (s+e)//2\n            low = self.superEggDrop(k-1, x-1)\n            high = self.superEggDrop(k, n-x)\n            if low > high:\n                ans = min(ans,low )\n                e = x-1\n            else:\n                ans = min(ans,high )\n                s = x+1\n        # for x in range(1, n+1):\n        #     ans  = min(ans, max(self.superEggDrop(k-1, x-1), self.superEggDrop(k, n-x)))\n        \n        return ans +1"
    },
    {
        "question_id": 924,
        "optimized_code": "class Solution:\n    def fairCandySwap(self, aliceSizes: List[int], bobSizes: List[int]) -> List[int]:\n        sum_alice = sum(aliceSizes)\n        sum_bob = sum(bobSizes)\n        half = (sum_alice + sum_bob) // 2\n        bob_set = set(bobSizes)\n        for i in aliceSizes:\n            needed_bob = half - (sum_alice - i)\n            if needed_bob in bob_set:\n                return [i, needed_bob]"
    },
    {
        "question_id": 632,
        "optimized_code": "from collections import defaultdict\nimport heapq\n\nclass Solution:\n    def smallestRange(self, nums: List[List[int]]) -> List[int]:\n        k = len(nums)\n        pointers = [0] * k\n        heap = []\n        max_range = float('-inf')\n        \n        for i in range(k):\n            heapq.heappush(heap, (nums[i][0], i))\n            max_range = max(max_range, nums[i][0])\n            \n        range_start, range_end = -10**5, 10**5\n        \n        while True:\n            min_val, min_index = heapq.heappop(heap)\n            \n            if max_range - min_val < range_end - range_start:\n                range_start, range_end = min_val, max_range\n            \n            pointers[min_index] += 1\n            \n            if pointers[min_index] == len(nums[min_index]):\n                break\n            \n            new_val = nums[min_index][pointers[min_index]]\n            max_range = max(max_range, new_val)\n            heapq.heappush(heap, (new_val, min_index))\n        \n        return [range_start, range_end]"
    },
    {
        "question_id": 637,
        "optimized_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nfrom collections import deque\nclass Solution:\n    def averageOfLevels(self, root: Optional[TreeNode]) -> List[float]:\n        levelsAverageList = []\n        if root != None:\n            queue = deque()\n            queue.append(root)\n            while queue:\n                size = len(queue)\n                level_sum = 0\n                level_count = 0\n                for start in range(size):\n                    treeNode = queue.popleft()\n                    level_sum += treeNode.val\n                    level_count += 1\n                    if treeNode.left != None:\n                        queue.append(treeNode.left)\n                    if treeNode.right != None:\n                        queue.append(treeNode.right)\n                levelsAverageList.append(float(level_sum/level_count))\n        return levelsAverageList"
    },
    {
        "question_id": 979,
        "optimized_code": "class Solution:\n    def diStringMatch(self, s: str) -> List[int]:\n        n = len(s)\n        low = 0\n        high = n\n        result = []\n        for c in s:\n            if c == 'I':\n                result.append(low)\n                low += 1\n            else:\n                result.append(high)\n                high -= 1\n        result.append(low)\n        return result"
    },
    {
        "question_id": 981,
        "optimized_code": "class Solution:\n    def minDeletionSize(self, strs: List[str]) -> int:\n        count = 0\n        for col in range(len(strs[0])):\n            for row in range(1, len(strs)):\n                if strs[row][col] < strs[row - 1][col]:\n                    count += 1\n                    break\n        return count"
    },
    {
        "question_id": 927,
        "optimized_code": "class Solution:\n    def sumSubseqWidths(self, nums: List[int]) -> int:\n        nums = sorted(nums)\n        total = 0\n        n = len(nums)\n        mod = 10**9 + 7\n        power_of_2 = [1] * n\n        for i in range(1, n):\n            power_of_2[i] = (power_of_2[i - 1] * 2) % mod\n\n        for i in range(n):\n            total = (total + (power_of_2[i] - power_of_2[n - i - 1]) * nums[i]) % mod\n\n        return total"
    },
    {
        "question_id": 933,
        "optimized_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def increasingBST(self, root: TreeNode) -> TreeNode:\n        self.tail = TreeNode()\n        self.ans = self.tail\n\n        def inorder(root):\n            if not root:\n                return\n            \n            inorder(root.left)\n\n            self.tail.right = root\n            root.left = None\n            self.tail = root\n\n            inorder(root.right)\n\n        inorder(root)\n        return self.ans.right"
    },
    {
        "question_id": 488,
        "optimized_code": "from collections import defaultdict\nfrom functools import cache\n\nclass Solution:\n    def compress(self, s):\n        stack = []\n        for c in s:\n            if stack and stack[-1][0] != c and stack[-1][1] >= 3:\n                stack.pop()\n            if not stack or stack[-1][0] != c:\n                stack.append([c, 1])\n            else:\n                stack[-1][1] += 1\n        if stack and stack[-1][1] >= 3:\n            stack.pop()\n        return ''.join(a*b for a, b in stack)\n\n    def findMinStep(self, board: str, hand: str) -> int:\n        n = len(hand)\n        hand = ''.join(sorted(hand))\n\n        @cache\n        def solve(board_tuple, hand_tuple):\n            board = \"\".join(board_tuple)\n            hand = \"\".join(hand_tuple)\n            \n            board = self.compress(board)\n            if board == '': return n - len(hand)\n            if hand == '': return float('inf')\n\n            ans = float('inf')\n            for i in range(len(hand)):\n                if i > 0 and hand[i] == hand[i-1]: continue\n    \n                for j in range(len(board)):\n                    if board[j] == hand[i] or j > 0 and board[j] == board[j-1] and board[j] != hand[i]:\n                        ans = min(ans, solve(tuple(list(board[0:j]) + [hand[i]] + list(board[j:]))), tuple(list(hand[0:i]) + list(hand[i+1:]))))\n            return ans\n        \n        res = solve(tuple(list(board)), tuple(list(hand)))\n        if res == float('inf'): return -1\n        else: return res"
    },
    {
        "question_id": 493,
        "optimized_code": "class BIT:\n\n    def __init__(self, n):\n        self.n = n+1\n        self.lt = [0]*self.n\n\n    def search(self, indx):\n        res = 0\n        while indx>0:\n            res += self.lt[indx]\n            indx -= indx&(-indx)\n        return res\n\n    def update(self, indx, val):\n        while indx<self.n:\n            self.lt[indx] += val\n            indx += indx&(-indx)\n\n\nclass Solution:\n    def reversePairs(self, nums: List[int]) -> int:\n        n = len(nums)\n        res = 0\n        unique_nums = sorted(list(set(nums + [x * 2 for x in nums])))\n        num_map = {num: i + 1 for i, num in enumerate(unique_nums)}\n        bit = BIT(len(unique_nums))\n\n        for num in nums:\n            res += bit.search(len(unique_nums)) - bit.search(num_map[num * 2])\n            bit.update(num_map[num], 1)\n        return res"
    },
    {
        "question_id": 495,
        "optimized_code": "class Solution:\n    def findPoisonedDuration(self, timeSeries: List[int], duration: int) -> int:\n        n = len(timeSeries)\n        res = 0\n        if n == 0:\n            return 0\n        \n        for i in range(n - 1):\n            res += min(duration, timeSeries[i + 1] - timeSeries[i])\n        return res + duration"
    },
    {
        "question_id": 496,
        "optimized_code": "class Solution:\n    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        next_greater = {}\n        stack = []\n        for num in nums2:\n            while stack and num > stack[-1]:\n                next_greater[stack.pop()] = num\n            stack.append(num)\n        \n        while stack:\n            next_greater[stack.pop()] = -1\n        \n        res_out = [next_greater[num] for num in nums1]\n        return res_out"
    },
    {
        "question_id": 830,
        "optimized_code": "class Solution:\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\n        res = 0\n        n = len(points)\n        for i in range(n):\n            for j in range(i + 1, n):\n                for k in range(j + 1, n):\n                    x1, y1 = points[i]\n                    x2, y2 = points[j]\n                    x3, y3 = points[k]\n                    area = 0.5 * abs(x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2))\n                    res = max(res, area)\n        return res"
    },
    {
        "question_id": 861,
        "optimized_code": "class Solution:\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\n        for row in image:\n            for i in range((len(row) + 1) // 2):\n                row[i], row[len(row) - 1 - i] = (row[len(row) - 1 - i] ^ 1), (row[i] ^ 1)\n                if i == len(row) - 1 - i:\n                    row[i] = row[i]\n                \n        return image"
    },
    {
        "question_id": 741,
        "optimized_code": "class Solution:\n    def cherryPickup(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        dp = [[-float('inf')] * n for _ in range(n)]\n        dp[0][0] = grid[0][0]\n\n        for k in range(1, 2 * n - 1):\n            new_dp = [[-float('inf')] * n for _ in range(n)]\n            for x1 in range(max(0, k - (n - 1)), min(n, k + 1)):\n                for x2 in range(max(0, k - (n - 1)), min(n, k + 1)):\n                    y1, y2 = k - x1, k - x2\n                    if grid[x1][y1] == -1 or grid[x2][y2] == -1:\n                        continue\n\n                    best = -float('inf')\n                    for d1 in [0, 1]:\n                        for d2 in [0, 1]:\n                            px1, px2 = x1 - d1, x2 - d2\n                            if px1 >= 0 and px2 >= 0:\n                                best = max(best, dp[px1][px2])\n\n                    if best == -float('inf'):\n                        continue\n                    \n                    new_dp[x1][x2] = best + grid[x1][y1]\n                    if x1 != x2:\n                        new_dp[x1][x2] += grid[x2][y2]\n            dp = new_dp\n\n        return max(0, dp[n-1][n-1])"
    },
    {
        "question_id": 750,
        "optimized_code": "class Solution:\n    def containVirus(self, mat: List[List[int]]) -> int:\n        m, n = len(mat), len(mat[0])\n        DIRECTIONS = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        \n        def get_regions():\n            visited = set()\n            regions = []\n            for i in range(m):\n                for j in range(n):\n                    if mat[i][j] == 1 and (i, j) not in visited:\n                        infected = set()\n                        walls = 0\n                        queue = [(i, j)]\n                        visited.add((i, j))\n                        \n                        region_cells = set()\n\n                        while queue:\n                            r, c = queue.pop(0)\n                            region_cells.add((r, c))\n\n                            for dx, dy in DIRECTIONS:\n                                nr, nc = r + dx, c + dy\n                                if 0 <= nr < m and 0 <= nc < n:\n                                    if mat[nr][nc] == 1 and (nr, nc) not in visited:\n                                        queue.append((nr, nc))\n                                        visited.add((nr, nc))\n                                    elif mat[nr][nc] == 0:\n                                        infected.add((nr, nc))\n                                        walls += 1\n\n                        if infected:\n                            regions.append((infected, walls, region_cells))\n            return regions\n\n        def quarantine(region_cells):\n            for r, c in region_cells:\n                mat[r][c] = 2\n\n        def infect(infected_regions):\n            for region in infected_regions:\n                for r, c in region:\n                    mat[r][c] = 1\n        \n        ans = 0\n        while True:\n            regions = get_regions()\n            \n            if not regions:\n                break\n            \n            regions.sort(key=lambda x: -len(x[0]))\n            \n            max_infected, max_walls, max_region_cells = regions[0]\n            ans += max_walls\n            quarantine(max_region_cells)\n\n            infected_regions = []\n            for infected, _, region_cells in regions[1:]:\n                infected_regions.append(infected)\n            \n            infect(infected_regions)\n        \n        return ans"
    },
    {
        "question_id": 699,
        "optimized_code": "class Node:\n    def __init__(self, l, r):\n        self.l = l\n        self.r = r\n        self.mid = (l + r) // 2\n        self.v = 0\n        self.add = 0\n        self.left = None\n        self.right = None\n\nclass SegmentTree:\n    def __init__(self):\n        self.root = Node(1, int(1e9))\n\n    def modify(self, l, r, v):\n        stack = [(self.root, l, r)]\n        while stack:\n            node, start, end = stack.pop()\n            if start > end:\n                continue\n            if node.l >= start and node.r <= end:\n                node.v = v\n                node.add = v\n                continue\n            self.pushdown(node)\n            if start <= node.mid:\n                stack.append((node.left, start, min(end, node.mid)))\n            if end > node.mid:\n                stack.append((node.right, max(start, node.mid + 1), end))\n            self.pushup(node)\n\n    def query(self, l, r):\n        stack = [(self.root, l, r)]\n        max_height = 0\n        while stack:\n            node, start, end = stack.pop()\n            if start > end:\n                continue\n            if node.l >= start and node.r <= end:\n                max_height = max(max_height, node.v)\n                continue\n            self.pushdown(node)\n            if start <= node.mid:\n                stack.append((node.left, start, min(end, node.mid)))\n            if end > node.mid:\n                stack.append((node.right, max(start, node.mid + 1), end))\n        return max_height\n\n    def pushup(self, node):\n        if node.left and node.right:\n            node.v = max(node.left.v, node.right.v)\n\n    def pushdown(self, node):\n        if node.left is None:\n            node.left = Node(node.l, node.mid)\n        if node.right is None:\n            node.right = Node(node.mid + 1, node.r)\n        if node.add != 0:\n            node.left.add = node.add\n            node.right.add = node.add\n            node.left.v = node.add\n            node.right.v = node.add\n            node.add = 0\n\nclass Solution:\n    def fallingSquares(self, positions):\n        ans = []\n        tree = SegmentTree()\n        mx = 0\n        for pos in positions:\n            l, w = pos\n            r = l + w - 1\n            h = tree.query(l, r) + w\n            mx = max(mx, h)\n            ans.append(mx)\n            tree.modify(l, r, h)\n        return ans"
    },
    {
        "question_id": 779,
        "optimized_code": "class Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        ans = 0\n        max_seen = 0\n        for i, num in enumerate(arr):\n            max_seen = max(max_seen, num)\n            if max_seen == i:\n                ans += 1\n        return ans"
    },
    {
        "question_id": 759,
        "optimized_code": "class Solution:\n    def intersectionSizeTwo(self, intervals: List[List[int]]) -> int:\n        intervals.sort(key=lambda x: x[1])\n        res = []\n        for interval in intervals:\n            s, e = interval\n            needed = 0\n            for x in res:\n                if s <= x <= e:\n                    needed += 1\n            if needed == 2:\n                continue\n            elif needed == 1:\n                val = e\n                if val not in res:\n                    res.append(val)\n            else:\n                val1 = e - 1\n                val2 = e\n                if val1 > val2:\n                  val1, val2 = val2, val1\n                if val2 not in res:\n                  res.append(val2)\n                if val1 not in res:\n                  res.append(val1)\n        return len(res)"
    },
    {
        "question_id": 854,
        "optimized_code": "class Solution:\n    def largestIsland(self, grid: List[List[int]]) -> int:\n        \n        directions = {(-1, 0), (1, 0), (0, -1), (0, 1)}\n        \n        def findAndSetArea(row, col, island_id):\n            stack = [(row, col)]\n            area = 0\n            grid[row][col] = island_id\n            while stack:\n                r, c = stack.pop()\n                area += 1\n\n                for dr, dc in directions:\n                    nr, nc = r + dr, c + dc\n                    if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and grid[nr][nc] == 1:\n                        grid[nr][nc] = island_id\n                        stack.append((nr, nc))\n            return area\n\n        island_id = 2 \n        island_sizes = {}\n        for r in range(len(grid)):\n            for c in range(len(grid[0])):\n                if grid[r][c] == 1:\n                    area = findAndSetArea(r, c, island_id)\n                    island_sizes[island_id] = area\n                    island_id += 1\n\n        max_area = 0\n        for size in island_sizes.values():\n            max_area = max(max_area, size)\n        \n        for r in range(len(grid)):\n            for c in range(len(grid[0])):\n                if grid[r][c] == 0:\n                    neighboring_islands = set()\n                    for dr, dc in directions:\n                        nr, nc = r + dr, c + dc\n                        if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and grid[nr][nc] > 1:\n                            neighboring_islands.add(grid[nr][nc])\n                    \n                    area_with_this_0 = 1\n                    for island in neighboring_islands:\n                        area_with_this_0 += island_sizes[island]\n                    max_area = max(max_area, area_with_this_0)\n\n        return max_area"
    },
    {
        "question_id": 855,
        "optimized_code": "import collections\n\nclass Solution:\n    def uniqueLetterString(self, s: str) -> int:\n        index = collections.defaultdict(list)\n        for i, c in enumerate(s):\n            index[c].append(i)\n        ans = 0\n        for c in index:\n            arr = index[c]\n            for i in range(len(arr)):\n                prev = arr[i - 1] if i > 0 else -1\n                nxt = arr[i + 1] if i < len(arr) - 1 else len(s)\n                ans += (arr[i] - prev) * (nxt - arr[i])\n        return ans"
    },
    {
        "question_id": 856,
        "optimized_code": "class Solution:\n    def consecutiveNumbersSum(self, n: int) -> int:\n        w = 0\n        k = 1\n        while k * (k + 1) / 2 <= n:\n            if (n - k * (k - 1) / 2) % k == 0:\n                w += 1\n            k += 1\n\n        return w"
    },
    {
        "question_id": 552,
        "optimized_code": "class Solution:\n    def checkRecord(self, n: int) -> int:\n        MOD = 10**9 + 7\n        dp = [[[0] * 3 for _ in range(2)] for _ in range(2)]\n\n        for i in range(1, n + 1):\n            new_dp = [[[0] * 3 for _ in range(2)] for _ in range(2)]\n            for a in range(2):\n                for l in range(3):\n                    if i == 1:\n                        if a == 0:\n                            new_dp[1][1][0] = 1\n                        new_dp[1][a][1] = 1\n                        new_dp[1][a][0] = 1\n                    else:\n                        if a < 1:\n                            new_dp[i % 2][a + 1][0] = (new_dp[i % 2][a + 1][0] + dp[(i - 1) % 2][a][l]) % MOD\n                        if l < 2:\n                            new_dp[i % 2][a][l + 1] = (new_dp[i % 2][a][l + 1] + dp[(i - 1) % 2][a][l]) % MOD\n                        new_dp[i % 2][a][0] = (new_dp[i % 2][a][0] + dp[(i - 1) % 2][a][l]) % MOD\n            dp = new_dp\n\n        total = 0\n        for a in range(2):\n            for l in range(3):\n                total = (total + dp[n % 2][a][l]) % MOD\n        return total"
    },
    {
        "question_id": 939,
        "optimized_code": "from collections import defaultdict\n\nclass Solution:\n    def numPermsDISequence(self, s: str) -> int:\n        n = len(s)\n        MOD = 10**9 + 7\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        dp[0][0] = 1\n\n        for i in range(1, n + 1):\n            new_dp = [[0] * (n + 1) for _ in range(n + 1)]\n            prefix_sum = 0\n            if s[i - 1] == 'D':\n                for j in range(n, -1, -1):\n                    prefix_sum = (prefix_sum + dp[i - 1][j]) % MOD\n                    new_dp[i][j] = prefix_sum\n            else:\n                for j in range(0, n + 1):\n                    prefix_sum = (prefix_sum + dp[i - 1][j]) % MOD\n                    new_dp[i][j] = prefix_sum\n                new_dp[i] = new_dp[i][::-1]\n\n            dp = new_dp\n\n        return sum(dp[n]) % MOD"
    }
]