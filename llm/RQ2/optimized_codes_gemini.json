[
    {
        "question_id": 131,
        "optimized_code": "```python\nclass Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        n = len(s)\n        dp = [[False] * n for _ in range(n)]\n\n        for i in range(n - 1, -1, -1):\n            for j in range(i, n):\n                if s[i] == s[j] and (j - i <= 2 or dp[i + 1][j - 1]):\n                    dp[i][j] = True\n\n        res = []\n\n        def backtrack(i, curr):\n            if i == n:\n                res.append(curr[:])\n                return\n\n            for j in range(i, n):\n                if dp[i][j]:\n                    curr.append(s[i:j + 1])\n                    backtrack(j + 1, curr)\n                    curr.pop()\n\n        backtrack(0, [])\n        return res\n```"
    },
    {
        "question_id": 132,
        "optimized_code": "```python\nfrom functools import lru_cache\n\nclass Solution:\n    def minCut(self, s: str) -> int:\n        n = len(s)\n        is_palindrome = [[False] * n for _ in range(n)]\n\n        for i in range(n):\n            is_palindrome[i][i] = True\n\n        for i in range(n - 1):\n            if s[i] == s[i+1]:\n                is_palindrome[i][i+1] = True\n\n        for length in range(3, n + 1):\n            for i in range(n - length + 1):\n                j = i + length - 1\n                if s[i] == s[j] and is_palindrome[i+1][j-1]:\n                    is_palindrome[i][j] = True\n\n        @lru_cache(None)\n        def f(i):\n            if i == n:\n                return 0\n\n            min_cuts = float('inf')\n            for j in range(i, n):\n                if is_palindrome[i][j]:\n                    min_cuts = min(min_cuts, 1 + f(j + 1))\n\n            return min_cuts\n\n        return f(0) - 1\n```"
    },
    {
        "question_id": 135,
        "optimized_code": "```python\nclass Solution:\n    def candy(self, ratings: List[int]) -> int:\n        n = len(ratings)\n        candies = [1] * n\n        \n        for i in range(1, n):\n            if ratings[i] > ratings[i - 1]:\n                candies[i] = candies[i - 1] + 1\n        \n        for i in range(n - 2, -1, -1):\n            if ratings[i] > ratings[i + 1]:\n                candies[i] = max(candies[i], candies[i + 1] + 1)\n        \n        return sum(candies)\n```"
    },
    {
        "question_id": 137,
        "optimized_code": "```python\nclass Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        result = 0\n        for num in nums:\n            result ^= num\n        return result\n```"
    },
    {
        "question_id": 138,
        "optimized_code": "```python\n\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        old_to_new = {None:None}\n        \n        old = head\n        while old:\n            new = Node(old.val)\n            old_to_new[old] = new\n            old = old.next\n        \n        old = head\n        while old:\n            new = old_to_new[old]\n            new.next = old_to_new[old.next]\n            new.random = old_to_new[old.random]\n            old = old.next\n        \n        return old_to_new[head]\n```"
    },
    {
        "question_id": 140,
        "optimized_code": "```python\nfrom typing import List\n\nclass Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\n        word_set = set(wordDict)\n        dp = [[] for _ in range(len(s) + 1)]\n        dp[0] = [\"\"]\n\n        for i in range(1, len(s) + 1):\n            for j in range(i):\n                word = s[j:i]\n                if word in word_set and dp[j]:\n                    for sentence in dp[j]:\n                        if sentence:\n                            dp[i].append(sentence + \" \" + word)\n                        else:\n                            dp[i].append(word)\n        return dp[len(s)]\n```"
    },
    {
        "question_id": 134,
        "optimized_code": "```python\nclass Solution:\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\n        n = len(gas)\n        total_gas = 0\n        curr_gas = 0\n        start_index = 0\n\n        for i in range(n):\n            total_gas += gas[i] - cost[i]\n            curr_gas += gas[i] - cost[i]\n\n            if curr_gas < 0:\n                curr_gas = 0\n                start_index = i + 1\n        \n        return start_index if total_gas >= 0 else -1\n```"
    },
    {
        "question_id": 228,
        "optimized_code": "```python\nclass Solution:\n    def summaryRanges(self, nums: List[int]) -> List[str]:\n        result = []\n        if not nums:\n            return result\n\n        small_arr = [nums[0]]\n        prev = nums[0]\n\n        for num in nums[1:]:\n            if num == prev + 1:\n                small_arr.append(num)\n            else:\n                if len(small_arr) == 1:\n                    result.append(str(small_arr[0]))\n                else:\n                    result.append(f\"{small_arr[0]}->{small_arr[-1]}\")\n                small_arr = [num]\n\n            prev = num\n\n        if len(small_arr) == 1:\n            result.append(str(small_arr[0]))\n        else:\n            result.append(f\"{small_arr[0]}->{small_arr[-1]}\")\n\n        return result\n```"
    },
    {
        "question_id": 229,
        "optimized_code": "```python\nfrom typing import List\n\nclass Solution:\n    def majorityElement(self, nums: List[int]) -> List[int]:\n        n1=None\n        c1=0\n        n2=None\n        c2=0\n        for num in nums:\n            if n1==num:\n                c1+=1\n            elif n2==num:\n                c2+=1\n            elif c1==0:\n                n1=num\n                c1=1\n            elif c2==0:\n                n2=num\n                c2=1\n            else:\n                c1-=1\n                c2-=1\n        c1=0\n        c2=0\n        for num in nums:\n            if num==n1:\n                c1+=1\n            if num==n2:\n                c2+=1\n        ans=[]\n        if c1>len(nums)//3:\n            ans.append(n1)\n        if c2>len(nums)//3 and n1!=n2:\n            ans.append(n2)\n        return ans\n```"
    },
    {
        "question_id": 230,
        "optimized_code": "```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:\n        stack = []\n        cur = root\n        while stack or cur:\n            while cur:\n                stack.append(cur)\n                cur = cur.left\n            cur = stack.pop()\n            k-=1\n            if k==0:\n                return cur.val\n            cur = cur.right\n        return -1\n```"
    },
    {
        "question_id": 231,
        "optimized_code": "```python\nclass Solution:\n    def isPowerOfTwo(self, n: int) -> bool:\n        return n > 0 and (n & (n - 1)) == 0\n```"
    },
    {
        "question_id": 123,
        "optimized_code": "```python\nfrom typing import List\n\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        n = len(prices)\n        dp = [[[0 for _ in range(3)] for _ in range(2)] for _ in range(2)]\n\n        for i in range(n - 1, -1, -1):\n            for j in range(2):\n                for k in range(1, 3):\n                    if j == 0:\n                        dp[i % 2][j][k] = max(-prices[i] + dp[(i + 1) % 2][1][k], 0 + dp[(i + 1) % 2][0][k])\n                    else:\n                        dp[i % 2][j][k] = max(+prices[i] + dp[(i + 1) % 2][0][k - 1], 0 + dp[(i + 1) % 2][1][k])\n\n        return dp[0][0][2]\n```"
    },
    {
        "question_id": 125,
        "optimized_code": "```python\nclass Solution:\n    def isPalindrome(self, s: str) -> bool:\n        l, r = 0, len(s) - 1\n        while l < r:\n            while l < r and not s[l].isalnum():\n                l += 1\n            while l < r and not s[r].isalnum():\n                r -= 1\n            if s[l].casefold() != s[r].casefold():\n                return False\n            l += 1\n            r -= 1\n        return True\n```"
    },
    {
        "question_id": 128,
        "optimized_code": "```python\nclass Solution:\n    def longestConsecutive(self, nums: List[int]) -> int:\n        numset = set(nums)\n        res = 0\n        for n in nums:\n            # check if n is a start of  seq\n            if (n-1) not in numset:\n                op = 0\n                while (n+op) in numset:\n                    op+=1\n                res = max(res,op)\n        return res\n```"
    },
    {
        "question_id": 130,
        "optimized_code": "```python\nclass Solution:\n    def solve(self, board: List[List[str]]) -> None:\n        \"\"\"\n        Do not return anything, modify board in-place instead.\n        \"\"\"\n        if not board:\n            return\n\n        M, N = len(board), len(board[0])\n\n        def dfs(i, j):\n            if i < 0 or i >= M or j < 0 or j >= N or board[i][j] != 'O':\n                return\n            \n            board[i][j] = 'T'  # Mark as temporary\n\n            dfs(i + 1, j)\n            dfs(i - 1, j)\n            dfs(i, j + 1)\n            dfs(i, j - 1)\n\n        # Iterate through the boundary and mark 'O's connected to the boundary\n        for i in range(M):\n            if board[i][0] == 'O':\n                dfs(i, 0)\n            if board[i][N - 1] == 'O':\n                dfs(i, N - 1)\n\n        for j in range(N):\n            if board[0][j] == 'O':\n                dfs(0, j)\n            if board[M - 1][j] == 'O':\n                dfs(M - 1, j)\n\n        # Replace 'O's with 'X's and 'T's with 'O's\n        for i in range(M):\n            for j in range(N):\n                if board[i][j] == 'O':\n                    board[i][j] = 'X'\n                elif board[i][j] == 'T':\n                    board[i][j] = 'O'\n```"
    },
    {
        "question_id": 82,
        "optimized_code": "```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def deleteDuplicates(self, head):\n        fake = ListNode(-1)\n        fake.next = head\n        prev, curr = fake, head\n        while curr:\n            while curr.next and curr.val == curr.next.val:\n                curr = curr.next\n            if prev.next == curr:\n                prev = prev.next\n                curr = curr.next\n            else:\n                prev.next = curr.next\n                curr = prev.next\n        return fake.next\n```"
    },
    {
        "question_id": 84,
        "optimized_code": "```python\nfrom typing import List\n\nclass Solution:\n    def largestRectangleArea(self, heights: List[int]) -> int:\n        st = []\n        area = 0\n        heights = [0] + heights + [0]\n\n        for i, a in enumerate(heights):\n            while st and heights[st[-1]] > a:\n                rr = i\n                k = st.pop()\n                ll = st[-1]\n                h = heights[k]\n                length = rr - ll - 1\n                area = max(area, h * length)\n\n            st.append(i)\n\n        return area\n```"
    },
    {
        "question_id": 85,
        "optimized_code": "```python\nclass Solution:\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\n        if not matrix:\n            return 0\n\n        m, n = len(matrix), len(matrix[0])\n        heights = [0] * n\n        max_area = 0\n\n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == '1':\n                    heights[j] += 1\n                else:\n                    heights[j] = 0\n\n            max_area = max(max_area, self.largestRectangleArea(heights))\n\n        return max_area\n\n    def largestRectangleArea(self, heights: List[int]) -> int:\n        stack = []\n        max_area = 0\n        n = len(heights)\n\n        for i in range(n + 1):\n            while stack and (i == n or heights[i] < heights[stack[-1]]):\n                height = heights[stack.pop()]\n                width = i - stack[-1] - 1 if stack else i\n                max_area = max(max_area, height * width)\n            stack.append(i)\n\n        return max_area\n```"
    },
    {
        "question_id": 87,
        "optimized_code": "```python\nclass Solution:\n    def isScramble(self, s1: str, s2: str) -> bool:\n        n = len(s1)\n        if len(s2) != n:\n            return False\n        if sorted(s1) != sorted(s2):\n            return False\n        if n <= 3:\n            return s1 == s2 or s1 == s2[::-1]\n\n        dp = {}\n\n        def solve(s1, s2):\n            if (s1, s2) in dp:\n                return dp[(s1, s2)]\n            if s1 == s2:\n                dp[(s1, s2)] = True\n                return True\n            if sorted(s1) != sorted(s2):\n                dp[(s1, s2)] = False\n                return False\n\n            n = len(s1)\n            for i in range(1, n):\n                if (solve(s1[:i], s2[:i]) and solve(s1[i:], s2[i:])) or \\\n                   (solve(s1[:i], s2[n-i:]) and solve(s1[i:], s2[:n-i])):\n                    dp[(s1, s2)] = True\n                    return True\n\n            dp[(s1, s2)] = False\n            return False\n\n        return solve(s1, s2)\n```"
    },
    {
        "question_id": 88,
        "optimized_code": "```python\nclass Solution:\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\n        \"\"\"\n        Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        p1 = m-1\n        p2 = n-1\n        p = m+n-1\n        while p2 >= 0:\n            if p1 >= 0 and nums1[p1] > nums2[p2]:\n                nums1[p] = nums1[p1]\n                p1 -= 1\n            else:\n                nums1[p] = nums2[p2]\n                p2 -= 1\n            p -= 1\n```"
    },
    {
        "question_id": 89,
        "optimized_code": "```python\nclass Solution:\n    def grayCode(self, n: int) -> list[int]:\n        result = [0]\n        for i in range(n):\n            mask = 1 << i\n            for j in range(len(result) - 1, -1, -1):\n                result.append(result[j] | mask)\n        return result\n```"
    },
    {
        "question_id": 90,
        "optimized_code": "```python\nclass Solution:\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\n        ans=[]\n        ds=[]\n\n        def findSubsets(ind:int):\n            ans.append(ds[:])\n            for i in range(ind,len(nums)):\n                if i != ind and nums[i] == nums[i-1]:\n                    continue\n                ds.append(nums[i])\n                findSubsets(i+1)\n                ds.pop()\n        nums.sort()\n        findSubsets(0)\n        return ans\n```"
    },
    {
        "question_id": 144,
        "optimized_code": "```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        ans = []\n        \n        def solve(node):\n            if not node:\n                return\n            ans.append(node.val)\n            solve(node.left)\n            solve(node.right)\n        \n        solve(root)\n        return ans\n```"
    },
    {
        "question_id": 148,
        "optimized_code": "```python\nfrom typing import Optional\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        def merge(head1, head2):\n            resultHead = ListNode(0)\n            cur = resultHead\n            while head1 and head2:\n                if head1.val < head2.val:\n                    cur.next = head1\n                    head1 = head1.next\n                else:\n                    cur.next = head2\n                    head2 = head2.next\n                cur = cur.next\n\n            if head1:\n                cur.next = head1\n            if head2:\n                cur.next = head2\n\n            return resultHead.next\n\n        def findOneBeforeMiddle(head):\n            if not head:\n                return None\n            slow = head\n            fast = head.next\n            while fast and fast.next:\n                slow = slow.next\n                fast = fast.next.next\n            return slow\n\n        if not head or not head.next:\n            return head\n\n        mid = findOneBeforeMiddle(head)\n        head1 = head\n        head2 = mid.next\n        mid.next = None\n\n        head1 = self.sortList(head1)\n        head2 = self.sortList(head2)\n\n        return merge(head1, head2)\n```"
    },
    {
        "question_id": 149,
        "optimized_code": "```python\nclass Solution:\n    def maxPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        if n <= 2:\n            return n\n        \n        max_points = 0\n        for i in range(n):\n            slopes = {}\n            same_points = 1\n            vertical_points = 0\n            for j in range(i + 1, n):\n                if points[i] == points[j]:\n                    same_points += 1\n                elif points[i][0] == points[j][0]:\n                    vertical_points += 1\n                else:\n                    dy = points[j][1] - points[i][1]\n                    dx = points[j][0] - points[i][0]\n                    \n                    import math\n                    gcd = math.gcd(dy, dx)\n                    dy //= gcd\n                    dx //= gcd\n                    \n                    slope = (dy, dx)\n                    \n                    if slope in slopes:\n                        slopes[slope] += 1\n                    else:\n                        slopes[slope] = 1\n            \n            current_max = same_points\n            if slopes:\n                current_max += max(slopes.values())\n            current_max = max(current_max, same_points + vertical_points)\n            \n            max_points = max(max_points, current_max)\n        \n        return max_points\n```"
    },
    {
        "question_id": 150,
        "optimized_code": "```python\nclass Solution:\n    def evalRPN(self, tokens):\n        stack = []\n        for token in tokens:\n            if token == '+':\n                operand2 = int(stack.pop())\n                operand1 = int(stack.pop())\n                stack.append(operand1 + operand2)\n            elif token == '-':\n                operand2 = int(stack.pop())\n                operand1 = int(stack.pop())\n                stack.append(operand1 - operand2)\n            elif token == '*':\n                operand2 = int(stack.pop())\n                operand1 = int(stack.pop())\n                stack.append(operand1 * operand2)\n            elif token == '/':\n                operand2 = int(stack.pop())\n                operand1 = int(stack.pop())\n                stack.append(int(operand1 / operand2))\n            else:\n                stack.append(token)\n        return int(stack[0])\n```"
    },
    {
        "question_id": 153,
        "optimized_code": "```python\nclass Solution:\n    def findMin(self, arr: List[int]) -> int:\n        n = len(arr)\n        l = 0\n        h = n - 1\n\n        while l <= h:\n            if arr[l] <= arr[h]:\n                return arr[l]\n\n            m = (l + h) // 2\n\n            if arr[l] <= arr[m]:\n                l = m + 1\n            else:\n                h = m - 1\n        return arr[l]\n```"
    },
    {
        "question_id": 160,
        "optimized_code": "```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        pA=headA\n        pB=headB\n        while pA!=pB:\n            pA=pA.next if pA else headB\n            pB=pB.next if pB else headA\n        return pA\n```"
    },
    {
        "question_id": 238,
        "optimized_code": "```python\nclass Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        res = [1] * len(nums)\n\n        prefix = 1\n        for i in range(len(nums)):\n            res[i] = prefix\n            prefix *= nums[i]\n\n        postfix = 1\n        for i in range(len(nums) -1, -1, -1):\n            res[i] *= postfix\n            postfix *= nums[i]\n        return res\n```"
    },
    {
        "question_id": 239,
        "optimized_code": "```python\nfrom collections import deque\n\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        if not nums:\n            return []\n        \n        if k == 1:\n            return nums\n\n        dq = deque()\n        result = []\n\n        for i in range(len(nums)):\n            # Remove elements out of the window\n            while dq and dq[0] <= i - k:\n                dq.popleft()\n\n            # Remove elements smaller than the current element to maintain decreasing order\n            while dq and nums[dq[-1]] <= nums[i]:\n                dq.pop()\n\n            dq.append(i)\n\n            # Add the maximum element to the result\n            if i >= k - 1:\n                result.append(nums[dq[0]])\n\n        return result\n```"
    },
    {
        "question_id": 241,
        "optimized_code": "```python\nfrom typing import List\n\nclass Solution:\n    def diffWaysToCompute(self, expression: str) -> List[int]:\n        memo = {}\n\n        def compute(expr):\n            if expr in memo:\n                return memo[expr]\n\n            if expr.isdigit():\n                return [int(expr)]\n\n            res = []\n            for i, s in enumerate(expr):\n                if s in \"+-*\":\n                    left = compute(expr[:i])\n                    right = compute(expr[i+1:])\n\n                    for l in left:\n                        for r in right:\n                            if s == '+':\n                                res.append(l + r)\n                            elif s == '-':\n                                res.append(l - r)\n                            else:\n                                res.append(l * r)\n\n            memo[expr] = res\n            return res\n\n        return compute(expression)\n```"
    },
    {
        "question_id": 242,
        "optimized_code": "```python\nclass Solution:\n    def isAnagram(self, s: str, t: str) -> bool:\n        if len(s) != len(t):\n            return False\n        sa = [0]*26\n        ta = [0]*26\n        for i in range(len(s)):\n            sa[ord(s[i])-ord('a')] += 1\n            ta[ord(t[i])-ord('a')] += 1\n        return sa==ta\n```"
    },
    {
        "question_id": 31,
        "optimized_code": "```python\nclass Solution:\n    def swap(self, nums, i, j):\n        nums[i], nums[j] = nums[j], nums[i]\n    def reverse(self, nums, i, j):\n        while i < j:\n            self.swap(nums, i, j)\n            i += 1\n            j -= 1\n            \n    def nextPermutation(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        i = len(nums) - 2\n        while i >= 0 and nums[i] >= nums[i + 1]:\n            i -= 1\n        if i >= 0:\n            j = len(nums) - 1\n            while nums[j] <= nums[i]:\n                j -= 1\n            self.swap(nums, i, j)\n        self.reverse(nums, i+1, len(nums) - 1)\n```"
    },
    {
        "question_id": 32,
        "optimized_code": "```python\nclass Solution:\n    def longestValidParentheses(self, s: str) -> int:\n        max_len = 0\n        dp = [0] * len(s)\n        for i in range(1, len(s)):\n            if s[i] == ')':\n                if s[i - 1] == '(':\n                    dp[i] = dp[i - 2] + 2 if i >= 2 else 2\n                elif i - dp[i - 1] > 0 and s[i - dp[i - 1] - 1] == '(':\n                    dp[i] = dp[i - 1] + 2 + (dp[i - dp[i - 1] - 2] if i - dp[i - 1] >= 2 else 0)\n                max_len = max(max_len, dp[i])\n        return max_len\n```"
    },
    {
        "question_id": 33,
        "optimized_code": "```python\nclass Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        l = 0\n        r = len(nums) - 1\n\n        while l <= r:\n            mid = (l + r) // 2\n            if nums[mid] == target:\n                return mid\n\n            if nums[l] <= nums[mid]:\n                if nums[l] <= target <= nums[mid]:\n                    r = mid - 1\n                else:\n                    l = mid + 1\n            else:\n                if nums[mid] <= target <= nums[r]:\n                    l = mid + 1\n                else:\n                    r = mid - 1\n\n        return -1\n```"
    },
    {
        "question_id": 34,
        "optimized_code": "```python\nfrom typing import List\nfrom bisect import bisect_left, bisect_right\n\nclass Solution:\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\n        l = bisect_left(nums, target)\n        if l == len(nums) or nums[l] != target:\n            return [-1, -1]\n        r = bisect_right(nums, target)\n        return [l, r - 1]\n```"
    },
    {
        "question_id": 191,
        "optimized_code": "```python\nclass Solution:\n    def hammingWeight(self, n: int) -> int:\n        count = 0\n        while n:\n            count += n & 1\n            n >>= 1\n        return count\n```"
    },
    {
        "question_id": 198,
        "optimized_code": "```python\nclass Solution:\n    def rob(self, nums: List[int]) -> int:\n        \n        if (len(nums) == 0):\n            return 0\n        elif (len(nums) == 1):\n            return nums[0]\n        elif (len(nums) == 2):\n            return max(nums)\n        \n        prev_max = nums[0]\n        curr_max = max(nums[0:2])\n        \n        \n        for i in range(2, len(nums)):\n            temp = curr_max\n            curr_max = max(curr_max, prev_max+nums[i])\n            prev_max = temp\n        return curr_max\n```"
    },
    {
        "question_id": 199,
        "optimized_code": "```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\n        def dfs(root, level):\n            if not root:\n                return\n            if len(res) == level:\n                res.append(root.val)\n            dfs(root.right, level + 1)\n            dfs(root.left, level + 1)\n        res = []\n        dfs(root, 0)\n        return res\n```"
    },
    {
        "question_id": 201,
        "optimized_code": "```python\nclass Solution:\n    def rangeBitwiseAnd(self, left: int, right: int) -> int:\n        while left < right:\n            right &= (right - 1)\n        return right\n```"
    },
    {
        "question_id": 205,
        "optimized_code": "```python\nclass Solution:\n    def isIsomorphic(self, s: str, t: str) -> bool:\n        stot = {}\n        ttos = {}\n        for s_, t_ in zip(s, t):\n            if s_ in stot and stot.get(s_)!=t_:\n                return False\n            if t_ in ttos and ttos.get(t_)!=s_:\n                return False\n\n            stot[s_] = t_\n            ttos[t_] = s_\n        return True\n```"
    },
    {
        "question_id": 210,
        "optimized_code": "```python\nclass Solution:\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\n        graph = [[] for _ in range(numCourses)]\n        indegree = [0] * numCourses\n        \n        for course, pre in prerequisites:\n            graph[pre].append(course)\n            indegree[course] += 1\n        \n        queue = [i for i in range(numCourses) if indegree[i] == 0]\n        result = []\n        \n        while queue:\n            course = queue.pop(0)\n            result.append(course)\n            \n            for neighbor in graph[course]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    queue.append(neighbor)\n        \n        if len(result) == numCourses:\n            return result\n        else:\n            return []\n```"
    },
    {
        "question_id": 214,
        "optimized_code": "```python\nclass Solution:\n    def shortestPalindrome(self, s: str) -> str:\n        n = len(s)\n        combined = s + \"#\" + s[::-1]\n        m = len(combined)\n        \n        lps = [0] * m\n        \n        length = 0\n        i = 1\n        \n        while i < m:\n            if combined[i] == combined[length]:\n                length += 1\n                lps[i] = length\n                i += 1\n            else:\n                if length != 0:\n                    length = lps[length - 1]\n                else:\n                    lps[i] = 0\n                    i += 1\n                    \n        longest_palindrome_prefix = lps[m - 1]\n        \n        return s[longest_palindrome_prefix:][::-1] + s\n```"
    },
    {
        "question_id": 216,
        "optimized_code": "```python\nclass Solution:\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\n        if 45-(9-k)*(10-k)/2 < n or k*(k+1)/2 > n:\n            return []\n\n        def backtrack(comb, s, target):\n            if target == 0 and len(comb) == k:\n                output.append(comb.copy())\n                return\n            if target < 0 or len(comb) > k:\n                return\n\n            for i in range(s, 10):\n                comb.append(i)\n                backtrack(comb, i + 1, target - i)\n                comb.pop()\n\n        output = []\n        backtrack([], 1, n)\n        return output\n```"
    },
    {
        "question_id": 93,
        "optimized_code": "```python\nclass Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        path = []\n        result = []\n\n        len_s = len(s)\n\n        def is_valid_ip(s):\n            if (s[0] == '0' and len(s) > 1) or int(s) > 255:\n                return False \n            else:\n                return True\n\n        def backtracking(start_idx, point_count):\n            if point_count == 4:\n                if start_idx == len_s:\n                    result.append(\".\".join(path))\n                return\n\n            if len_s - start_idx < (4 - point_count) or len_s - start_idx > (4 - point_count) * 3:\n                return\n\n            for i in range(start_idx, min(start_idx + 3, len_s)):\n                temp = s[start_idx:i + 1]\n                if is_valid_ip(temp):\n                    path.append(temp)\n                    backtracking(i + 1, point_count + 1)\n                    path.pop()\n        \n        backtracking(0, 0)\n        return result\n```"
    },
    {
        "question_id": 127,
        "optimized_code": "```python\nfrom collections import deque\nfrom typing import List\n\nclass Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\n        wordList = set(wordList)\n\n        if endWord not in wordList:\n            return 0\n        \n        def offByOne(s, t):\n            diff = 0\n            for i in range(len(s)):\n                if s[i] != t[i]:\n                    diff += 1\n                if diff > 1:\n                    return False\n            return diff == 1\n\n        queue = deque([(beginWord, 1)])\n        seen = {beginWord}\n        while queue:\n            word, length = queue.popleft()\n            \n\n            if word == endWord:\n                return length\n\n            for nextWord in wordList:\n                if nextWord not in seen and offByOne(word, nextWord):\n                    queue.append((nextWord, length + 1))\n                    seen.add(nextWord)\n        return 0\n```"
    },
    {
        "question_id": 81,
        "optimized_code": "```python\nclass Solution:\n    def search(self, nums: List[int], target: int) -> bool:\n        left = 0\n        right = len(nums) - 1\n        while left <= right:\n            middle = (left + right) // 2\n            if nums[middle] == target:\n                return True\n            if (nums[left] == nums[middle] and nums[middle] == nums[right]):\n                while left <= right and nums[left] == nums[middle]:\n                    left += 1\n                while left <= right and nums[right] == nums[middle]:\n                    right -= 1\n            elif nums[left] <= nums[middle]:\n                if nums[left] <= target and target < nums[middle]:\n                    right = middle - 1\n                else:\n                    left = middle + 1\n            else:\n                if target > nums[middle] and target <= nums[right]:\n                    left = middle + 1\n                else:\n                    right = middle - 1\n        return False\n```"
    },
    {
        "question_id": 151,
        "optimized_code": "```python\nclass Solution:\n    def reverseWords(self, s: str) -> str:\n        words = []\n        word = \"\"\n        for char in s:\n            if char == \" \":\n                if word:\n                    words.append(word)\n                    word = \"\"\n            else:\n                word += char\n        if word:\n            words.append(word)\n\n        result = \"\"\n        for i in range(len(words) - 1, -1, -1):\n            result += words[i]\n            if i > 0:\n                result += \" \"\n\n        return result\n```"
    },
    {
        "question_id": 152,
        "optimized_code": "```python\nfrom typing import List\n\nclass Solution:\n    def maxProduct(self, nums: List[int]) -> int:\n        max_prod = float('-inf')\n        prefix, suffix = 1, 1\n        n = len(nums)\n        for i in range(n):\n            if prefix == 0: prefix = 1\n            if suffix == 0: suffix = 1\n\n            prefix *= nums[i]\n            suffix *= nums[n - i - 1]\n            max_prod = max(max_prod, prefix, suffix)\n        return max_prod\n```"
    },
    {
        "question_id": 95,
        "optimized_code": "```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def generateTrees(self, n: int) -> List[TreeNode]:\n        memo = {}\n\n        def dfs(l, r):\n            if (l, r) in memo:\n                return memo[(l, r)]\n\n            if l > r:\n                return [None]\n\n            trees = []\n            for i in range(l, r + 1):\n                left_trees = dfs(l, i - 1)\n                right_trees = dfs(i + 1, r)\n\n                for left in left_trees:\n                    for right in right_trees:\n                        root = TreeNode(i)\n                        root.left = left\n                        root.right = right\n                        trees.append(root)\n\n            memo[(l, r)] = trees\n            return trees\n\n        if n == 0:\n            return []\n        return dfs(1, n)\n```"
    },
    {
        "question_id": 96,
        "optimized_code": "```python\nclass Solution:\n    def numTrees(self, n: int) -> int:\n\n        list_ = [0]*(n + 1)\n        list_[0], list_[1] = 1,1\n        for i in range(2, n+1):\n            for j in range(1,i+1):\n                list_[i] += list_[j-1]*list_[i-j]\n\n        return list_[n]\n```"
    },
    {
        "question_id": 97,
        "optimized_code": "```python\nclass Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n\n        if len(s1) + len(s2) != len(s3):\n            return False\n\n        dp = [[False] * (len(s2) + 1) for _ in range((len(s1) + 1))]\n\n        dp[0][0] = True\n\n        for i in range(len(s1) + 1):\n            for j in range(len(s2) + 1):\n                if i == 0 and j == 0:\n                    continue\n                elif i == 0:\n                    dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\n                elif j == 0:\n                    dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\n                else:\n                    dp[i][j] = (dp[i][j - 1] and s2[j - 1] == s3[j + i - 1]) or \\\n                               (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1])\n\n        return dp[len(s1)][len(s2)]\n```"
    },
    {
        "question_id": 1,
        "optimized_code": "```python\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        num_map = {}\n        for index, num in enumerate(nums):\n            complement = target - num\n            if complement in num_map:\n                return [num_map[complement], index]\n            num_map[num] = index\n```"
    },
    {
        "question_id": 5,
        "optimized_code": "```python\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        longest = \"\"\n        palin = set()\n        for i in range(len(s)):\n            # Odd length palindromes\n            l, r = i, i\n            while l >= 0 and r < len(s) and s[l] == s[r]:\n                if (r - l + 1) > len(longest):\n                    longest = s[l:r + 1]\n                l -= 1\n                r += 1\n\n            # Even length palindromes\n            l, r = i, i + 1\n            while l >= 0 and r < len(s) and s[l] == s[r]:\n                if (r - l + 1) > len(longest):\n                    longest = s[l:r + 1]\n                l -= 1\n                r += 1\n        if not longest:\n            return s[0:1] if len(s) > 0 else \"\"\n        return longest\n```"
    },
    {
        "question_id": 6,
        "optimized_code": "```python\nclass Solution:\n    def convert(self, s: str, numRows: int) -> str:\n        if numRows <= 1 or numRows >= len(s):\n            return s\n\n        result = \"\"\n        for row in range(numRows):\n            for j in range(0, len(s), 2 * (numRows - 1)):\n                index1 = j + row\n                if index1 < len(s):\n                    result += s[index1]\n\n                if row != 0 and row != numRows - 1:\n                    index2 = j + 2 * (numRows - 1) - row\n                    if index2 < len(s):\n                        result += s[index2]\n\n        return result\n```"
    },
    {
        "question_id": 8,
        "optimized_code": "```python\nclass Solution:\n    def myAtoi(self, s: str) -> int:\n        negative = False\n        start_digit = False\n        result = 0\n        INT_MAX = 2**31 - 1\n        INT_MIN = -2**31\n        \n        for char in s:\n            if char == \" \" and not start_digit:\n                continue\n            \n            if char == \"-\" and not start_digit:\n                negative = True\n                start_digit = True\n                continue\n            elif char == \"+\" and not start_digit:\n                start_digit = True\n                continue\n            \n            if char.isdigit():\n                digit = int(char)\n                \n                # Check for potential overflow before multiplying by 10\n                if result > INT_MAX // 10 or (result == INT_MAX // 10 and digit > 7):\n                    return INT_MAX if not negative else INT_MIN\n                \n                result = result * 10 + digit\n                start_digit = True\n                continue\n            \n            # If a non-digit character is encountered after starting to read digits\n            if start_digit:\n                break\n            \n            # If the character is invalid at the start (non-digit and not a sign)\n            if not char.isdigit() and not start_digit:\n                return 0\n        \n        if negative:\n            result = -result\n        \n        # Clamp the result to the 32-bit integer range\n        if result < INT_MIN:\n            return INT_MIN\n        if result > INT_MAX:\n            return INT_MAX\n        return result\n```"
    },
    {
        "question_id": 309,
        "optimized_code": "```python\nclass Solution:\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        max_profit = 0\n        min_price = float('inf')\n        for price in prices:\n            min_price = min(min_price, price)\n            profit = price - min_price\n            max_profit = max(max_profit, profit)\n        return max_profit\n```"
    },
    {
        "question_id": 299,
        "optimized_code": "```python\nclass Solution:\n    def getHint(self, secret: str, guess: str) -> str:\n        counts = {}\n        bulls = 0\n        cows = 0\n\n        for i in range(len(secret)):\n            if secret[i] == guess[i]:\n                bulls += 1\n            else:\n                counts[secret[i]] = counts.get(secret[i], 0) + 1\n\n        for i in range(len(secret)):\n            if secret[i] != guess[i]:\n                if guess[i] in counts and counts[guess[i]] > 0:\n                    cows += 1\n                    counts[guess[i]] -= 1\n\n        return f'{bulls}A{cows}B'\n```"
    },
    {
        "question_id": 300,
        "optimized_code": "```python\nimport bisect\n\nclass Solution:\n    def lengthOfLIS(self, nums: list[int]) -> int:\n        tails = []\n        for num in nums:\n            if not tails or num > tails[-1]:\n                tails.append(num)\n            else:\n                idx = bisect.bisect_left(tails, num)\n                tails[idx] = num\n        return len(tails)\n```"
    },
    {
        "question_id": 301,
        "optimized_code": "```python\nfrom typing import List\n\nclass Solution:\n    def removeInvalidParentheses(self, s: str) -> List[str]:\n        def is_valid(s):\n            count = 0\n            for char in s:\n                if char == '(':\n                    count += 1\n                elif char == ')':\n                    count -= 1\n                if count < 0:\n                    return False\n            return count == 0\n\n        def bfs(s):\n            queue = {s}\n            visited = {s}\n            result = []\n            found = False\n\n            while queue:\n                next_queue = set()\n                for current in queue:\n                    if is_valid(current):\n                        result.append(current)\n                        found = True\n\n                if found:\n                    return result\n\n                for current in queue:\n                    for i in range(len(current)):\n                        if current[i] in '()':\n                            neighbor = current[:i] + current[i+1:]\n                            if neighbor not in visited:\n                                next_queue.add(neighbor)\n                                visited.add(neighbor)\n                queue = next_queue\n\n            return result\n\n        return bfs(s)\n```"
    },
    {
        "question_id": 162,
        "optimized_code": "```python\nclass Solution:\n    def findPeakElement(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n == 1:\n            return 0\n        \n        for i in range(n):\n            if i == 0:\n                if nums[i] > nums[i+1]:\n                    return i\n            elif i == n - 1:\n                if nums[i] > nums[i-1]:\n                    return i\n            else:\n                if nums[i] > nums[i-1] and nums[i] > nums[i+1]:\n                    return i\n        \n        return 0\n```"
    },
    {
        "question_id": 164,
        "optimized_code": "```python\nclass Solution:\n    def maximumGap(self, nums: List[int]) -> int:\n        if len(nums) < 2:\n            return 0\n        if len(nums) == 2:\n            return abs(nums[0] - nums[1])\n        nmax, nmin = max(nums), min(nums)\n        if nmax == nmin:\n            return 0\n        num_buckets = len(nums) - 1\n        bucket_size = (nmax - nmin) / num_buckets\n        buckets = [[float('inf'), -1] for _ in range(num_buckets)]\n        for num in nums:\n            bucket_num = min(int((num - nmin) // bucket_size), num_buckets - 1)\n            buckets[bucket_num][0] = min(buckets[bucket_num][0], num)\n            buckets[bucket_num][1] = max(buckets[bucket_num][1], num)\n        prev_max = nmin\n        ret = 0\n        for i in range(num_buckets):\n            if buckets[i][0] == float('inf'):\n                continue\n            ret = max(ret, buckets[i][0] - prev_max)\n            prev_max = buckets[i][1]\n        return ret\n```"
    },
    {
        "question_id": 166,
        "optimized_code": "```python\nclass Solution:\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\n        if numerator==0:\n            return \"0\"\n        if denominator == 0:\n            return\n        string = []\n        if numerator * denominator < 0 :\n            string.append(\"-\")\n        numerator, denominator = abs(numerator), abs(denominator)\n        quo = numerator//denominator\n        string.append(str(quo))\n        rem = numerator%denominator\n\n        if rem==0:\n            return ''.join(string)\n        else:\n            string.append(\".\")\n        seen = {}\n        while rem:\n            if rem in seen:\n                ind = seen[rem]\n                return ''.join(string[:ind]) + \"(\" + ''.join(string[ind:]) + \")\"\n            seen[rem] = len(string)\n            rem *= 10\n            quo = rem//denominator\n            rem = rem%denominator\n            string.append(str(quo))\n        return ''.join(string)\n```"
    },
    {
        "question_id": 168,
        "optimized_code": "```python\nclass Solution:\n    def convertToTitle(self, columnNumber: int) -> str:\n        result = ''\n        while columnNumber > 0:\n            columnNumber -= 1\n            result = chr(65 + (columnNumber % 26)) + result\n            columnNumber //= 26\n        return result\n```"
    },
    {
        "question_id": 43,
        "optimized_code": "```python\nclass Solution:\n    def multiply(self, num1: str, num2: str) -> str:\n        if num1 == \"0\" or num2 == \"0\":\n            return \"0\"\n\n        n1 = len(num1)\n        n2 = len(num2)\n        product = [0] * (n1 + n2)\n\n        for i in range(n1 - 1, -1, -1):\n            carry = 0\n            for j in range(n2 - 1, -1, -1):\n                product[i + j + 1] += int(num1[i]) * int(num2[j]) + carry\n                carry = product[i + j + 1] // 10\n                product[i + j + 1] %= 10\n            product[i] += carry\n\n        result = \"\".join(map(str, product))\n        while result[0] == '0' and len(result) > 1:\n            result = result[1:]\n\n        return result\n```"
    },
    {
        "question_id": 50,
        "optimized_code": "```python\nclass Solution:\n    def myPow(self, x: float, n: int) -> float:\n        res = 1.0\n        abs_n = abs(n)\n        while abs_n > 0:\n            if abs_n & 1:\n                res *= x\n            x *= x\n            abs_n >>= 1\n        if n < 0:\n            return 1 / res\n        return res\n```"
    },
    {
        "question_id": 221,
        "optimized_code": "```python\nclass Solution:\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\n        if not matrix:\n            return 0\n\n        rows, cols = len(matrix), len(matrix[0])\n        dp = [[0] * cols for _ in range(rows)]\n        max_side = 0\n\n        for i in range(rows):\n            for j in range(cols):\n                if matrix[i][j] == '1':\n                    if i == 0 or j == 0:\n                        dp[i][j] = 1\n                    else:\n                        dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n                    max_side = max(max_side, dp[i][j])\n\n        return max_side * max_side\n```"
    },
    {
        "question_id": 223,
        "optimized_code": "```python\nclass Solution:\n    def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -> int:\n        width = max(0, min(ax2, bx2) - max(ax1, bx1))\n        height = max(0, min(ay2, by2) - max(ay1, by1))\n        return (ax2-ax1)*(ay2-ay1) + (bx2-bx1)*(by2-by1) - width*height\n```"
    },
    {
        "question_id": 107,
        "optimized_code": "```python\nfrom collections import deque\nfrom typing import Optional, List\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n\n        if not root:\n            return []\n\n        queue = deque([root])\n        solutions = deque([])\n\n        while queue:\n            level = []\n            level_size = len(queue)\n\n            for _ in range(level_size):\n                node = queue.popleft()\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n\n\n            solutions.appendleft(level)\n\n        return list(solutions)\n```"
    },
    {
        "question_id": 109,
        "optimized_code": "```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        def get_length(head):\n            length = 0\n            while head:\n                length += 1\n                head = head.next\n            return length\n\n        def sortedListToBSTHelper(start, end):\n            nonlocal head\n            if start > end:\n                return None\n\n            mid = (start + end) // 2\n            left = sortedListToBSTHelper(start, mid - 1)\n            \n            node = TreeNode(head.val)\n            node.left = left\n            head = head.next\n            \n            node.right = sortedListToBSTHelper(mid + 1, end)\n            \n            return node\n        \n        length = get_length(head)\n        return sortedListToBSTHelper(0, length - 1)\n```"
    },
    {
        "question_id": 268,
        "optimized_code": "```python\nclass Solution:\n    def missingNumber(self, nums: List[int]) -> int:\n        n = len(nums)\n        expected_sum = n * (n + 1) // 2\n        actual_sum = sum(nums)\n        return expected_sum - actual_sum\n```"
    },
    {
        "question_id": 172,
        "optimized_code": "```python\nclass Solution:\n    def trailingZeroes(self, n: int) -> int:\n        ans = 0\n        while n > 0:\n            n //= 5\n            ans += n\n        return ans\n```"
    },
    {
        "question_id": 179,
        "optimized_code": "```python\nfrom typing import List\n\nclass Solution:\n    def largestNumber(self, nums: List[int]) -> str:\n        nums = list(map(str, nums))\n        nums.sort(key=lambda x: x * 3, reverse=True)\n        return str(int(\"\".join(nums)))\n```"
    },
    {
        "question_id": 187,
        "optimized_code": "```python\nclass Solution:\n    def findRepeatedDnaSequences(self, s: str) -> List[str]:\n        if len(s) < 10:\n            return []\n\n        mapping = {'A': 0, 'C': 1, 'G': 2, 'T': 3}\n        seen = set()\n        repeated = set()\n        ans = []\n\n        for i in range(len(s) - 9):\n            num = 0\n            for j in range(10):\n                num = (num << 2) | mapping[s[i+j]]\n            \n            if num in seen:\n                if num not in repeated:\n                    ans.append(s[i:i+10])\n                    repeated.add(num)\n            else:\n                seen.add(num)\n        \n        return ans\n```"
    },
    {
        "question_id": 12,
        "optimized_code": "```python\nclass Solution:\n    def intToRoman(self, num: int) -> str:\n        dictionary = {1000:'M', 900:'CM', 500:'D', 400:'CD', 100:'C', 90:'XC', 50:'L', 40:'XL', 10:'X', 9:'IX', 5:'V', 4:'IV', 1:'I'}\n        ans=''\n        for key, val in dictionary.items():\n            while num>=key:\n                ans+=val\n                num-=key\n            if num==0:break\n        return ans\n```"
    },
    {
        "question_id": 13,
        "optimized_code": "```python\nclass Solution:\n    def romanToInt(self, s: str) -> int:\n        m = {\n            'I': 1,\n            'V': 5,\n            'X': 10,\n            'L': 50,\n            'C': 100,\n            'D': 500,\n            'M': 1000\n        }\n        \n        ans = 0\n        \n        for i in range(len(s)):\n            if i < len(s) - 1 and m[s[i]] < m[s[i+1]]:\n                ans -= m[s[i]]\n            else:\n                ans += m[s[i]]\n        \n        return ans\n```"
    },
    {
        "question_id": 113,
        "optimized_code": "```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:\n        res=[]\n        def helper(root,sm,gen):\n            if root is None:\n                return \n            \n            sm+=root.val\n            gen.append(root.val)\n\n            if root.left is None and root.right is None:\n                if sm==targetSum:\n                    res.append(gen[:])\n            else:\n                helper(root.left,sm,gen)\n                helper(root.right,sm,gen)\n            \n            gen.pop()\n        helper(root,0,[])\n        return res\n```"
    },
    {
        "question_id": 117,
        "optimized_code": "```python\n\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.next = next\n\"\"\"\n\nclass Solution:\n    def connect(self, root: 'Node') -> 'Node':\n        if not root:\n            return root\n\n        level_start = root\n\n        while level_start:\n            curr = level_start\n            while curr:\n                if curr.left:\n                    curr.left.next = curr.right\n                if curr.right and curr.next:\n                    curr.right.next = curr.next.left\n                curr = curr.next\n            level_start = level_start.left\n\n        return root\n```"
    },
    {
        "question_id": 118,
        "optimized_code": "```python\nclass Solution:\n    def generate(self, numRows: int) -> List[List[int]]:\n        \n        result = []\n        for i in range(numRows):\n            row = [1] * (i + 1)\n            if i > 1:\n                for j in range(1, i):\n                    row[j] = result[i-1][j-1] + result[i-1][j]\n            result.append(row)\n        return result\n```"
    },
    {
        "question_id": 119,
        "optimized_code": "```python\nclass Solution:\n    def getRow(self, rowIndex: int) -> List[int]:\n        row = [0] * (rowIndex + 1)\n        row[0] = 1\n        for i in range(1, rowIndex + 1):\n            for j in range(i, 0, -1):\n                row[j] += row[j - 1]\n        return row\n```"
    },
    {
        "question_id": 260,
        "optimized_code": "```python\nclass Solution:\n    def singleNumber(self, nums: List[int]) -> List[int]:\n        counts = {}\n        for num in nums:\n            counts[num] = counts.get(num, 0) + 1\n        \n        L = []\n        for num in nums:\n            if counts[num] == 1:\n                L.append(num)\n        \n        return L\n```"
    },
    {
        "question_id": 264,
        "optimized_code": "```python\nimport heapq\n\nclass Solution:\n    def nthUglyNumber(self, n: int) -> int:\n        seen = {1}\n        heap = [1]\n        \n        for _ in range(n - 1):\n            curr = heapq.heappop(heap)\n            \n            for factor in [2, 3, 5]:\n                next_ugly = curr * factor\n                if next_ugly not in seen:\n                    seen.add(next_ugly)\n                    heapq.heappush(heap, next_ugly)\n                    \n        return heapq.heappop(heap)\n```"
    },
    {
        "question_id": 71,
        "optimized_code": "```python\nclass Solution:\n    def simplifyPath(self, path: str) -> str:\n        components = path.split('/')\n        stack = []\n        \n        for component in components:\n            if component == \"..\":\n                if stack:\n                    stack.pop()\n            elif component and component != \".\":\n                stack.append(component)\n        \n        simplified_path = '/' + '/'.join(stack)\n        return simplified_path\n```"
    },
    {
        "question_id": 75,
        "optimized_code": "```python\nclass Solution:\n    def sortColors(self, nums: List[int]) -> None:\n        low = 0\n        mid = 0\n        high = len(nums) - 1\n\n        while mid <= high:\n            if nums[mid] == 0:\n                nums[low], nums[mid] = nums[mid], nums[low]\n                low += 1\n                mid += 1\n            elif nums[mid] == 1:\n                mid += 1\n            else:\n                nums[mid], nums[high] = nums[high], nums[mid]\n                high -= 1\n```"
    },
    {
        "question_id": 77,
        "optimized_code": "```python\nclass Solution:\n    def combine(self, n: int, k: int):\n        res = []\n\n        def dfs(combination, start):\n            if len(combination) == k:\n                res.append(combination.copy())\n                return\n            \n            if len(combination) + (n - start + 1) < k:\n                return\n            \n            for i in range(start, n + 1):\n                combination.append(i)\n                dfs(combination, i + 1)\n                combination.pop()\n\n        dfs([], 1)\n        return res\n```"
    },
    {
        "question_id": 80,
        "optimized_code": "```python\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n        \n        k = 0\n        count = 1\n        \n        for i in range(1, len(nums)):\n            if nums[i] == nums[k]:\n                if count < 2:\n                    k += 1\n                    nums[k] = nums[i]\n                    count += 1\n            else:\n                k += 1\n                nums[k] = nums[i]\n                count = 1\n                \n        return k + 1\n```"
    },
    {
        "question_id": 21,
        "optimized_code": "```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\n        cur = ListNode()\n        d = cur\n        while list1 and list2:\n            if list1.val < list2.val:\n                cur.next = list1\n                list1 = list1.next\n            else:\n                cur.next = list2\n                list2 = list2.next\n\n            cur = cur.next\n        if list1:\n            cur.next = list1\n        else:\n            cur.next = list2\n        return d.next\n```"
    },
    {
        "question_id": 27,
        "optimized_code": "```python\nclass Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        i = 0\n        for j in range(len(nums)):\n            if nums[j] != val:\n                nums[i] = nums[j]\n                i += 1\n        return i\n```"
    },
    {
        "question_id": 28,
        "optimized_code": "```python\nclass Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        if not needle:\n            return 0\n        \n        n = len(haystack)\n        m = len(needle)\n\n        for i in range(n - m + 1):\n            if haystack[i:i+m] == needle:\n                return i\n\n        return -1\n```"
    },
    {
        "question_id": 29,
        "optimized_code": "```python\nclass Solution:\n    def divide(self, dividend: int, divisor: int) -> int:\n        INT_MAX, INT_MIN = 2**31 - 1, -2**31\n        if dividend == INT_MIN and divisor == -1:\n            return INT_MAX\n        \n        sign = (dividend < 0) != (divisor < 0)\n        dividend, divisor = abs(dividend), abs(divisor)\n        quotient = 0\n        \n        power = 31\n        divisor_power = divisor << power\n        \n        while dividend >= divisor:\n            while divisor_power > dividend:\n                divisor_power >>= 1\n                power -= 1\n            dividend -= divisor_power\n            quotient += 1 << power\n        \n        if sign:\n            quotient = -quotient\n        \n        return min(max(quotient, INT_MIN), INT_MAX)\n```"
    },
    {
        "question_id": 30,
        "optimized_code": "```python\nfrom typing import List\nfrom collections import Counter\n\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        n = len(words)\n        k = len(words[0])\n        l = n * k\n        indices = []\n\n        if len(s) < l:\n            return indices\n\n        words_counts = Counter(words)\n\n        for i in range(len(s) - l + 1):\n            seen_words = Counter()\n            words_found = 0\n            for j in range(n):\n                word = s[i + j * k: i + (j + 1) * k]\n                if word in words_counts:\n                    seen_words[word] += 1\n                    if seen_words[word] <= words_counts[word]:\n                        words_found += 1\n                    else:\n                        break\n                else:\n                    break\n\n            if words_found == n:\n                indices.append(i)\n\n        return indices\n```"
    },
    {
        "question_id": 62,
        "optimized_code": "```python\nclass Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        row = [1] * n\n\n        for i in range(1, m):\n            newRow = [1] * n\n            for j in range(1, n):\n                newRow[j] = newRow[j - 1] + row[j]\n            row = newRow\n\n        return row[-1]\n```"
    },
    {
        "question_id": 64,
        "optimized_code": "```python\nfrom typing import List\n\nclass Solution:\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        if not grid or not grid[0]:\n            return 0\n        \n        m, n = len(grid), len(grid[0])\n        \n        dp = [0] * n\n        \n        dp[0] = grid[0][0]\n        \n        for j in range(1, n):\n            dp[j] = dp[j-1] + grid[0][j]\n        \n        for i in range(1, m):\n            dp[0] = dp[0] + grid[i][0]\n            for j in range(1, n):\n                dp[j] = grid[i][j] + min(dp[j-1], dp[j])\n        \n        return dp[n-1]\n```"
    },
    {
        "question_id": 65,
        "optimized_code": "```python\nimport re\n\nclass Solution:\n    def isNumber(self, s: str) -> bool:\n        s = s.strip()\n        pattern = r\"^[-+]?(\\d+\\.?\\d*|\\.\\d+)([eE][-+]?\\d+)?$\"\n        return bool(re.match(pattern, s))\n```"
    },
    {
        "question_id": 66,
        "optimized_code": "```python\nclass Solution:\n    def plusOne(self, digits: List[int]) -> List[int]:\n        n=len(digits)\n        for i  in range(n-1,-1,-1):\n            if digits[i]<9:\n                digits[i]+=1\n                return digits\n            else:\n                digits[i]=0\n        return [1]+digits\n```"
    },
    {
        "question_id": 67,
        "optimized_code": "```python\nclass Solution:\n    def addBinary(self, a: str, b: str) -> str:\n        i= len(a)-1\n        j= len(b)-1\n\n        car=0\n        sol=[]\n        while i >= 0 or j >= 0 or car:\n            digit_a = int(a[i]) if i >= 0 else 0\n            digit_b = int(b[j]) if j >= 0 else 0\n            \n            total = digit_a + digit_b + car\n            sol.append(str(total % 2))\n            car = total // 2  \n\n            i-=1\n            j-=1\n        return \"\".join(sol[::-1])\n```"
    },
    {
        "question_id": 69,
        "optimized_code": "```python\nclass Solution:\n    def mySqrt(self, x: int) -> int:\n        if x == 0 or x == 1:\n            return x\n\n        left = 1\n        right = x\n\n        while left <= right:\n            mid = (left + right) // 2\n            if mid * mid == x:\n                return mid\n            elif mid * mid < x:\n                left = mid + 1\n            else:\n                right = mid - 1\n\n        return right\n```"
    },
    {
        "question_id": 70,
        "optimized_code": "```python\nclass Solution:\n    def climbStairs(self, n: int) -> int:\n        if n <= 1:\n            return 1\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        dp[1] = 1\n        for i in range(2, n + 1):\n            dp[i] = dp[i - 1] + dp[i - 2]\n        return dp[n]\n```"
    },
    {
        "question_id": 51,
        "optimized_code": "```python\nclass Solution:\n    def solveNQueens(self, n: int) -> List[List[str]]:\n        def is_safe(board, row, col, n):\n            # Check column\n            for i in range(row):\n                if board[i][col] == 'Q':\n                    return False\n\n            # Check upper left diagonal\n            i = row - 1\n            j = col - 1\n            while i >= 0 and j >= 0:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j -= 1\n\n            # Check upper right diagonal\n            i = row - 1\n            j = col + 1\n            while i >= 0 and j < n:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j += 1\n\n            return True\n\n        def solve_n_queens_util(board, row, n, solutions):\n            if row == n:\n                solution = [\"\".join(row) for row in board]\n                solutions.append(solution)\n                return\n\n            for col in range(n):\n                if is_safe(board, row, col, n):\n                    board[row][col] = 'Q'\n                    solve_n_queens_util(board, row + 1, n, solutions)\n                    board[row][col] = '.'  # Backtrack\n\n        solutions = []\n        board = [['.' for _ in range(n)] for _ in range(n)]\n        solve_n_queens_util(board, 0, n, solutions)\n        return solutions\n```"
    },
    {
        "question_id": 52,
        "optimized_code": "```python\nclass Solution:\n    def totalNQueens(self, n: int) -> int:\n        cols = set()\n        pos_diags = set()  # (row + col)\n        neg_diags = set()  # (row - col)\n        count = 0\n\n        def backtrack(row):\n            nonlocal count\n\n            if row == n:\n                count += 1\n                return\n\n            for col in range(n):\n                if col in cols or (row + col) in pos_diags or (row - col) in neg_diags:\n                    continue\n\n                cols.add(col)\n                pos_diags.add(row + col)\n                neg_diags.add(row - col)\n\n                backtrack(row + 1)\n\n                cols.remove(col)\n                pos_diags.remove(row + col)\n                neg_diags.remove(row - col)\n\n        backtrack(0)\n        return count\n```"
    },
    {
        "question_id": 53,
        "optimized_code": "```python\nclass Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        maxSum = float('-inf')\n        currentSum = 0\n        \n        for num in nums:\n            currentSum += num\n            \n            if currentSum > maxSum:\n                maxSum = currentSum\n            \n            if currentSum < 0:\n                currentSum = 0\n        \n        return maxSum\n```"
    },
    {
        "question_id": 55,
        "optimized_code": "```python\nclass Solution:\n    def canJump(self, nums: List[int]) -> bool:\n        reachable = 0\n        for i, num in enumerate(nums):\n            if i > reachable:\n                return False\n            reachable = max(reachable, i + num)\n        return True\n```"
    },
    {
        "question_id": 58,
        "optimized_code": "```python\nclass Solution:\n    def lengthOfLastWord(self, s: str) -> int:\n        s = s.rstrip()\n        if not s:\n            return 0\n        return len(s.split()[-1])\n```"
    },
    {
        "question_id": 60,
        "optimized_code": "```python\nclass Solution:\n    def getPermutation(self, n: int, k: int) -> str:\n        import math\n        numbers = list(range(1, n + 1))\n        permutation = ''\n        k -= 1\n        for i in range(n, 0, -1):\n            index = k // math.factorial(i - 1)\n            permutation += str(numbers[index])\n            numbers.pop(index)\n            k %= math.factorial(i - 1)\n        return permutation\n```"
    },
    {
        "question_id": 282,
        "optimized_code": "```python\nclass Solution:\n    def addOperators(self, num: str, target: int) -> List[str]:\n        n = len(num)\n        res = []\n\n        def dfs(index, current_expr, current_val, prev_operand):\n            if index == n:\n                if current_val == target:\n                    res.append(current_expr)\n                return\n\n            for j in range(index, n):\n                if j > index and num[index] == '0':\n                    break\n\n                current_num = int(num[index:j + 1])\n\n                if index == 0:\n                    dfs(j + 1, str(current_num), current_num, current_num)\n                else:\n                    dfs(j + 1, current_expr + '+' + str(current_num), current_val + current_num, current_num)\n                    dfs(j + 1, current_expr + '-' + str(current_num), current_val - current_num, -current_num)\n                    dfs(j + 1, current_expr + '*' + str(current_num), current_val - prev_operand + prev_operand * current_num, prev_operand * current_num)\n\n        dfs(0, \"\", 0, 0)\n        return res\n```"
    },
    {
        "question_id": 283,
        "optimized_code": "```python\nclass Solution:\n    def moveZeroes(self, nums: List[int]) -> None:\n        n = len(nums)\n        left = 0\n        for right in range(n):\n            if nums[right] != 0:\n                nums[left], nums[right] = nums[right], nums[left]\n                left += 1\n```"
    },
    {
        "question_id": 336,
        "optimized_code": "```python\nfrom collections import defaultdict\nfrom typing import List\n\nclass Solution:\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\n        dct = {word: i for i, word in enumerate(words)}\n        result = []\n\n        for i, word in enumerate(words):\n            n = len(word)\n            for j in range(n + 1):\n                prefix = word[:j]\n                suffix = word[j:]\n\n                if prefix[::-1] in dct and dct[prefix[::-1]] != i and suffix == suffix[::-1]:\n                    result.append([i, dct[prefix[::-1]]])\n\n                if j > 0 and suffix[::-1] in dct and dct[suffix[::-1]] != i and prefix == prefix[::-1]:\n                    result.append([dct[suffix[::-1]], i])\n        return result\n```"
    },
    {
        "question_id": 338,
        "optimized_code": "```python\nclass Solution:\n    def countBits(self, n: int) -> List[int]:\n        dp = [0] * (n + 1)\n        for i in range(1, n + 1):\n            dp[i] = dp[i >> 1] + (i & 1)\n        return dp\n```"
    },
    {
        "question_id": 342,
        "optimized_code": "```python\nclass Solution:\n    def isPowerOfFour(self, n: int) -> bool:\n        if n <= 0:\n            return False\n        while n % 4 == 0:\n            n //= 4\n        return n == 1\n```"
    },
    {
        "question_id": 345,
        "optimized_code": "```python\nclass Solution:\n    def reverseVowels(self, s: str) -> str:\n        buf = list(s)\n        myset = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        vowels = []\n        indexs = []\n\n        for i in range(len(s)):\n            if s[i] in myset:\n                vowels.append(s[i])\n                indexs.append(i)\n        \n        vowels.reverse()\n\n        for i in range(len(indexs)):\n            buf[indexs[i]] = vowels[i]\n        \n        answer = ''.join(buf)\n        return answer\n```"
    },
    {
        "question_id": 389,
        "optimized_code": "```python\nclass Solution:\n    def findTheDifference(self, s: str, t: str) -> str:\n        s_sum = sum(ord(c) for c in s)\n        t_sum = sum(ord(c) for c in t)\n        return chr(t_sum - s_sum)\n```"
    },
    {
        "question_id": 391,
        "optimized_code": "```python\nfrom typing import List\n\nclass Solution:\n    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\n        x1 = float('inf')\n        y1 = float('inf')\n        x2 = float('-inf')\n        y2 = float('-inf')\n        area = 0\n        corners = set()\n\n        for x, y, a, b in rectangles:\n            x1 = min(x1, x)\n            y1 = min(y1, y)\n            x2 = max(x2, a)\n            y2 = max(y2, b)\n            area += (a - x) * (b - y)\n\n            corners.add((x, y))\n            corners.add((x, b))\n            corners.add((a, y))\n            corners.add((a, b))\n\n        if (x2 - x1) * (y2 - y1) != area:\n            return False\n\n        expected_corners = {(x1, y1), (x1, y2), (x2, y1), (x2, y2)}\n\n        if len(corners - expected_corners) > 0:\n            return False\n        \n        count = {}\n        for x, y, a, b in rectangles:\n            for p in [(x, y), (x, b), (a, y), (a, b)]:\n                count[p] = count.get(p, 0) + 1\n        \n        odd_count = 0\n        for c in count:\n            if count[c] % 2 != 0:\n                odd_count += 1\n        return odd_count == 4 and corners == expected_corners\n```"
    },
    {
        "question_id": 392,
        "optimized_code": "```python\nclass Solution:\n    def isSubsequence(self, s: str, t: str) -> bool:\n        s_ptr = 0\n        t_ptr = 0\n        while s_ptr < len(s) and t_ptr < len(t):\n            if s[s_ptr] == t[t_ptr]:\n                s_ptr += 1\n            t_ptr += 1\n        return s_ptr == len(s)\n```"
    },
    {
        "question_id": 479,
        "optimized_code": "```python\nclass Solution:\n    def largestPalindrome(self, n: int) -> int:\n        if n == 1:\n            return 9\n        upper_bound = 10 ** n - 1\n        lower_bound = 10 ** (n - 1)\n\n        for a in range(upper_bound, lower_bound - 1, -1):\n            palindrome = int(str(a) + str(a)[::-1])\n\n            for x in range(upper_bound, int(palindrome**0.5) - 1, -1):\n                if palindrome % x == 0 and palindrome // x <= upper_bound:\n                    return palindrome % 1337\n        return 0\n```"
    },
    {
        "question_id": 483,
        "optimized_code": "```python\nclass Solution:\n    def smallestGoodBase(self, n: str) -> str:\n        n = int(n)\n        m_max = int((n).bit_length())\n\n        for m in range(m_max, 1, -1):\n            k = int(n ** (1 / m))\n            low, high = 2, n\n            while low <= high:\n                mid = (low + high) // 2\n                sum_val = (mid ** (m + 1) - 1) // (mid - 1)\n                if sum_val == n:\n                    return str(mid)\n                elif sum_val < n:\n                    low = mid + 1\n                else:\n                    high = mid - 1\n        return str(n - 1)\n```"
    },
    {
        "question_id": 485,
        "optimized_code": "```python\nclass Solution:\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\n        maxLength = 0\n        length = 0\n        for i in range(len(nums)):\n            if nums[i] == 0:\n                length = 0\n            else: \n                length += 1\n            maxLength = max(maxLength, length)\n\n        return maxLength\n```"
    },
    {
        "question_id": 410,
        "optimized_code": "```python\nclass Solution:\n    def splitArray(self, nums: List[int], k: int) -> int:\n        def check(x):\n            cnt = 1\n            cur = 0\n            for num in nums:\n                if num > x:\n                    return False\n                cur += num\n                if cur > x:\n                    cnt += 1\n                    cur = num\n            return cnt <= k\n\n        left = max(nums)\n        right = sum(nums)\n        ans = right\n        while left <= right:\n            mid = (left + right) // 2\n            if check(mid):\n                ans = mid\n                right = mid - 1\n            else:\n                left = mid + 1\n        return ans\n```"
    },
    {
        "question_id": 414,
        "optimized_code": "```python\nclass Solution:\n    def thirdMax(self, nums: List[int]) -> int:\n        nums = sorted(list(set(nums)), reverse=True)\n        if len(nums) >= 3:\n            return nums[2]\n        else:\n            return nums[0]\n```"
    },
    {
        "question_id": 472,
        "optimized_code": "```python\nclass Solution:\n    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\n        word_set = set(words)\n        result = []\n\n        def can_form(word):\n            if not word:\n                return False\n            dp = [False] * (len(word) + 1)\n            dp[0] = True\n            for i in range(1, len(word) + 1):\n                for j in range(i):\n                    if dp[j] and word[j:i] in word_set:\n                        dp[i] = True\n                        break\n            return dp[len(word)]\n\n        for word in words:\n            if can_form(word):\n                result.append(word)\n\n        filtered_result = []\n        for word in result:\n            word_set.remove(word)\n            if can_form(word):\n                filtered_result.append(word)\n            word_set.add(word)\n            \n        return filtered_result\n```"
    },
    {
        "question_id": 476,
        "optimized_code": "```python\nclass Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        bit_length = num.bit_length()\n        mask = (1 << bit_length) - 1\n        return num ^ mask\n```"
    },
    {
        "question_id": 440,
        "optimized_code": "```python\nclass Solution(object):\n    def findKthNumber(self, n, k):\n        curr = 1\n        k -= 1\n\n        while k > 0:\n            step = self.countSteps(n, curr, curr + 1)\n            if step <= k:\n                curr += 1\n                k -= step\n            else:\n                curr *= 10\n                k -= 1\n\n        return curr\n\n    def countSteps(self, n, prefix1, prefix2):\n        steps = 0\n        while prefix1 <= n:\n            steps += min(n + 1, prefix2) - prefix1\n            prefix1 *= 10\n            prefix2 *= 10\n        return steps\n```"
    },
    {
        "question_id": 441,
        "optimized_code": "```python\nclass Solution:\n    def arrangeCoins(self, n: int) -> int:\n        left, right = 0, n\n        while left <= right:\n            mid = left + (right - left) // 2\n            coins_needed = mid * (mid + 1) // 2\n            if coins_needed == n:\n                return mid\n            elif coins_needed < n:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return right\n```"
    },
    {
        "question_id": 401,
        "optimized_code": "```python\nclass Solution:\n    def readBinaryWatch(self, num: int) -> list[str]:\n        def count_set_bits(n):\n            count = 0\n            while n > 0:\n                n &= (n - 1)\n                count += 1\n            return count\n\n        times = []\n        for h in range(12):\n            for m in range(60):\n                if count_set_bits(h) + count_set_bits(m) == num:\n                    times.append(f\"{h}:{m:02d}\")\n        return times\n```"
    },
    {
        "question_id": 404,
        "optimized_code": "```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sumOfLeftLeaves(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        \n        stack = [(root, False)]  # (node, is_left_child)\n        total_sum = 0\n        \n        while stack:\n            node, is_left = stack.pop()\n            \n            if node:\n                if is_left and not node.left and not node.right:\n                    total_sum += node.val\n                \n                if node.right:\n                    stack.append((node.right, False))\n                if node.left:\n                    stack.append((node.left, True))\n        \n        return total_sum\n```"
    },
    {
        "question_id": 363,
        "optimized_code": "```python\nimport bisect\nfrom typing import List\n\nclass Solution:\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\n        m, n = len(matrix), len(matrix[0])\n        max_sum = float('-inf')\n\n        for left in range(n):\n            row_sums = [0] * m\n            for right in range(left, n):\n                for i in range(m):\n                    row_sums[i] += matrix[i][right]\n\n                cur_sum = 0\n                prefix_sums = [0]\n                for row_sum in row_sums:\n                    cur_sum += row_sum\n                    target = cur_sum - k\n                    \n                    pos = bisect.bisect_left(prefix_sums, target)\n                    if pos < len(prefix_sums):\n                        max_sum = max(max_sum, cur_sum - prefix_sums[pos])\n                        \n                    bisect.insort(prefix_sums, cur_sum)\n\n        return max_sum\n```"
    },
    {
        "question_id": 459,
        "optimized_code": "```python\nclass Solution:\n    def repeatedSubstringPattern(self, s: str) -> bool:\n        n = len(s)\n        for i in range(1, n // 2 + 1):\n            if n % i == 0:\n                sub = s[:i]\n                k = n // i\n                new = sub * k\n                if new == s:\n                    return True\n        return False\n```"
    },
    {
        "question_id": 461,
        "optimized_code": "```python\nclass Solution:\n    def hammingDistance(self, x: int, y: int) -> int:\n        xor_result = x ^ y\n        hamming_distance = 0\n        while xor_result:\n            hamming_distance += xor_result & 1\n            xor_result >>= 1\n        return hamming_distance\n```"
    },
    {
        "question_id": 463,
        "optimized_code": "```python\nclass Solution:\n    def islandPerimeter(self, grid: List[List[int]]) -> int:\n        rows, cols = len(grid), len(grid[0])\n        perimeter = 0\n\n        for i in range(rows):\n            for j in range(cols):\n                if grid[i][j] == 1:\n                    # Check up\n                    if i == 0 or grid[i-1][j] == 0:\n                        perimeter += 1\n                    # Check down\n                    if i == rows - 1 or grid[i+1][j] == 0:\n                        perimeter += 1\n                    # Check left\n                    if j == 0 or grid[i][j-1] == 0:\n                        perimeter += 1\n                    # Check right\n                    if j == cols - 1 or grid[i][j+1] == 0:\n                        perimeter += 1\n        return perimeter\n```"
    },
    {
        "question_id": 685,
        "optimized_code": "```python\nfrom collections import defaultdict\n\nclass Solution:\n    def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:\n        n = len(edges)\n        parent = list(range(n + 1))\n\n        def find(i):\n            if parent[i] == i:\n                return i\n            parent[i] = find(parent[i])\n            return parent[i]\n\n        def union(i, j):\n            root_i = find(i)\n            root_j = find(j)\n            if root_i != root_j:\n                parent[root_i] = root_j\n                return True\n            return False\n\n        in_degree = defaultdict(int)\n        for u, v in edges:\n            in_degree[v] += 1\n\n        multiple_in_degree = []\n        for i in range(len(edges) - 1, -1, -1):\n            if in_degree[edges[i][1]] > 1:\n                multiple_in_degree.append(edges[i])\n        \n        if multiple_in_degree:\n            \n            candidate = multiple_in_degree[0]\n\n            edges_without_candidate = [edge for edge in edges if edge != candidate]\n            \n            parent = list(range(n + 1))\n            cycle_present = False\n\n            for u, v in edges_without_candidate:\n                if not union(u, v):\n                    cycle_present = True\n                    break\n            if cycle_present:\n                return candidate\n            else:\n                \n                \n                for i in range(len(multiple_in_degree)-1, -1, -1):\n                    candidate = multiple_in_degree[i]\n                    return candidate\n        else:\n            \n            parent = list(range(n + 1))\n            cycle_edge = None\n            for u, v in edges:\n                if not union(u, v):\n                    cycle_edge = [u, v]\n                    break\n            return cycle_edge\n```"
    },
    {
        "question_id": 736,
        "optimized_code": "```python\nfrom collections import deque\nimport copy\n\nclass Solution:\n    def evaluate(self, expression: str) -> int:\n        \"\"\"\n        expr := (let [string expr]*)\n        expr := (add  expr expr)\n        expr := (mult expr expr)\n        expr := var \n        \"\"\"\n\n        def tokenize(s):\n            Q = deque()\n            cur = 0\n            n = len(s)\n            while cur < n:\n                c = s[cur]\n                if c in ('(', ')'):\n                    Q.append(c)\n                    cur += 1\n                    continue\n                if c.isdigit() or c == '-':\n                    res = 0\n                    sign = 1\n                    if c == '-':\n                        sign = -1\n                        cur += 1\n                    while cur < n and s[cur].isdigit():\n                        res = res*10 + int(s[cur])\n                        cur += 1\n                    Q.append(sign * res)\n                    continue\n                if c.isalpha():\n                    res = []\n                    while cur < n and (s[cur].isalpha() or s[cur].isdigit()):\n                        res.append(s[cur])\n                        cur += 1\n                    Q.append(''.join(res))\n                    continue\n                cur += 1\n            return Q\n\n        tokens = tokenize(expression)  #TODO\n\n        def string():\n            return tokens.popleft()\n\n        def var(mp):\n            s = tokens.popleft()\n            if s in mp:\n                return mp[s]\n            return int(s)\n\n        def expr(mp):\n            if tokens[0] == '(':\n                tokens.popleft()  # Remove '('\n                op = tokens.popleft()\n\n                if op == 'let':\n                    new_vars = {}\n                    while tokens[0] != '(' and tokens[1] != ')':\n                        variable_name = string()\n                        expression = expr(mp)\n                        new_vars[variable_name] = expression\n                        mp[variable_name] = expression\n\n                    expression = expr(mp)\n\n                    # Restore original scope\n                    for var_name in new_vars:\n                        del mp[var_name]\n                    tokens.popleft() # Remove ')'\n                    return expression\n                elif op == 'mult':\n                    expr1 = expr(mp)\n                    expr2 = expr(mp)\n                    tokens.popleft() # Remove ')'\n                    return expr1 * expr2\n                elif op == 'add':\n                    expr1 = expr(mp)\n                    expr2 = expr(mp)\n                    tokens.popleft() # Remove ')'\n                    return expr1 + expr2\n            else:\n                return var(mp)\n\n        return expr({})\n```"
    },
    {
        "question_id": 973,
        "optimized_code": "```python\nclass Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        m, n = len(stamp), len(target)\n        target = list(target)\n        result = []\n        q = []\n        A = []\n        for i in range(n - m + 1):\n            diff = 0\n            for j in range(m):\n                if target[i + j] != stamp[j]:\n                    diff += 1\n            A.append([diff, i])\n            if diff == 0:\n                q.append(i)\n\n        visited = [False] * n\n\n        while q:\n            i = q.pop(0)\n            result.append(i)\n            for k in range(max(0, i - m + 1), min(n - m, i) + 1):\n                if visited[k]:\n                    continue\n                A[k][0] -= 1\n                if A[k][0] == 0:\n                    q.append(k)\n                    visited[k] = True\n\n        return result[::-1] if len(result) * m == n else []\n```"
    },
    {
        "question_id": 975,
        "optimized_code": "```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\n        total = 0\n\n        def dfs(node: TreeNode) -> int:\n            if not node:\n                return 0\n            \n            current_sum = 0\n            if low <= node.val <= high:\n                current_sum += node.val\n            \n            if node.val > low:\n                current_sum += dfs(node.left)\n            \n            if node.val < high:\n                current_sum += dfs(node.right)\n                \n            return current_sum\n        \n        return dfs(root)\n```"
    },
    {
        "question_id": 977,
        "optimized_code": "```python\nMOD = 10 ** 9 + 7\n\n\nclass Solution:\n    \"\"\"\n    @param S: The string s\n    @return: The number of distinct, non-empty subsequences of S.\n    \"\"\"\n    def distinctSubseqII(self, S):\n        n = len(S)\n        \n        # state: dp[i] \u8868\u793a\u4ee5\u4e0b\u6807 i \u4f5c\u4e3a subseq \u7684\u6700\u540e\u4e00\u4e2a\u5b57\u7b26 \n        # \u7684\u65b9\u6848\u603b\u6570\n        f = [0] * (n+1)\n        \n        # initialization: \u5982\u679c i \u662f\u7b2c\u4e00\u4e2a\u51fa\u73b0 S[i] \u8fd9\u4e2a\u5b57\u7b26\u7684\u4f4d\u7f6e\uff0c\u90a3\u4e48 dp[i] = 1\n       \n        f[0] = 1\n        # function: dp[i] = sigma{dp[j]}, j \u5230 i - 1 \u4e4b\u95f4\u6ca1\u6709 S[i]\n        last = {}\n        for i in range(1, n+1): \n            \n            dup = 0\n            if S[i-1] in last:\n                dup = f[last[S[i-1]]]\n                \n            f[i] = ( 2 * f[i-1]  - dup) %MOD\n            last[S[i-1]] = i-1\n        # answer: \u4ee5\u6240\u6709\u4f4d\u7f6e\u7ed3\u5c3e\u7684\u65b9\u6848\u603b\u6570\u4e4b\u548c\n        return (f[-1] -1 ) %MOD\n```"
    },
    {
        "question_id": 1013,
        "optimized_code": "```python\nclass Solution:\n    def fib(self, n: int) -> int:\n        memo = {}\n        \n        def fib_memo(n):\n            if n in memo:\n                return memo[n]\n            \n            if n < 2:\n                return n\n            \n            memo[n] = fib_memo(n-1) + fib_memo(n-2)\n            return memo[n]\n        \n        return fib_memo(n)\n```"
    },
    {
        "question_id": 514,
        "optimized_code": "```python\nfrom collections import defaultdict\nfrom math import inf\n\nclass Solution:\n    def findRotateSteps(self, ring: str, key: str) -> int:\n        n, m = len(ring), len(key)\n        pos = defaultdict(list)\n        for i, c in enumerate(ring):\n            pos[c].append(i)\n\n        dp = [0] * n\n        for k in reversed(range(m)):\n            nextDP = [inf] * n\n            for r in range(n):\n                for i in pos[key[k]]:\n                    minDist = min(abs(r - i), n - abs(r - i))\n                    nextDP[r] = min(nextDP[r], 1 + minDist + dp[i])\n            dp = nextDP\n\n        return dp[0]\n```"
    },
    {
        "question_id": 920,
        "optimized_code": "```python\nfrom collections import Counter\nfrom typing import List\n\nclass Solution:\n    def uncommonFromSentences(self, s1: str, s2: str) -> List[str]:\n        d=Counter(s1.split())+Counter(s2.split())\n        return [x for x in d if d[x]==1]\n```"
    },
    {
        "question_id": 35,
        "optimized_code": "```python\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        low = 0\n        high = len(nums) - 1\n\n        while low <= high:\n            mid = (low + high) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                low = mid + 1\n            else:\n                high = mid - 1\n\n        return low\n```"
    },
    {
        "question_id": 10,
        "optimized_code": "```python\nclass Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        m, n = len(s), len(p)\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\n        dp[0][0] = True\n\n        for i in range(n):\n            if p[i] == '*' and dp[0][i - 1]:\n                dp[0][i + 1] = True\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if p[j - 1] == '*':\n                    dp[i][j] = dp[i][j - 2] or (\n                        (s[i - 1] == p[j - 2] or p[j - 2] == '.') and dp[i - 1][j]\n                    )\n                elif p[j - 1] == '.' or s[i - 1] == p[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n\n        return dp[m][n]\n```"
    },
    {
        "question_id": 218,
        "optimized_code": "```python\nclass Solution:\n    def getSkyline(self, buildings: List[List[int]]) -> List[List[int]]:\n        import heapq\n        \n        events = []\n        for L, R, H in buildings:\n            events.append((L, -H, R))\n            events.append((R, 0, 0))\n        \n        events.sort()\n        \n        heap = [(0, float('inf'))]\n        result = []\n        \n        for x, negH, R in events:\n            while heap and heap[0][1] <= x:\n                heapq.heappop(heap)\n                \n            if negH != 0:\n                heapq.heappush(heap, (negH, R))\n                \n            current_height = -heap[0][0]\n            \n            if not result or result[-1][1] != current_height:\n                result.append([x, current_height])\n        \n        return result\n```"
    },
    {
        "question_id": 226,
        "optimized_code": "```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        if root is None:\n            return root\n            \n        root.left, root.right = root.right, root.left\n\n        if root.left:\n            self.invertTree(root=root.left)\n        if root.right:\n            self.invertTree(root=root.right)\n        \n        return root\n```"
    },
    {
        "question_id": 273,
        "optimized_code": "```python\nclass Solution:\n    def numberToWords(self, num: int) -> str:\n        if num == 0:\n            return \"Zero\"\n\n        less_than_20 = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\",\n                         \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\",\n                         \"Nineteen\"]\n        tens = [\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n        thousands = [\"\", \"Thousand\", \"Million\", \"Billion\"]\n\n        def helper(n):\n            if n < 20:\n                return less_than_20[n]\n            elif n < 100:\n                return tens[n // 10] + (\" \" + less_than_20[n % 10]) if n % 10 != 0 else tens[n//10]\n            else:\n                return less_than_20[n // 100] + \" Hundred \" + helper(n % 100)\n\n        result = []\n        for i in range(4):\n            num_mod = num % 1000\n            if num_mod != 0:\n                result.append(helper(num_mod) + \" \" + thousands[i])\n            num //= 1000\n\n        return \" \".join(result[::-1]).strip()\n```"
    },
    {
        "question_id": 14,
        "optimized_code": "```python\nclass Solution:\n    def longestCommonPrefix(self, strs: List[str]) -> str:\n        if not strs:\n            return \"\"\n\n        prefix = strs[0]\n        for i in range(1, len(strs)):\n            while strs[i].find(prefix) != 0:\n                prefix = prefix[:-1]\n                if not prefix:\n                    return \"\"\n        return prefix\n```"
    },
    {
        "question_id": 258,
        "optimized_code": "```python\nclass Solution:\n    def addDigits(self, num: int) -> int:\n        if num == 0: \n            return 0\n        mod = num % 9 \n        if mod == 0:\n            return 9 \n        else: return mod\n```"
    },
    {
        "question_id": 76,
        "optimized_code": "```python\nfrom collections import Counter\n\nclass Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        if not t or not s:\n            return \"\"\n\n        t_counter = Counter(t)\n        required = len(t_counter)\n        formed = 0\n        window_counter = {}\n        left, right = 0, 0\n        min_length = float('inf')\n        min_window = \"\"\n\n        while right < len(s):\n            character = s[right]\n            window_counter[character] = window_counter.get(character, 0) + 1\n\n            if character in t_counter and window_counter[character] == t_counter[character]:\n                formed += 1\n\n            while left <= right and formed == required:\n                character = s[left]\n\n                if right - left + 1 < min_length:\n                    min_length = right - left + 1\n                    min_window = s[left:right + 1]\n\n                window_counter[character] -= 1\n                if character in t_counter and window_counter[character] < t_counter[character]:\n                    formed -= 1\n\n                left += 1\n            right += 1\n\n        return min_window\n```"
    },
    {
        "question_id": 68,
        "optimized_code": "```python\nclass Solution:\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\n        n = len(words)\n        output, line, width = [], [], 0\n\n        for w in words:\n            if width + len(w) + len(line) > maxWidth:\n                if len(line) > 1:\n                    spaces_needed = maxWidth - width\n                    spaces_per_gap = spaces_needed // (len(line) - 1)\n                    extra_spaces = spaces_needed % (len(line) - 1)\n                    justified_line = \"\"\n                    for i in range(len(line) - 1):\n                        justified_line += line[i] + \" \" * (spaces_per_gap + (1 if i < extra_spaces else 0))\n                    justified_line += line[-1]\n                    output.append(justified_line)\n                else:\n                    output.append(line[0].ljust(maxWidth))\n                line = []\n                width = 0\n\n            line.append(w)\n            width += len(w)\n\n        return output + [' '.join(line).ljust(maxWidth)]\n```"
    },
    {
        "question_id": 332,
        "optimized_code": "```python\nclass Solution:\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\n        self.graph = {}\n        for src, dst in tickets:\n            self.graph.setdefault(src, []).append(dst)\n        \n        for src_dst in self.graph.values():\n            src_dst.sort()\n\n        self.res = []\n        self.dfs(\"JFK\")\n        return self.res[::-1]\n    \n    def dfs(self, src):\n        destinations = self.graph.get(src, [])\n        while destinations:\n            dst = destinations.pop(0)\n            self.dfs(dst)\n        self.res.append(src)\n```"
    },
    {
        "question_id": 689,
        "optimized_code": "```python\nclass Solution:\n    def maxSumOfThreeSubarrays(self, nums: List[int], k: int) -> List[int]:\n        n = len(nums)\n        sums = [0] * (n - k + 1)\n        current_sum = sum(nums[:k])\n        sums[0] = current_sum\n        for i in range(1, n - k + 1):\n            current_sum = current_sum - nums[i - 1] + nums[i + k - 1]\n            sums[i] = current_sum\n\n        left = [0] * (n - k + 1)\n        best = 0\n        for i in range(n - k + 1):\n            if sums[i] > sums[best]:\n                best = i\n            left[i] = best\n\n        right = [n - k] * (n - k + 1)\n        best = n - k\n        for i in range(n - k, -1, -1):\n            if sums[i] >= sums[best]:\n                best = i\n            right[i] = best\n\n        result = []\n        max_sum = 0\n        for mid in range(k, n - 2 * k + 1):\n            l, r = left[mid - k], right[mid + k]\n            cur_sum = sums[l] + sums[r] + sums[mid]\n            if cur_sum > max_sum:\n                max_sum = cur_sum\n                result = [l, mid, r]\n        return result\n```"
    },
    {
        "question_id": 953,
        "optimized_code": "```python\nclass Solution:\n    def reverseOnlyLetters(self, s: str) -> str:\n        left = 0\n        right = len(s) - 1\n        s_list = list(s)\n        while (left < right):\n            if not s_list[left].isalpha():\n                left += 1\n                continue\n            if not s_list[right].isalpha():\n                right -= 1\n                continue\n            s_list[left], s_list[right] = s_list[right], s_list[left]\n            left += 1\n            right -=1\n        \n        return \"\".join(s_list)\n```"
    },
    {
        "question_id": 923,
        "optimized_code": "```python\nfrom functools import cache\n\nclass Solution:\n    @cache\n    def superEggDrop(self, k: int, n: int) -> int:\n        \n        # base condition\n\n        if n==0:\n            return 0\n        if n==1:\n            return 1\n        if k==1:\n            return n\n        ans = float('inf')\n        s, e = 1, n\n        while (s <= e):\n            x = (s+e)//2\n            broken = self.superEggDrop(k-1, x-1)\n            not_broken = self.superEggDrop(k, n-x)\n            if broken > not_broken:\n                ans = min(ans, broken)\n                e = x-1\n            else:\n                ans = min(ans, not_broken)\n                s = x+1\n        \n        return ans +1\n```"
    },
    {
        "question_id": 924,
        "optimized_code": "```python\nclass Solution:\n    def fairCandySwap(self, aliceSizes: List[int], bobSizes: List[int]) -> List[int]:\n        sum_alice = sum(aliceSizes)\n        sum_bob = sum(bobSizes)\n        half = (sum_alice + sum_bob) // 2\n        bob_set = set(bobSizes)\n        for i in aliceSizes:\n            needed_bob = half - (sum_alice - i)\n            if needed_bob in bob_set:\n                return [i, needed_bob]\n```"
    },
    {
        "question_id": 632,
        "optimized_code": "```python\nfrom typing import List\nimport heapq\n\nclass Solution:\n    def smallestRange(self, nums: List[List[int]]) -> List[int]:\n        k = len(nums)\n        pointers = [0] * k\n        heap = []\n        max_val = float('-inf')\n        \n        for i in range(k):\n            heapq.heappush(heap, (nums[i][0], i))\n            max_val = max(max_val, nums[i][0])\n        \n        range_start = float('-inf')\n        range_end = float('inf')\n        \n        while True:\n            min_val, list_index = heapq.heappop(heap)\n            \n            if max_val - min_val < range_end - range_start:\n                range_start, range_end = min_val, max_val\n            \n            pointers[list_index] += 1\n            \n            if pointers[list_index] == len(nums[list_index]):\n                break\n            \n            next_val = nums[list_index][pointers[list_index]]\n            max_val = max(max_val, next_val)\n            heapq.heappush(heap, (next_val, list_index))\n        \n        return [range_start, range_end]\n```"
    },
    {
        "question_id": 637,
        "optimized_code": "```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nfrom collections import deque\nclass Solution:\n    def averageOfLevels(self, root: Optional[TreeNode]) -> List[float]:\n        levelsAverageList = []\n        if root != None:\n            queue = deque()\n            queue.append(root)\n            while queue:\n                size = len(queue)\n                level_sum = 0\n                level_count = 0\n                for start in range(size):\n                    treeNode = queue.popleft()\n                    level_sum += treeNode.val\n                    level_count += 1\n                    if treeNode.left != None:\n                        queue.append(treeNode.left)\n                    if treeNode.right != None:\n                        queue.append(treeNode.right)\n                levelsAverageList.append(float(level_sum/level_count))\n        return levelsAverageList\n```"
    },
    {
        "question_id": 979,
        "optimized_code": "```python\nclass Solution:\n    def diStringMatch(self, s: str) -> List[int]:\n        n = len(s)\n        low = 0\n        high = n\n        result = []\n        for c in s:\n            if c == 'I':\n                result.append(low)\n                low += 1\n            else:\n                result.append(high)\n                high -= 1\n        result.append(low)\n        return result\n```"
    },
    {
        "question_id": 981,
        "optimized_code": "```python\nclass Solution:\n    def minDeletionSize(self, strs: List[str]) -> int:\n        count = 0\n        for col in range(len(strs[0])):\n            for row in range(1, len(strs)):\n                if strs[row][col] < strs[row-1][col]:\n                    count += 1\n                    break\n        return count\n```"
    },
    {
        "question_id": 927,
        "optimized_code": "```python\nclass Solution:\n    def sumSubseqWidths(self, nums: List[int]) -> int:\n        nums = sorted(nums)\n        total = 0\n        n = len(nums)\n        mod = 10**9 + 7\n        power_of_2 = [1] * n\n        for i in range(1, n):\n            power_of_2[i] = (power_of_2[i - 1] * 2) % mod\n\n        for i in range(n):\n            total = (total + (power_of_2[i] - power_of_2[n - i - 1]) * nums[i]) % mod\n\n        return total\n```"
    },
    {
        "question_id": 933,
        "optimized_code": "```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def increasingBST(self, root: TreeNode) -> TreeNode:\n        def increasingBST_helper(root, tail):\n            if not root:\n                return tail\n            \n            res = increasingBST_helper(root.left, root)\n            root.left = None\n            root.right = increasingBST_helper(root.right, tail)\n            return res\n        \n        return increasingBST_helper(root, None)\n```"
    },
    {
        "question_id": 488,
        "optimized_code": "```python\nfrom functools import cache\n\nclass Solution:\n    def compress(self, s):\n        stack = []\n        for c in s:\n            if stack and stack[-1][0] != c and stack[-1][1] >= 3:\n                stack.pop()\n            if not stack or stack[-1][0] != c:\n                stack.append([c, 1])\n            else:\n                stack[-1][1] += 1\n        if stack and stack[-1][1] >= 3:\n            stack.pop()\n        return ''.join(a*b for a, b in stack)\n\n    def findMinStep(self, board: str, hand: str) -> int:\n        n = len(hand)\n        hand = ''.join(sorted(hand))\n\n        @cache\n        def solve(board_tuple, hand_tuple):\n            board = \"\".join(board_tuple)\n            hand = \"\".join(hand_tuple)\n            board = self.compress(board)\n            if board == '': return n - len(hand)\n            if hand == '': return float('inf')\n\n            ans = float('inf')\n            for i in range(len(hand)):\n                if i > 0 and hand[i] == hand[i-1]: continue\n    \n                for j in range(len(board)):\n                    if board[j] == hand[i] or j > 0 and board[j] == board[j-1] and board[j] != hand[i]:\n                        new_board = list(board)\n                        new_board.insert(j, hand[i])\n                        new_hand = list(hand)\n                        del new_hand[i]\n                        ans = min(ans, solve(tuple(new_board), tuple(new_hand)))\n            return ans\n        \n        res = solve(tuple(board), tuple(hand))\n        if res == float('inf'): return -1\n        else: return res\n```"
    },
    {
        "question_id": 493,
        "optimized_code": "```python\nclass BIT:\n\n    def __init__(self, n):\n        self.n = n+1\n        self.lt = [0]*self.n\n\n    def search(self, indx):\n        res = 0\n        while indx>0:\n            res += self.lt[indx]\n            indx -= indx&(-indx)\n        return res\n\n    def update(self, indx, val):\n        while indx<self.n:\n            self.lt[indx] += val\n            indx += indx&(-indx)\n\n\nclass Solution:\n    # https://leetcode.com/problems/reverse-pairs/solutions/97268/general-principles-behind-problems-similar-to-reverse-pairs/\n    def reversePairs(self, nums: List[int]) -> int:\n        res = 0\n        n = len(nums)\n        \n        # Create a sorted set of unique numbers\n        sorted_nums = sorted(list(set(nums)))\n        \n        # Create a mapping from number to its index in sorted_nums\n        num_to_index = {num: i + 1 for i, num in enumerate(sorted_nums)}\n        \n        bit = BIT(len(sorted_nums))\n\n        for x in reversed(nums):\n            res += bit.search(num_to_index[x])\n            \n            # Find the index of 2*x in sorted_nums\n            \n            val = 2 * x\n            l, r = 0, len(sorted_nums)\n            ind = -1\n            while l < r:\n                mid = (l + r) // 2\n                if sorted_nums[mid] > val:\n                    r = mid\n                else:\n                    l = mid + 1\n            \n            index_to_update = l\n            \n            bit.update(num_to_index[x], 1)\n        return res\n```"
    },
    {
        "question_id": 495,
        "optimized_code": "```python\nclass Solution:\n    def findPoisonedDuration(self, timeSeries: List[int], duration: int) -> int:\n        n = len(timeSeries)\n        res = 0\n        if n == 0:\n            return 0\n        \n        for i in range(n - 1):\n            res += min(duration, timeSeries[i + 1] - timeSeries[i])\n        return res + duration\n```"
    },
    {
        "question_id": 496,
        "optimized_code": "```python\nclass Solution:\n    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        next_greater = {}\n        stack = []\n        for num in nums2:\n            while stack and num > stack[-1]:\n                next_greater[stack.pop()] = num\n            stack.append(num)\n        \n        while stack:\n            next_greater[stack.pop()] = -1\n        \n        result = [next_greater[num] for num in nums1]\n        return result\n```"
    },
    {
        "question_id": 830,
        "optimized_code": "```python\nclass Solution:\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\n        def area(p1, p2, p3):\n            return 0.5 * abs(p1[0] * (p2[1] - p3[1]) + p2[0] * (p3[1] - p1[1]) + p3[0] * (p1[1] - p2[1]))\n\n        max_area = 0\n        n = len(points)\n        for i in range(n):\n            for j in range(i + 1, n):\n                for k in range(j + 1, n):\n                    max_area = max(max_area, area(points[i], points[j], points[k]))\n        return max_area\n```"
    },
    {
        "question_id": 861,
        "optimized_code": "```python\nclass Solution:\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\n        for row in image:\n            for i in range((len(row) + 1) // 2):\n                row[i], row[len(row) - 1 - i] = (1 - row[len(row) - 1 - i]), (1 - row[i])\n        return image\n```"
    },
    {
        "question_id": 741,
        "optimized_code": "```python\nclass Solution:\n    def cherryPickup(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        dp = {}\n\n        def solve(r1, c1, r2):\n            c2 = r1 + c1 - r2\n            if n <= r1 or n <= c1 or n <= r2 or n <= c2 or grid[r1][c1] == -1 or grid[r2][c2] == -1:\n                return -float('inf')\n            if (r1, c1, r2) in dp:\n                return dp[(r1, c1, r2)]\n            if r1 == n - 1 and c1 == n - 1:\n                return grid[r1][c1]\n\n            ans = max(solve(r1 + 1, c1, r2 + 1), solve(r1 + 1, c1, r2))\n            ans = max(ans, solve(r1, c1 + 1, r2 + 1), solve(r1, c1 + 1, r2))\n\n            if ans == -float('inf'):\n                dp[(r1, c1, r2)] = -float('inf')\n                return -float('inf')\n\n            ans += grid[r1][c1]\n            if r1 != r2:\n                ans += grid[r2][c2]\n            dp[(r1, c1, r2)] = ans\n            return ans\n\n        result = solve(0, 0, 0)\n        return max(0, result)\n```"
    },
    {
        "question_id": 750,
        "optimized_code": "```python\nclass Solution:\n    def containVirus(self, mat: List[List[int]]) -> int:\n        m, n = len(mat), len(mat[0])\n        DIRECTIONS = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        \n        def find_regions():\n            regions = []\n            visited = set()\n            for i in range(m):\n                for j in range(n):\n                    if mat[i][j] == 1 and (i, j) not in visited:\n                        infected, walls = set(), 0\n                        queue = [(i, j)]\n                        region_cells = {(i,j)}\n                        visited.add((i,j))\n\n                        while queue:\n                            x, y = queue.pop(0)\n                            for dx, dy in DIRECTIONS:\n                                nx, ny = x + dx, y + dy\n                                if 0 <= nx < m and 0 <= ny < n:\n                                    if mat[nx][ny] == 0:\n                                        walls += 1\n                                        infected.add((nx, ny))\n                                    elif mat[nx][ny] == 1 and (nx, ny) not in visited:\n                                        queue.append((nx, ny))\n                                        region_cells.add((nx, ny))\n                                        visited.add((nx, ny))\n                        regions.append((infected, walls, region_cells))\n            return regions\n        \n        def quarantine(region_cells):\n            for i, j in region_cells:\n                mat[i][j] = 2\n\n        def infect(infected_regions):\n            for region in infected_regions:\n                for i, j in region:\n                    if mat[i][j] == 0:\n                        mat[i][j] = 1\n\n        ans = 0\n        while True:\n            regions = find_regions()\n            if not regions:\n                break\n            \n            if len(regions) == 1:\n                ans += regions[0][1]\n                quarantine(regions[0][2])\n                break\n\n            regions.sort(key=lambda x: len(x[0]), reverse=True)\n            \n            ans += regions[0][1]\n            quarantine(regions[0][2])\n            \n            infected_regions = []\n            for k in range(1, len(regions)):\n                infected_regions.append(regions[k][0])\n\n            infect(infected_regions)\n        \n        return ans\n```"
    },
    {
        "question_id": 699,
        "optimized_code": "```python\nclass Node:\n    def __init__(self, l, r):\n        self.l = l\n        self.r = r\n        self.mid = (l + r) // 2\n        self.v = 0\n        self.add = 0\n        self.left = None\n        self.right = None\n\nclass SegmentTree:\n    def __init__(self):\n        self.root = Node(1, int(1e9))\n\n    def modify(self, l, r, v):\n        stack = [(self.root, l, r)]\n        while stack:\n            node, left, right = stack.pop()\n            if left > right:\n                continue\n            if node.l >= left and node.r <= right:\n                node.v = v\n                node.add = v\n                continue\n\n            self.pushdown(node)\n\n            if left <= node.mid:\n                stack.append((node.left, left, min(right, node.mid)))\n            if right > node.mid:\n                stack.append((node.right, max(left, node.mid + 1), right))\n\n            self.pushup(node)\n\n    def query(self, l, r):\n        stack = [(self.root, l, r)]\n        max_val = 0\n        while stack:\n            node, left, right = stack.pop()\n            if left > right:\n                continue\n            if node.l >= left and node.r <= right:\n                max_val = max(max_val, node.v)\n                continue\n            self.pushdown(node)\n            if left <= node.mid:\n                stack.append((node.left, left, min(right, node.mid)))\n            if right > node.mid:\n                stack.append((node.right, max(left, node.mid + 1), right))\n        return max_val\n\n    def pushup(self, node):\n        if node.left and node.right:\n            node.v = max(node.left.v, node.right.v)\n\n    def pushdown(self, node):\n        if node.left is None:\n            node.left = Node(node.l, node.mid)\n        if node.right is None:\n            node.right = Node(node.mid + 1, node.r)\n        if node.add != 0:\n            node.left.add = node.add\n            node.right.add = node.add\n            node.left.v = node.add\n            node.right.v = node.add\n            node.add = 0\n\nclass Solution:\n    def fallingSquares(self, positions):\n        ans = []\n        tree = SegmentTree()\n        mx = 0\n        for pos in positions:\n            l, w = pos\n            r = l + w - 1\n            h = tree.query(l, r) + w\n            mx = max(mx, h)\n            ans.append(mx)\n            tree.modify(l, r, h)\n        return ans\n```"
    },
    {
        "question_id": 779,
        "optimized_code": "```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        ans = 0\n        max_so_far = 0\n        for i, num in enumerate(arr):\n            max_so_far = max(max_so_far, num)\n            if max_so_far == i:\n                ans += 1\n        return ans\n```"
    },
    {
        "question_id": 759,
        "optimized_code": "```python\nclass Solution:\n    def intersectionSizeTwo(self, intervals: List[List[int]]) -> int:\n        intervals.sort(key=lambda x: x[1])\n        res = 0\n        covered = []\n\n        for interval in intervals:\n            start, end = interval\n            count = 0\n            for num in covered:\n                if start <= num <= end:\n                    count += 1\n\n            if count == 2:\n                continue\n            elif count == 1:\n                res += 1\n                covered.append(end)\n            else:\n                res += 2\n                covered.append(end - 1)\n                covered.append(end)\n\n            covered = sorted(list(set(covered)))\n            covered = [num for num in covered if num >= intervals[0][0]]\n\n        return res\n```"
    },
    {
        "question_id": 854,
        "optimized_code": "```python\nclass Solution:\n    def largestIsland(self, grid: List[List[int]]) -> int:\n        \n        directions = {(-1, 0), (1, 0), (0, -1), (0, 1)}\n        n = len(grid)\n        m = len(grid[0])\n        \n        def bfs(row, col, area_id):\n            area = 0\n            stack = [(row, col)]\n            grid[row][col] = area_id\n            \n            while stack:\n                r, c = stack.pop()\n                area += 1\n                \n                for dr, dc in directions:\n                    nr, nc = r + dr, c + dc\n                    if 0 <= nr < n and 0 <= nc < m and grid[nr][nc] == 1:\n                        grid[nr][nc] = area_id\n                        stack.append((nr, nc))\n            return area\n\n        area_sizes = {0: 0}  # area_id: size\n        area_id = 2\n        for r in range(n):\n            for c in range(m):\n                if grid[r][c] == 1:\n                    area_sizes[area_id] = bfs(r, c, area_id)\n                    area_id += 1\n        \n        max_area = max(area_sizes.values())\n\n        for r in range(n):\n            for c in range(m):\n                if grid[r][c] == 0:\n                    neighbor_areas = set()\n                    for dr, dc in directions:\n                        nr, nc = r + dr, c + dc\n                        if 0 <= nr < n and 0 <= nc < m and grid[nr][nc] != 0:\n                            neighbor_areas.add(grid[nr][nc])\n                    \n                    total_area = 1\n                    for area_id in neighbor_areas:\n                        total_area += area_sizes[area_id]\n                    \n                    max_area = max(max_area, total_area)\n        \n        return max_area\n```"
    },
    {
        "question_id": 855,
        "optimized_code": "```python\nimport collections\n\nclass Solution:\n    def uniqueLetterString(self, s: str) -> int:\n        index = collections.defaultdict(list)\n        for i, c in enumerate(s):\n            index[c].append(i)\n\n        ans = 0\n        for arr in index.values():\n            arr = [-1] + arr + [len(s)]\n            for i in range(1, len(arr) - 1):\n                ans += (arr[i] - arr[i - 1]) * (arr[i + 1] - arr[i])\n        return ans\n```"
    },
    {
        "question_id": 856,
        "optimized_code": "```python\nclass Solution:\n    def consecutiveNumbersSum(self, n: int) -> int:\n        w = 0\n        k = 1\n        while k * (k + 1) / 2 <= n:\n            if (n - k * (k - 1) / 2) % k == 0:\n                w += 1\n            k += 1\n\n        return w\n```"
    },
    {
        "question_id": 552,
        "optimized_code": "```python\nclass Solution:\n    def checkRecord(self, n: int) -> int:\n        MOD = 10**9 + 7\n        dp = [[[0] * 3 for _ in range(2)] for _ in range(2)]  # Rolling array: size 2 x 2 x 3\n\n        dp[0][0][0] = 1\n\n        for i in range(1, n + 1):\n            curr_dp = [[[0] * 3 for _ in range(2)] for _ in range(2)]\n            \n            # P\n            for a in range(2):\n                for l in range(3):\n                    curr_dp[i % 2][a][0] = (curr_dp[i % 2][a][0] + dp[(i - 1) % 2][a][l]) % MOD\n            \n            # A\n            for l in range(3):\n                if 0 < 1:  # a < 1 which is 0\n                    curr_dp[i % 2][1][0] = (curr_dp[i % 2][1][0] + dp[(i - 1) % 2][0][l]) % MOD\n            \n            # L\n            for a in range(2):\n                for l in range(2):\n                    curr_dp[i % 2][a][l + 1] = (curr_dp[i % 2][a][l + 1] + dp[(i - 1) % 2][a][l]) % MOD\n            \n            dp = curr_dp  # Update rolling array\n\n        total = 0\n        for a in range(2):\n            for l in range(3):\n                total = (total + dp[n % 2][a][l]) % MOD\n\n        return total\n```"
    },
    {
        "question_id": 939,
        "optimized_code": "```python\nfrom collections import defaultdict\n\nclass Solution:\n    def numPermsDISequence(self, s: str) -> int:\n        n = len(s)\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        dp[0][0] = 1\n        mod = 10**9 + 7\n\n        for i in range(1, n + 1):\n            new_dp = [[0] * (n + 1) for _ in range(n + 1)]\n            prefix_sum = 0\n            if s[i - 1] == 'I':\n                for j in range(1, i + 1):\n                    new_dp[i][j] = (new_dp[i][j-1] + dp[i-1][j-1]) % mod\n                dp = new_dp\n            else:\n                prefix_sum = 0\n                for j in range(i, 0, -1):\n                    new_dp[i][j-1] = (new_dp[i][j] + dp[i-1][j-1]) % mod\n                dp = new_dp\n\n        ans = 0\n        for j in range(n + 1):\n            ans = (ans + dp[n][j]) % mod\n        return ans\n```"
    }
]