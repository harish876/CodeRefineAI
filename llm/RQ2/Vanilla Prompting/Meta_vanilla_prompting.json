[
    {
        "question_id":131,
        "optimized_code":"class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        res = []\n        self.backtrack(s, [], res)\n        return res\n\n    def backtrack(self, s, curr, res):\n        if len(curr) == len(s):\n            res.append(curr[:])\n            return\n        \n        for i in range(len(s)):\n            if s[i] == curr[-1]:\n                self.backtrack(s, curr + [s[i]], res)\n            else:\n                self.backtrack(s, curr, res)"
    },
    {
        "question_id":132,
        "optimized_code":"class Solution:\n    def minCut(self, s: str) -> int:\n        def is_palindrome(s):\n            return s == s[::-1]\n\n        @lru_cache(None)\n        def f(s):\n            if not s or len(s) == 1 or is_palindrome(s):\n                return 0\n\n            min_ = float('inf')\n            for i in range(len(s)):\n                if is_palindrome(s[:i+1]):\n                    min_ = min(min_, 1 + f(s[i+1:]))\n            return min_\n\n        return f(s)"
    },
    {
        "question_id":135,
        "optimized_code":"class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        ratings.sort()\n        candies = 0\n        for i in range(1, len(ratings)):\n            if ratings[i] > ratings[i - 1]:\n                candies += 1\n        return candies"
    },
    {
        "question_id":137,
        "optimized_code":"class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        ln=len(nums)\n        if ln<999999:\n            while(1):\n                val = nums[-1]\n                nums.pop()\n                if val in nums:\n                    nums.insert(0,val)\n                else:\n                    return val\n        else:\n            dicto={}\n            for i in nums:\n                if i in dicto.keys():\n                    dicto[i]+=1\n                else:\n                    dicto[i]=1\n            mini=min(dicto.values())\n            for i in dicto.items():\n                if i[1]==mini:\n                    return i[0]"
    },
    {
        "question_id":138,
        "optimized_code":"\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        if not head:\n            return None\n        \n        old_to_new = {None:None}\n        \n        old = head\n        while old:\n            new = Node(old.val)\n            old_to_new[old] = new\n            old = old.next\n        \n        old = head\n        while old:\n            new = old_to_new[old]\n            new.next = old_to_new[old.next]\n            new.random = old_to_new[old.random]\n            old = old.next\n        \n        return old_to_new[head]"
    },
    {
        "question_id":140,
        "optimized_code":"class Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\n        # Time complexity: O(n\u22c52^n)\n        # Space complexity: O(2^n)\n\n        wordDict = set(wordDict)\n\n        # curr_i is where to continue iteration, stop_i is if > i then eating into next word, don't take\n        output = []\n\n        @lru_cache(None)\n        def dfs(curr_i, stop_i, word_str):\n            if stop_i == 0:\n                output.append(word_str[:-1])\n            elif curr_i < 0 or curr_i < 0:\n                return\n\n            for i in range(curr_i, -1, -1):\n                if s[i: stop_i] in wordDict:\n                    # Use a set instead of a dictionary, we can do look up of the word instead of looping through the word dic each time\n                    dfs(i - 1, i, s[i: stop_i] + \" \" + word_str)\n\n        dfs(len(s)-1, len(s), \"\")\n        return output"
    },
    {
        "question_id":134,
        "optimized_code":"class Solution:\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\n        n = len(gas)\n        total_gas = 0\n        curr_gas = 0\n        start_index = 0\n\n        for i in range(n):\n            total_gas += gas[i] - cost[i]\n            curr_gas += gas[i] - cost[i]\n            if curr_gas < 0:\n                curr_gas = 0\n                start_index = i + 1\n        return start_index if total_gas >= 0 else -1"
    },
    {
        "question_id":228,
        "optimized_code":"class Solution:\n    def summaryRanges(self, nums: List[int]) -> List[str]:\n        if not nums:\n            return []\n        result = []\n        start = nums[0]\n        for i in range(1, len(nums)):\n            if nums[i]!= start + 1:\n                if start!= -1:\n                    result.append(str(start) + \"->\" + str(nums[i]))\n                start = nums[i]\n            else:\n                if start == -1:\n                    result.append(str(start))\n                start = nums[i]\n        if start == -1:\n            result.append(str(start))\n        return result"
    },
    {
        "question_id":229,
        "optimized_code":"class Solution:\n    def majorityElement(self, nums: List[int]) -> List[int]:\n        n1, n2 = nums[0], nums[0]\n        for i in range(1, len(nums)):\n            if nums[i] == n1:\n                n1 = nums[i]\n                n2 = nums[i]\n                c1 += 1\n                c2 += 1\n            elif nums[i] == n2:\n                n2 = nums[i]\n                c2 += 1\n            else:\n                c1 -= 1\n                c2 -= 1\n        return [n1, n2]"
    },
    {
        "question_id":230,
        "optimized_code":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:\n        if not root:\n            return -1\n        stack = [(root, 0)]\n        while stack:\n            node, level = stack.pop()\n            if node.left:\n                stack.append((node.left, level+1))\n            if node.right:\n                stack.append((node.right, level+1))\n            if level == k:\n                return node.val\n        return -1"
    },
    {
        "question_id":231,
        "optimized_code":"class Solution:\n    def isPowerOfTwo(self, n: int) -> bool:\n        return n > 0 and 2 ** n == n"
    },
    {
        "question_id":233,
        "optimized_code":"class Solution:\n    def countDigitOne(self, n: int) -> int:\n        ans = 0\n        while n > 0:\n            ans += n * (10 ** i) + 10 ** (i - 1)\n            n \/\/= 10\n            i += 1\n        return ans"
    },
    {
        "question_id":123,
        "optimized_code":"class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        # Tabulation\n\n        n = len(prices)\n        dp = [[[0 for _ in range(3)] for _ in range(2)] for _ in range(n + 1)]\n\n        # Base cases are already covered as the dp is initialized to 0\n      \n        for i in range(n - 1, -1, -1):\n            for j in range(2):\n                for k in range(1, 3):\n                    if j == 0:\n                        dp[i][j][k] = max(-prices[i] + dp[i + 1][1][k], 0 + dp[i + 1][0][k])\n                    else:\n                        dp[i][j][k] = max(+prices[i] + dp[i + 1][0][k - 1], 0 + dp[i + 1][1][k])\n\n        return dp[0][0][2]"
    },
    {
        "question_id":125,
        "optimized_code":"class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        return s == s[::-1]"
    },
    {
        "question_id":128,
        "optimized_code":"class Solution:\n    def longestConsecutive(self, nums: List[int]) -> int:\n        numset = set(nums)\n        res = 0\n        for n in nums:\n            if (n-1) not in numset:\n                op = 0\n                while (n+op) in numset:\n                    op+=1\n                res = max(res,op)\n        return res"
    },
    {
        "question_id":130,
        "optimized_code":"class Solution:\n    def solve(self, board: List[List[str]]) -> None:\n        \"\"\"\n        Do not return anything, modify board in-place instead.\n        \"\"\"\n        M, N = len(board), len(board[0])\n        total_visited = set()\n        def dfs(i,j):\n            nonlocal M,N,board,total_visited\n            curr_visited = set()\n            q = [(i,j)]\n            edged = False\n            while q:\n                curr = q.pop()\n                curr_visited.add(curr)\n                for di in [(-1,0), (1,0), (0,1), (0,-1)]:\n                    new_i, new_j = curr[0]+di[0], curr[1]+di[1]\n                    if new_i >= 0 and new_i < M and new_j >= 0 and new_j < N:\n                        if board[new_i][new_j] == 'O' and (new_i, new_j) not in curr_visited:\n                            q.append((new_i, new_j))\n                    else:\n                        edged = True\n            total_visited.update(curr_visited)\n            if edged:\n                return\n            for i,j in curr_visited:\n                board[i][j] = 'X'\n                \n\n        for i in range(M):\n            for j in range(N):\n                if board[i][j] == 'O' and (i,j) not in total_visited:\n                    dfs(i,j)"
    },
    {
        "question_id":82,
        "optimized_code":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        dummy = ListNode(-1)\n        dummy.next = head\n        curr, prev = dummy, head\n        while curr and curr.next:\n            if curr.next.val == curr.val:\n                prev.next = curr.next\n                curr = curr.next\n            else:\n                prev = curr\n                curr = curr.next\n        return dummy.next"
    },
    {
        "question_id":84,
        "optimized_code":"class Solution:\n    def largestRectangleArea(self, heights: List[int]) -> int:\n        # OK\n        stack = []\n        max_area = 0\n        heights = [-1] + heights + [-1]\n        for i, h in enumerate(heights):\n            while stack and heights[stack[-1]] > h:\n                rr = i\n                k = stack.pop()\n                ll = stack[-1]\n                h = heights[k]\n                length = i - ll - 1\n                area = max(area, h * length)\n            stack.append(i)\n\n        return max_area"
    },
    {
        "question_id":85,
        "optimized_code":"class Solution:\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\n        m, n = len(matrix), len(matrix[0])\n        dp = [[0 for _ in range(n+1)] for _ in range(m+1)]\n        for i in range(1, m+1):\n            for j in range(1, n+1):\n                if matrix[i-1][j-1] == '1':\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1] + 1) * (j+1)\n        return max(max(dp[i][j] for i in range(1, m+1) for j in range(1, n+1)) for i in range(1, m+1))"
    },
    {
        "question_id":87,
        "optimized_code":"class Solution:\n    def isScramble(self, s1: str, s2: str) -> bool:\n        def isScramble1(s1, s2):\n            return True if s1==s2 else False\n\n        def isScramble2(s1, s2):\n            if len(s1)!=len(s2):\n                return False\n            for i in range(len(s1)):\n                if isScramble1(s1[:i], s2[:i])!= isScramble1(s1[i:], s2[i:]):\n                    return False\n            return True\n\n        return isScramble2(s1, s2)"
    },
    {
        "question_id":88,
        "optimized_code":"class Solution:\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\n        \"\"\"\n        Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        p1 = m-1\n        p2 = n-1\n        p = m+n-1\n        while p2 >= 0:\n            if p1 >= 0 and nums1[p1] > nums2[p2]:\n                nums1[p] = nums1[p1]\n                p1 -= 1\n            else:\n                nums1[p] = nums2[p2]\n                p2 -= 1\n            p -= 1"
    },
    {
        "question_id":89,
        "optimized_code":"class Solution:\n    def grayCode(self, n: int) -> List[int]:\n        return [0, 1] + list(self.grayCode(n-1))"
    },
    {
        "question_id":90,
        "optimized_code":"class Solution:\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\n        ans=[]\n        ds=[]\n        nums.sort()\n        def findSubsets(ind:int):\n            ans.append(ds[:])\n            for i in range(ind,len(nums)):\n                if i!= ind and nums[i] == nums[i-1]:\n                    continue\n                ds.append(nums[i])\n                findSubsets(i+1)\n                ds.pop()\n        findSubsets(0)\n        return ans"
    },
    {
        "question_id":144,
        "optimized_code":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\ndef solve(root, ans):\n    if root is None:\n        return\n    ans.append(root.val)\n    solve(root.left,ans)\n    solve(root.right,ans)\n\nclass Solution:\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        ans = []\n        solve(root,ans)\n        return ans\n\n#### Input Code:\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        ans = []\n        return ans"
    },
    {
        "question_id":148,
        "optimized_code":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        def merge(head1, head2):\n            resultHead = ListNode(0)\n            cur = resultHead\n            while head1!= None or head2!= None:\n                if head1 == None:\n                    cur.next = head2\n                    head2 = None\n                elif head2 == None:\n                    cur.next = head1\n                    head1 = None\n                else:\n                    if head1.val < head2.val:\n                        cur.next = head1\n                        cur = head1\n                        head1 = head1.next \n                    else:\n                        cur.next = head2\n                        cur = head2\n                        head2 = head2.next\n            \n            return resultHead.next\n\n\n        def findOneBeforeMiddle(head):\n            fast = head\n            slow = head\n            prev = None\n            while fast and fast.next:\n                prev = slow\n\n                fast = fast.next.next\n                slow = slow.next\n                \n            return prev\n        \n        if not head or not head.next:\n            return head\n\n        prev = findOneBeforeMiddle(head)\n        if prev!= None:\n            middle = prev.next\n            prev.next = None\n\n        return merge(self.sortList(head), self.sortList(middle))"
    },
    {
        "question_id":149,
        "optimized_code":"class Solution:\n\n    def num(self, points, p1, p2):\n        v = [p2[0]-p1[0], p2[1]-p1[1]]\n        n = [v[1], -v[0]]\n        C = p2[0]*p1[1]-p1[0]*p2[1]\n        count = 0\n        for p in points:\n            sum_v = n[0]*p[0] + n[1]*p[1] + C\n\n            if sum_v == 0:\n                count += 1\n        return count\n\n    def maxPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        if n == 1:\n            return 1\n        max_num = 0\n        d = {}\n        for i in range(n):\n            for j in range(i+1,n):\n                if (i,j) in d or (j,i) in d:\n                    continue\n                max_num = max(max_num, self.num(points, points[i], points[j]))\n                d[(i,j)] = max_num\n        return max_num"
    },
    {
        "question_id":150,
        "optimized_code":"class Solution:\n    def evalRPN(self, tokens):\n        operators = ['+', '-', '*', '\/']\n        stack = []\n        for i in tokens:\n            if i not in operators:\n                stack.append(i)\n            else:\n                operation = stack.pop(-2) + i + stack.pop()\n                stack.append(str(int(eval(operation))))\n        return int(stack[0])"
    },
    {
        "question_id":153,
        "optimized_code":"class Solution:\n    def findMin(self, arr: List[int]) -> int:\n        n = len(arr)\n        l = 0\n        h = n - 1\n        ans = float('inf')\n\n        while l <= h:\n            m = (l + h) \/\/ 2\n\n            if arr[l] <= arr[h]:\n                ans = min(arr[l], ans)\n                break\n\n            if arr[l] <= arr[m]:\n                ans = min (ans, arr[l])\n                l = m + 1\n            else:\n                ans = min(ans, arr[m])\n                h = m - 1\n        return ans"
    },
    {
        "question_id":160,
        "optimized_code":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        if not headA or not headB:\n            return None\n        pA=headA\n        pB=headB\n        while pA!=pB:\n            pA=pA.next if pA else headB\n            pB=pB.next if pB else headA\n        return pA"
    },
    {
        "question_id":238,
        "optimized_code":"class Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        res = [1] * len(nums)\n        prefix = 1\n        postfix = 1\n        for i in range(len(nums)):\n            res[i] = prefix\n            prefix *= nums[i]\n            postfix *= nums[i]\n        return res"
    },
    {
        "question_id":239,
        "optimized_code":"from collections import deque\nimport heapq\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        q = deque()\n        heapq.heapify(q)\n        ans = []\n        for j, i in enumerate(nums):\n            if len(q) < k:\n                q.append(i)\n                if i > -1:\n                    heapq.heappop(q)\n                else:\n                    heapq.heappush(q, (-i, j))\n            else:\n                ans.append(-1)\n                pop = q.popleft()\n                if pop == -1:\n                    pop, index = heapq.heappop(q)\n                    -1\n                    while q:\n                        if q[0][1] < index:\n                            heapq.heappop(q)\n                        else:\n                            break\n                q.append(i)\n                if i > -1:\n                    heapq.heappush(q, (-1*i, j))\n        ans.append(-1)\n        return ans"
    },
    {
        "question_id":241,
        "optimized_code":"class Solution:\n    def diffWaysToCompute(self, expression: str) -> List[int]:\n        if not expression:\n            return []\n        elif expression.isdigit():\n            return [int(expression)]\n        else:\n            res = []\n            for i, s in enumerate(expression):\n                if s in \"+-*\":\n                    l = self.diffWaysToCompute(expression[:i])\n                    r = self.diffWaysToCompute(expression[i+1:])\n                    for ls in l:\n                        for rs in r:\n                            res.append(eval(str(ls) + s + str(rs)))\n            return res"
    },
    {
        "question_id":242,
        "optimized_code":"class Solution:\n    def isAnagram(self, s: str, t: str) -> bool:\n        return self.countOfChar(s) == self.countOfChar(t)\n    \n    def countOfChar(self, str):\n        counter = {}\n        for char in str:\n            if char not in counter:\n                counter[char] = 1\n            else:\n                counter[char] += 1\n        return counter\n\n#### Explanation:\n# We create a dictionary of counters that stores the frequency of each character in string's' and another dictionary of counters that stores the frequency of each character in string 't'.\n# Then we compare the two counters and return True if they are equal.\n# We use a counter that maps characters to their frequency in's' and a counter that maps characters to their frequency in 't' to compare the two counters. \n# If the counters are equal, then the two strings are anagrams of each other."
    },
    {
        "question_id":31,
        "optimized_code":"class Solution:\n    def reverse(self, nums, i, j):\n        while i < j:\n            self.swap(nums, i, j)\n            i += 1\n            j -= 1\n\n    def nextPermutation(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        i = len(nums) - 2\n        while i >= 0 and nums[i] >= nums[i + 1]:\n            i -= 1\n        if i >= 0:\n            j = len(nums) - 1\n            while nums[j] <= nums[i]:\n                j -= 1\n            self.swap(nums, i, j)\n        self.reverse(nums, i+1, len(nums) - 1)\n\n        return nums"
    },
    {
        "question_id":32,
        "optimized_code":"class Solution:\n    def longestValidParentheses(self, s: str) -> int:\n        memo = {}\n        def dfs(i):\n            if i >= len(s):\n                return 0\n            if i in memo:\n                return memo[i]\n            memo[i] = 0\n            if s[i] == '(':\n                if i + 1 < len(s) and s[i + 1] == ')':\n                    memo[i] = dfs(i + 2) + 2\n                elif i + dfs(i + 1) + 1 < len(s) and s[i + dfs(i + 1) + 1] == ')':\n                    memo[i] = dfs(i + 1) + 2 + dfs(i + dfs(i + 1) + 2)\n            return memo[i]\n\n        for i in range(len(s)):\n            dfs(i)\n        return max(memo.values()) if memo else 0"
    },
    {
        "question_id":33,
        "optimized_code":"class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        l = 0\n        r = len(nums) - 1\n        while l <= r:\n            mid = (l + r) \/\/ 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                if nums[mid] <= nums[l] and nums[mid] <= nums[r]:\n                    l = mid + 1\n                else:\n                    r = mid - 1\n            elif nums[mid] > target:\n                if nums[mid] >= nums[l] and nums[mid] >= nums[r]:\n                    r = mid - 1\n                else:\n                    l = mid + 1\n        return -1"
    },
    {
        "question_id":34,
        "optimized_code":"class Solution:\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\n        return self.searchRange(nums, 0, len(nums) - 1, target)\n    \n    def searchRange(self, nums, l, r, target):\n        if l > r:\n            return [-1, -1]\n        m = bisect_left(nums, target)\n        if m == len(nums) or nums[m]!= target:\n            return [-1, -1]\n        m += 1\n        if m < len(nums) and nums[m] == target:\n            return [m, m]\n        return [m - 1, m]"
    },
    {
        "question_id":191,
        "optimized_code":"class Solution:\n    def hammingWeight(self, n: int) -> int:\n        return bin(n)[2:].count('1')"
    },
    {
        "question_id":198,
        "optimized_code":"class Solution:\n    def rob(self, nums: List[int]) -> int:\n        \n        if (len(nums) == 0):\n            return 0\n        elif (len(nums) == 1):\n            return nums[0]\n        elif (len(nums) == 2):\n            return max(nums)\n        \n        dp = [0]* len(nums)\n        dp[0] = nums[0]\n        dp[1] = max(nums[0:2])\n        \n        \n        for i in range(2, len(nums)):\n            dp[i] = max(dp[i-1], dp[i-2]+nums[i])\n        \n        return dp[-1]"
    },
    {
        "question_id":199,
        "optimized_code":"class Solution:\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\n        def dfs(root, level):\n            if not root:\n                return\n            if len(res) == level:\n                res.append(root.val)\n            dfs(root.right, level + 1)\n            dfs(root.left, level + 1)\n        res = []\n        dfs(root, 0)\n        return res"
    },
    {
        "question_id":201,
        "optimized_code":"class Solution:\n    def rangeBitwiseAnd(self, left: int, right: int) -> int:\n        return bin(left)[2:].zfill(right.bit_length()) & bin(right)[2:].zfill(left.bit_length())"
    },
    {
        "question_id":202,
        "optimized_code":"class Solution:\n    def isHappy(self, n: int) -> bool:\n        def get_next(number: int) -> int:\n            total_sum = 0\n            while number > 0:\n                digit = number % 10\n                total_sum += digit * digit\n                number \/\/= 10\n            return total_sum\n        \n        seen = set()\n        while n!= 1 and n not in seen:\n            seen.add(n)\n            n = get_next(n)\n        \n        return n == 1"
    },
    {
        "question_id":204,
        "optimized_code":"class Solution:\n    def countPrimes(self, n: int) -> int:\n        if n==0 or n==1:\n            return 0\n        return sum(1 for i in range(2, n) if all(i%j!=0 for j in range(2, int(i**0.5)+1)))"
    },
    {
        "question_id":205,
        "optimized_code":"class Solution:\n    def isIsomorphic(self, s: str, t: str) -> bool:\n        return sorted(set(s)) == set(t)"
    },
    {
        "question_id":210,
        "optimized_code":"class Solution:\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\n        world = [Node(n) for n in range(numCourses)]\n        for (a, b) in prerequisites:\n            world[a].prereqs.add(world[b])\n        res = []\n        taken = set()\n        for n in world:\n            if n.n in taken:\n                continue\n            ne = n.how_to_take_this(taken, visited=set())\n            if ne is False:\n                return []\n            taken |= set(ne)\n            res.append(ne)\n        return [ele for node in res for ele in node]"
    },
    {
        "question_id":214,
        "optimized_code":"class Solution:\n    def shortestPalindrome(self, s: str) -> str:\n        n = len(s)\n        res = 0\n        for i in range(1, n+1):\n            if s[:i] == s[i-1::-1]:\n                res = i\n        return s[:res-1:-1] +s"
    },
    {
        "question_id":216,
        "optimized_code":"class Solution:\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\n        if 45-(9-k)*(10-k)\/2 < n or k*(k+1)\/2 > n:\n            return []\n\n        def backtrack(comb, s, n):\n            if n == 0 and len(comb) == k:\n                output.append(comb)\n                return\n            for i in range(s, min(n+1, 10)):\n                if n-i <0:\n                    break\n                backtrack(comb + [i], i+1, n-i)\n        \n        output = []\n        backtrack([], 1, n)\n        return output"
    },
    {
        "question_id":91,
        "optimized_code":"class Solution:\n    def numDecodings(self, s: str) -> int:\n        if s == \"\":\n            return 0\n        \n        @lru_cache(None)\n        def helper(idx):\n            if idx == len(s):\n                return 1\n            \n            if s[idx] == '0':\n                return 0\n            \n            single_digit = helper(idx + 1)\n            two_digit = 0\n            if (idx + 1 < len(s) and (s[idx] == '1' or (s[idx] == '2' and s[idx + 1] <= '6'))):\n                two_digit = helper(idx + 2)\n                \n            return single_digit + two_digit\n        return helper(0)"
    },
    {
        "question_id":93,
        "optimized_code":"class Solution:\r\n    def restoreIpAddresses(self, s: str) -> List[str]:\r\n        result = []\r\n        def backtracking(start_idx, point_count):\r\n            if point_count == 4 and start_idx >= len(s):\r\n                result.append(\".\".join(path))\r\n                return \r\n\r\n            for i in range(start_idx, len(s)):\r\n                temp = s[start_idx:i + 1]\r\n                if temp.count('.') == 1 and int(temp) <= 255:\r\n                    path.append(temp)\r\n                    backtracking(i + 1, point_count + 1)\r\n                    path.pop()\r\n        \r\n        backtracking(0, 0)\r\n        return result"
    },
    {
        "question_id":127,
        "optimized_code":"class Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\n        wordList = set(wordList)\n\n        if endWord not in wordList:\n            return 0\n        \n        def offByOne(s, t):\n            if s == t:\n                return False\n            diff = 0\n            for i in range(len(s)):\n                if s[i]!= t[i]:\n                    diff += 1\n                if diff > 1:\n                    return False\n            return True\n\n        queue = deque([(beginWord, 1)])\n        seen = set()\n        while queue:\n            word, length = queue.popleft()\n            if word in seen:\n                continue\n            elif offByOne(word, endWord):\n                return length + 1\n\n            seen.add(word)\n            for nextWord in wordList:\n                if offByOne(word, nextWord):\n                    queue.append((nextWord, length + 1))\n        return 0"
    },
    {
        "question_id":81,
        "optimized_code":"class Solution:\n    def search(self, nums: List[int], target: int) -> bool:\n        left = 0\n        right = len(nums) - 1\n        while left <= right:\n            middle = (left + right) \/\/ 2\n            if nums[middle] == target:\n                return True\n            if (nums[left] == nums[middle] and nums[middle] == nums[right]):\n                left += 1\n                right -= 1\n            elif nums[left] <= nums[middle]:\n                if nums[left] <= target and target < nums[middle]:\n                    right = middle - 1\n                else:\n                    left = middle + 1 \n            else:\n                if target > nums[middle] and target <= nums[right]:\n                    left = middle + 1\n                else:\n                    right = middle - 1\n        return False"
    },
    {
        "question_id":151,
        "optimized_code":"class Solution:\n    def reverseWords(self, s: str) -> str:\n        return \" \".join(reversed(s.split()))\n        \n\n#### Explanation:\nclass Solution:\n    def reverseWords(self, s: str) -> str:\n        return \" \".join(reversed(s.split()))"
    },
    {
        "question_id":152,
        "optimized_code":"class Solution:\n    def maxProduct(self, nums: List[int]) -> int:\n        n = len(nums)\n        prefix, suffix = 1, 1\n        for i in range(n):\n            prefix *= nums[i]\n            suffix *= nums[n - i - 1]\n            if prefix >= suffix: continue\n            prefix = suffix = prefix \/\/ nums[i]\n        return max(prefix, suffix)"
    },
    {
        "question_id":95,
        "optimized_code":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def generateTrees(self, n: int) -> List[TreeNode]:\n        def dfs(l, r):\n            if r < l: return [None]\n            arr = []\n            for m in range(l, r + 1):\n                left = dfs(l, m - 1)\n                right = dfs(m + 1, r)\n                for lNode in left:\n                    for rNode in right:\n                        new = TreeNode(m)\n                        new.left = lNode\n                        new.right = rNode\n                        arr.append(new)\n            return arr\n        res = dfs(1, n)\n        return [] if res == [None] else res"
    },
    {
        "question_id":96,
        "optimized_code":"class Solution:\n    def numTrees(self, n: int) -> int:\n        return self.dp(n)"
    },
    {
        "question_id":97,
        "optimized_code":"class Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n\n        # dp[i][j] represents whether the first i characters in s1\n        # and the first j characters in s2\n        # can form the first i + j characters of s3\n\n        if len(s1) + len(s2)!= len(s3):\n            return False\n\n        dp = [[False] * (len(s2) + 1) for _ in range((len(s1) + 1))]\n\n        # true for empty string\n        dp[0][0] = True\n\n        for i in range(len(s1) + 1):\n            for j in range(len(s2) + 1):\n                if i == 0 and j == 0:\n                    continue\n                # initialise base cases i and j\n                elif i == 0:\n                    dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\n                elif j == 0:\n                    dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\n                # interleave using either s1 OR s2\n                else:\n                    dp[i][j] = (dp[i][j - 1] and s2[j - 1] == s3[j + i - 1]) or \\\n                               (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1])\n\n        return dp[len(s1)][len(s2)]"
    },
    {
        "question_id":1,
        "optimized_code":"class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        nums.sort()\n        for i in range(len(nums) - 1):\n            complement = target - nums[i]\n            if complement in nums[i + 1:]:\n                return [i, nums[i + 1:].index(complement) + i]\n        return None"
    },
    {
        "question_id":5,
        "optimized_code":"class Solution:\n    def longestPalindrome(self, s: str) -> str:\n        longest = s[0]\n        palin = set()\n        for i in range(len(s)):\n            for j in range(i + 1, len(s)):\n                if j - i < len(longest):\n                    continue\n                _s = s[i : j + 1]\n                if _s in palin:\n                    continue\n                elif self.check(_s, palin):\n                    palin.add(_s)\n                    if len(_s) > len(longest):\n                        longest = _s\n        return longest\n\n    def check(self, s, palin):\n        n = len(s)\n        i = 0\n        j = n - 1\n        while i < j:\n            if s in palin:\n                return True\n            if s[i]!= s[j]:\n                return False\n            else:\n                i += 1\n                j -= 1\n        return True\n\n\n#### Output Code:\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        longest = s[0]\n        palin = set()\n        for i in range(len(s)):\n            for j in range(i + 1, len(s)):\n                if j - i < len(longest):\n                    continue\n                _s = s[i : j + 1]\n                if _s in palin:\n                    continue\n                elif self.check(_s, palin):\n                    palin.add(_s)\n                    if len(_s) > len(longest):\n                        longest = _s\n        return longest\n\n    def check(self, s, palin):\n        n = len(s)\n        i = 0\n        j = n - 1\n        while i < j:\n            if s in palin:\n                return True\n            if s[i]!= s[j]:\n                return False\n            else:\n                i += 1\n                j -= 1\n        return True\n\n\n#### Input Code:\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        longest = s[0]\n        palin = set()\n        for i in range(len(s)):\n            for j in range(i + 1, len(s)):\n                if j - i < len(longest):\n                    continue\n                _s = s[i : j + 1]\n                if _s in palin:\n                    continue"
    },
    {
        "question_id":6,
        "optimized_code":"class Solution:\n    def convert(self, s: str, numRows: int) -> str:\n        strings = []\n        currString = \"\"\n        if(numRows <= 1):\n            return s\n        idx = 0\n        while (idx < len(s)):\n            for i in range(0, numRows):\n                if(idx + i >= len(s)):\n                    currString += \"_\"\n                else:\n                    currString += s[idx + i]\n            idx += i\n            strings.append(currString)\n            currString = \"\"\n            for i in range (numRows - 2, 0, -1):\n                idx += 1\n                if(idx >= len(s)):\n                    break\n                for j in range(0, i):\n                    currString += \"_\"\n                currString += s[idx]\n                for j in range(i+1, numRows):\n                    currString += \"_\"\n                strings.append(currString)\n                currString = \"\"\n            idx += 1\n        outputString = \"\"\n        for idx in range(0, numRows):\n            for line in strings:\n                if(line[idx]!= \"_\"):\n                    outputString+= line[idx]\n        return outputString"
    },
    {
        "question_id":8,
        "optimized_code":"class Solution:\n    def myAtoi(self, s: str) -> int:\n        negative = False\n        start_digit = False\n        string_number = \"\"\n        INT_MAX = 2**31 - 1\n        INT_MIN = -2**31\n        \n        for char in s:\n            if char == \" \" and not start_digit:\n                continue\n            \n            if char == \"-\" and not start_digit:\n                negative = True\n                start_digit = True\n                continue\n            elif char == \"+\" and not start_digit:\n                start_digit = True\n                continue\n            \n            if char.isdigit():\n                string_number += char\n                start_digit = True\n                continue\n            \n            # If a non-digit character is encountered after starting to read digits\n            if start_digit:\n                break\n            \n            # If the character is invalid at the start (non-digit and not a sign)\n            if not char.isdigit() and not start_digit:\n                return 0\n        \n        if not string_number:\n            return 0\n        \n        result = int(string_number)\n        \n        # Clamp the result to the 32-bit integer range\n        if result < INT_MIN:\n            return INT_MIN\n        if result > INT_MAX:\n            return INT_MAX\n        return result"
    },
    {
        "question_id":309,
        "optimized_code":"class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        L = len(prices)\n        # padding the array with additional zero to simply the logic\n        MP = [0] * (L + 2)\n\n        for i in range(L-1, -1, -1):\n            C1 = 0\n            # Case 1). buy and sell the stock\n            for sell in range(i + 1, L):\n                profit = (prices[sell] - prices[i]) + MP[sell + 2]\n                C1 = max(profit, C1)\n\n            # Case 2). do no transaction with the stock p[i]\n            C2 = MP[i + 1]\n\n            # sum up two cases\n            MP[i] = max(C1, C2)\n\n        return MP[0]"
    },
    {
        "question_id":312,
        "optimized_code":"class Solution:\n    def maxCoins(self, nums: List[int]) -> int:\n        nums = [1]+nums+[1]\n        memo = {}\n        def dfs(leftbound, rightbound):\n            if (leftbound, rightbound) in memo:\n                return memo[(leftbound, rightbound)]\n            if rightbound - leftbound <= 1:\n                return 0\n            res = 0\n            for i in range(leftbound, rightbound + 1):\n                gain = nums[leftbound] * nums[i] * nums[rightbound]\n                total_gain = dfs(leftbound, i) + gain + dfs(i, rightbound)\n                res = max(res, total_gain)\n            memo[(leftbound, rightbound)] = res\n            return res\n        return dfs(0, len(nums) - 1)"
    },
    {
        "question_id":299,
        "optimized_code":"class Solution:\n    def getHint(self, secret: str, guess: str) -> str:\n        bulls = 0\n        cows = 0\n        guessDict = {}\n        secretDict = {}\n        for i in range(len(secret)):\n            if secret[i] == guess[i]:\n                bulls += 1\n            else:\n                if secret[i] in guessDict and guessDict[secret[i]] > 0:\n                    cows += 1\n                    guessDict[secret[i]] -= 1\n                else:\n                    secretDict[secret[i]] = secretDict.get(secret[i], 0) + 1\n                if guess[i] in secretDict and secretDict[guess[i]] > 0:\n                    cows += 1\n                    secretDict[guess[i]] -= 1\n                else:\n                    guessDict[guess[i]] = guessDict.get(guess[i], 0) + 1\n        return f'{bulls}A{cows}B'"
    },
    {
        "question_id":300,
        "optimized_code":"class Solution:\n    def lengthOfLIS(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n == 0:\n            return 0\n        dp = [0] * n\n        dp[0] = nums[0]\n        for i in range(1, n):\n            if nums[i] > dp[i - 1]:\n                dp[i] = nums[i]\n            else:\n                dp[i] = max(dp[i - 1], dp[i])\n        return max(dp)"
    },
    {
        "question_id":301,
        "optimized_code":"class Solution:\n    def removeInvalidParentheses(self, s: str) -> List[str]:\n        def dfs(i, c, o):\n            if o < 0:\n                return set()\n            if i == len(s):\n                if o == 0:\n                    return {c}\n                else:\n                    return set()\n\n            combos = set()\n            if s[i] == \"(\":\n                combos |= dfs(i + 1, c + \"(\", o + 1)\n                combos |= dfs(i + 1, c, o)\n            elif s[i] == \")\":\n                combos |= dfs(i + 1, c + \")\", o - 1)\n                combos |= dfs(i + 1, c, o)\n            else:\n                combos |= dfs(i + 1, c + s[i], o)\n\n            maxlen = 0\n            for c in combos:\n                maxlen = max(maxlen, len(c))\n            for c in list(combos):\n                if len(c) < maxlen:\n                    combos.remove(c)\n\n            return combos\n\n        return list(dfs(0, \"\", 0))"
    },
    {
        "question_id":162,
        "optimized_code":"class Solution:\n    def findPeakElement(self, nums: List[int]) -> int:\n        left = 0\n        right = len(nums) - 1\n\n        while left < right:\n            mid = left + (right - left) \/\/ 2\n            if nums[mid] > nums[mid + 1]:\n                right = mid\n            else:\n                left = mid + 1\n\n        return left"
    },
    {
        "question_id":164,
        "optimized_code":"class Solution:\n    def maximumGap(self, nums: List[int]) -> int:\n        if len(nums) < 2:\n            return 0\n        if len(nums) == 2:\n            return abs(nums[0] - nums[1])\n        nmax, nmin = max(nums), min(nums)\n        if nmax == nmin:\n            return 0\n        num_buckets = len(nums) - 1\n        bucket_size = (nmax - nmin) \/ num_buckets\n        buckets = [[float('inf'), -1] for _ in range(num_buckets)]\n        for num in nums:\n            bucket_num = min(int((num - nmin) \/\/ bucket_size), num_buckets - 1)\n            buckets[bucket_num][0] = min(buckets[bucket_num][0], num)\n            buckets[bucket_num][1] = max(buckets[bucket_num][1], num)\n        prev_bucket = buckets[0]\n        ret = -1\n        for i in range(1, len(buckets)):\n            cur_bucket = buckets[i]\n            if cur_bucket[1]!= -1:\n                ret = max(ret, cur_bucket[0] - prev_bucket[1])\n                prev_bucket = cur_bucket\n        return ret\n\n#### Code Explanation:\n# To get the maximum gap between 2 elements, we will use the following formula:\n# max_gap = max(max(abs(x1 - x2), abs(x3 - x4),..., abs(x1 - xn)))\n# where x1, x2, x3,..., xn are the elements in the array.\n# We will use the max() function to find the maximum value from the array and then find the difference between the max value and the current element, and compare the result with the current element. We will repeat this process until we reach the end of the array. We will use a list to store the values, and the list will be filled with the results of the comparison.\n# We will use the -1 to represent the maximum value in the list, and the -1 to represent the minimum value in the list.\n# The -1 to represent the minimum value in the list is useful because it allows us to skip the minimum value in the list and move on to the next one. This will save time and make the code more efficient.\n# We will use a nested for loop to iterate through the elements of the array and compare"
    },
    {
        "question_id":166,
        "optimized_code":"class Solution:\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\n        if numerator == 0 or denominator == 0:\n            return \"0\"\n        if numerator * denominator < 0:\n            numerator, denominator = abs(numerator), abs(denominator)\n            string = \"\"\n            quo = numerator \/\/ denominator\n            string += str(quo)\n            rem = numerator % denominator\n            if rem == 0:\n                return string\n            else:\n                seen = {}\n                while rem:\n                    if rem in seen:\n                        ind = seen[rem]\n                        return ''.join(string[:ind]) + \"(\" + ''.join(string[ind:]) + \")\"\n                    seen[rem] = len(string)\n                    rem *= 10\n                    quo = rem \/\/ denominator\n                    rem = rem % denominator\n                    string += str(quo)\n                return ''.join(string)\n        return ''.join(string)"
    },
    {
        "question_id":168,
        "optimized_code":"class Solution:\n    def convertToTitle(self, columnNumber: int) -> str:\n        if columnNumber == 0:\n            return \"\"\n        else:\n            return chr(ord('A')+columnNumber-1) + self.convertToTitle(columnNumber-1)"
    },
    {
        "question_id":43,
        "optimized_code":"class Solution:\n    def multiply(self, num1: str, num2: str) -> str:\n        zero = ord('0')\n        n, m = len(num1), len(num2)\n        ret = 0\n        for j in range(m-1, -1, -1):\n            jmult = 10**(m-j-1)\n            carry = 0\n            for i in range(n-1, -1, -1):\n                tmp = (ord(num1[i]) - zero) * (ord(num2[j]) - zero) + carry\n                imult = 10**(n-i-1)\n                ret += (tmp % 10) * jmult * imult\n                carry = tmp \/\/ 10\n            ret = ret + (carry * jmult * 10**n)\n        return str(ret)"
    },
    {
        "question_id":50,
        "optimized_code":"class Solution:\n    def solve(self, a, b):\n        if b == 0:\n            return 1\n        ans = self.solve(a, b \/\/ 2)\n        ans *= ans\n        if b & 1:\n            return ans * a\n        else:\n            return ans\n\n    def myPow(self, x: float, n: int) -> float:\n        res = self.solve(x, abs(n))\n        if n < 0:\n            return 1 \/ res\n        return res\n\n#### Output:\nInput: a = 2, b = 5\nOutput: 16\n\nInput: a = 2, b = 3\nOutput: 8\n\nInput: a = 2, b = 0\nOutput: 1\n\nInput: a = 2, b = 1\nOutput: 4\n\nInput: a = 2, b = -2\nOutput: 0.25\n\nInput: a = 2, b = 2\nOutput: 4\n\nInput: a = 2, b = -1\nOutput: 0.25\n\nInput: a = 2, b = 0\nOutput: 1\n\nInput: a = 2, b = -1\nOutput: 0.25\n\nInput: a = 2, b = 0\nOutput: 1\n\nInput: a = 2, b = -1\nOutput: 0.25\n\nInput: a = 2, b = 0\nOutput: 1\n\nInput: a = 2, b = -1\nOutput: 0.25\n\nInput: a = 2, b = 0\nOutput: 1\n\nInput: a = 2, b = -1\nOutput: 0.25\n\nInput: a = 2, b = 0\nOutput: 1\n\nInput: a = 2, b = -1\nOutput: 0.25\n\nInput: a = 2, b = 0\nOutput: 1\n\nInput: a = 2, b = -1\nOutput: 0.25\n\nInput: a = 2, b = 0\nOutput: 1\n\nInput: a = 2, b = -1\nOutput: 0.25\n\nInput: a = 2, b = 0\nOutput: 1"
    },
    {
        "question_id":219,
        "optimized_code":"class Solution:\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\n        if k > len(nums):\n            return False\n        seen = {}\n        for i in range(len(nums)):\n            if nums[i] in seen and abs(i - seen[nums[i]]) <= k:\n                return True\n            seen[nums[i]] = i\n        return False"
    },
    {
        "question_id":221,
        "optimized_code":"class Solution:\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\n        R, C = len(matrix), len(matrix[0])\n\n        sums = [[0 for c in range(C + 1)] for r in range(R + 1)]\n        for r in range(1, R + 1):\n            for c in range(1, C + 1):\n                sums[r][c] = sums[r][c - 1] + sums[r - 1][c] - sums[r - 1][c - 1] + int(matrix[r - 1][c - 1])\n\n        result = 0\n\n        for r in range(1, R + 1):\n            for c in range(1, C + 1):\n                if matrix[r - 1][c - 1] == \"0\":\n                    continue\n\n                st, en = 1, min(R - r + 1, C - c + 1)\n                while en - st > 1:\n                    md = (st + en) \/\/ 2\n                    if sums[r + md - 1][c + md - 1] - sums[r + md - 1][c - 1] - sums[r - 1][c + md - 1] + sums[r - 1][c - 1] == md * md:\n                        st = md\n                    else:\n                        en = md\n                if sums[r + en - 1][c + en - 1] - sums[r + en - 1][c - 1] - sums[r - 1][c + en - 1] + sums[r - 1][c - 1] == en * en:\n                    st = en\n\n                result = max(result, st)\n\n        return result * result"
    },
    {
        "question_id":223,
        "optimized_code":"class Solution:\n    def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -> int:\n        int_x = set(range(ax1, ax2)).intersection(range(bx1, bx2))\n        int_y = set(range(ay1, ay2)).intersection(range(by1, by2))\n        return (ax2-ax1)*(ay2-ay1) + (bx2-bx1)*(by2-by1) - len(int_x)*len(int_y)"
    },
    {
        "question_id":107,
        "optimized_code":"from collections import deque\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n\n        if not root:\n            return []\n\n        queue = deque([root])\n        solutions = deque([])\n\n        while queue:\n            level = []\n            level_size = len(queue)\n\n            for _ in range(level_size):\n                node = queue.popleft()\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n\n\n            solutions.appendleft(level)\n\n        return solutions"
    },
    {
        "question_id":109,
        "optimized_code":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        if not head:\n            return None\n        if not head.next:\n            return TreeNode(head.val)\n        slow, fast = head, head.next\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        root = TreeNode(slow.val)\n        root.left = self.sortedListToBST(slow.next)\n        root.right = self.sortedListToBST(slow.next.next)\n        return root"
    },
    {
        "question_id":268,
        "optimized_code":"class Solution:\n    def missingNumber(self, nums: List[int]) -> int:\n        h={}\n        for i in range(len(nums)+1):\n            if i not in h:\n                if i not in nums:\n                    return i\n                h[nums[i]]=1"
    },
    {
        "question_id":172,
        "optimized_code":"class Solution:\n    def trailingZeroes(self, n: int) -> int:\n        return n \/\/ math.factorial(n\/\/5) * 5"
    },
    {
        "question_id":179,
        "optimized_code":"def insert (n, l) :\n    l.append (n)\n    i = len (l) - 1\n    while i and str(n) + str(l[i-1]) > str(l[i-1]) + str(n): \n        l[i] = l[i-1]\n        i -= 1\n    l[i] = n\n\nclass Solution:\n    def largestNumber(self, nums: List[int]) -> str:\n        nums.sort(key = lambda x : (str (x), -1 if str (x) + str (nums[0]) > str (nums[0]) + str (x) else 1))\n        return str (nums[0])"
    },
    {
        "question_id":187,
        "optimized_code":"class Solution:\n    def findRepeatedDnaSequences(self, s: str) -> List[str]:\n        if len(s) < 10:\n            return []\n\n        mp = {}\n        currList = collections.deque()\n        for i in range(10):\n            currList.append(s[i])\n\n        mp[tuple(currList)] = 0\n        r = 10\n        ans = []\n        while r < len(s):\n            currList.append(s[r])\n            currList.popleft()\n            dna = tuple(currList)\n            if dna in mp and mp[dna]!= 1:\n                ans.append(\"\".join(currList))\n                mp[dna] = 1\n            elif dna not in mp:\n                mp[dna] = 0\n            r += 1\n        return ans"
    },
    {
        "question_id":12,
        "optimized_code":"class Solution:\n    def intToRoman(self, num: int) -> str:\n        dictionary = {1000:'M', 900:'CM', 500:'D', 400:'CD', 100:'C', 90:'XC', 50:'L', 40:'XL', 10:'X', 9:'IX', 5:'V', 4:'IV', 1:'I'}\n        ans=''\n        for key, val in dictionary.items():\n            while num>=key:\n                ans+=val\n                num-=key\n        return ans"
    },
    {
        "question_id":13,
        "optimized_code":"class Solution:\n    def romanToInt(self, s: str) -> int:\n        m = {\n            'I': 1,\n            'V': 5,\n            'X': 10,\n            'L': 50,\n            'C': 100,\n            'D': 500,\n            'M': 1000\n        }\n        \n        ans = 0\n        \n        for i in range(len(s)):\n            if i < len(s) - 1 and m[s[i]] < m[s[i+1]]:\n                ans -= m[s[i]]\n            else:\n                ans += m[s[i]]\n        \n        return ans"
    },
    {
        "question_id":18,
        "optimized_code":"class Solution:\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\n        nums.sort()\n        res = set()\n        for i in range(len(nums)-3):\n            for j in range(i+1,len(nums)-2):\n                m = j+1\n                n = len(nums) - 1\n                while m < n:\n                    if nums[m] + nums[n] == target - (nums[i] + nums[j]):\n                       res.add((nums[i],nums[j],nums[m],nums[n]))\n                       m+=1\n                       n-=1\n                    elif  target - (nums[i] + nums[j]) > (nums[m] + nums[n]):\n                        m+=1\n                    else:\n                        n-=1\n        return [list(t) for t in res]"
    },
    {
        "question_id":20,
        "optimized_code":"class Solution(object):\n    def isValid(self, s):\n        stack = [] \n        pairs = {\n            '(': ')',\n            '{': '}',\n            '[': ']'\n        }\n        \n        for bracket in s:\n            if bracket in pairs:\n                stack.append(bracket)\n            elif len(stack) == 0 or bracket!= pairs[stack.pop()]:\n                return False\n\n        return len(stack) == 0"
    },
    {
        "question_id":113,
        "optimized_code":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:\n        res=[]\n        def helper(root,sm,gen):\n            if root is None:\n                return \n            if root.left is None and root.right is None:\n                sm+=root.val\n                gen+=[root.val]\n                if sm==targetSum:\n                    res.append(gen[:])\n            helper(root.left,sm+root.val,gen+[root.val])\n            helper(root.right,sm+root.val,gen+[root.val])\n        helper(root,0,[],[])\n        return res"
    },
    {
        "question_id":115,
        "optimized_code":"class Solution:\n    def numDistinct(self, s: str, t: str) -> int:\n        #s = \"rabbbit\", t = \"rabbit\"\n\n        #ultimatly its all about moving pointers, when to move them (need to try all the possiblities of moving the pointers)\n\n        #if i == j\n            #move both and just move i (since duh not j)\n        #else:\n            #move i to find other\n\n        #store (cache) when we get to i,j we've already seen ()\n\n        dp = {}\n\n        def dfs(i,j):\n            if j == len(t):\n                return 1\n            if i == len(s):\n                return 0\n            if (i,j) in dp:\n                return dp[(i,j)]\n            \n            if s[i] == t[j]:\n                dp[(i,j)] = dfs(i + 1, j + 1) + dfs(i + 1, j)\n            else:\n                dp[(i,j)] = dfs(i + 1,j)\n\n            return dp[(i,j)]\n\n        return dfs(0,0)"
    },
    {
        "question_id":117,
        "optimized_code":"\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.next = next\n\"\"\"\n\nclass Solution:\n    def connect(self, root: 'Node') -> 'Node':\n        \"\"\"\n        Do BFGS; Process each layer before moving on \n        \"\"\"\n\n        if not root or (not root.left and not root.right):\n            return root\n        \n        buffer = [root]\n        while len(buffer) > 0:\n            \n            # add children to the next layer buffer\n            for node in buffer:\n                if node.left: buffer.append(node.left)\n                if node.right: buffer.append(node.right)\n\n            # reconnect\n            i = 0\n            while i < len(buffer)-1:\n                buffer[i].next = buffer[i+1]\n                i += 1\n            buffer[i].next = None\n            \n            buffer = []\n        \n        return root"
    },
    {
        "question_id":118,
        "optimized_code":"class Solution:\n    def generate(self, numRows: int) -> List[List[int]]:\n        \n        if numRows == 1: return [[1]]\n        if numRows == 2: return [[1], [1, 1]]\n\n        prev_result = self.generate(numRows-1)\n        last_row = prev_result[-1]\n        new_result = [1]\n        for i in range(1, numRows-1):\n            new_result.append(last_row[i] + last_row[i-1])\n        new_result.append(1)\n        prev_result.append(new_result)\n        return prev_result"
    },
    {
        "question_id":119,
        "optimized_code":"class Solution:\n    def getRow(self, rowIndex: int) -> List[int]:\n        # \u5982\u679c\u53ea\u8981\u7b2c0\u5217\n        if rowIndex == 0:\n            return [1]\n\n        # \u5132\u5b58\u73fe\u5728\u9019\u5217\n        rowNums = [1,1]\n\n        for _ in range(1, rowIndex):\n            # \u65b0\u5217\n            newRow = [1]\n            for i in range(1, len(rowNums)):\n                newRow.append(rowNums[i]+rowNums[i-1])\n            rowNums = newRow + [1]\n        return rowNums\n\nif __name__ == \"__main__\":\n    Solution().getRow(1)"
    },
    {
        "question_id":260,
        "optimized_code":"class Solution:\n    def singleNumber(self, nums: List[int]) -> List[int]:\n\n        nums.sort()\n        L = []\n\n        for num in nums:\n            if nums.count(num) == 1:\n                L.append(num)\n\n        return L"
    },
    {
        "question_id":264,
        "optimized_code":"from heapq import heappush, heappop\nclass Solution:\n    def nthUglyNumber(self, n: int) -> int:\n        nums = [1]\n        ugly = [1]\n        count = 0\n        while len(nums) < n:\n            if nums[-1] * 2 not in ugly:\n                nums.append(nums[-1] * 2)\n                heappush(ugly, nums[-1] * 2)\n            if nums[-1] * 3 not in ugly:\n                nums.append(nums[-1] * 3)\n                heappush(ugly, nums[-1] * 3)\n            if nums[-1] * 5 not in ugly:\n                nums.append(nums[-1] * 5)\n                heappush(ugly, nums[-1] * 5)\n            count += 1\n        return ugly[0]"
    },
    {
        "question_id":71,
        "optimized_code":"class Solution:\n    def simplifyPath(self, path: str) -> str:\n        components = path.split('\/')\n        stack = []\n        for component in components:\n            if component == '.':\n                continue\n            elif component == '..':\n                if stack:\n                    stack.pop()\n            else:\n                stack.append(component)\n        return '\/' + '\/'.join(stack)"
    },
    {
        "question_id":75,
        "optimized_code":"class Solution:\n    def sortColors(self, nums: List[int]) -> None:\n        nums.sort()\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\""
    },
    {
        "question_id":77,
        "optimized_code":"class Solution:\n    def combine(self, n: int, k: int) -> List[List[int]]:\n        self.res = []\n        self.dfs(n, k, [])\n        return self.res\n\n    def dfs(self, n, k, tmp):\n        if len(tmp) == k:\n            self.res.append(tmp)\n        else:\n            for i in range(n + 1):\n                tmp.append(i)\n                self.dfs(n, k, tmp)\n                tmp.pop()"
    },
    {
        "question_id":80,
        "optimized_code":"class Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        count=0\n        for i in range(1,len(nums)):\n            if(nums[i-1]==nums[i]):\n                count+=1\n            else:\n                nums[count]=nums[i]\n                count+=1\n        return count"
    },
    {
        "question_id":21,
        "optimized_code":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\n        dummy = ListNode()\n        head = dummy\n        while list1 and list2:\n            if list1.val < list2.val:\n                head.next = list1\n                list1 = list1.next\n            else:\n                head.next = list2\n                list2 = list2.next\n            head = head.next\n        if list1:\n            head.next = list1\n        else:\n            head.next = list2\n        return dummy.next"
    },
    {
        "question_id":27,
        "optimized_code":"class Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        i = 0\n        j = len(nums) - 1\n        while i < j:\n            if nums[j] == val:\n                nums[i], nums[j] = nums[j], nums[i]\n                j -= 1\n            elif nums[i] == val:\n                i += 1\n            else:\n                j -= 1\n        return i + (0 if nums[i] == val else 1)"
    },
    {
        "question_id":28,
        "optimized_code":"class Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        for i in range(len(haystack)):\n            if haystack[i:i+len(needle)]==needle:\n                return i\n        return -1"
    },
    {
        "question_id":29,
        "optimized_code":"class Solution:\n    def divide(self, dividend: int, divisor: int) -> int:\n        # Constants for 32-bit signed integer limits\n        INT_MAX, INT_MIN = 2**31 - 1, -2**31\n        \n        # Edge case for overflow\n        if dividend == INT_MIN and divisor == -1:\n            return INT_MAX\n        \n        # Determine the sign of the result\n        sign = (dividend < 0)!= (divisor < 0)\n        \n        # Work with absolute values\n        dividend, divisor = abs(dividend), abs(divisor)\n        \n        # Initialize the result\n        quotient = 0\n        \n        # The power of two divisor\n        power = 31\n        # The value of divisor shifted left\n        divisor_power = divisor << power\n        \n        # Subtract divisor multiples from dividend\n        while dividend >= divisor:\n            while divisor_power > dividend:\n                divisor_power >>= 1\n                power -= 1\n            dividend -= divisor_power\n            quotient += 1 << power\n        \n        # Apply the sign\n        if sign:\n            quotient = -quotient\n        \n        # Clamp the result within the 32-bit signed integer range\n        return min(max(quotient, INT_MIN), INT_MAX)"
    },
    {
        "question_id":30,
        "optimized_code":"class Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        n = len(words)\n        k = len(words[0])\n        words_counts = Counter(words)\n        l = n * k\n\n        indices = []\n        for i in range(len(s) - l + 1):\n            if Counter(s[i + j * k: i + (j + 1) * k] for j in range(n)) == words_counts:\n                indices.append(i)\n\n        return indices"
    },
    {
        "question_id":62,
        "optimized_code":"class Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        return self._uniquePaths(m, n)\n\n    def _uniquePaths(self, m, n):\n        if m == 0 or n == 0:\n            return 1\n\n        dp = [[0] * n for _ in range(m)]\n\n        dp[0][0] = 1\n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j == 0:\n                    dp[i][j] = 1\n                elif i == 0:\n                    dp[i][j] = dp[i][j-1]\n                elif j == 0:\n                    dp[i][j] = dp[i-1][j]\n                else:\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1]\n\n        return dp[-1][-1]"
    },
    {
        "question_id":64,
        "optimized_code":"class Solution:\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        if not grid or not grid[0]:\n            return 0\n        \n        m, n = len(grid), len(grid[0])\n        \n        # Initialize the dp table\n        dp = [[0] * n for _ in range(m)]\n        \n        # Base case: starting point\n        dp[0][0] = grid[0][0]\n        \n        # Fill the first row\n        for j in range(1, n):\n            dp[0][j] = dp[0][j-1] + grid[0][j]\n        \n        # Fill the first column\n        for i in range(1, m):\n            dp[i][0] = dp[i-1][0] + grid[i][0]\n        \n        # Fill the rest of the dp table\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])\n        \n        # The bottom-right corner has the result\n        return dp[m-1][n-1]"
    },
    {
        "question_id":65,
        "optimized_code":"class Solution:\n    def isNumber(self, s: str) -> bool:\n        \"\"\"\n        2\n        0089\n        -0.1\n        +3.14\n        4.\n        -.9\n        2e10\n        -90E3\n\n        Integer followed by optional exponent\n        decimal with optional exponent\n        integer is defined wtih - or +\n        followed by digits\n        \n        This is Integer to English words vibe question.\n        all possible characters we have\n        [0-9]\n       .\n        e,E\n        -, +\n\n        [0,9] can occur anywhere.\n       . cannot occur while defining an exponent like 99e2.5\n\n        e\/E cannot occur \n            - if there is no num before it \n            - after it there is no {-,+}[0-9]\n        \n        - and + cannot occur if there is a - or + before it or after.\n        anything else is invalid \n\n        but how many cases can we have\n\n        what about 2e2e2? CONFIRMED INVALID\n        - given 2e2.5 is invalid this may also be invalid\n        - it's possible its not tho\n\n        1. splitting at E should give 2 non-empty elements.\n            - it may not matter if its 3 elements\n            - but if its less than 2 its invalid\n            because it's either e3 or 3e. both invalid\n            for each string:\n                check the - and + \n                check the. \n                    this can only happen in the first element.\n                    remember 2.5e is invalid. but 2.5e3 is not\n        \n        and assumption is are we allowed to modify the input?\n        because if we can I can convert it to all lowercase then split at \"e\"\n        otherwise we have to split at either (might be possible)\n\n        \"\"\"\n        s = s.replace(\"E\",\"e\")\n        elems = s.split(\"e\")\n        # FOR THIS CASE \"92e1740e91\"\n        if len(elems) > 2:\n            return False \n    \n        for i in range(len(elems)):\n            cur_num = elems[i]\n            # eitehr e3 or 3e case\n            if cur_num == \"\":\n                return False\n            # check this number\n            found_dot = False\n\n            for j in range(len(cur_num)):"
    },
    {
        "question_id":66,
        "optimized_code":"class Solution:\n    def plusOne(self, digits: List[int]) -> List[int]:\n        n=len(digits)\n        for i in range(n-1,-1,-1):\n            if digits[i]<9:\n                digits[i]+=1\n                return digits\n            else:\n                digits[i]=0\n        return [1]+digits"
    },
    {
        "question_id":67,
        "optimized_code":"class Solution:\n    def addBinary(self, a: str, b: str) -> str:\n        i= len(a)-1\n        j= len(b)-1\n\n        car=0\n        sol=\"\"\n        while i >= 0 or j >= 0 or car:\n            digit_a = int(a[i]) if i >= 0 else 0\n            digit_b = int(b[j]) if j >= 0 else 0\n            \n            total = digit_a + digit_b + car\n            sol+=str(total % 2)\n            car = total \/\/ 2  \n\n            i-=1\n            j-=1\n        return sol[::-1]"
    },
    {
        "question_id":69,
        "optimized_code":"class Solution:\n    def mySqrt(self, x: int) -> int:\n        if x == 0 or x == 1:\n            return x\n        return int(-1\/2 * (math.log(x) \/ math.log(2)) + 0.5)"
    },
    {
        "question_id":70,
        "optimized_code":"class Solution:\n    def climbStairs(self, n: int) -> int:\n        return self._dfs(n, {})\n\n    def _dfs(self, n: int, memo: dict[int, int]):\n        if n == 0 or n == 1:\n            return 1\n        if n not in memo:\n            memo[n] = self._dfs(n - 1, memo) + self._dfs(n - 2, memo)\n        return memo[n]\n\n#### Test Code:\nimport unittest\nfrom Solution import Solution as s\n\nclass Test(unittest.TestCase):\n    def test_climbStairs(self):\n        self.assertEqual(1, s.climbStairs(1))\n        self.assertEqual(2, s.climbStairs(2))\n        self.assertEqual(3, s.climbStairs(3))\n        self.assertEqual(5, s.climbStairs(5))\n        self.assertEqual(15, s.climbStairs(15))\n\nif __name__ == '__main__':\n    unittest.main()"
    },
    {
        "question_id":51,
        "optimized_code":"class Solution:\n    def solveNQueens(self, n: int) -> List[List[str]]:\n        def backtrace(restricted, queens, row, n, sols):\n            pos_location = [n for n, i in enumerate(restricted[row]) if i == False]\n            for pos in pos_location:\n                if row == n - 1: # store solution\n                    sol = copy.deepcopy(queens)\n                    sol[row][pos] = 'Q'\n                    sol = [''.join(i) for i in sol]\n                    sols.append(sol)\n                else:\n                    new_restricted = copy.deepcopy(restricted)\n                    ### add new restricted grid\n                    # horizontal direction\n                    new_restricted[row] = [True] * n\n                    # vertical direction\n                    for y in range(n):\n                        new_restricted[y][pos] = True\n                    # bottom left direction\n                    y = row\n                    x = pos\n                    while y < n and 0 <= x:\n                        new_restricted[y][x] = True\n                        y += 1\n                        x -= 1\n                    # bottom right direction\n                    y = row\n                    x = pos\n                    while y < n and x < n:\n                        new_restricted[y][x] = True\n                        y += 1\n                        x += 1\n\n                    new_queens = copy.deepcopy(queens)\n                    new_queens[row][pos] = 'Q'\n                    # recursion\n                    backtrace(new_restricted, new_queens, row + 1, n, sols)\n        \n\n        sols = []\n        restricted = [[False for _ in range(n)] for _ in range(n)]\n        queens = [['.' for _ in range(n)] for _ in range(n)]\n        backtrace(restricted, queens, 0, n, sols)\n        return sols"
    },
    {
        "question_id":52,
        "optimized_code":"class Solution:\n    def totalNQueens(self, n: int) -> int:\n        def helper(row):\n            if row == n:\n                return 1\n            count = 0\n            for c in range(len(board[row])):\n                if board[row][c] == 0:\n                    continue\n                count += helper(row+1)\n            return count\n\n        board = [[0] * n for _ in range(n)]\n        count = 0\n        for r in range(n):\n            for c in range(n):\n                if board[r][c] == 0:\n                    continue\n                count += helper(r)\n\n        return count"
    },
    {
        "question_id":53,
        "optimized_code":"def maxSubArray(nums):\n    # maxSum = float('-inf') # initialize maxSum is -infinity which is the lowest of any number \n    # currentSum = 0\n    \n    # for num in nums:\n    #     currentSum += num\n    #     if currentSum > maxSum:\n    #         maxSum = currentSum\n    #     if currentSum < 0:\n    #         currentSum = 0\n    \n    # return maxSum\n    \n    if not nums:\n        return 0\n    \n    currentSum = nums[0]\n    maxSum = currentSum\n    \n    for num in nums[1:]:\n        currentSum = max(currentSum + num, num)\n        maxSum = max(maxSum, currentSum)\n    \n    return maxSum"
    },
    {
        "question_id":55,
        "optimized_code":"class Solution:\n    def canJump(self, nums: List[int]) -> bool:\n        n = len(nums)\n        dp = [0] * n\n        dp[0] = 1\n\n        for i in range(1, n):\n            if dp[i - 1] == 1:\n                continue\n            for j in range(nums[i]):\n                if i + j + 1 < n:\n                    dp[i + j + 1] = 1\n                    i = i + j + 1\n\n        return dp[n - 1] == 1"
    },
    {
        "question_id":58,
        "optimized_code":"class Solution:\n    def lengthOfLastWord(self, s: str) -> int:\n        return len(s.split(' ')[-1])"
    },
    {
        "question_id":60,
        "optimized_code":"class Solution:\n    def getPermutation(self, n: int, k: int) -> str:\n        def nextPermutation(lst):\n            if len(lst)==1:\n                return lst\n            else:\n                e=len(lst)-1\n                b=[]\n                while (lst[e]<=lst[e-1]):\n                    b.append(lst[e])\n                    e=e-1\n                    if e==0:\n                        return []\n                b.append(lst[e])\n                b.append(lst[e-1])\n                pivot=lst[e-1]\n                min_next=max(lst)+1\n                for element in b:\n                    if element > pivot and element<min_next:\n                        min_next=element\n                m=lst[0:e-1]\n                m.append(min_next)\n                b.remove(min_next)\n                b.sort()\n                for e in b:\n                    m.append(e)\n                return m\n        if n==1:\n            return str(n)\n        else:\n            nums=[]\n            for i in range(1,n+1):\n                nums.append(i)\n            count=1\n            while(count<k):\n                nums=nextPermutation(nums)\n                count+=1\n            s=''\n            for elem in nums:\n                s+=str(elem) \n        return s"
    },
    {
        "question_id":282,
        "optimized_code":"class Solution:\n    def addOperators(self, num: str, target: int) -> List[str]:\n        def add(expr: str, val: int, val2: int):\n            if val2 == 0: return expr + str(val)\n            return str(val) + expr\n        \n        def validate(expr: str):\n            prev = ''\n            check = False\n            cnt = 0\n            for v in expr:\n                if not prev.isdigit():\n                    if v == '0': check = True\n                    else: \n                        check = False\n                        cnt = 0\n                if v.isdigit() and check: cnt += 1\n                else:\n                    check = False\n                    cnt = 0\n                if cnt == 2: return False\n                prev = v\n            return True\n        \n        def find_expressions(available):\n            if not available: return ''\n            if len(available) == 1: return available[0]\n            exps = []\n            c = available.pop()\n            for expr in find_expressions(available):\n                exps.append(expr + c)\n                exps.append(expr + '+' + c)\n                exps.append(expr + '-' + c)\n                exps.append(expr + '*' + c)\n            return exps\n\n        ret = []\n        available = list(num)\n        for expr in find_expressions(available):\n            if eval_expr(expr) == target and validate(expr): ret.append(expr)\n\n        return ret"
    },
    {
        "question_id":283,
        "optimized_code":"class Solution:\n    def moveZeroes(self, nums: List[int]) -> None:\n        n = len(nums)\n        for i in range(n):\n            if nums[i]==0:\n                for j in range(i,n):\n                    if nums[j]!=0:\n                        nums[i],nums[j]=nums[j],nums[i]\n                        break"
    },
    {
        "question_id":335,
        "optimized_code":"class Solution:\n    def isSelfCrossing(self, x: List[int]) -> bool:\n        n = len(x)\n        for i in range(3, n):\n            if x[i] >= x[i - 2] and x[i - 1]<= x[i - 3]:\n                return True\n            if i >= 4:\n                if x[i - 1] == x[i - 3] and x[i]+ x[i - 4] >= x[i - 2]:\n                    return True\n            if i >= 5:\n                if x[i] + x[i - 4] >= x[i - 2] and x[i - 1] + x[i - 5] >= x[i - 3] and x[i - 2] > x[i - 4] and x[i - 3] > x[i - 1]:\n                    return True\n        return False\n        \n\n#### Expected Output:\nTrue"
    },
    {
        "question_id":336,
        "optimized_code":"class Solution:\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\n        dct=defaultdict(lambda :-1)\n        n=len(words)\n        flg=-1\n        for i in range(n):\n            dct[words[i]]=i\n            if words[i]==\"\":\n                flg=i\n        lst=[]\n        for i in range(n):\n            for j in range(len(words[i])):\n                if dct[words[i][j:][::-1]]!=-1 and i!=dct[words[i][j:][::-1]] and words[i][:j]==words[i][:j][::-1]:\n                    if [dct[words[i][j:][::-1]],i] not in lst:\n                        lst.append([dct[words[i][j:][::-1]],i])\n                if dct[words[i][:j][::-1]]!=-1 and i!=dct[words[i][:j][::-1]] and words[i][j:]==words[i][j:][::-1]:\n                    \n                    lst.append([i,dct[words[i][:j][::-1]]])\n        if \"\" in words:\n            for i in range(n):\n                if \"\"!=words[i] and words[i][::-1]==words[i]:\n                    if [i,flg] not in lst:\n                        lst.append([i,flg])\n                    if [flg,i] not in lst:\n                        lst.append([flg,i])\n        return lst"
    },
    {
        "question_id":338,
        "optimized_code":"class Solution:\n    def countBits(self, n: int) -> List[int]:\n        return [bin(i).count('1') for i in range(n+1)]"
    },
    {
        "question_id":342,
        "optimized_code":"class Solution:\n    def isPowerOfFour(self, n: int) -> bool:\n        return n>0 and (n&(-n)==n)"
    },
    {
        "question_id":345,
        "optimized_code":"class Solution:\n    def reverseVowels(self, s: str) -> str:\n        buf = list(s)\n        vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n        vowels.reverse()\n        vowels = vowels + vowels[::-1]\n        vowels = [vowels[i] for i in range(len(vowels))]\n        indexs = [i for i, v in enumerate(vowels) if v in buf]\n        indexs = [i for i, v in enumerate(vowels) if v not in buf]\n        for i in range(len(indexs)):\n            buf[indexs[i]] = vowels[i]\n        answer = ''.join(buf)\n        return answer"
    },
    {
        "question_id":521,
        "optimized_code":"class Solution:\n    def findLUSlength(self, a: str, b: str) -> int:\n        return max(len(a), len(b))"
    },
    {
        "question_id":383,
        "optimized_code":"class Solution:\n    def canConstruct(self, ransomNote: str, magazine: str) -> bool:\n        d={}\n        for c in magazine:\n            if c not in d:\n                d[c]=1\n            else:\n                d[c]+=1\n        for i in ransomNote:\n            if i in d and d[i]>0:\n                d[i]-=1\n            else:\n                return False\n        return True"
    },
    {
        "question_id":389,
        "optimized_code":"class Solution:\n    def findTheDifference(self, s: str, t: str) -> str:\n        s = list(s)\n        t = list(t)\n        for i in range(len(s)):\n            s[i] -= ord(s[i])\n            t[i] -= ord(t[i])\n        return chr(s[0] + t[0])"
    },
    {
        "question_id":391,
        "optimized_code":"class Solution:\n    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\n        x1, x2 = max([x[0] for x in rectangles]), min([x[2] for x in rectangles])\n        y1, y2 = max([y[1] for y in rectangles]), min([y[3] for y in rectangles])\n        if x1 >= x2 or y1 >= y2: return False\n        area = 0\n        for x, y, a, b in rectangles:\n            area += (a - x) * (b - y)\n        return area == x2 - x1 * y2 \/ y1"
    },
    {
        "question_id":392,
        "optimized_code":"class Solution:\n    def isSubsequence(self, s: str, t: str) -> bool:\n        if len(s) == 0:\n            return True\n        return self.isSubsequenceHelper(s, t, 0, len(t))"
    },
    {
        "question_id":354,
        "optimized_code":"class Solution:\n    def maxEnvelopes(self, envelopes: List[List[int]]) -> int:\n        n = len(envelopes)\n        envelopes.sort(key=lambda x: (x[0], -x[1])) # when there is a tie in width, desc height prevent wrong LIS\n\n        sub = [envelopes[0][1]]\n        for e in envelopes:\n            idx = bisect_left(sub, e[1])\n            if idx == len(sub):\n                sub.append(e[1])\n            else:\n                sub[idx] = e[1]\n        return len(sub)"
    },
    {
        "question_id":479,
        "optimized_code":"class Solution:\n    def largestPalindrome(self, n: int) -> int:\n        if n == 1: return 9\n        upper = int('9'*n)\n        lower = int('9'*(n-1))\n        \n        firstHalf = upper\n\n        while True:\n            pal = int(str(firstHalf) + str(firstHalf)[::-1])\n            for div in range(upper, lower, -1):\n                if div * div < pal or pal \/ div > upper:\n                    break\n                if pal % div == 0:\n                    return pal % 1337\n            firstHalf -= 1"
    },
    {
        "question_id":483,
        "optimized_code":"class Solution:\n    def smallestGoodBase(self, n: str) -> str:\n        import math\n        import time\n        from fractions import Fraction\n\n        n = int(n)\n\n        def f(u, n, x):\n            a = 0\n            for i in range(n + 1):\n                a += u**i\n            a -= x\n            return a\n\n        def candidates(x):\n            Z = set()\n            L = 6\n            for m in range(1, L + 1):\n                a = 0\n                b = x\n                z = 0\n                while (True):\n                    z = Fraction(a + b, 2)\n                    if (f(z, m, x) < -0.1):\n                        a = z\n                    elif (f(z, m, x) > 0.1):\n                        b = z\n                    else:\n                        z = int(round(z))\n                        if (f(z, m, x) == 0):\n                            Z.add(z)\n                        break\n            if (min(Z) == 1):\n                Z.pop()\n            return min(Z)\n\n        for b in range(2, 1201):\n            y = n\n            g = 1\n            while (y!= 0):\n                if (y % b!= 1):\n                    g = 0\n                    break\n                else:\n                    y \/\/= b\n            if (g == 1):\n                return str(b)\n\n        return str(candidates(n))"
    },
    {
        "question_id":485,
        "optimized_code":"class Solution:\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\n        maxLength = 0\n        length = 0\n        for i in range(len(nums)):\n            if nums[i] == 0:\n                length = 0\n            else:\n                length += 1\n            maxLength = max(maxLength, length)\n\n        return maxLength"
    },
    {
        "question_id":409,
        "optimized_code":"class Solution:\n    def longestPalindrome(self, s: str) -> int:\n        char_count = Counter(s)\n        length = 0\n        odd_found = False\n        for count in char_count.values():\n            if count % 2 == 0:\n                length += count\n            else:\n                length += count - 1\n                odd_found = True\n        if odd_found:\n            return length + 1\n        return length"
    },
    {
        "question_id":410,
        "optimized_code":"class Solution:\n    def splitArray(self, nums: List[int], k: int) -> int:\n\n        def count_subarray_sum(nums, s):\n            cnt = 0\n            for i in range(len(nums)):\n                cnt += nums[i]\n                if cnt == s:\n                    return i\n            return -1\n\n        def dfs(nums, s, start, k, ans):\n            if k == 0:\n                return 1\n            if s > nums[start]:\n                return 0\n            if count_subarray_sum(nums, s)!= -1:\n                return dfs(nums, s, start, k-1, ans)\n            else:\n                for i in range(start, len(nums)):\n                    if count_subarray_sum(nums, s) == -1:\n                        break\n                    if i - start > k:\n                        continue\n                    if dfs(nums, s, i, k, ans) == 1:\n                        return 1\n                return 0\n\n        return dfs(nums, s, 0, k, 1)"
    },
    {
        "question_id":412,
        "optimized_code":"class Solution:\n    def fizzBuzz(self, n: int) -> List[str]:\n        return [str(i) if i % 3 == 0 and i % 5 == 0 else str(i) if i % 3 == 0 else str(i) if i % 5 == 0 else \"FizzBuzz\" if i % 15 == 0 else \"Fizz\" if i % 5 == 0 else \"Buzz\" if i % 3 == 0 else str(i) for i in range(1, n+1)]"
    },
    {
        "question_id":414,
        "optimized_code":"def thirdMax(nums):\n    if len(nums) < 3:\n        return max(nums)\n    return max(nums) if nums.count(max(nums)) == 1 else max(nums) if nums.count(max(nums)) == 2 else max(nums)[0]"
    },
    {
        "question_id":472,
        "optimized_code":"class Solution:\n    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\n        def dfs(word, i):\n            if i >= len(word):\n                return True\n            if word[i] not in word_dict:\n                return False\n            curr = word_dict[word[i]]\n            if \"$\" in curr:\n                return dfs(word, i + 1)\n            return dfs(word, i + 1)\n        word_dict = {}\n        for word in words:\n            word_dict[word] = {}\n            for i in range(len(word)):\n                word_dict[word][word[i]] = {}\n                word_dict[word][word[i]][\"$\"] = None\n        return [w for w in words if dfs(w, 0)]"
    },
    {
        "question_id":476,
        "optimized_code":"class Solution(object):\n    def findComplement(self, num):\n        return ~num"
    },
    {
        "question_id":440,
        "optimized_code":"class Solution(object):\n    def findKthNumber(self, n, k):\n        def countSteps(n, prefix1, prefix2):\n            steps = 0\n            while prefix1 <= n:\n                steps += min(n + 1, prefix2) - prefix1\n                prefix1 *= 10\n                prefix2 *= 10\n            return steps\n\n        def countPrefixes(n, prefix1):\n            return countSteps(n, prefix1, prefix1 + 1)\n\n        def countPrefixes2(n"
    },
    {
        "question_id":441,
        "optimized_code":"class Solution:\n    def arrangeCoins(self, n: int) -> int:\n        res = 0\n        step = 1\n        \n        while n >= step:\n            res += 1\n            n -= step\n            step += 1\n        \n        return res"
    },
    {
        "question_id":401,
        "optimized_code":"class Solution:\n    def readBinaryWatch(self, num: int) -> list[str]:\n        times = []\n        if num == 0:\n            return times\n\n        for h in range(12):\n            for m in range(60):\n                if m == 0:\n                    hOnes = 1\n                else:\n                    hOnes = bin(h).count('1')\n                mOnes = bin(m).count('1')\n\n                if hOnes + mOnes == num:\n                    times.append(f\"{h}:{m:02d}\")\n\n        return times"
    },
    {
        "question_id":404,
        "optimized_code":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sumOfLeftLeaves(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        res = 0\n        if root.left:\n            if root.left.left:\n                res += self.sumOfLeftLeaves(root.left.left)\n            else:\n                res += self.sumOfLeftLeaves(root.left.right)\n        if root.right:\n            if root.right.left:\n                res += self.sumOfLeftLeaves(root.right.left)\n            else:\n                res += self.sumOfLeftLeaves(root.right.right)\n        return res"
    },
    {
        "question_id":405,
        "optimized_code":"class Solution:\n    def toHex(self, num: int) -> str:\n        return ''.join([hexas[i] for i in bin(num)[2:]])"
    },
    {
        "question_id":363,
        "optimized_code":"import numpy as np\nfrom sortedcontainers import SortedList\nfrom typing import List\n\nclass Solution:\n    def helper(self, a_list: List[int], k: int) -> int:\n        prefix_sums = SortedList([0])\n        cur_sum = 0\n        max_sum = float('-inf')\n        \n        for num in a_list:\n            cur_sum += num\n            # \u67e5\u627e\u5c0f\u4e8e\u7b49\u4e8e cur_sum - k \u7684\u524d\u7f00\u548c\n            target = cur_sum - k\n            pos = prefix_sums.bisect_left(target)\n            if pos < len(prefix_sums):\n                max_sum = max(max_sum, cur_sum - prefix_sums[pos])\n            prefix_sums.add(cur_sum)\n            \n            if max_sum == k:\n                return k\n        \n        return max_sum\n\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\n        mtx = matrix = np.array(matrix)\n        M, N = len(matrix), len(matrix[0])\n        max_sum = float('-inf')\n        sums = []\n\n        cursums = np.array([0] * N)\n        for i in range(M): \n            cur = mtx[i]\n            cursums += cur\n            sums.append(cursums.copy())\n        sums = np.array(sums)\n\n        for i in range(M): \n            for j in range(i, M): \n                nowsums = sums[j] - sums[i] + mtx[i]\n                max_sum = max(self.helper(nowsums, k), max_sum)\n        \n        return max_sum"
    },
    {
        "question_id":459,
        "optimized_code":"import numpy as np\nclass Solution:\n    def repeatedSubstringPattern(self, s: str) -> bool:\n        return bool(s[:1] * len(s)\/len(s[1:]))"
    },
    {
        "question_id":461,
        "optimized_code":"class Solution:\n    def hammingDistance(self, x: int, y: int) -> int:\n        return sum(x!= y and bin(x)[i]!= bin(y)[i] for i in range(32))"
    },
    {
        "question_id":463,
        "optimized_code":"class Solution:\n    def count_perimeter_at(self, neiboughr_matrix, grid, i, j):\n        counter = 0\n        for step in neiboughr_matrix:\n            new_step = [step[0] + i, step[1] + j]\n            if not (0 <= new_step[0] < len(grid)):\n                counter += 1\n                continue\n            elif not (0 <= new_step[1] < len(grid[0])):\n                counter += 1\n                continue\n            elif grid[new_step[0]][new_step[1]] == 0:\n                counter += 1\n        return counter\n\n    def islandPerimeter(self, grid: List[List[int]]) -> int:\n        neiboughr_matrix = [[1, 0], [0, 1], [-1, 0], [0, -1]]\n        counter = 0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 1:\n                    counter += self.count_perimeter_at(neiboughr_matrix, grid, i, j)\n        return counter"
    },
    {
        "question_id":466,
        "optimized_code":"class Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n        dp = [[0,0]]\n\n        for i in range(len(s2)):\n            start, count = i, 0 \n            for j in range(len(s1)):\n                if s1[j] == s2[start]:\n                    start += 1 \n                    if start == len(s2):\n                        start = 0 \n                        count += 1 \n            dp.append([start,count])\n\n        total, idx = 0, 0\n\n        for _ in range(n1):\n            total += dp[idx][1]\n            idx = dp[idx][0]\n\n        return total\/\/n2"
    },
    {
        "question_id":685,
        "optimized_code":"from collections import defaultdict\n\nclass Solution:\n    def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:\n        graph = defaultdict(set)\n        num_incoming_edges = defaultdict(int)\n        for edge in edges:\n            a, b = edge[0], edge[1]\n            graph[a].add(b)\n            num_incoming_edges[b] += 1\n\n        def findCycleDfs(root, curr, history, visited):\n            if curr == root:\n                return history\n            if curr in visited:\n                return\n            visited.add(curr)\n            for node in graph[curr]:\n                history.add((curr, node))\n                result = findCycleDfs(root, node, history, visited)\n                if result is not None:\n                    return result\n                history.remove((curr, node))\n\n        result = None\n        for edge in edges:\n            a, b = edge[0], edge[1]\n            if num_incoming_edges[b] > 1:\n                result = edge\n            if result is not None and (a, b) in result:\n                return edge\n\n        return result"
    },
    {
        "question_id":736,
        "optimized_code":"class Solution:\n    def evaluate(self, expression: str) -> int:\n        \"\"\"\n        expr := (let [string expr]*)\n        expr := (add  expr expr)\n        expr := (mult expr expr)\n        expr := var \n        \"\"\"\n\n        def tokenize(s):\n            Q = deque()\n            cur = 0\n            n = len(s)\n            while cur < n:\n                c = s[cur]\n                if c in ('(', ')'):\n                    Q.append(c)\n                    cur += 1\n                    continue\n                if c.isdigit() or c == '-':\n                    res = 0\n                    sign = 1\n                    if c == '-':\n                        sign = -1\n                        cur += 1\n                    while cur < n and s[cur].isdigit():\n                        res = res*10 + int(s[cur])\n                        cur += 1\n                    Q.append(sign * res)\n                    continue\n                if c.isalpha():\n                    res = []\n                    while cur < n and (s[cur].isalpha() or s[cur].isdigit()):\n                        res.append(s[cur])\n                        cur += 1\n                    Q.append(''.join(res))\n                    continue\n                cur += 1\n            return Q\n\n        tokens = tokenize(expression)  #TODO\n\n        def string():\n            return tokens.popleft()\n\n        def var(mp):\n            s = tokens.popleft()\n            if mp.get(s)!= None:\n                return mp[s]\n            return s\n\n        def expr(_mp):\n            mp = copy.copy(_mp)\n            if tokens[0] == '(':\n                assert tokens.popleft() == '('\n                op = tokens.popleft()\n                if op == 'let':\n                    while tokens[0]!= '(' and tokens[1]!= ')':\n                        variable_name = string()\n                        expression = expr(mp)\n                        mp[variable_name] = expression\n                    expression = expr(mp)\n                elif op =='mult':\n                    expr1 = expr(mp)\n                    expr2 = expr(mp)\n                    expression = expr1 * expr2\n                elif op == 'add':\n                    expr1 = expr(mp)\n                    expr2 = expr(mp)\n                    expression = expr1 + expr2\n                assert tokens.popleft() == ')'\n                return expression\n            else:\n                return var(mp)\n\n        return expr({})"
    },
    {
        "question_id":973,
        "optimized_code":"class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        def can_stamp(i):\n            changed = False\n            for j in range(len(stamp)):\n                if target[i + j] == '?':\n                    continue\n                if target[i + j]!= stamp[j]:\n                    return False\n                changed = True\n            return changed\n\n        def do_stamp(i):\n            for j in range(len(stamp)):"
    },
    {
        "question_id":975,
        "optimized_code":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\n        return self.dfs(root, low, high)\n\n    def dfs(self, root: TreeNode, low: int, high: int) -> int:\n        if not root:\n            return 0\n\n        if low <= root.val <= high:\n            return root.val\n\n        return self.dfs(root.left, low, high) + self.dfs(root.right, low, high)"
    },
    {
        "question_id":977,
        "optimized_code":"class Solution:\n    \"\"\"\n    @param S: The string s\n    @return: The number of distinct, non-empty subsequences of S.\n    \"\"\"\n    def distinctSubseqII(self, S):\n        n = len(S)\n        \n        # state: dp[i] \u8868\u793a\u4ee5\u4e0b\u6807 i \u4f5c\u4e3a subseq \u7684\u6700\u540e\u4e00\u4e2a\u5b57\u7b26\u7684\u65b9\u6848\u603b\u6570\n        # f[i] \u8868\u793a\u4ee5\u4e0b\u6807 i \u4f5c\u4e3a subseq \u7684\u6700\u540e\u4e00\u4e2a\u5b57\u7b26\u7684\u65b9\u6848\u603b\u6570\n        # \u5982\u679c i \u662f\u7b2c\u4e00\u4e2a\u51fa\u73b0 S[i] \u8fd9\u4e2a\u5b57\u7b26\u7684\u4f4d\u7f6e\uff0c\u90a3\u4e48 dp[i] = 1\n        # \u5982\u679c i \u662f\u7b2c\u4e00\u4e2a\u51fa\u73b0 S[i] \u8fd9\u4e2a\u5b57\u7b26\u7684\u4f4d\u7f6e\uff0c\u90a3\u4e48 f[i] = dp[j-1] + 1\n        # function: dp[i] = sigma{dp[j]}, j \u5230 i - 1 \u4e4b\u95f4\u6ca1\u6709 S[i]\n        f = [0] * (n+1)\n        for i in range(1, n+1):\n            f[i] = f[i-1] + 1\n            for j in range(i-1, 0, -1):\n                if S[i-1] == S[j-1]:\n                    f[i] = ( 2 * f[i-1]  - f[j] ) %MOD\n        return (f[-1] -1 ) %MOD"
    },
    {
        "question_id":1013,
        "optimized_code":"class Solution:\n    def fib(self, n: int) -> int:\n        if n < 2: \n            return n\n        \n        return self.fib(n-2) + self.fib(n-1)"
    },
    {
        "question_id":514,
        "optimized_code":"class Solution:\n    def findRotateSteps(self, ring: str, key: str) -> int:\n        dp = [0] * len(ring)\n        dp[0] = 0\n        for k in reversed(range(len(key))):\n            nextDP = [inf] * len(ring)\n            for r in range(len(ring)):\n                for i, c in enumerate(ring):\n                    if c == key[k]:\n                        minDist = min(abs(r-i), len(ring)-abs(r-i))\n                        nextDP[r] = min(nextDP[r], 1+minDist+dp[i])\n                dp = nextDP\n        return dp[0]"
    },
    {
        "question_id":920,
        "optimized_code":"class Solution:\n    def uncommonFromSentences(self, s1: str, s2: str) -> List[str]:\n        d=Counter(s1.split())+Counter(s2.split())\n        return [x for x in d if d[x]==1]"
    },
    {
        "question_id":35,
        "optimized_code":"class Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        if target == nums[0]:\n            return 0\n        elif target < nums[0]:\n            return 1\n        elif target > nums[-1]:\n            return len(nums)\n        else:\n            left = 0\n            right = len(nums) - 1\n            while left <= right:\n                mid = (left + right) \/\/ 2\n                if nums[mid] == target:\n                    return mid\n                elif nums[mid] < target:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return left if left < right else right + 1"
    },
    {
        "question_id":9,
        "optimized_code":"class Solution:\n    def isPalindrome(self, x: int) -> bool:\n        if x < 0:\n            return False\n        if x == 0:\n            return True\n        return x % 10 == x \/\/ 10"
    },
    {
        "question_id":10,
        "optimized_code":"class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        m, n = len(s), len(p)\n        j = 0\n        i = 0\n        while i < n:\n            if i + 1 < n and p[i + 1] == \"*\":\n                # Handle the '*' wildcard\n                # If the current pattern character and the character after '*' match the string character\n                if j < m and (p[i] == s[j] or p[i] == \".\"):\n                    # Try to match 0 or more characters\n                    while j < m and (p[i] == s[j] or p[i] == \".\"):\n                        if self.isMatch(s[j:], p[i + 2:]):\n                            return True\n                        j += 1\n                    i += 2  # Skip both the current character and '*'\n                else:\n                    # Skip the '*' and the preceding element in pattern\n                    i += 2\n            elif j < m and (p[i] == s[j] or p[i] == \".\"):\n                # Characters match or p[i] is '.'\n                j += 1\n                i += 1\n            else:\n                return False\n\n        # Ensure full match of both pattern and string\n        return j == m and i == n"
    },
    {
        "question_id":218,
        "optimized_code":"class Solution:\n    def getSkyline(self, buildings: List[List[int]]) -> List[List[int]]:\n        # Sort the unique positions of all the edges.\n        positions = sorted(list(set([x for building in buildings for x in building[:2]])))\n        \n        # Hast table 'edge_index_map' to record every {position : index} pairs in edges.\n        edge_index_map = {x : i for i, x in enumerate(positions)}\n\n        # Initialize 'heights' to record maximum height at each index.\n        heights = [0] * len(positions)\n        \n        # Iterate over all the buildings.\n        for left, right, height in buildings:\n            # For each building, find the indexes of its left\n            # and right edges.\n            left_idx = edge_index_map[left]\n            right_idx = edge_index_map[right]\n\n            # Update the maximum height within the range [left_idx, right_idx)\n            for i in range(left_idx, right_idx):\n                heights[i] = max(heights[i], height)\n\n        answer = []\n\n        # Iterate over 'heights'.\n        for i in range(len(heights)):\n            curr_height = heights[i]\n            curr_x = positions[i]\n\n            # Add all the positions where the height changes to 'answer'.\n            if not answer or answer[-1][1]!= curr_height:\n                answer.append([curr_x, curr_height])\n        return answer"
    },
    {
        "question_id":226,
        "optimized_code":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        if root is None:\n            return root\n\n        left = self.invertTree(root=root.left)\n        right = self.invertTree(root=root.right)\n        root.left, root.right = left, right\n\n        return root"
    },
    {
        "question_id":273,
        "optimized_code":"class Solution:\n    def numberToWords(self, num: int) -> str:\n        if num == 0:\n            return \"Zero\"\n        \n        converter = {1:\"One\",2:'Two',3:'Three',4:'Four',5:'Five',6:'Six',7:'Seven', 8:\"Eight\", 9:'Nine',10:'Ten',11:\"Eleven\",12:'Twelve',13:'Thirteen',14:'Fourteen',15:'Fifteen',16:\"Sixteen\",17:'Seventeen',18:\"Eighteen\",19:\"Nineteen\",20:\"Twenty\",30:\"Thirty\",40:\"Forty\",50:\"Fifty\",60:\"Sixty\",70:\"Seventy\", 80:\"Eighty\",90:\"Ninety\"}\n        \n        def hundreds(number):\n            ans = []\n            if number >= 100:\n                hundreds_digit,number = divmod(number,100)\n                ans.append(converter[hundreds_digit])\n                ans.append(\"Hundred\")\n            if number > 20:\n                tens_digit,number = divmod(number,10)\n                ans.append(converter[tens_digit*10])\n            if number > 0:\n                ans.append(converter[number])\n            return \" \".join(ans)\n        sol = []\n        digit,num = divmod(num,10**9)\n        \n        if digit:\n            sol.append(hundreds(digit))\n            sol.append(\"Billion\")\n        \n        digit,num = divmod(num,10**6)\n        \n        if digit:\n            sol.append(hundreds(digit))\n            sol.append(\"Million\")\n        \n        digit,num = divmod(num,10**3)\n        \n        if digit:\n            sol.append(hundreds(digit))\n            sol.append(\"Thousand\")\n        if num:\n            sol.append(hundreds(num))\n        return \" \".join(sol)"
    },
    {
        "question_id":14,
        "optimized_code":"class Solution:\n    def longestCommonPrefix(self, strs: List[str]) -> str:\n        if not strs: return ''\n        strs.sort(key=len)\n        pf = ''\n        for i,l in enumerate(strs[0]):\n            for word in strs:\n                if word[i]!= l:\n                    return pf\n            pf += l\n        return pf"
    },
    {
        "question_id":258,
        "optimized_code":"class Solution:\n    def addDigits(self, num: int) -> int:\n        if num == 0: \n            return 0\n        mod = num % 9 \n        if mod == 0:\n            return 9 \n        else: return mod\n\n#### Explanation:\n1. The code is optimized by removing the unnecessary variable'mod' and return statement."
    },
    {
        "question_id":76,
        "optimized_code":"class Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        n = len(s)\n        t_counter = Counter(t)\n        curr_counter = t_counter.copy()\n        for key in curr_counter:\n            curr_counter[key] = 0\n        left, right = 0, 0\n        minimum_window = ''\n        length = n + 1\n        while right < n:\n            curr_counter[s[right]] += 1\n            t_counter[s[right]] += 0\n            valid = True\n            for key in t_counter:\n                if curr_counter[key] < t_counter[key]:\n                    valid = False\n            if valid:\n                while True:\n                    if curr_counter[s[left]] - 1 >= t_counter[s[left]]:\n                        curr_counter[s[left]] -= 1\n                        left += 1\n                    else:\n                        break\n                if right - left + 1 < length:\n                    minimum_window = s[left:right+1]\n                    length = len(minimum_window)\n            right += 1\n        return minimum_window"
    },
    {
        "question_id":68,
        "optimized_code":"class Solution:\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\n        \n        res=[]\n        n=len(words)\n        cur_width = 0\n        for word in words:\n            cur_width += len(word) + 1\n            if cur_width > maxWidth:\n                res += [' '.join(line) for line in [word] * (maxWidth \/\/ len(word))]\n                cur_width = 0\n            else:\n                res.append([word] * (maxWidth \/\/ len(word)))\n        return res"
    },
    {
        "question_id":332,
        "optimized_code":"class Solution:\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\n        self.graph = {}\n        for src, dst in tickets:\n            self.graph[src] = self.graph.get(src, []) + [dst]\n        \n        self.res = []\n        self.dfs(\"JFK\")\n        return self.res[::-1]\n    \n    def dfs(self, src):\n        #\u00a0destinations = self.graph.get(src, [])\n        while self.graph.get(src, []):\n            dst = self.graph[src].pop(-1)\n            self.dfs(dst)\n        self.res.append(src)"
    },
    {
        "question_id":446,
        "optimized_code":"class Solution:\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\n        N = len(nums)\n        if N<=2:\n            return 0\n        dp = defaultdict(int)\n        ans = 0\n        for n in range(2,N):\n            v2 = nums[n]\n            for j in range(0,n):\n                v1 = nums[j]\n                dis = v2-v1\n                ans1 = dp[(j,dis)]\n                ans += ans1\n                dp[(n,dis)]+= (ans1+1)\n        return ans"
    },
    {
        "question_id":689,
        "optimized_code":"class Solution:\n    def maxSumOfThreeSubarrays(self, nums: List[int], k: int) -> List[int]:\n        sums = []\n        n = len(nums)\n        for i in range(n-k+1):\n            sums.append(sum(nums[i:i+k]))\n        best = 0\n        left = [0]*(n-k+1)\n        for i in range(n-k+1):\n            if sums[i] > sums[best]:\n                best = i\n            left[i] = best\n        \n        best = n-k\n        right = [0]*(n-k+1)\n        for i in range(n-k, -1, -1):\n            if sums[i] >= sums[best]:\n                best = i\n            right[i] = best\n\n        result = []\n        max_sum = 0\n        for mid in range(k, n-2*k+1):\n            l, r = left[mid-k], right[mid+k]\n            cur_sum = sums[l] + sums[r] + sums[mid]\n            if cur_sum > max_sum:\n                max_sum = cur_sum\n                result = [l, mid, r]\n        return result"
    },
    {
        "question_id":953,
        "optimized_code":"class Solution:\n    def reverseOnlyLetters(self, s: str) -> str:\n        s_list = list(s)\n        for i in range(len(s_list)):\n            if not s_list[i].isalpha():\n                continue\n            start = i\n            end = i + 1\n            while (start < len(s_list) and not s_list[start].isalpha()):\n                start += 1\n            while (end < len(s_list) and not s_list[end].isalpha()):\n                end += 1\n            s_list[start:end] = s_list[start:end][::-1]\n        return \"\".join(s_list)"
    },
    {
        "question_id":956,
        "optimized_code":"class Solution:\n    def numMusicPlaylists(self, n: int, goal: int, k: int) -> int:\n        MOD = 1_000_000_007\n        dp = [[0 for _ in range(n + 1)] for _ in range(goal + 1)]\n\n        def number_of_playlists(i, j):\n            # Base cases\n            if i == 0 and j == 0:\n                return 1\n            if i == 0 or j == 0:\n                return 0\n            if dp[i][j]!= -1:\n                return dp[i][j]\n            # DP transition: add a new song or replay an old one\n            dp[i][j] = (number_of_playlists(i - 1, j - 1) * (n - j + 1)) % MOD\n            if j > k:\n                dp[i][j] += (number_of_playlists(i - 1, j) * (j - k)) % MOD\n                dp[i][j] %= MOD\n            return dp[i][j]\n\n        return number_of_playlists(goal, n)"
    },
    {
        "question_id":517,
        "optimized_code":"class Solution:\n    def findMinMoves(self, machines: List[int]) -> int:\n        n = len(machines)\n        k, mod = divmod(sum(machines), n)\n        if mod:\n            return -1\n        ans = s = 0\n        for x in machines:\n            x -= k\n            s += x\n            ans = max(ans, abs(s), x)\n        return ans"
    },
    {
        "question_id":923,
        "optimized_code":"class Solution:\n    @cache\n    def superEggDrop(self, k: int, n: int) -> int:\n        \n        # base condition\n\n        if n==0:\n            return 0\n        if n==1:\n            return 1\n        if k==1:\n            return n\n        ans = float('inf')\n        s, e = 1, n\n        while (s <= e):\n            x = (s+e)\/\/2\n            if self.superEggDrop(k-1, x-1) >= self.superEggDrop(k, n-x):\n                ans = min(ans,self.superEggDrop(k-1, x-1) )\n                e = x-1\n            else:\n                ans = min(ans,self.superEggDrop(k, n-x) )\n                s = x+1\n        # for x in range(1, n+1):\n        #     ans  = min(ans, max(self.superEggDrop(k-1, x-1), self.superEggDrop(k, n-x)))\n        return ans +1\n\nclass Solution:\n    def superEggDrop(self, k: int, n: int) -> int:\n        # base condition\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        if k == 1:\n            return n\n        # cache\n        self.cache = {}\n        # dp table\n        dp = [[0 for i in range(n + 1)] for j in range(k + 1)]\n        # base case\n        dp[0][0] = 0\n        for i in range(1, n + 1):\n            dp[0][i] = dp[0][i - 1] + 1\n        for j in range(1, k + 1):\n            dp[j][0] = dp[j - 1][0] + 1\n        # for x in range(1, n+1):\n        #     ans  = min(ans, max(self.superEggDrop(k-1, x-1), self.superEggDrop(k, n-x)))\n        for i in range(1, n + 1):\n            for j in range(1, k + 1):\n                dp[j][i] = dp[j - 1][i] + dp[j]["
    },
    {
        "question_id":924,
        "optimized_code":"class Solution:\n    def fairCandySwap(self, aliceSizes: List[int], bobSizes: List[int]) -> List[int]:\n        diff = sum(aliceSizes) - sum(bobSizes)\n        return [half - (diff + i), half - (diff - i)]"
    },
    {
        "question_id":632,
        "optimized_code":"class Solution:\n    def smallestRange(self, nums: List[List[int]]) -> List[int]:\n        all_nums = []\n        for i, lst in enumerate(nums):\n            for n in lst:\n                all_nums.append((n, i))\n        all_nums.sort()\n        output = [float(\"-inf\"), float(\"inf\")]\n        included = {}\n        l, r = 0, 0\n        last_used_l = -1\n        while r < len(all_nums):\n            if all_nums[r][1] not in included:\n                included[all_nums[r][1]] = deque()\n            included[all_nums[r][1]].append(all_nums[r][0])\n            while len(included) == len(nums) and len(included[all_nums[l][1]]) > 1:\n                included[all_nums[l][1]].popleft()\n                l += 1\n            if len(included) == len(nums) and l!= last_used_l:\n                min_num = float(\"inf\")\n                max_num = float(\"-inf\")\n                for q in included.values():\n                    min_num = min(q[0], min_num)\n                    max_num = max(q[-1], max_num)\n                if max_num - min_num < output[1] - output[0]:\n                    output = [min_num, max_num]\n                last_used_l = l\n            r += 1\n        return output"
    },
    {
        "question_id":637,
        "optimized_code":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nfrom collections import deque\nclass Solution:\n    def averageOfLevels(self, root: Optional[TreeNode]) -> List[float]:\n        levelsAverageList = []\n        if root!= None:\n            queue = deque()\n            queue.append(root)\n            while queue:\n                size = len(queue)\n                levels = []\n                for start in range(size):\n                    treeNode = queue.popleft()\n                    levels.append(float(treeNode.val))\n                    if treeNode.left!= None:\n                        queue.append(treeNode.left)\n                    if treeNode.right!= None:\n                        queue.append(treeNode.right)\n                levelsAverageList.append(float(sum(levels)\/len(levels)))\n        return levelsAverageList"
    },
    {
        "question_id":979,
        "optimized_code":"class Solution:\n    def diStringMatch(self, s: str) -> List[int]:\n        greater_than = set()\n        less_than = set()\n        for c in s:\n            if c == \"D\":\n                greater_than.add(c)\n            else:\n                less_than.add(c)\n        n = len(s)\n        zero_candidates = [i for i in range(n+1) if i not in less_than]\n        q = list(zero_candidates)\n        assignments = [-1] * (n+1)\n        counter = 0\n        while q:\n            curr = q.pop()\n            assignments[curr] = counter\n            counter += 1\n            if curr not in greater_than:\n                continue\n            for bigger in greater_than:\n                less_than.remove(bigger)\n                if len(less_than) == 0:\n                    q.append(bigger)\n        return assignments"
    },
    {
        "question_id":981,
        "optimized_code":"class Solution:\n    def minDeletionSize(self, strs: List[str]) -> int:\n        return len([s for s in strs[0] if s < max(s for s in strs[1:])])"
    },
    {
        "question_id":927,
        "optimized_code":"class Solution:\n    def sumSubseqWidths(self, nums: List[int]) -> int:\n        nums = sorted(nums)\n        n = len(nums)\n        mod = 10**9 + 7\n        total = 0\n        forward = 1\n        backward = 1\n        for i in range(n):\n            forward *= 2\n            backward *= 2\n            total += forward * nums[i]\n            total %= mod\n            total += backward * nums[i]\n            total %= mod\n        return total"
    },
    {
        "question_id":928,
        "optimized_code":"class Solution:\n    def surfaceArea(self, grid) -> int :\n        length = len(grid)\n\n        def behind(point) :\n                array = []\n                i, j = point\n                # top :       \n                if length > i > 0 : array.append(min((grid[i-1][j],grid[i][j])))\n                # left :\n                if j < length-1 : array.append(min((grid[i][j+1], grid[i][j])))\n                # bottom :\n                if i < length-1 : array.append(min((grid[i+1][j], grid[i][j])))\n                # right :\n                if length > j > 0 : array.append(min((grid[i][j-1],grid[i][j])))\n\n                return array\n        \n        def tower_surface(height) : return height*6-(height-1)*2 if height > 0 else 0\n\n        surface = 0\n        \n        for i in range(length) :\n                for j in range(length) :\n                        surface += tower_surface(grid[i][j]) - sum(behind((i,j)))\n\n        return surface"
    },
    {
        "question_id":933,
        "optimized_code":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def increasingBST(self, root: TreeNode) -> TreeNode:\n        def dfs(root):\n            if not root:\n                return\n            dfs(root.left)\n            root.left = None\n            root.right = TreeNode(root.val)\n            dfs(root.right)\n        dfs(root)\n        return root.right"
    },
    {
        "question_id":488,
        "optimized_code":"class Solution:\n    @cache\n    def compress(self, s):\n        stack = []\n        for c in s:\n            if stack and stack[-1][0]!= c and stack[-1][1] >= 3:\n                stack.pop()\n            if not stack or stack[-1][0]!= c:\n                stack.append([c, 1])\n            else:\n                stack[-1][1] += 1\n        if stack and stack[-1][1] >= 3:\n            stack.pop()\n        return ''.join(a*b for a, b in stack)\n\n    def findMinStep(self, board: str, hand: str) -> int:\n        n = len(hand)\n        hand = ''.join(sorted(hand))\n        @cache\n        def solve(board, hand):\n            board = self.compress(board)\n            if board == '': return n - len(hand)\n            if hand == '': return 1e9\n\n            ans = 1e9\n            for i in range(len(hand)):\n                if i > 0 and hand[i] == hand[i-1]: continue\n    \n                for j in range(len(board)):\n                    if board[j] == hand[i] or j > 0 and board[j] == board[j-1] and board[j]!= hand[i]:\n                        ans = min(ans, solve(board[0:j] + hand[i] + board[j:], hand[0:i] + hand[i+1:]))\n            return ans\n        \n        res = solve(board, hand)\n        if res == 1e9: return -1\n        else: return res"
    },
    {
        "question_id":493,
        "optimized_code":"class Solution:\n    def reversePairs(self, nums: List[int]) -> int:\n        res = 0\n        bit = BIT(len(nums)+1)\n        for x in nums:\n            indx = binary_search(bit.n, 2*x+1)+1\n            res += bit.search(indx)\n            indx = binary_search(bit.n, x)+1\n            bit.update(indx)\n        return res\n\n#### Explanation:\nclass Solution:\n    def reversePairs(self, nums: List[int]) -> int:\n        res = 0\n        bit = BIT(len(nums)+1)\n        for x in nums:\n            indx = binary_search(bit.n, 2*x+1)+1\n            res += bit.search(indx)\n            indx = binary_search(bit.n, x)+1\n            bit.update(indx)\n        return res\n\ndef binary_search(lt, target):\n    l, r = 0, len(lt)\n    while l<r:\n        m = l + ((r-l)>>1)\n        if target<=lt[m]:\n            r = m\n        else:\n            l = m+1\n    return l\n\ndef binary_search_new(lt, target):\n    l, r = 0, len(lt)\n    while l<r:\n        m = l + ((r-l)>>1)\n        if target<=lt[m]:\n            r = m\n        else:\n            l = m+1\n    return l\n\ndef binary_search_new2(lt, target):\n    l, r = 0, len(lt)\n    while l<r:\n        m = l + ((r-l)>>1)\n        if target<=lt[m]:\n            r = m\n        else:\n            l = m+1\n    return l\n\ndef binary_search_new3(lt, target):\n    l, r = 0, len(lt)\n    while l<r:\n        m = l + ((r-l)>>1)\n        if target<=lt[m]:\n            r = m\n        else:\n            l = m+1\n    return l\n\ndef binary_search_new4(lt, target):\n    l, r = 0, len(lt)\n    while l<r:\n        m = l + ((r-l)>>1)\n        if target<=lt[m]:\n            r = m\n        else:\n            l = m+1\n    return l\n\ndef binary_search_new5(lt, target):\n    l"
    },
    {
        "question_id":495,
        "optimized_code":"class Solution:\n    def findPoisonedDuration(self, timeSeries: List[int], duration: int) -> int:\n        n = len(timeSeries)\n        if n == 0:\n            return 0\n        res = 0\n        if duration > 0:\n            for i in range(n - 1):\n                res += min(duration, timeSeries[i + 1] - timeSeries[i])\n        return res + duration"
    },
    {
        "question_id":496,
        "optimized_code":"class Solution:\n    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        stack = []\n        for i in nums1:\n            while stack and i > stack[-1]:\n                stack.pop()\n            if stack:\n                stack.append(i)\n        return [stack.pop() for i in nums2 if i in stack]"
    },
    {
        "question_id":830,
        "optimized_code":"class Solution:\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\n        res = 0\n        for i in range(len(points) - 2):\n            for j in range(i + 1, len(points) - 1):\n                for k in range(j + 1, len(points)):\n                    u1, v1 = points[i][0] - points[j][0], points[i][1] - points[j][1]\n                    u2, v2 = points[j][0] - points[k][0], points[j][1] - points[k][1]\n                    u3, v3 = points[k][0] - points[i][0], points[k][1] - points[i][1]\n                    area = abs(u1 * v2 - u2 * v1) \/ 2\n                    res = max(res, area)\n        return res"
    },
    {
        "question_id":836,
        "optimized_code":"class Solution:\n    def racecar(self, target: int) -> int:\n        \"\"\"\n        cache or something\n        \"\"\"\n        cache = {0: 0}\n        q = deque()\n        \n        q.append((0, 1))\n        res = 0\n        while q:\n            for _ in range(len(q)):\n                pos, speed = q.popleft()\n                if (pos, speed) in cache:\n                    continue\n                cache[pos] = res\n                res += 1\n                \n                q.append((pos + speed, speed *2))\n                q.append((pos, -1 if speed > 0 else 1))\n                \n            \n            res += 1\n        \n        return res"
    },
    {
        "question_id":861,
        "optimized_code":"class Solution:\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\n        for i in range(len(image)):\n            image[i] = (image[i][::-1])\n        for j in range(0, len(image)):\n            for k in range(0, len(image[j])):\n                if image[j][k] == 0:\n                    image[j][k] = 1 \n                else:\n                    image[j][k] = 0\n        return image"
    },
    {
        "question_id":741,
        "optimized_code":"class Solution:\n    def cherryPickup(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        dp[0][0] = grid[0][0]\n\n        for k in range(1, n + 1):\n            for x1 in range(max(0, k - (n - 1)), min(n, k + 1)):\n                for x2 in range(max(0, k - (n - 1)), min(n, k + 1)):\n                    y1, y2 = k - x1, k - x2\n                    if grid[x1][y1] == -1 or grid[x2][y2] == -1:\n                        continue\n\n                    best = -float('inf')\n                    for d1 in [0, 1]:\n                        for d2 in [0, 1]:\n                            px1, px2 = x1 - d1, x2 - d2\n                            if px1 >= 0 and px2 >= 0:\n                                best = max(best, dp[k-1][px1][px2])\n\n                    if best == -float('inf'):\n                        continue\n\n                    dp[k][x1][x2] = best + grid[x1][y1]\n                    if x1!= x2:\n                        dp[k][x1][x2] += grid[x2][y2]\n\n        return max(0, dp[n][n-1][n-1])"
    },
    {
        "question_id":750,
        "optimized_code":"class Solution:\n    def containVirus(self, mat: List[List[int]]) -> int:\n        m, n = len(mat), len(mat[0])\n        DIRECTIONS = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        \n        def dfs(i, j, visited):\n            if not (0 <= i < m and 0 <= j < n) or (i, j) in visited:\n                return set(), 0\n            if mat[i][j] == 2:\n                return set(), 0\n            elif mat[i][j] == 0:\n                return {(i, j)}, 1\n            \n            visited.add((i, j))\n            infected, walls = set(), 0\n            for dx, dy in DIRECTIONS:\n                ni, nj = i + dx, j + dy\n                next_infected, next_walls = dfs(ni, nj, visited)\n                infected |= next_infected\n                walls += next_walls\n            return infected, walls\n        \n        def quarantine(i, j):\n            if 0 <= i < m and 0 <= j < n and mat[i][j] == 1:\n                mat[i][j] = 2\n                for dx, dy in DIRECTIONS:\n                    quarantine(i + dx, j + dy)\n        \n        ans = 0\n        while True:\n            visited, regions = set(), []\n            for i in range(m):\n                for j in range(n):\n                    if mat[i][j] == 1 and (i, j) not in visited:\n                        infected, walls = dfs(i, j, visited)\n                        if infected:\n                            regions.append((infected, walls, (i, j)))\n            \n            if not regions:\n                break\n            \n            regions.sort(key=lambda x: (-len(x[0]), x[1]))\n            max_infected, max_walls, start = regions[0]\n            ans += max_walls\n            quarantine(*start)\n            \n            for region in regions[1:]:\n                for i, j in region[0]:\n                    mat[i][j] = 1\n        \n        return ans"
    },
    {
        "question_id":699,
        "optimized_code":"class Node:\n    def __init__(self, l, r):\n        self.l = l\n        self.r = r\n        self.v = 0\n        self.add = 0\n        self.left = None\n        self.right = None\n\nclass SegmentTree:\n    def __init__(self):\n        self.root = Node(1, int(1e9))\n\n    def modify(self, l, r, v, node=None):\n        if node is None:\n            node = self.root\n        if l > r:\n            return\n        if node.l >= l and node.r <= r:\n            node.v = v\n            node.add = v\n            return\n        self.pushdown(node)\n        if l <= node.mid:\n            self.modify(l, r, v, node.left)\n        if r > node.mid:\n            self.modify(l, r, v, node.right)\n        self.pushup(node)\n\n    def query(self, l, r, node=None):\n        if node is None:\n            node = self.root\n        if l > r:\n            return 0\n        if node.l >= l and node.r <= r:\n            return node.v\n        self.pushdown(node)\n        v = 0\n        if l <= node.mid:\n            v = max(v, self.query(l, r, node.left))\n        if r > node.mid:\n            v = max(v, self.query(l, r, node.right))\n        return v\n\n    def pushup(self, node):\n        if node.left and node.right:\n            node.v = max(node.left.v, node.right.v)\n\n    def pushdown(self, node):\n        if node.left is None:\n            node.left = Node(node.l, node.mid)\n        if node.right is None:\n            node.right = Node(node.mid + 1, node.r)\n        if node.add!= 0:\n            node.left.add = node.add\n            node.right.add = node.add\n            node.left.v = node.add\n            node.right.v = node.add\n            node.add = 0\n\nclass Solution:\n    def fallingSquares(self, positions):\n        ans = []\n        tree = SegmentTree()\n        mx = 0\n        for pos in positions:\n            l, w = pos\n            r = l + w - 1\n            h = tree.query(l, r) + w\n            mx = max(mx, h)\n            ans.append(mx)"
    },
    {
        "question_id":779,
        "optimized_code":"from bisect import insort\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        st=sorted(arr)\n        ans=0\n        for n in arr:\n            insort(st,n)\n            if st==st[:len(st)]:\n                ans += 1\n        return ans"
    },
    {
        "question_id":759,
        "optimized_code":"class Solution:\n    def intersectionSizeTwo(self, intervals: List[List[int]]) -> int:\n        intervals.sort(key=lambda x:x[1])\n        return len([i for i in intervals if i[0] <= intervals[0][1] and i[1] >= intervals[0][0]])"
    },
    {
        "question_id":854,
        "optimized_code":"class Solution:\n    def largestIsland(self, grid: List[List[int]]) -> int:\n        def getArea(grid, row, col):\n            if (row, col) not in visited:\n                visited.add((row, col))\n                return 1\n            else:\n                return 0\n        def findAndSetArea(grid, row, col):\n            queue = [(row, col)]\n            visited = set()\n            visited.add((row, col))\n\n            area = 0\n            while queue:\n                row, col = queue.pop(0)\n                area += 1\n                for direction in directions:\n                    nextRow, nextCol = row + direction[0], col + direction[1]\n                    if 0 <= nextRow < len(grid) and 0 <= nextCol < len(grid[0]) and grid[nextRow][nextCol] and (nextRow, nextCol) not in visited:\n                        queue.append((nextRow, nextCol))\n                        grid[nextRow][nextCol] = -1\n                        visited.add((nextRow, nextCol))\n            for r, c in visited:\n                positionToArea[(r, c)] = [uniqueKey, area]\n            return area\n\n        maxArea = 0\n        uniqueKey = 0\n        positionToArea = {}\n        directions = {(-1, 0), (1, 0), (0, -1), (0, 1)}\n        for row in range(len(grid)):\n            for col in range(len(grid[0])):\n                if grid[row][col] == 1:\n                    area = findAndSetArea(grid, row, col)\n                    uniqueKey += 1\n                    maxArea = max(maxArea, area)\n                elif grid[row][col] == 0:\n                    areaWithThis0 = 1\n                    keys = set()\n                    for direction in directions:\n                        nextRow, nextCol = row + direction[0], col + direction[1]\n                        key, area = positionToArea.get((nextRow, nextCol), [-1, 0])\n                        if key not in keys:\n                            keys.add(key)\n                            areaWithThis0 += area\n                    maxArea = max(maxArea, areaWithThis0)\n        for row, col in positionToArea:\n            areaWithThis0 = 1\n            keys = set()\n            for direction in directions:\n                nextRow, nextCol = row + direction"
    },
    {
        "question_id":855,
        "optimized_code":"class Solution:\n    def uniqueLetterString(self, s: str) -> int:\n        last_exists = collections.defaultdict(lambda: [-1, -1])\n        res = 0\n        for i, c in enumerate(s):\n            last_exists[c][0], last_exists[c][1] = i, last_exists[c][0]\n            for _, exists in last_exists.items(): res += exists[0] - exists[1]\n        return res"
    },
    {
        "question_id":856,
        "optimized_code":"class Solution:\n    def consecutiveNumbersSum(self, n: int) -> int:\n        w = 0\n        k = 1\n        while k * (k + 1) \/ 2 <= n:\n            if (n - k * (k - 1) \/ 2) % k == 0:\n                w += 1\n            k += 1\n\n        return w"
    },
    {
        "question_id":564,
        "optimized_code":"class Solution:\n    def nearestPalindromic(self, n: str) -> str:\n        return self.half_to_palindrome(n, len(n) % 2 == 0)\n\n    def half_to_palindrome(self, left: int, even: bool) -> int:\n        res = left\n        if not even:\n            left = left \/\/ 10\n        while left > 0:\n            res = res * 10 + left % 10\n            left \/\/= 10\n        return res"
    },
    {
        "question_id":552,
        "optimized_code":"class Solution:\n    def checkRecord(self, n: int) -> int:\n        MOD = 10**9 + 7\n        dp = [[[-1]*3 for _ in range(2)] for _ in range(n+1)]\n        def helper(a, l, i):\n            if i == n:\n                return 1\n            if dp[i][a][l]!=-1:\n                return dp[i][a][l]\n            total = 0\n            \n            # Add an 'A' if less than 1 absence\n            if a < 1:\n                total += helper(a + 1, 0, i + 1)\n            \n            # Add an 'L' if less than 2 consecutive late days\n            if l < 2:\n                total += helper(a, l + 1, i + 1)\n            \n            # Add a 'P'\n            total += helper(a, 0, i + 1)\n            dp[i][a][l] = total % MOD\n            return dp[i][a][l]\n        \n        return helper(0, 0, 0)"
    },
    {
        "question_id":938,
        "optimized_code":"class Solution:\n  def atMostNGivenDigitSet(self, digits: List[str], n: int) -> int:\n    ans = 0\n    num = str(n)\n    for i in range(1, len(num)):\n      ans += pow(len(digits), i)\n    for i, c in enumerate(num):\n      dHasSameNum = False\n      for digit in digits:\n        if digit[0] < c:\n          ans += pow(len(digits), len(num) - i - 1)\n        elif digit[0] == c:\n          dHasSameNum = True\n      if not dHasSameNum:\n        return ans\n    return ans + 1"
    },
    {
        "question_id":939,
        "optimized_code":"class Solution:\n    def numPermsDISequence(self, s: str) -> int:\n        mem=defaultdict(int)\n        def dfs(i,val=0):\n            if i==len(s):\n                return 1\n            if (i,val) in mem:\n                return mem[i,val]\n            p=0\n            if s[i]==\"D\":\n                for ind in range(0,val+1):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            else:\n                for ind in range(val+1,i+2):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            mem[i,val]=p\n            return p\n        return dfs(0)\n\n#### Output:"
    }
]