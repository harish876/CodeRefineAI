[
    {
        "question_id": 131,
        "optimized_code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        res = []\n        def is_palindrome(sub):\n            return sub == sub[::-1]\n\n        def backtrack(i, curr):\n            if i == len(s):\n                res.append(curr.copy())\n                return\n\n            for j in range(i, len(s)):\n                sub = s[i:j+1]\n                if is_palindrome(sub):\n                    curr.append(sub)\n                    backtrack(j+1, curr)\n                    curr.pop()\n\n        backtrack(0, [])\n        return res"
    },
    {
        "question_id": 132,
        "optimized_code": "class Solution:\n    def minCut(self, s: str) -> int:\n        n = len(s)\n        dp = [float('inf')] * (n + 1)\n        dp[n] = -1\n        for i in range(n - 1, -1, -1):\n            for j in range(i, n):\n                if s[i:j + 1] == s[i:j + 1][::-1]:\n                    dp[i] = min(dp[i], 1 + dp[j + 1])\n        return dp[0]"
    },
    {
        "question_id": 135,
        "optimized_code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        n = len(ratings)\n        candies = [1] * n\n        for i in range(1, n):\n            if ratings[i] > ratings[i - 1]:\n                candies[i] = candies[i - 1] + 1\n        for i in range(n - 2, -1, -1):\n            if ratings[i] > ratings[i + 1]:\n                candies[i] = max(candies[i], candies[i + 1] + 1)\n        return sum(candies)"
    },
    {
        "question_id": 137,
        "optimized_code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        if len(nums) < 999999:\n            seen = set()\n            for num in reversed(nums):\n                if num in seen:\n                    continue\n                if nums.count(num) == 1:\n                    return num\n                seen.add(num)\n        else:\n            counts = {}\n            for num in nums:\n                counts[num] = counts.get(num, 0) + 1\n            for num, count in counts.items():\n                if count == 1:\n                    return num"
    },
    {
        "question_id": 138,
        "optimized_code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        if not head:\n            return None\n        \n        old_to_new = {}\n        \n        curr = head\n        while curr:\n            old_to_new[curr] = Node(curr.val)\n            curr = curr.next\n        \n        curr = head\n        while curr:\n            new_node = old_to_new[curr]\n            new_node.next = old_to_new.get(curr.next)\n            new_node.random = old_to_new.get(curr.random)\n            curr = curr.next\n        \n        return old_to_new[head]"
    },
    {
        "question_id": 140,
        "optimized_code": "class Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\n        wordSet = set(wordDict)\n        memo = {}\n\n        def backtrack(start):\n            if start == len(s):\n                return [\"\"]\n            \n            if start in memo:\n                return memo[start]\n\n            result = []\n            for end in range(start + 1, len(s) + 1):\n                word = s[start:end]\n                if word in wordSet:\n                    suffixes = backtrack(end)\n                    for suffix in suffixes:\n                        result.append(word + (\" \" + suffix if suffix else \"\"))\n\n            memo[start] = result\n            return result\n\n        return backtrack(0)"
    },
    {
        "question_id": 134,
        "optimized_code": "class Solution:\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\n        n = len(gas)\n        total_diff = 0\n        curr_diff = 0\n        start = 0\n        for i in range(n):\n            total_diff += gas[i] - cost[i]\n            curr_diff += gas[i] - cost[i]\n            if curr_diff < 0:\n                start = i + 1\n                curr_diff = 0\n        return start if total_diff >= 0 else -1"
    },
    {
        "question_id": 228,
        "optimized_code": "class Solution:\n    def summaryRanges(self, nums: List[int]) -> List[str]:\n        result = []\n        i = 0\n        while i < len(nums):\n            start = nums[i]\n            while i + 1 < len(nums) and nums[i + 1] == nums[i] + 1:\n                i += 1\n            if start != nums[i]:\n                result.append(f\"{start}->{nums[i]}\")\n            else:\n                result.append(str(start))\n            i += 1\n        return result"
    },
    {
        "question_id": 229,
        "optimized_code": "class Solution:\n    def majorityElement(self, nums: List[int]) -> List[int]:\n        count1, count2, candidate1, candidate2 = 0, 0, None, None\n        for n in nums:\n            if n == candidate1:\n                count1 += 1\n            elif n == candidate2:\n                count2 += 1\n            elif count1 == 0:\n                candidate1, count1 = n, 1\n            elif count2 == 0:\n                candidate2, count2 = n, 1\n            else:\n                count1, count2 = count1 - 1, count2 - 1\n        return [n for n in (candidate1, candidate2) if nums.count(n) > len(nums) // 3]"
    },
    {
        "question_id": 230,
        "optimized_code": "class Solution:\n    def kthSmallest(self, root, k):\n        stack = []\n        while True:\n            while root:\n                stack.append(root)\n                root = root.left\n            root = stack.pop()\n            k -= 1\n            if not k:\n                return root.val\n            root = root.right"
    },
    {
        "question_id": 231,
        "optimized_code": "class Solution:\n    def isPowerOfTwo(self, n: int) -> bool:\n        return n > 0 and (n & (n - 1)) == 0"
    },
    {
        "question_id": 233,
        "optimized_code": "class Solution:\n    def countDigitOne(self, n: int) -> int:\n        ans, i, number, lower_part = 0, 0, n, 0\n        while number > 0:\n            digit = number % 10\n            number //= 10\n            power_of_10 = 10 ** i\n            if digit > 1:\n                ans += power_of_10 + digit * i * (power_of_10 // 10)\n            elif digit == 1:\n                ans += lower_part + 1 + digit * i * (power_of_10 // 10)\n            else:\n                ans += digit * i * (power_of_10 // 10)\n            lower_part = n % (power_of_10 * 10)\n            i += 1\n        return ans"
    },
    {
        "question_id": 123,
        "optimized_code": "class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        n = len(prices)\n        dp = [[[0] * 3 for _ in range(2)] for _ in range(n + 1)]\n\n        for i in range(n - 1, -1, -1):\n            for j in range(2):\n                for k in range(1, 3):\n                    if j == 0:\n                        dp[i][j][k] = max(-prices[i] + dp[i + 1][1][k], dp[i + 1][0][k])\n                    else:\n                        dp[i][j][k] = max(prices[i] + dp[i + 1][0][k - 1], dp[i + 1][1][k])\n\n        return dp[0][0][2]"
    },
    {
        "question_id": 125,
        "optimized_code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        alphanumeric_string = ''.join(c.lower() for c in s if c.isalnum())\n        return alphanumeric_string == alphanumeric_string[::-1]"
    },
    {
        "question_id": 128,
        "optimized_code": "class Solution:\n    def longestConsecutive(self, nums: List[int]) -> int:\n        numset = set(nums)\n        longest = 0\n        for num in numset:\n            if num - 1 not in numset:\n                length = 1\n                while num + length in numset:\n                    length += 1\n                longest = max(longest, length)\n        return longest"
    },
    {
        "question_id": 130,
        "optimized_code": "class Solution:\n    def solve(self, board: List[List[str]]) -> None:\n        M, N = len(board), len(board[0])\n\n        def dfs(i, j):\n            if 0 <= i < M and 0 <= j < N and board[i][j] == 'O':\n                board[i][j] = 'T'\n                dfs(i + 1, j)\n                dfs(i - 1, j)\n                dfs(i, j + 1)\n                dfs(i, j - 1)\n\n        for i in range(M):\n            for j in range(N):\n                if i in [0, M - 1] or j in [0, N - 1]:\n                    dfs(i, j)\n\n        for i in range(M):\n            for j in range(N):\n                if board[i][j] == 'O':\n                    board[i][j] = 'X'\n                elif board[i][j] == 'T':\n                    board[i][j] = 'O'"
    },
    {
        "question_id": 82,
        "optimized_code": "class Solution:\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        dummy = ListNode(0, head)\n        prev, curr = dummy, head\n        while curr:\n            if curr.next and curr.val == curr.next.val:\n                while curr.next and curr.val == curr.next.val:\n                    curr = curr.next\n                prev.next = curr.next\n            else:\n                prev = curr\n            curr = curr.next\n        return dummy.next"
    },
    {
        "question_id": 84,
        "optimized_code": "class Solution:\n    def largestRectangleArea(self, heights: List[int]) -> int:\n        stack = []\n        max_area = 0\n        heights = [0] + heights + [0]\n\n        for i, h in enumerate(heights):\n            while stack and heights[stack[-1]] > h:\n                height = heights[stack.pop()]\n                width = i - stack[-1] - 1\n                max_area = max(max_area, height * width)\n            stack.append(i)\n\n        return max_area"
    },
    {
        "question_id": 85,
        "optimized_code": "class Solution:\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\n        if not matrix:\n            return 0\n        m, n = len(matrix), len(matrix[0])\n        heights = [0] * n\n        max_area = 0\n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == '1':\n                    heights[j] += 1\n                else:\n                    heights[j] = 0\n            stack = [-1]\n            for j in range(n):\n                while stack[-1] != -1 and heights[stack[-1]] >= heights[j]:\n                    height = heights[stack.pop()]\n                    width = j - stack[-1] - 1\n                    max_area = max(max_area, height * width)\n                stack.append(j)\n            while stack[-1] != -1:\n                height = heights[stack.pop()]\n                width = n - stack[-1] - 1\n                max_area = max(max_area, height * width)\n        return max_area"
    },
    {
        "question_id": 87,
        "optimized_code": "class Solution:\n    def isScramble(self, s1: str, s2: str) -> bool:\n        n = len(s1)\n        dp = [[[False] * n for _ in range(n)] for _ in range(n + 1)]\n        for i in range(n):\n            for j in range(n):\n                dp[1][i][j] = s1[i] == s2[j]\n        for length in range(2, n + 1):\n            for i in range(n - length + 1):\n                for j in range(n - length + 1):\n                    for k in range(1, length):\n                        dp[length][i][j] |= (dp[k][i][j] and dp[length - k][i + k][j + k]) or (dp[k][i][j + length - k] and dp[length - k][i + k][j])\n        return dp[n][0][0]"
    },
    {
        "question_id": 88,
        "optimized_code": "class Solution:\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\n        p1 = m - 1\n        p2 = n - 1\n        p = m + n - 1\n        while p2 >= 0:\n            if p1 >= 0 and nums1[p1] > nums2[p2]:\n                nums1[p] = nums1[p1]\n                p1 -= 1\n            else:\n                nums1[p] = nums2[p2]\n                p2 -= 1\n            p -= 1"
    },
    {
        "question_id": 89,
        "optimized_code": "class Solution:\n    def grayCode(self, n: int) -> List[int]:\n        result = [0]\n        for i in range(n):\n            result += [x + (1 << i) for x in reversed(result)]\n        return result"
    },
    {
        "question_id": 90,
        "optimized_code": "class Solution:\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\n        ans = []\n        nums.sort()\n        def backtrack(index, subset):\n            ans.append(subset[:])\n            for i in range(index, len(nums)):\n                if i > index and nums[i] == nums[i-1]:\n                    continue\n                subset.append(nums[i])\n                backtrack(i + 1, subset)\n                subset.pop()\n        backtrack(0, [])\n        return ans"
    },
    {
        "question_id": 144,
        "optimized_code": "class Solution:\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        res = []\n        def dfs(node):\n            if not node:\n                return\n            res.append(node.val)\n            dfs(node.left)\n            dfs(node.right)\n        dfs(root)\n        return res"
    },
    {
        "question_id": 148,
        "optimized_code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n\n        slow, fast = head, head.next\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        mid = slow.next\n        slow.next = None\n\n        left = self.sortList(head)\n        right = self.sortList(mid)\n\n        dummy = ListNode(0)\n        curr = dummy\n\n        while left and right:\n            if left.val < right.val:\n                curr.next = left\n                left = left.next\n            else:\n                curr.next = right\n                right = right.next\n            curr = curr.next\n\n        curr.next = left or right\n\n        return dummy.next"
    },
    {
        "question_id": 149,
        "optimized_code": "class Solution:\n    def maxPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        if n <= 2:\n            return n\n        max_count = 0\n        for i in range(n):\n            slopes = {}\n            duplicates = 1\n            for j in range(i + 1, n):\n                if points[i] == points[j]:\n                    duplicates += 1\n                else:\n                    dx = points[j][0] - points[i][0]\n                    dy = points[j][1] - points[i][1]\n                    if dx == 0:\n                        slope = float('inf')\n                    else:\n                        slope = dy / dx\n                    slopes[slope] = slopes.get(slope, 0) + 1\n            max_count = max(max_count, duplicates)\n            for slope_count in slopes.values():\n                max_count = max(max_count, slope_count + duplicates)\n        return max_count"
    },
    {
        "question_id": 150,
        "optimized_code": "class Solution:\n    def evalRPN(self, tokens):\n        stack = []\n        for token in tokens:\n            if token == '+':\n                stack.append(stack.pop() + stack.pop())\n            elif token == '-':\n                op2 = stack.pop()\n                op1 = stack.pop()\n                stack.append(op1 - op2)\n            elif token == '*':\n                stack.append(stack.pop() * stack.pop())\n            elif token == '/':\n                op2 = stack.pop()\n                op1 = stack.pop()\n                stack.append(int(op1 / op2))\n            else:\n                stack.append(int(token))\n        return stack[0]"
    },
    {
        "question_id": 153,
        "optimized_code": "class Solution:\n    def findMin(self, arr: List[int]) -> int:\n        l, h = 0, len(arr) - 1\n        while l < h:\n            m = (l + h) // 2\n            if arr[m] > arr[h]:\n                l = m + 1\n            else:\n                h = m\n        return arr[l]"
    },
    {
        "question_id": 160,
        "optimized_code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        pA, pB = headA, headB\n        while pA != pB:\n            pA = pA.next if pA else headB\n            pB = pB.next if pB else headA\n        return pA"
    },
    {
        "question_id": 238,
        "optimized_code": "class Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        res = [1] * n\n        prefix = 1\n        for i in range(n):\n            res[i] = prefix\n            prefix *= nums[i]\n        postfix = 1\n        for i in range(n - 1, -1, -1):\n            res[i] *= postfix\n            postfix *= nums[i]\n        return res"
    },
    {
        "question_id": 239,
        "optimized_code": "from collections import deque\n\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        d = deque()\n        result = []\n        for i, num in enumerate(nums):\n            while d and nums[d[-1]] < num:\n                d.pop()\n            d.append(i)\n            if d[0] == i - k:\n                d.popleft()\n            if i >= k - 1:\n                result.append(nums[d[0]])\n        return result"
    },
    {
        "question_id": 241,
        "optimized_code": "class Solution:\n    def diffWaysToCompute(self, expression: str) -> List[int]:\n        if expression.isdigit():\n            return [int(expression)]\n        res = []\n        for i, s in enumerate(expression):\n            if s in \"+-*\":\n                left = self.diffWaysToCompute(expression[:i])\n                right = self.diffWaysToCompute(expression[i+1:])\n                for l in left:\n                    for r in right:\n                        if s == '+':\n                            res.append(l + r)\n                        elif s == '-':\n                            res.append(l - r)\n                        else:\n                            res.append(l * r)\n        return res"
    },
    {
        "question_id": 242,
        "optimized_code": "class Solution:\n    def isAnagram(self, s: str, t: str) -> bool:\n        if len(s) != len(t):\n            return False\n        count = {}\n        for char in s:\n            count[char] = count.get(char, 0) + 1\n        for char in t:\n            count[char] = count.get(char, 0) - 1\n        for val in count.values():\n            if val != 0:\n                return False\n        return True"
    },
    {
        "question_id": 31,
        "optimized_code": "class Solution:\n    def nextPermutation(self, nums: List[int]) -> None:\n        i = len(nums) - 2\n        while i >= 0 and nums[i] >= nums[i + 1]:\n            i -= 1\n        if i >= 0:\n            j = len(nums) - 1\n            while nums[j] <= nums[i]:\n                j -= 1\n            nums[i], nums[j] = nums[j], nums[i]\n        nums[i+1:] = reversed(nums[i+1:])"
    },
    {
        "question_id": 32,
        "optimized_code": "class Solution:\n    def longestValidParentheses(self, s: str) -> int:\n        max_len = 0\n        stack = [-1]\n        for i in range(len(s)):\n            if s[i] == '(':\n                stack.append(i)\n            else:\n                stack.pop()\n                if not stack:\n                    stack.append(i)\n                else:\n                    max_len = max(max_len, i - stack[-1])\n        return max_len"
    },
    {
        "question_id": 33,
        "optimized_code": "class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        l, r = 0, len(nums) - 1\n        while l <= r:\n            mid = (l + r) // 2\n            if nums[mid] == target:\n                return mid\n            if (nums[l] <= nums[mid]):\n                if nums[l] <= target < nums[mid]:\n                    r = mid - 1\n                else:\n                    l = mid + 1\n            else:\n                if nums[mid] < target <= nums[r]:\n                    l = mid + 1\n                else:\n                    r = mid - 1\n        return -1"
    },
    {
        "question_id": 34,
        "optimized_code": "class Solution:\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\n        l = bisect_left(nums, target)\n        if l == len(nums) or nums[l] != target:\n            return [-1, -1]\n        return [l, bisect_right(nums, target) - 1]"
    },
    {
        "question_id": 191,
        "optimized_code": "class Solution:\n    def hammingWeight(self, n: int) -> int:\n        return bin(n).count('1')"
    },
    {
        "question_id": 198,
        "optimized_code": "class Solution:\n    def rob(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n        if len(nums) <= 2:\n            return max(nums)\n        a, b = nums[0], max(nums[0], nums[1])\n        for i in range(2, len(nums)):\n            a, b = b, max(b, a + nums[i])\n        return b"
    },
    {
        "question_id": 199,
        "optimized_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\n        res = []\n        def dfs(node, level):\n            if not node:\n                return\n            if len(res) == level:\n                res.append(node.val)\n            dfs(node.right, level + 1)\n            dfs(node.left, level + 1)\n        dfs(root, 0)\n        return res"
    },
    {
        "question_id": 201,
        "optimized_code": "class Solution:\n    def rangeBitwiseAnd(self, left: int, right: int) -> int:\n        while left < right:\n            right &= (right - 1)\n        return right"
    },
    {
        "question_id": 202,
        "optimized_code": "class Solution:\n    def isHappy(self, n: int) -> bool:\n        seen = set()\n        while n != 1 and n not in seen:\n            seen.add(n)\n            n = sum(int(d)**2 for d in str(n))\n        return n == 1"
    },
    {
        "question_id": 204,
        "optimized_code": "import math\n\nclass Solution:\n    def countPrimes(self, n: int) -> int:\n        if n < 3:\n            return 0\n        primes = [True] * n\n        primes[0] = primes[1] = False\n        for i in range(2, int(math.sqrt(n)) + 1):\n            if primes[i]:\n                primes[i*i:n:i] = [False] * len(primes[i*i:n:i])\n        return sum(primes)"
    },
    {
        "question_id": 205,
        "optimized_code": "class Solution:\n    def isIsomorphic(self, s: str, t: str) -> bool:\n        s_map = {}\n        t_map = {}\n        for i in range(len(s)):\n            s_char = s[i]\n            t_char = t[i]\n            if s_char not in s_map and t_char not in t_map:\n                s_map[s_char] = t_char\n                t_map[t_char] = s_char\n            elif s_char in s_map and t_char in t_map:\n                if s_map[s_char] != t_char or t_map[t_char] != s_char:\n                    return False\n            else:\n                return False\n        return True"
    },
    {
        "question_id": 210,
        "optimized_code": "class Solution:\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\n        adj = [[] for _ in range(numCourses)]\n        indegree = [0] * numCourses\n        for course, pre in prerequisites:\n            adj[pre].append(course)\n            indegree[course] += 1\n        \n        queue = [i for i in range(numCourses) if indegree[i] == 0]\n        result = []\n        \n        while queue:\n            node = queue.pop(0)\n            result.append(node)\n            \n            for neighbor in adj[node]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    queue.append(neighbor)\n        \n        return result if len(result) == numCourses else []"
    },
    {
        "question_id": 214,
        "optimized_code": "class Solution:\n    def shortestPalindrome(self, s: str) -> str:\n        n = len(s)\n        for i in range(n, 0, -1):\n            if s[:i] == s[:i][::-1]:\n                return s[i:][::-1] + s"
    },
    {
        "question_id": 216,
        "optimized_code": "class Solution:\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\n        if 45 - (9 - k) * (10 - k) / 2 < n or k * (k + 1) / 2 > n:\n            return []\n\n        def backtrack(comb, start, remain):\n            if remain == 0 and len(comb) == k:\n                result.append(comb[:])\n                return\n            if len(comb) == k or remain < 0:\n                return\n            for i in range(start, 10):\n                comb.append(i)\n                backtrack(comb, i + 1, remain - i)\n                comb.pop()\n\n        result = []\n        backtrack([], 1, n)\n        return result"
    },
    {
        "question_id": 91,
        "optimized_code": "class Solution:\n    def numDecodings(self, s: str) -> int:\n        n = len(s)\n        dp = [0] * (n + 1)\n        dp[n] = 1\n        for i in range(n - 1, -1, -1):\n            if s[i] != '0':\n                dp[i] = dp[i + 1]\n                if i + 1 < n and (s[i] == '1' or (s[i] == '2' and s[i + 1] <= '6')):\n                    dp[i] += dp[i + 2]\n        return dp[0]"
    },
    {
        "question_id": 93,
        "optimized_code": "class Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        def isValid(segment):\n            return 0 <= int(segment) <= 255 and (segment == '0' or not segment.startswith('0'))\n\n        def backtrack(start, dots, current_ip):\n            if dots == 4:\n                if start == len(s):\n                    result.append(current_ip[:-1])\n                return\n\n            for i in range(start, min(start + 3, len(s))):\n                segment = s[start:i + 1]\n                if isValid(segment):\n                    backtrack(i + 1, dots + 1, current_ip + segment + '.')\n\n        result = []\n        backtrack(0, 0, '')\n        return result"
    },
    {
        "question_id": 127,
        "optimized_code": "class Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\n        wordList = set(wordList)\n        if endWord not in wordList:\n            return 0\n        queue = [(beginWord, 1)]\n        while queue:\n            word, length = queue.pop(0)\n            if word == endWord:\n                return length\n            for i in range(len(word)):\n                for char in 'abcdefghijklmnopqrstuvwxyz':\n                    new_word = word[:i] + char + word[i+1:]\n                    if new_word in wordList:\n                        wordList.remove(new_word)\n                        queue.append((new_word, length + 1))\n        return 0"
    },
    {
        "question_id": 81,
        "optimized_code": "class Solution:\n    def search(self, nums: List[int], target: int) -> bool:\n        l, r = 0, len(nums) - 1\n        while l <= r:\n            mid = (l + r) // 2\n            if nums[mid] == target:\n                return True\n            if nums[l] == nums[mid] == nums[r]:\n                l += 1\n                r -= 1\n            elif nums[l] <= nums[mid]:\n                if nums[l] <= target < nums[mid]:\n                    r = mid - 1\n                else:\n                    l = mid + 1\n            else:\n                if nums[mid] < target <= nums[r]:\n                    l = mid + 1\n                else:\n                    r = mid - 1\n        return False"
    },
    {
        "question_id": 151,
        "optimized_code": "class Solution:\n    def reverseWords(self, s: str) -> str:\n        return \" \".join(s.split()[::-1])"
    },
    {
        "question_id": 152,
        "optimized_code": "class Solution:\n    def maxProduct(self, nums: List[int]) -> int:\n        max_prod = float('-inf')\n        prefix, suffix = 1, 1\n        n = len(nums)\n        for i in range(n):\n            prefix = (prefix or 1) * nums[i]\n            suffix = (suffix or 1) * nums[n - i - 1]\n            max_prod = max(max_prod, prefix, suffix)\n        return max_prod"
    },
    {
        "question_id": 95,
        "optimized_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def generateTrees(self, n: int) -> List[TreeNode]:\n        def dfs(l, r):\n            if l > r: return [None]\n            return [TreeNode(m, left, right)\n                    for m in range(l, r + 1)\n                    for left in dfs(l, m - 1)\n                    for right in dfs(m + 1, r)]\n        return dfs(1, n) if n else []"
    },
    {
        "question_id": 96,
        "optimized_code": "class Solution:\n    def numTrees(self, n: int) -> int:\n        dp = [0] * (n + 1)\n        dp[0] = dp[1] = 1\n        for i in range(2, n + 1):\n            for j in range(1, i + 1):\n                dp[i] += dp[j - 1] * dp[i - j]\n        return dp[n]"
    },
    {
        "question_id": 97,
        "optimized_code": "class Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        if len(s1) + len(s2) != len(s3):\n            return False\n        n, m, l = len(s1), len(s2), len(s3)\n        dp = [False] * (m + 1)\n        dp[0] = True\n        for j in range(1, m + 1):\n            dp[j] = dp[j - 1] and s2[j - 1] == s3[j - 1]\n        for i in range(1, n + 1):\n            dp[0] = dp[0] and s1[i - 1] == s3[i - 1]\n            for j in range(1, m + 1):\n                dp[j] = (dp[j - 1] and s2[j - 1] == s3[i + j - 1]) or (dp[j] and s1[i - 1] == s3[i + j - 1])\n        return dp[m]"
    },
    {
        "question_id": 1,
        "optimized_code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        num_map = {}\n        for index, num in enumerate(nums):\n            complement = target - num\n            if complement in num_map:\n                return [num_map[complement], index]\n            num_map[num] = index"
    },
    {
        "question_id": 5,
        "optimized_code": "class Solution:\n    def longestPalindrome(self, s: str) -> str:\n        longest = ''\n        for i in range(len(s)):\n            l, r = i, i\n            while l >= 0 and r < len(s) and s[l] == s[r]:\n                if (r - l + 1) > len(longest):\n                    longest = s[l:r+1]\n                l -= 1\n                r += 1\n            l, r = i, i + 1\n            while l >= 0 and r < len(s) and s[l] == s[r]:\n                if (r - l + 1) > len(longest):\n                    longest = s[l:r+1]\n                l -= 1\n                r += 1\n        return longest"
    },
    {
        "question_id": 6,
        "optimized_code": "class Solution:\n    def convert(self, s: str, numRows: int) -> str:\n        if numRows <= 1:\n            return s\n        rows = [''] * numRows\n        currRow, direction = 0, 1\n        for char in s:\n            rows[currRow] += char\n            if currRow == 0:\n                direction = 1\n            elif currRow == numRows - 1:\n                direction = -1\n            currRow += direction\n        return ''.join(rows)"
    },
    {
        "question_id": 8,
        "optimized_code": "class Solution:\n    def myAtoi(self, s: str) -> int:\n        s = s.strip()\n        sign = 1\n        result = 0\n        index = 0\n        n = len(s)\n        INT_MAX = 2**31 - 1\n        INT_MIN = -2**31\n\n        if index < n and (s[index] == '+' or s[index] == '-'):\n            sign = -1 if s[index] == '-' else 1\n            index += 1\n\n        while index < n and s[index].isdigit():\n            digit = int(s[index])\n            if result > INT_MAX // 10 or (result == INT_MAX // 10 and digit > 7):\n                return INT_MAX if sign == 1 else INT_MIN\n            result = result * 10 + digit\n            index += 1\n\n        return sign * result"
    },
    {
        "question_id": 309,
        "optimized_code": "class Solution(object):\n    def maxProfit(self, prices):\n        n = len(prices)\n        dp = [0] * (n + 2)\n        for i in range(n - 1, -1, -1):\n            dp[i] = max(max(prices[j] - prices[i] + dp[j + 2] for j in range(i + 1, n)), dp[i + 1])\n        return dp[0]"
    },
    {
        "question_id": 312,
        "optimized_code": "class Solution:\n    def maxCoins(self, nums: List[int]) -> int:\n        nums = [1] + nums + [1]\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n\n        for len_ in range(2, n):\n            for left in range(0, n - len_):\n                right = left + len_\n                for i in range(left + 1, right):\n                    dp[left][right] = max(dp[left][right], nums[left] * nums[i] * nums[right] + dp[left][i] + dp[i][right])\n\n        return dp[0][n - 1]"
    },
    {
        "question_id": 299,
        "optimized_code": "class Solution:\n    def getHint(self, secret: str, guess: str) -> str:\n        bulls = sum(s == g for s, g in zip(secret, guess))\n        secret_counts = {}\n        guess_counts = {}\n        for s, g in zip(secret, guess):\n            if s != g:\n                secret_counts[s] = secret_counts.get(s, 0) + 1\n                guess_counts[g] = guess_counts.get(g, 0) + 1\n        cows = 0\n        for digit, count in guess_counts.items():\n            if digit in secret_counts:\n                cows += min(count, secret_counts[digit])\n        return f'{bulls}A{cows}B'"
    },
    {
        "question_id": 301,
        "optimized_code": "class Solution:\n    def removeInvalidParentheses(self, s: str) -> List[str]:\n        def is_valid(s):\n            count = 0\n            for char in s:\n                if char == '(':\n                    count += 1\n                elif char == ')':\n                    count -= 1\n                if count < 0:\n                    return False\n            return count == 0\n\n        level = {s}\n        while True:\n            valid = list(filter(is_valid, level))\n            if valid:\n                return valid\n            next_level = set()\n            for item in level:\n                for i in range(len(item)):\n                    if item[i] in '()':\n                        next_level.add(item[:i] + item[i+1:])\n            level = next_level"
    },
    {
        "question_id": 162,
        "optimized_code": "class Solution:\n    def findPeakElement(self, nums: List[int]) -> int:\n        l, r = 0, len(nums) - 1\n        while l < r:\n            mid = (l + r) // 2\n            if nums[mid] > nums[mid+1]:\n                r = mid\n            else:\n                l = mid + 1\n        return l"
    },
    {
        "question_id": 164,
        "optimized_code": "class Solution:\n    def maximumGap(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n < 2:\n            return 0\n        a, b = min(nums), max(nums)\n        if a == b:\n            return 0\n        size = (b - a) / (n - 1) or 1\n        buckets = [[float('inf'), float('-inf')] for _ in range(n)]\n        for x in nums:\n            idx = int((x - a) / size)\n            buckets[idx][0] = min(buckets[idx][0], x)\n            buckets[idx][1] = max(buckets[idx][1], x)\n        gap = 0\n        prev = buckets[0][1]\n        for i in range(1, n):\n            if buckets[i][0] != float('inf'):\n                gap = max(gap, buckets[i][0] - prev)\n                prev = buckets[i][1]\n        return gap"
    },
    {
        "question_id": 166,
        "optimized_code": "class Solution:\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\n        if numerator == 0:\n            return \"0\"\n        sign = \"-\" if (numerator * denominator < 0) else \"\"\n        numerator, denominator = abs(numerator), abs(denominator)\n        integer_part = numerator // denominator\n        remainder = numerator % denominator\n        if remainder == 0:\n            return sign + str(integer_part)\n        decimal_part = \"\"\n        remainder_map = {}\n        while remainder != 0:\n            if remainder in remainder_map:\n                index = remainder_map[remainder]\n                return sign + str(integer_part) + \".\" + decimal_part[:index] + \"(\" + decimal_part[index:] + \")\"\n            remainder_map[remainder] = len(decimal_part)\n            remainder *= 10\n            decimal_part += str(remainder // denominator)\n            remainder %= denominator\n        return sign + str(integer_part) + \".\" + decimal_part"
    },
    {
        "question_id": 168,
        "optimized_code": "class Solution:\n    def convertToTitle(self, columnNumber: int) -> str:\n        result = ''\n        while columnNumber > 0:\n            columnNumber -= 1\n            result = chr(65 + (columnNumber % 26)) + result\n            columnNumber //= 26\n        return result"
    },
    {
        "question_id": 43,
        "optimized_code": "class Solution:\n    def multiply(self, num1: str, num2: str) -> str:\n        if num1 == \"0\" or num2 == \"0\":\n            return \"0\"\n        n, m = len(num1), len(num2)\n        product = [0] * (n + m)\n        \n        for i in range(n - 1, -1, -1):\n            carry = 0\n            for j in range(m - 1, -1, -1):\n                product[i + j + 1] += int(num1[i]) * int(num2[j]) + carry\n                carry = product[i + j + 1] // 10\n                product[i + j + 1] %= 10\n            product[i] += carry\n        \n        result = \"\".join(map(str, product))\n        while result[0] == '0' and len(result) > 1:\n            result = result[1:]\n        return result"
    },
    {
        "question_id": 50,
        "optimized_code": "class Solution:\n    def myPow(self, x: float, n: int) -> float:\n        if n == 0:\n            return 1.0\n        if n < 0:\n            x = 1 / x\n            n = -n\n        res = 1.0\n        while n > 0:\n            if n % 2 == 1:\n                res *= x\n            x *= x\n            n //= 2\n        return res"
    },
    {
        "question_id": 219,
        "optimized_code": "class Solution:\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\n        seen = {}\n        for i, num in enumerate(nums):\n            if num in seen and i - seen[num] <= k:\n                return True\n            seen[num] = i\n        return False"
    },
    {
        "question_id": 221,
        "optimized_code": "class Solution:\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\n        rows, cols = len(matrix), len(matrix[0])\n        dp = [[0] * (cols + 1) for _ in range(rows + 1)]\n        max_side = 0\n\n        for i in range(1, rows + 1):\n            for j in range(1, cols + 1):\n                if matrix[i - 1][j - 1] == '1':\n                    dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n                    max_side = max(max_side, dp[i][j])\n\n        return max_side * max_side"
    },
    {
        "question_id": 223,
        "optimized_code": "class Solution:\n    def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -> int:\n        area_a = (ax2 - ax1) * (ay2 - ay1)\n        area_b = (bx2 - bx1) * (by2 - by1)\n        \n        x_overlap = max(0, min(ax2, bx2) - max(ax1, bx1))\n        y_overlap = max(0, min(ay2, by2) - max(ay1, by1))\n        \n        return area_a + area_b - x_overlap * y_overlap"
    },
    {
        "question_id": 107,
        "optimized_code": "from collections import deque\n\nclass Solution:\n    def levelOrderBottom(self, root):\n        if not root:\n            return []\n        q = deque([root])\n        res = []\n        while q:\n            level = []\n            for _ in range(len(q)):\n                node = q.popleft()\n                level.append(node.val)\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n            res.insert(0, level)\n        return res"
    },
    {
        "question_id": 109,
        "optimized_code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        def to_array(head):\n            arr = []\n            while head:\n                arr.append(head.val)\n                head = head.next\n            return arr\n\n        def build_tree(arr):\n            if not arr:\n                return None\n            mid = len(arr) // 2\n            root = TreeNode(arr[mid])\n            root.left = build_tree(arr[:mid])\n            root.right = build_tree(arr[mid+1:])\n            return root\n\n        return build_tree(to_array(head))"
    },
    {
        "question_id": 268,
        "optimized_code": "class Solution:\n    def missingNumber(self, nums: List[int]) -> int:\n        n = len(nums)\n        return n * (n + 1) // 2 - sum(nums)"
    },
    {
        "question_id": 172,
        "optimized_code": "class Solution:\n    def trailingZeroes(self, n: int) -> int:\n        ans = 0\n        while n > 0:\n            n //= 5\n            ans += n\n        return ans"
    },
    {
        "question_id": 179,
        "optimized_code": "class Solution:\n    def largestNumber(self, nums: List[int]) -> str:\n        from functools import cmp_to_key\n        nums = sorted(nums, key=cmp_to_key(lambda a, b: 1 if str(a) + str(b) < str(b) + str(a) else -1))\n        return str(int(\"\".join(map(str, nums))))"
    },
    {
        "question_id": 187,
        "optimized_code": "class Solution:\n    def findRepeatedDnaSequences(self, s: str) -> List[str]:\n        if len(s) < 10:\n            return []\n        seen = set()\n        repeated = set()\n        for i in range(len(s) - 9):\n            sub = s[i:i+10]\n            if sub in seen:\n                repeated.add(sub)\n            else:\n                seen.add(sub)\n        return list(repeated)"
    },
    {
        "question_id": 12,
        "optimized_code": "class Solution:\n    def intToRoman(self, num: int) -> str:\n        roman_map = {1: 'I', 4: 'IV', 5: 'V', 9: 'IX', 10: 'X', 40: 'XL', 50: 'L', 90: 'XC', 100: 'C', 400: 'CD', 500: 'D', 900: 'CM', 1000: 'M'}\n        integers = list(roman_map.keys())\n        integers.reverse()\n        roman_values = list(roman_map.values())\n        roman_values.reverse()\n        result = ''\n        for i in range(len(integers)):\n            count = num // integers[i]\n            if count:\n                result += roman_values[i] * count\n                num %= integers[i]\n        return result"
    },
    {
        "question_id": 13,
        "optimized_code": "class Solution:\n    def romanToInt(self, s: str) -> int:\n        roman_map = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\n        result = 0\n        prev_value = 0\n        for i in range(len(s) - 1, -1, -1):\n            curr_value = roman_map[s[i]]\n            if curr_value < prev_value:\n                result -= curr_value\n            else:\n                result += curr_value\n            prev_value = curr_value\n        return result"
    },
    {
        "question_id": 18,
        "optimized_code": "class Solution:\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\n        nums.sort()\n        res = []\n        n = len(nums)\n        for i in range(n - 3):\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n            for j in range(i + 1, n - 2):\n                if j > i + 1 and nums[j] == nums[j - 1]:\n                    continue\n                left, right = j + 1, n - 1\n                while left < right:\n                    s = nums[i] + nums[j] + nums[left] + nums[right]\n                    if s == target:\n                        res.append([nums[i], nums[j], nums[left], nums[right]])\n                        while left < right and nums[left] == nums[left + 1]:\n                            left += 1\n                        while left < right and nums[right] == nums[right - 1]:\n                            right -= 1\n                        left += 1\n                        right -= 1\n                    elif s < target:\n                        left += 1\n                    else:\n                        right -= 1\n        return res"
    },
    {
        "question_id": 20,
        "optimized_code": "class Solution(object):\n    def isValid(self, s):\n        stack = []\n        pairs = {')': '(', '}': '{', ']': '['}\n        for c in s:\n            if c in pairs:\n                if not stack or stack[-1] != pairs[c]:\n                    return False\n                stack.pop()\n            else:\n                stack.append(c)\n        return not stack"
    },
    {
        "question_id": 113,
        "optimized_code": "class Solution:\n    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:\n        res = []\n        def dfs(node, current_sum, path):\n            if not node:\n                return\n            current_sum += node.val\n            path.append(node.val)\n            if not node.left and not node.right and current_sum == targetSum:\n                res.append(path[:])\n            else:\n                dfs(node.left, current_sum, path)\n                dfs(node.right, current_sum, path)\n            path.pop()\n        dfs(root, 0, [])\n        return res"
    },
    {
        "question_id": 115,
        "optimized_code": "class Solution:\n    def numDistinct(self, s: str, t: str) -> int:\n        n, m = len(s), len(t)\n        dp = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(n + 1):\n            dp[i][m] = 1\n        for i in range(n - 1, -1, -1):\n            for j in range(m - 1, -1, -1):\n                if s[i] == t[j]:\n                    dp[i][j] = dp[i + 1][j + 1] + dp[i + 1][j]\n                else:\n                    dp[i][j] = dp[i + 1][j]\n        return dp[0][0]"
    },
    {
        "question_id": 117,
        "optimized_code": "class Solution:\n    def connect(self, root: 'Node') -> 'Node':\n        if not root:\n            return root\n        \n        queue = [root]\n        \n        while queue:\n            level_size = len(queue)\n            for i in range(level_size):\n                node = queue.pop(0)\n                if i < level_size - 1:\n                    node.next = queue[0]\n                \n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n        \n        return root"
    },
    {
        "question_id": 118,
        "optimized_code": "class Solution:\n    def generate(self, numRows: int):\n        triangle = []\n        for i in range(numRows):\n            row = [1] * (i + 1)\n            if i > 1:\n                for j in range(1, i):\n                    row[j] = triangle[i - 1][j - 1] + triangle[i - 1][j]\n            triangle.append(row)\n        return triangle"
    },
    {
        "question_id": 119,
        "optimized_code": "class Solution:\n    def getRow(self, rowIndex: int) -> list[int]:\n        row = [1]\n        for i in range(1, rowIndex + 1):\n            new_row = [1]\n            for j in range(len(row) - 1):\n                new_row.append(row[j] + row[j + 1])\n            new_row.append(1)\n            row = new_row\n        return row"
    },
    {
        "question_id": 260,
        "optimized_code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> List[int]:\n        counts = {}\n        for num in nums:\n            counts[num] = counts.get(num, 0) + 1\n        return [num for num, count in counts.items() if count == 1]"
    },
    {
        "question_id": 264,
        "optimized_code": "import heapq\n\nclass Solution:\n    def nthUglyNumber(self, n: int) -> int:\n        heap = [1]\n        seen = {1}\n        \n        for _ in range(n):\n            ugly = heapq.heappop(heap)\n            \n            for factor in [2, 3, 5]:\n                new_ugly = ugly * factor\n                if new_ugly not in seen:\n                    heapq.heappush(heap, new_ugly)\n                    seen.add(new_ugly)\n        \n        return ugly"
    },
    {
        "question_id": 71,
        "optimized_code": "class Solution:\n    def simplifyPath(self, path: str) -> str:\n        stack = []\n        for component in path.split('/'):\n            if component == '..':\n                if stack:\n                    stack.pop()\n            elif component and component != '.':\n                stack.append(component)\n        return '/' + '/'.join(stack)"
    },
    {
        "question_id": 75,
        "optimized_code": "class Solution:\n    def sortColors(self, nums: List[int]) -> None:\n        nums.sort()"
    },
    {
        "question_id": 77,
        "optimized_code": "class Solution:\n    def combine(self, n: int, k: int) -> List[List[int]]:\n        res = []\n        def dfs(start, comb):\n            if len(comb) == k:\n                res.append(comb.copy())\n                return\n            for i in range(start, n + 1):\n                comb.append(i)\n                dfs(i + 1, comb)\n                comb.pop()\n        dfs(1, [])\n        return res"
    },
    {
        "question_id": 80,
        "optimized_code": "class Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        a = 0\n        for i in nums:\n            if a < 2 or i > nums[a - 2]:\n                nums[a] = i\n                a += 1\n        return a"
    },
    {
        "question_id": 21,
        "optimized_code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\n        dummy = ListNode()\n        tail = dummy\n        while list1 and list2:\n            if list1.val < list2.val:\n                tail.next = list1\n                list1 = list1.next\n            else:\n                tail.next = list2\n                list2 = list2.next\n            tail = tail.next\n        tail.next = list1 or list2\n        return dummy.next"
    },
    {
        "question_id": 27,
        "optimized_code": "class Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        i = 0\n        for j in range(len(nums)):\n            if nums[j] != val:\n                nums[i] = nums[j]\n                i += 1\n        return i"
    },
    {
        "question_id": 28,
        "optimized_code": "class Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        try:\n            return haystack.index(needle)\n        except ValueError:\n            return -1"
    },
    {
        "question_id": 29,
        "optimized_code": "class Solution:\n    def divide(self, dividend: int, divisor: int) -> int:\n        INT_MAX, INT_MIN = 2**31 - 1, -2**31\n        if dividend == INT_MIN and divisor == -1:\n            return INT_MAX\n        sign = (dividend < 0) != (divisor < 0)\n        dividend, divisor = abs(dividend), abs(divisor)\n        quotient = 0\n        while dividend >= divisor:\n            temp, i = divisor, 1\n            while dividend >= temp << 1:\n                if temp > INT_MAX >> 1:\n                    break\n                temp <<= 1\n                i <<= 1\n            dividend -= temp\n            quotient += i\n        if sign:\n            quotient = -quotient\n        return min(max(quotient, INT_MIN), INT_MAX)"
    },
    {
        "question_id": 30,
        "optimized_code": "class Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        if not s or not words:\n            return []\n\n        n = len(s)\n        k = len(words[0])\n        l = len(words) * k\n        word_counts = Counter(words)\n        result = []\n\n        for i in range(n - l + 1):\n            seen = Counter()\n            for j in range(len(words)):\n                word = s[i + j * k: i + (j + 1) * k]\n                if word in word_counts:\n                    seen[word] += 1\n                    if seen[word] > word_counts[word]:\n                        break\n                else:\n                    break\n            else:\n                if seen == word_counts:\n                    result.append(i)\n\n        return result"
    },
    {
        "question_id": 62,
        "optimized_code": "class Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        row = [1] * n\n        for i in range(1, m):\n            for j in range(1, n):\n                row[j] += row[j - 1]\n        return row[-1]"
    },
    {
        "question_id": 64,
        "optimized_code": "class Solution:\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        if not grid or not grid[0]:\n            return 0\n        \n        m, n = len(grid), len(grid[0])\n        \n        dp = [0] * n\n        dp[0] = grid[0][0]\n        \n        for j in range(1, n):\n            dp[j] = dp[j-1] + grid[0][j]\n        \n        for i in range(1, m):\n            dp[0] += grid[i][0]\n            for j in range(1, n):\n                dp[j] = grid[i][j] + min(dp[j-1], dp[j])\n        \n        return dp[n-1]"
    },
    {
        "question_id": 65,
        "optimized_code": "class Solution:\n    def isNumber(self, s: str) -> bool:\n        s = s.strip()\n        has_e = False\n        has_dot = False\n        has_num = False\n        num_after_e = True\n        \n        for i, c in enumerate(s):\n            if c.isdigit():\n                has_num = True\n                num_after_e = True\n            elif c == '.':\n                if has_e or has_dot:\n                    return False\n                has_dot = True\n            elif c == 'e' or c == 'E':\n                if has_e or not has_num:\n                    return False\n                has_e = True\n                num_after_e = False\n            elif c == '+' or c == '-':\n                if i != 0 and s[i-1] != 'e' and s[i-1] != 'E':\n                    return False\n            else:\n                return False\n        \n        return has_num and num_after_e"
    },
    {
        "question_id": 66,
        "optimized_code": "class Solution:\n    def plusOne(self, digits: List[int]) -> List[int]:\n        for i in range(len(digits) - 1, -1, -1):\n            digits[i] += 1\n            if digits[i] < 10:\n                return digits\n            digits[i] = 0\n        return [1] + digits"
    },
    {
        "question_id": 67,
        "optimized_code": "class Solution:\n    def addBinary(self, a: str, b: str) -> str:\n        i, j, carry, res = len(a) - 1, len(b) - 1, 0, ''\n        while i >= 0 or j >= 0 or carry:\n            carry += (int(a[i]) if i >= 0 else 0) + (int(b[j]) if j >= 0 else 0)\n            res += str(carry % 2)\n            carry //= 2\n            i -= 1\n            j -= 1\n        return res[::-1]"
    },
    {
        "question_id": 69,
        "optimized_code": "class Solution:\n    def mySqrt(self, x: int) -> int:\n        if x < 2:\n            return x\n        left, right = 2, x // 2\n        while left <= right:\n            mid = left + (right - left) // 2\n            square = mid * mid\n            if square > x:\n                right = mid - 1\n            elif square < x:\n                left = mid + 1\n            else:\n                return mid\n        return right"
    },
    {
        "question_id": 70,
        "optimized_code": "class Solution:\n    def climbStairs(self, n: int) -> int:\n        a, b = 1, 1\n        for _ in range(n - 1):\n            a, b = b, a + b\n        return b"
    },
    {
        "question_id": 51,
        "optimized_code": "class Solution:\n    def solveNQueens(self, n: int) -> list[list[str]]:\n        def backtrack(row, cols, diag1, diag2, board, solutions):\n            if row == n:\n                solutions.append([\"\".join(row) for row in board])\n                return\n\n            for col in range(n):\n                if col in cols or (row + col) in diag1 or (row - col) in diag2:\n                    continue\n\n                board[row][col] = \"Q\"\n                cols.add(col)\n                diag1.add(row + col)\n                diag2.add(row - col)\n\n                backtrack(row + 1, cols, diag1, diag2, board, solutions)\n\n                board[row][col] = \".\"\n                cols.remove(col)\n                diag1.remove(row + col)\n                diag2.remove(row - col)\n\n        solutions = []\n        board = [[\".\"] * n for _ in range(n)]\n        backtrack(0, set(), set(), set(), board, solutions)\n        return solutions"
    },
    {
        "question_id": 52,
        "optimized_code": "class Solution:\n    def totalNQueens(self, n: int) -> int:\n        cols = set()\n        pos_diag = set()\n        neg_diag = set()\n        count = 0\n\n        def backtrack(row):\n            nonlocal count\n            if row == n:\n                count += 1\n                return\n\n            for col in range(n):\n                if col in cols or (row + col) in pos_diag or (row - col) in neg_diag:\n                    continue\n\n                cols.add(col)\n                pos_diag.add(row + col)\n                neg_diag.add(row - col)\n                backtrack(row + 1)\n                cols.remove(col)\n                pos_diag.remove(row + col)\n                neg_diag.remove(row - col)\n\n        backtrack(0)\n        return count"
    },
    {
        "question_id": 53,
        "optimized_code": "class Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        max_so_far = nums[0]\n        curr_max = nums[0]\n        for i in range(1, len(nums)):\n            curr_max = max(nums[i], curr_max + nums[i])\n            max_so_far = max(max_so_far, curr_max)\n        return max_so_far"
    },
    {
        "question_id": 55,
        "optimized_code": "class Solution:\n    def canJump(self, nums: List[int]) -> bool:\n        reach = 0\n        for i, num in enumerate(nums):\n            if i > reach:\n                return False\n            reach = max(reach, i + num)\n        return True"
    },
    {
        "question_id": 58,
        "optimized_code": "class Solution:\n    def lengthOfLastWord(self, s: str) -> int:\n        return len(s.split()[-1]) if s.split() else 0"
    },
    {
        "question_id": 60,
        "optimized_code": "class Solution:\n    def getPermutation(self, n: int, k: int) -> str:\n        import math\n        nums = list(range(1, n + 1))\n        result = ''\n        k -= 1\n        for i in range(n - 1, -1, -1):\n            index = k // math.factorial(i)\n            result += str(nums.pop(index))\n            k %= math.factorial(i)\n        return result"
    },
    {
        "question_id": 282,
        "optimized_code": "class Solution:\n    def addOperators(self, num: str, target: int) -> List[str]:\n        n = len(num)\n        res = []\n\n        def backtrack(index, path, prev_num, current_val):\n            if index == n:\n                if current_val == target:\n                    res.append(path)\n                return\n\n            for i in range(index, n):\n                if i > index and num[index] == '0':\n                    break\n                current_num = int(num[index:i + 1])\n\n                if index == 0:\n                    backtrack(i + 1, str(current_num), current_num, current_num)\n                else:\n                    backtrack(i + 1, path + \"+\" + str(current_num), current_num, current_val + current_num)\n                    backtrack(i + 1, path + \"-\" + str(current_num), -current_num, current_val - current_num)\n                    backtrack(i + 1, path + \"*\" + str(current_num), prev_num * current_num, current_val - prev_num + prev_num * current_num)\n\n        backtrack(0, \"\", 0, 0)\n        return res"
    },
    {
        "question_id": 283,
        "optimized_code": "class Solution:\n    def moveZeroes(self, nums: List[int]) -> None:\n        i = 0\n        for j in range(len(nums)):\n            if nums[j] != 0:\n                nums[i], nums[j] = nums[j], nums[i]\n                i += 1"
    },
    {
        "question_id": 335,
        "optimized_code": "class Solution:\n    def isSelfCrossing(self, x: List[int]) -> bool:\n        n = len(x)\n        for i in range(3, n):\n            if x[i] >= x[i - 2] and x[i - 1] <= x[i - 3]:\n                return True\n            if i >= 4 and x[i - 1] == x[i - 3] and x[i] + x[i - 4] >= x[i - 2]:\n                return True\n            if i >= 5 and x[i] + x[i - 4] >= x[i - 2] and x[i - 1] + x[i - 5] >= x[i - 3] and x[i - 2] > x[i - 4] and x[i - 3] > x[i - 1]:\n                return True\n        return False"
    },
    {
        "question_id": 336,
        "optimized_code": "class Solution:\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\n        d = {w: i for i, w in enumerate(words)}\n        res = []\n        for i, word in enumerate(words):\n            n = len(word)\n            for j in range(n + 1):\n                s1 = word[:j]\n                s2 = word[j:]\n                if s1[::-1] in d and d[s1[::-1]] != i and s2 == s2[::-1]:\n                    res.append([i, d[s1[::-1]]])\n                if j > 0 and s2[::-1] in d and d[s2[::-1]] != i and s1 == s1[::-1]:\n                    res.append([d[s2[::-1]], i])\n        return res"
    },
    {
        "question_id": 338,
        "optimized_code": "class Solution:\n    def countBits(self, n: int) -> list[int]:\n        dp = [0] * (n + 1)\n        for i in range(1, n + 1):\n            dp[i] = dp[i >> 1] + (i & 1)\n        return dp"
    },
    {
        "question_id": 342,
        "optimized_code": "class Solution:\n    def isPowerOfFour(self, n: int) -> bool:\n        return n > 0 and (n & (n - 1)) == 0 and (n & 0x55555555) != 0"
    },
    {
        "question_id": 345,
        "optimized_code": "class Solution:\n    def reverseVowels(self, s: str) -> str:\n        vowels = set('aeiouAEIOU')\n        s = list(s)\n        i, j = 0, len(s) - 1\n        while i < j:\n            while i < j and s[i] not in vowels:\n                i += 1\n            while i < j and s[j] not in vowels:\n                j -= 1\n            if i < j:\n                s[i], s[j] = s[j], s[i]\n                i += 1\n                j -= 1\n        return ''.join(s)"
    },
    {
        "question_id": 521,
        "optimized_code": "class Solution:\n    def findLUSlength(self, a: str, b: str) -> int:\n        return -1 if a == b else max(len(a), len(b))"
    },
    {
        "question_id": 383,
        "optimized_code": "class Solution:\n    def canConstruct(self, ransomNote: str, magazine: str) -> bool:\n        from collections import Counter\n        magazine_counts = Counter(magazine)\n        for char in ransomNote:\n            if magazine_counts[char] <= 0:\n                return False\n            magazine_counts[char] -= 1\n        return True"
    },
    {
        "question_id": 389,
        "optimized_code": "class Solution:\n    def findTheDifference(self, s: str, t: str) -> str:\n        return chr(sum(ord(c) for c in t) - sum(ord(c) for c in s))"
    },
    {
        "question_id": 391,
        "optimized_code": "class Solution:\n    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\n        x1, y1 = float('inf'), float('inf')\n        x2, y2 = float('-inf'), float('-inf')\n        area = 0\n        corners = set()\n        for x, y, a, b in rectangles:\n            x1 = min(x1, x)\n            y1 = min(y1, y)\n            x2 = max(x2, a)\n            y2 = max(y2, b)\n            area += (a - x) * (b - y)\n            corners ^= {(x, y), (x, b), (a, y), (a, b)}\n        if len(corners) != 4 or (x1, y1) not in corners or (x1, y2) not in corners or (x2, y1) not in corners or (x2, y2) not in corners:\n            return False\n        return (x2 - x1) * (y2 - y1) == area"
    },
    {
        "question_id": 392,
        "optimized_code": "class Solution:\n    def isSubsequence(self, s: str, t: str) -> bool:\n        i = 0\n        for char in t:\n            if i < len(s) and char == s[i]:\n                i += 1\n        return i == len(s)"
    },
    {
        "question_id": 354,
        "optimized_code": "class Solution:\n    def maxEnvelopes(self, envelopes: List[List[int]]) -> int:\n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n        dp = []\n        for _, h in envelopes:\n            idx = bisect_left(dp, h)\n            if idx == len(dp):\n                dp.append(h)\n            else:\n                dp[idx] = h\n        return len(dp)"
    },
    {
        "question_id": 479,
        "optimized_code": "class Solution:\n    def largestPalindrome(self, n: int) -> int:\n        if n == 1: return 9\n        upper = 10 ** n - 1\n        lower = upper // 10\n        for a in range(upper, lower, -1):\n            p = int(str(a) + str(a)[::-1])\n            for x in range(upper, int(p ** 0.5) - 1, -1):\n                if p % x == 0 and p // x <= upper:\n                    return p % 1337"
    },
    {
        "question_id": 483,
        "optimized_code": "class Solution:\n    def smallestGoodBase(self, n: str) -> str:\n        n = int(n)\n        m_max = int((n).bit_length())\n        for m in range(m_max, 1, -1):\n            k = int(n**(1 / m))\n            if (k**(m + 1) - 1) // (k - 1) == n:\n                return str(k)\n        return str(n - 1)"
    },
    {
        "question_id": 485,
        "optimized_code": "class Solution:\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\n        max_length = 0\n        length = 0\n        for num in nums:\n            length = 0 if num == 0 else length + 1\n            max_length = max(max_length, length)\n        return max_length"
    },
    {
        "question_id": 409,
        "optimized_code": "from collections import Counter\nclass Solution:\n    def longestPalindrome(self, s: str) -> int:\n        counts = Counter(s)\n        length = 0\n        odd_present = False\n        for count in counts.values():\n            length += count // 2 * 2\n            if count % 2 != 0:\n                odd_present = True\n        return length + 1 if odd_present else length"
    },
    {
        "question_id": 410,
        "optimized_code": "class Solution:\n    def splitArray(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        s = [0] * (n + 1)\n        for i in range(n):\n            s[i + 1] = s[i] + nums[i]\n        f = [[float('inf')] * (k + 1) for _ in range(n + 1)]\n        f[0][0] = 0\n        for i in range(1, n + 1):\n            for kk in range(1, k + 1):\n                for j in range(1, i + 1):\n                    f[i][kk] = min(f[i][kk], max(s[i] - s[j - 1], f[j - 1][kk - 1]))\n        return f[n][k]"
    },
    {
        "question_id": 412,
        "optimized_code": "class Solution:\n    def fizzBuzz(self, n: int) -> List[str]:\n        return ['FizzBuzz' if i % 15 == 0 else 'Fizz' if i % 3 == 0 else 'Buzz' if i % 5 == 0 else str(i) for i in range(1, n + 1)]"
    },
    {
        "question_id": 414,
        "optimized_code": "class Solution:\n    def thirdMax(self, nums: List[int]) -> int:\n        nums = sorted(list(set(nums)), reverse=True)\n        if len(nums) >= 3:\n            return nums[2]\n        return nums[0]"
    },
    {
        "question_id": 472,
        "optimized_code": "class Solution:\n    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\n        word_set = set(words)\n        \n        def is_concatenated(word):\n            if not word:\n                return False\n            \n            dp = [False] * (len(word) + 1)\n            dp[0] = True\n            \n            for i in range(1, len(word) + 1):\n                for j in range(i):\n                    if dp[j] and word[j:i] in word_set:\n                        dp[i] = True\n                        break\n            return dp[len(word)]\n\n        return [word for word in words if is_concatenated(word)]"
    },
    {
        "question_id": 476,
        "optimized_code": "class Solution(object):\n    def findComplement(self, num):\n        mask = (1 << num.bit_length()) - 1\n        return num ^ mask"
    },
    {
        "question_id": 440,
        "optimized_code": "class Solution(object):\n    def findKthNumber(self, n, k):\n        curr = 1\n        k -= 1\n        while k > 0:\n            steps = 0\n            first, last = curr, curr + 1\n            while first <= n:\n                steps += min(n + 1, last) - first\n                first *= 10\n                last *= 10\n            if steps <= k:\n                curr += 1\n                k -= steps\n            else:\n                curr *= 10\n                k -= 1\n        return curr"
    },
    {
        "question_id": 441,
        "optimized_code": "class Solution:\n    def arrangeCoins(self, n: int) -> int:\n        l, r = 0, n\n        while l <= r:\n            mid = (l + r) // 2\n            coins = mid * (mid + 1) // 2\n            if coins == n:\n                return mid\n            if coins < n:\n                l = mid + 1\n            else:\n                r = mid - 1\n        return r"
    },
    {
        "question_id": 401,
        "optimized_code": "class Solution:\n    def readBinaryWatch(self, num: int) -> list[str]:\n        return [f\"{h}:{m:02d}\" for h in range(12) for m in range(60) if bin(h).count('1') + bin(m).count('1') == num]"
    },
    {
        "question_id": 404,
        "optimized_code": "class Solution:\n    def sumOfLeftLeaves(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        res = 0\n        if root.left:\n            if not root.left.left and not root.left.right:\n                res += root.left.val\n            else:\n                res += self.sumOfLeftLeaves(root.left)\n        res += self.sumOfLeftLeaves(root.right)\n        return res"
    },
    {
        "question_id": 405,
        "optimized_code": "class Solution:\n    def toHex(self, num: int) -> str:\n        if num == 0:\n            return \"0\"\n        hex_map = \"0123456789abcdef\"\n        res = \"\"\n        for _ in range(8):\n            digit = num & 0xf\n            res = hex_map[digit] + res\n            num >>= 4\n            if num == 0:\n                break\n        return res"
    },
    {
        "question_id": 363,
        "optimized_code": "import numpy as np\nfrom sortedcontainers import SortedList\nfrom typing import List\n\nclass Solution:\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\n        m, n = len(matrix), len(matrix[0])\n        max_sum = float('-inf')\n        for l in range(n):\n            row_sum = [0] * m\n            for r in range(l, n):\n                for i in range(m):\n                    row_sum[i] += matrix[i][r]\n                prefix_sum = 0\n                seen = SortedList([0])\n                for num in row_sum:\n                    prefix_sum += num\n                    target = prefix_sum - k\n                    idx = seen.bisect_left(target)\n                    if idx < len(seen):\n                        max_sum = max(max_sum, prefix_sum - seen[idx])\n                    seen.add(prefix_sum)\n        return max_sum"
    },
    {
        "question_id": 459,
        "optimized_code": "class Solution:\n    def repeatedSubstringPattern(self, s: str) -> bool:\n        n = len(s)\n        for i in range(1, n // 2 + 1):\n            if n % i == 0:\n                sub = s[:i]\n                if sub * (n // i) == s:\n                    return True\n        return False"
    },
    {
        "question_id": 461,
        "optimized_code": "class Solution:\n    def hammingDistance(self, x: int, y: int) -> int:\n        xor = x ^ y\n        distance = 0\n        while xor:\n            distance += xor & 1\n            xor >>= 1\n        return distance"
    },
    {
        "question_id": 463,
        "optimized_code": "class Solution:\n    def islandPerimeter(self, grid: List[List[int]]) -> int:\n        perimeter = 0\n        rows, cols = len(grid), len(grid[0])\n        for i in range(rows):\n            for j in range(cols):\n                if grid[i][j] == 1:\n                    perimeter += 4\n                    if i > 0 and grid[i-1][j] == 1:\n                        perimeter -= 2\n                    if j > 0 and grid[i][j-1] == 1:\n                        perimeter -= 2\n        return perimeter"
    },
    {
        "question_id": 466,
        "optimized_code": "class Solution:\n    def getMaxRepetitions(self, s1, n1, s2, n2):\n        r = {}\n        j = 0\n        cnt = 0\n        for k in range(1, n1 + 1):\n            for i in range(len(s1)):\n                if s1[i] == s2[j]:\n                    j += 1\n                    if j == len(s2):\n                        cnt += 1\n                        j = 0\n            if j in r:\n                p_k, p_cnt = r[j]\n                rem_k = n1 - p_k\n                repeat_cnt = (rem_k // (k - p_k)) * (cnt - p_cnt)\n                rem_cnt = 0\n                rem_k %= (k - p_k)\n                if rem_k > 0:\n                    for l in range(p_k, p_k + rem_k):\n                        for i in range(len(s1)):\n                            if s1[i] == s2[j]:\n                                j += 1\n                                if j == len(s2):\n                                    rem_cnt += 1\n                                    j = 0\n                return (p_cnt + repeat_cnt + rem_cnt) // n2\n            r[j] = (k, cnt)\n        return cnt // n2"
    },
    {
        "question_id": 685,
        "optimized_code": "class Solution:\n    def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:\n        n = len(edges)\n        parent = list(range(n + 1))\n        \n        def find(x):\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n\n        def union(x, y):\n            root_x = find(x)\n            root_y = find(y)\n            if root_x != root_y:\n                parent[root_y] = root_x\n                return True\n            return False\n            \n        in_degree = [0] * (n + 1)\n        for u, v in edges:\n            in_degree[v] += 1\n            \n        candidates = [edge for edge in reversed(edges) if in_degree[edge[1]] > 1]\n        \n        if candidates:\n            edges_without_candidate = [edge for edge in edges if edge != candidates[0]]\n            \n            parent = list(range(n + 1))\n            cycle = False\n            \n            for u, v in edges_without_candidate:\n                if find(u) == find(v):\n                    cycle = True\n                    break\n                union(u, v)\n                \n            if cycle:\n                return candidates[0]\n            else:\n                \n                \n                for u, v in reversed(edges):\n                  if in_degree[v]>1:\n                    return [u,v]\n                return []\n\n        else:\n            parent = list(range(n + 1))\n            last_edge = None\n            for u, v in edges:\n                if find(u) == find(v):\n                    last_edge = [u, v]\n                    \n                    break\n                union(u, v)\n            return last_edge"
    },
    {
        "question_id": 736,
        "optimized_code": "import re\n\nclass Solution:\n    def evaluate(self, expression: str) -> int:\n        def eval_expr(expr, scope):\n            if expr[0] == '(':\n                parts = re.findall(r'\\(|\\)|[A-Za-z0-9-]+', expr)\n                op = parts[1]\n                if op == 'let':\n                    new_scope = scope.copy()\n                    i = 2\n                    while i < len(parts) - 1:\n                        if parts[i+1] == ')':\n                            val = eval_expr(parts[i], new_scope) if parts[i][0] == '(' else (new_scope.get(parts[i], int(parts[i])))\n                            i+=1\n                            return val\n                        var = parts[i]\n                        i += 1\n                        val_expr = ''\n                        \n                        j = i\n                        balance = 0\n                        if parts[i] == '(':\n                            val_expr += parts[i]\n                            i += 1\n                            balance += 1\n                            while balance > 0:\n                                val_expr += parts[i]\n                                if parts[i] == '(':\n                                    balance += 1\n                                elif parts[i] == ')':\n                                    balance -= 1\n                                i += 1\n                        else:\n                            val_expr = parts[i]\n                            i+=1\n                        \n                        val = eval_expr(val_expr, new_scope) if val_expr[0] == '(' else (new_scope.get(val_expr, int(val_expr)))\n                        new_scope[var] = val\n\n                    return eval_expr(parts[-1], new_scope) if parts[-1][0] == '(' else (new_scope.get(parts[-1], int(parts[-1])))\n\n                elif op == 'add':\n                    val1 = eval_expr(parts[2], scope) if parts[2][0] == '(' else (scope.get(parts[2], int(parts[2])))\n                    val2 = eval_expr(parts[3], scope) if parts[3][0] == '(' else (scope.get(parts[3], int(parts[3])))\n                    return val1 + val2\n                elif op == 'mult':\n                    val1 = eval_expr(parts[2], scope) if parts[2][0] == '(' else (scope.get(parts[2], int(parts[2])))\n                    val2 = eval_expr(parts[3], scope) if parts[3][0] == '(' else (scope.get(parts[3], int(parts[3])))\n                    return val1 * val2\n            else:\n                return scope.get(expr, int(expr))\n\n        return eval_expr(expression, {})"
    },
    {
        "question_id": 973,
        "optimized_code": "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        m, n = len(stamp), len(target)\n        target = list(target)\n        q = []\n        A = []\n        match = [0] * (n - m + 1)\n        for i in range(n - m + 1):\n            stars = 0\n            for j in range(m):\n                if target[i+j] == stamp[j]:\n                    continue\n                elif target[i+j] == '?':\n                    stars += 1\n                else:\n                    stars = -1\n                    break\n            if stars == 0:\n                q.append(i)\n            match[i] = stars\n        \n        while q:\n            i = q.pop(0)\n            A.append(i)\n            for j in range(max(0, i - m + 1), min(n - m + 1, i + m)):\n                if match[j] >= 0:\n                    match[j] += 1\n                    if match[j] == m:\n                        q.append(j)\n                        \n        return A[::-1] if match.count(m) == n - m + 1 else []"
    },
    {
        "question_id": 975,
        "optimized_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\n        if not root:\n            return 0\n        \n        if root.val < low:\n            return self.rangeSumBST(root.right, low, high)\n        if root.val > high:\n            return self.rangeSumBST(root.left, low, high)\n        \n        return root.val + self.rangeSumBST(root.left, low, high) + self.rangeSumBST(root.right, low, high)"
    },
    {
        "question_id": 977,
        "optimized_code": "MOD = 10 ** 9 + 7\n\nclass Solution:\n    def distinctSubseqII(self, S):\n        last = {}\n        dp = 1\n        for i, c in enumerate(S):\n            new_dp = (2 * dp) % MOD\n            if c in last:\n                new_dp = (new_dp - dp + last[c]) % MOD\n            else:\n                new_dp = new_dp % MOD\n            last[c] = dp\n            dp = new_dp\n        return (dp - 1) % MOD"
    },
    {
        "question_id": 1013,
        "optimized_code": "class Solution:\n    def fib(self, n: int) -> int:\n        a, b = 0, 1\n        for _ in range(n):\n            a, b = b, a + b\n        return a"
    },
    {
        "question_id": 514,
        "optimized_code": "class Solution:\n    def findRotateSteps(self, ring: str, key: str) -> int:\n        n, m = len(ring), len(key)\n        pos = [[] for _ in range(26)]\n        for i, c in enumerate(ring):\n            pos[ord(c) - ord('a')].append(i)\n        dp = [0] * n\n        for k in reversed(range(m)):\n            next_dp = [float('inf')] * n\n            for i in range(n):\n                for p in pos[ord(key[k]) - ord('a')]:\n                    dist = min(abs(i - p), n - abs(i - p))\n                    next_dp[i] = min(next_dp[i], 1 + dist + dp[p])\n            dp = next_dp\n        return dp[0]"
    },
    {
        "question_id": 920,
        "optimized_code": "from collections import Counter\nfrom typing import List\n\nclass Solution:\n    def uncommonFromSentences(self, s1: str, s2: str) -> List[str]:\n        d = Counter(s1.split() + s2.split())\n        return [x for x in d if d[x] == 1]"
    },
    {
        "question_id": 35,
        "optimized_code": "class Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        l, r = 0, len(nums) - 1\n        while l <= r:\n            mid = (l + r) // 2\n            if nums[mid] == target:\n                return mid\n            if nums[mid] < target:\n                l = mid + 1\n            else:\n                r = mid - 1\n        return l"
    },
    {
        "question_id": 9,
        "optimized_code": "class Solution:\n    def isPalindrome(self, x: int) -> bool:\n        if x < 0 or (x % 10 == 0 and x != 0):\n            return False\n        rev = 0\n        while x > rev:\n            rev = rev * 10 + x % 10\n            x //= 10\n        return x == rev or x == rev // 10"
    },
    {
        "question_id": 10,
        "optimized_code": "class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        m, n = len(s), len(p)\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\n        dp[0][0] = True\n        for i in range(n):\n            if p[i] == '*' and dp[0][i - 1]:\n                dp[0][i + 1] = True\n        for i in range(m):\n            for j in range(n):\n                if p[j] == '.' or p[j] == s[i]:\n                    dp[i + 1][j + 1] = dp[i][j]\n                elif p[j] == '*':\n                    if p[j - 1] == '.' or p[j - 1] == s[i]:\n                        dp[i + 1][j + 1] = dp[i + 1][j - 1] or dp[i][j + 1] or dp[i+1][j-1]\n                    else:\n                        dp[i + 1][j + 1] = dp[i + 1][j - 1]\n                else:\n                    dp[i + 1][j + 1] = False\n        return dp[m][n]"
    },
    {
        "question_id": 218,
        "optimized_code": "class Solution:\n    def getSkyline(self, buildings: List[List[int]]) -> List[List[int]]:\n        events = []\n        for l, r, h in buildings:\n            events.append((l, -h, r))\n            events.append((r, 0, 0))\n        events.sort()\n\n        import heapq\n        heap = [(0, float('inf'))]\n        res = []\n        prev = 0\n\n        for x, neg_h, r in events:\n            while heap and heap[0][1] <= x:\n                heapq.heappop(heap)\n            if neg_h != 0:\n                heapq.heappush(heap, (neg_h, r))\n\n            curr_h = -heap[0][0]\n            if curr_h != prev:\n                res.append([x, curr_h])\n                prev = curr_h\n        return res"
    },
    {
        "question_id": 226,
        "optimized_code": "class Solution:\n    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        if not root:\n            return None\n        root.left, root.right = self.invertTree(root.right), self.invertTree(root.left)\n        return root"
    },
    {
        "question_id": 273,
        "optimized_code": "class Solution:\n    def numberToWords(self, num: int) -> str:\n        less_than_20 = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n        tens = [\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n        thousands = [\"\", \"Thousand\", \"Million\", \"Billion\"]\n\n        def helper(n):\n            if n < 20:\n                return less_than_20[n]\n            elif n < 100:\n                return tens[n // 10] + (\" \" + less_than_20[n % 10]) if n % 10 else tens[n // 10]\n            else:\n                return less_than_20[n // 100] + \" Hundred \" + helper(n % 100) if n % 100 else less_than_20[n // 100] + \" Hundred\"\n\n        if num == 0:\n            return \"Zero\"\n\n        result = []\n        for i in range(4):\n            num, remainder = divmod(num, 1000)\n            if remainder:\n                result.append(helper(remainder) + \" \" + thousands[i])\n\n        return \" \".join(result[::-1]).strip()"
    },
    {
        "question_id": 14,
        "optimized_code": "class Solution:\n    def longestCommonPrefix(self, strs: List[str]) -> str:\n        if not strs:\n            return \"\"\n        shortest = min(strs, key=len)\n        for i, char in enumerate(shortest):\n            for other in strs:\n                if other[i] != char:\n                    return shortest[:i]\n        return shortest"
    },
    {
        "question_id": 258,
        "optimized_code": "class Solution:\n    def addDigits(self, num: int) -> int:\n        return 0 if num == 0 else (num % 9) or 9"
    },
    {
        "question_id": 76,
        "optimized_code": "from collections import Counter\n\nclass Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        if not t or not s:\n            return \"\"\n\n        dict_t = Counter(t)\n        required = len(dict_t)\n\n        l, r = 0, 0\n        formed = 0\n        window_counts = {}\n        ans = float(\"inf\"), None, None\n\n        while r < len(s):\n            character = s[r]\n            window_counts[character] = window_counts.get(character, 0) + 1\n\n            if character in dict_t and window_counts[character] == dict_t[character]:\n                formed += 1\n\n            while l <= r and formed == required:\n                character = s[l]\n\n                if r - l + 1 < ans[0]:\n                    ans = (r - l + 1, l, r)\n\n                window_counts[character] -= 1\n                if character in dict_t and window_counts[character] < dict_t[character]:\n                    formed -= 1\n\n                l += 1    \n            r += 1\n\n        return \"\" if ans[0] == float(\"inf\") else s[ans[1] : ans[2] + 1]"
    },
    {
        "question_id": 68,
        "optimized_code": "class Solution:\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\n        res, line, width = [], [], 0\n        for w in words:\n            if width + len(w) + len(line) > maxWidth:\n                spaces = maxWidth - width\n                if len(line) > 1:\n                    q, r = divmod(spaces, len(line) - 1)\n                    for i in range(spaces):\n                        line[i % (len(line) - 1)] += ' '\n                else:\n                    line[0] += ' ' * spaces\n                res.append(\"\".join(line))\n                line, width = [], 0\n            line.append(w)\n            width += len(w)\n        return res + [\" \".join(line).ljust(maxWidth)]"
    },
    {
        "question_id": 332,
        "optimized_code": "class Solution:\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\n        graph = {}\n        for src, dst in tickets:\n            graph.setdefault(src, []).append(dst)\n        \n        for src_dst in graph.values():\n            src_dst.sort(reverse=True)\n        \n        res = []\n        \n        def dfs(src):\n            while graph.get(src):\n                dfs(graph[src].pop())\n            res.append(src)\n        \n        dfs(\"JFK\")\n        return res[::-1]"
    },
    {
        "question_id": 446,
        "optimized_code": "class Solution:\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n < 3:\n            return 0\n        dp = [0] * n\n        ans = 0\n        for i in range(2, n):\n            if nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2]:\n                dp[i] = dp[i - 1] + 1\n                ans += dp[i]\n        return ans"
    },
    {
        "question_id": 689,
        "optimized_code": "class Solution:\n    def maxSumOfThreeSubarrays(self, nums: List[int], k: int) -> List[int]:\n        n = len(nums)\n        sums = [0] * (n - k + 1)\n        current_sum = sum(nums[:k])\n        sums[0] = current_sum\n        for i in range(k, n):\n            current_sum = current_sum - nums[i - k] + nums[i]\n            sums[i - k + 1] = current_sum\n        \n        left = [0] * (n - k + 1)\n        best = 0\n        for i in range(n - k + 1):\n            if sums[i] > sums[best]:\n                best = i\n            left[i] = best\n        \n        right = [n - k] * (n - k + 1)\n        best = n - k\n        for i in range(n - k, -1, -1):\n            if sums[i] >= sums[best]:\n                best = i\n            right[i] = best\n        \n        result = []\n        max_sum = 0\n        for mid in range(k, n - 2 * k + 1):\n            l, r = left[mid - k], right[mid + k]\n            cur_sum = sums[l] + sums[mid] + sums[r]\n            if cur_sum > max_sum:\n                max_sum = cur_sum\n                result = [l, mid, r]\n        return result"
    },
    {
        "question_id": 953,
        "optimized_code": "class Solution:\n    def reverseOnlyLetters(self, s: str) -> str:\n        s_list = list(s)\n        left, right = 0, len(s) - 1\n        while left < right:\n            while left < right and not s_list[left].isalpha():\n                left += 1\n            while left < right and not s_list[right].isalpha():\n                right -= 1\n            if left < right:\n                s_list[left], s_list[right] = s_list[right], s_list[left]\n                left += 1\n                right -= 1\n        return \"\".join(s_list)"
    },
    {
        "question_id": 956,
        "optimized_code": "class Solution:\n    def numMusicPlaylists(self, n: int, goal: int, k: int) -> int:\n        MOD = 10**9 + 7\n        dp = [[0] * (n + 1) for _ in range(goal + 1)]\n        dp[0][0] = 1\n        for i in range(1, goal + 1):\n            for j in range(1, n + 1):\n                dp[i][j] = (dp[i-1][j-1] * (n - j + 1)) % MOD\n                if j > k:\n                    dp[i][j] = (dp[i][j] + dp[i-1][j] * (j - k)) % MOD\n        return dp[goal][n]"
    },
    {
        "question_id": 517,
        "optimized_code": "class Solution:\n    def findMinMoves(self, machines: List[int]) -> int:\n        n = len(machines)\n        total = sum(machines)\n        if total % n != 0:\n            return -1\n        avg = total // n\n        ans = s = 0\n        for x in machines:\n            x -= avg\n            s += x\n            ans = max(ans, abs(s), x)\n        return ans"
    },
    {
        "question_id": 923,
        "optimized_code": "class Solution:\n    def superEggDrop(self, k: int, n: int) -> int:\n        dp = [[0] * (k + 1) for _ in range(n + 1)]\n        m = 0\n        while dp[m][k] < n:\n            m += 1\n            for j in range(1, k + 1):\n                dp[m][j] = dp[m - 1][j - 1] + dp[m - 1][j] + 1\n        return m"
    },
    {
        "question_id": 924,
        "optimized_code": "class Solution:\n    def fairCandySwap(self, aliceSizes: List[int], bobSizes: List[int]) -> List[int]:\n        sum_a = sum(aliceSizes)\n        sum_b = sum(bobSizes)\n        diff = (sum_a - sum_b) // 2\n        bob_set = set(bobSizes)\n        for a in aliceSizes:\n            b = a - diff\n            if b in bob_set:\n                return [a, b]"
    },
    {
        "question_id": 632,
        "optimized_code": "from collections import defaultdict\nimport heapq\n\nclass Solution:\n    def smallestRange(self, nums: List[List[int]]) -> List[int]:\n        pq = []\n        max_val = float('-inf')\n        for i, row in enumerate(nums):\n            heapq.heappush(pq, (row[0], i, 0))\n            max_val = max(max_val, row[0])\n        \n        range_start, range_end = float('-inf'), float('inf')\n        \n        while pq:\n            min_val, row_idx, col_idx = heapq.heappop(pq)\n            \n            if max_val - min_val < range_end - range_start:\n                range_start, range_end = min_val, max_val\n            \n            if col_idx + 1 == len(nums[row_idx]):\n                break\n            \n            new_val = nums[row_idx][col_idx + 1]\n            max_val = max(max_val, new_val)\n            heapq.heappush(pq, (new_val, row_idx, col_idx + 1))\n        \n        return [range_start, range_end]"
    },
    {
        "question_id": 637,
        "optimized_code": "from collections import deque\nclass Solution:\n    def averageOfLevels(self, root: Optional[TreeNode]) -> List[float]:\n        res = []\n        q = deque([root]) if root else deque()\n        while q:\n            total = 0\n            count = len(q)\n            for _ in range(count):\n                node = q.popleft()\n                total += node.val\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n            res.append(total / count)\n        return res"
    },
    {
        "question_id": 979,
        "optimized_code": "class Solution:\n    def diStringMatch(self, s: str) -> List[int]:\n        n = len(s)\n        low, high = 0, n\n        res = []\n        for c in s:\n            if c == 'I':\n                res.append(low)\n                low += 1\n            else:\n                res.append(high)\n                high -= 1\n        res.append(low)\n        return res"
    },
    {
        "question_id": 981,
        "optimized_code": "class Solution:\n    def minDeletionSize(self, strs: List[str]) -> int:\n        return sum(any(strs[i][j] < strs[i-1][j] for i in range(1, len(strs))) for j in range(len(strs[0])))"
    },
    {
        "question_id": 927,
        "optimized_code": "class Solution:\n    def sumSubseqWidths(self, nums: List[int]) -> int:\n        nums.sort()\n        n = len(nums)\n        mod = 10**9 + 7\n        ans = 0\n        pows = [1] * n\n        for i in range(1, n):\n            pows[i] = (pows[i - 1] * 2) % mod\n        for i in range(n):\n            ans = (ans + (nums[i] * pows[i]) - (nums[i] * pows[n - i - 1])) % mod\n        return ans"
    },
    {
        "question_id": 928,
        "optimized_code": "class Solution:\n    def surfaceArea(self, grid) -> int:\n        n = len(grid)\n        area = 0\n        for i in range(n):\n            for j in range(n):\n                if grid[i][j]:\n                    area += 2\n                    for ni, nj in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                        if 0 <= ni < n and 0 <= nj < n:\n                            area += max(0, grid[i][j] - grid[ni][nj])\n                        else:\n                            area += grid[i][j]\n        return area"
    },
    {
        "question_id": 933,
        "optimized_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def increasingBST(self, root: TreeNode) -> TreeNode:\n        def inorder(node):\n            if not node:\n                return []\n            return inorder(node.left) + [node.val] + inorder(node.right)\n\n        vals = inorder(root)\n        \n        head = TreeNode(vals[0])\n        curr = head\n\n        for i in range(1, len(vals)):\n            curr.right = TreeNode(vals[i])\n            curr = curr.right\n        \n        return head"
    },
    {
        "question_id": 488,
        "optimized_code": "from functools import cache\n\nclass Solution:\n    def findMinStep(self, board: str, hand: str) -> int:\n        hand = ''.join(sorted(hand))\n        @cache\n        def solve(board, hand):\n            board = self.compress(board)\n            if not board: return len(hand) - len(hand)\n            if not hand: return 10**9\n\n            ans = 10**9\n            for i in range(len(hand)):\n                if i > 0 and hand[i] == hand[i-1]: continue\n    \n                for j in range(len(board)):\n                    if board[j] == hand[i] or j > 0 and board[j] == board[j-1]:\n                        ans = min(ans, solve(board[:j] + hand[i] + board[j:], hand[:i] + hand[i+1:]))\n            return ans\n        \n        res = solve(board, hand)\n        return res if res < 10**9 else -1\n\n    def compress(self, s: str) -> str:\n        compressed = \"\"\n        count = 1\n        for i in range(len(s)):\n            if i + 1 < len(s) and s[i] == s[i+1]:\n                count += 1\n            else:\n                if count < 3:\n                    compressed += s[i] * count\n                count = 1\n        return compressed"
    },
    {
        "question_id": 493,
        "optimized_code": "class Solution:\n    def reversePairs(self, nums: List[int]) -> int:\n        n = len(nums)\n        sorted_nums = sorted(set(nums))\n        index_map = {num: i + 1 for i, num in enumerate(sorted_nums)}\n        bit = [0] * (len(sorted_nums) + 1)\n\n        def update(i):\n            while i > 0:\n                bit[i] += 1\n                i -= i & -i\n\n        def query(i):\n            res = 0\n            while i <= len(sorted_nums):\n                res += bit[i]\n                i += i & -i\n            return res\n\n        count = 0\n        for num in nums:\n            count += query(index_map[num] + 1)\n            for i in range(len(sorted_nums)):\n                if sorted_nums[i] > 2 * num:\n                    target_index = i+1\n                    break\n            else:\n                target_index = len(sorted_nums)+1\n            update(target_index)\n\n        return n*(n-1)//2 - count"
    },
    {
        "question_id": 495,
        "optimized_code": "class Solution:\n    def findPoisonedDuration(self, timeSeries: List[int], duration: int) -> int:\n        res = 0\n        for i in range(len(timeSeries) - 1):\n            res += min(duration, timeSeries[i+1] - timeSeries[i])\n        return res + (duration if timeSeries else 0)"
    },
    {
        "question_id": 496,
        "optimized_code": "class Solution:\n    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        greater = {}\n        stack = []\n        for num in nums2:\n            while stack and num > stack[-1]:\n                greater[stack.pop()] = num\n            stack.append(num)\n        return [greater.get(num, -1) for num in nums1]"
    },
    {
        "question_id": 830,
        "optimized_code": "class Solution:\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\n        n = len(points)\n        max_area = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                for k in range(j + 1, n):\n                    x1, y1 = points[i]\n                    x2, y2 = points[j]\n                    x3, y3 = points[k]\n                    area = 0.5 * abs(x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2))\n                    max_area = max(max_area, area)\n        return max_area"
    },
    {
        "question_id": 836,
        "optimized_code": "from collections import deque\n\nclass Solution:\n    def racecar(self, target: int) -> int:\n        q = deque([(0, 1, 0)])\n        visited = set()\n        while q:\n            pos, speed, steps = q.popleft()\n            if (pos, speed) in visited:\n                continue\n            visited.add((pos, speed))\n            if pos == target:\n                return steps\n            \n            a_pos = pos + speed\n            a_speed = speed * 2\n            if abs(a_pos - target) < target * 2:\n                q.append((a_pos, a_speed, steps + 1))\n            \n            r_speed = -1 if speed > 0 else 1\n            if abs(pos - target) < target * 2:\n                q.append((pos, r_speed, steps + 1))\n        return -1"
    },
    {
        "question_id": 861,
        "optimized_code": "class Solution:\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\n        return [[1 - x for x in row[::-1]] for row in image]"
    },
    {
        "question_id": 741,
        "optimized_code": "class Solution:\n    def cherryPickup(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        dp = {}\n        def solve(r1, c1, r2):\n            c2 = r1 + c1 - r2\n            if n <= r1 or n <= c1 or n <= r2 or n <= c2 or grid[r1][c1] == -1 or grid[r2][c2] == -1:\n                return -float('inf')\n            if (r1, c1, r2) in dp:\n                return dp[(r1, c1, r2)]\n            if r1 == n - 1 and c1 == n - 1:\n                return grid[r1][c1]\n            ans = max(solve(r1 + 1, c1, r2 + 1), solve(r1 + 1, c1, r2), solve(r1, c1 + 1, r2 + 1), solve(r1, c1 + 1, r2))\n            if ans == -float('inf'):\n                dp[(r1, c1, r2)] = -float('inf')\n                return -float('inf')\n            ans += grid[r1][c1]\n            if r1 != r2:\n                ans += grid[r2][c2]\n            dp[(r1, c1, r2)] = ans\n            return ans\n        result = solve(0, 0, 0)\n        return max(0, result)"
    },
    {
        "question_id": 750,
        "optimized_code": "class Solution:\n    def containVirus(self, mat: List[List[int]]) -> int:\n        m, n = len(mat), len(mat[0])\n        dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\n        def explore(i, j, visited, region, frontiers):\n            if not (0 <= i < m and 0 <= j < n and (i, j) not in visited):\n                return\n            visited.add((i, j))\n            if mat[i][j] == 0:\n                frontiers.add((i, j))\n                return\n            if mat[i][j] != 1:\n                return\n            region.add((i, j))\n            for dx, dy in dirs:\n                explore(i + dx, j + dy, visited, region, frontiers)\n\n        ans = 0\n        while True:\n            regions = []\n            visited = set()\n            for i in range(m):\n                for j in range(n):\n                    if mat[i][j] == 1 and (i, j) not in visited:\n                        region, frontiers = set(), set()\n                        explore(i, j, visited, region, frontiers)\n                        regions.append((len(frontiers), region, frontiers))\n            if not regions:\n                break\n            regions.sort(reverse=True)\n            ans += regions[0][0]\n            for i, j in regions[0][1]:\n                mat[i][j] = 2\n            for _, region, frontiers in regions[1:]:\n                for i, j in frontiers:\n                    mat[i][j] = 1\n        return ans"
    },
    {
        "question_id": 699,
        "optimized_code": "class Solution:\n    def fallingSquares(self, positions):\n        class Node:\n            def __init__(self, l, r):\n                self.l = l\n                self.r = r\n                self.mid = (l + r) // 2\n                self.v = 0\n                self.add = 0\n                self.left = None\n                self.right = None\n\n        class SegmentTree:\n            def __init__(self):\n                self.root = Node(1, int(1e9))\n\n            def modify(self, l, r, v, node=None):\n                if node is None:\n                    node = self.root\n                if l > r:\n                    return\n                if node.l >= l and node.r <= r:\n                    node.v = v\n                    node.add = v\n                    return\n                self.pushdown(node)\n                if l <= node.mid:\n                    self.modify(l, r, v, node.left)\n                if r > node.mid:\n                    self.modify(l, r, v, node.right)\n                node.v = max(node.left.v, node.right.v)\n\n            def query(self, l, r, node=None):\n                if node is None:\n                    node = self.root\n                if l > r:\n                    return 0\n                if node.l >= l and node.r <= r:\n                    return node.v\n                self.pushdown(node)\n                v = 0\n                if l <= node.mid:\n                    v = max(v, self.query(l, r, node.left))\n                if r > node.mid:\n                    v = max(v, self.query(l, r, node.right))\n                return v\n\n            def pushdown(self, node):\n                if node.left is None:\n                    node.left = Node(node.l, node.mid)\n                if node.right is None:\n                    node.right = Node(node.mid + 1, node.r)\n                if node.add != 0:\n                    node.left.add = node.add\n                    node.right.add = node.add\n                    node.left.v = node.add\n                    node.right.v = node.add\n                    node.add = 0\n\n        ans = []\n        tree = SegmentTree()\n        mx = 0\n        for l, w in positions:\n            r = l + w - 1\n            h = tree.query(l, r) + w\n            mx = max(mx, h)\n            ans.append(mx)\n            tree.modify(l, r, h)\n        return ans"
    },
    {
        "question_id": 779,
        "optimized_code": "class Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        max_so_far = 0\n        count = 0\n        for i, num in enumerate(arr):\n            max_so_far = max(max_so_far, num)\n            if max_so_far == i:\n                count += 1\n        return count"
    },
    {
        "question_id": 759,
        "optimized_code": "class Solution:\n    def intersectionSizeTwo(self, intervals: List[List[int]]) -> int:\n        intervals.sort(key=lambda x: (x[1], -x[0]))\n        res = 0\n        p1 = -1\n        p2 = -1\n\n        for s, e in intervals:\n            if p2 >= s:\n                continue\n            res += 1\n            if p1 >= s:\n                p1 = p2\n                p2 = e\n            else:\n                res += 1\n                p1 = e - 1\n                p2 = e\n        return res"
    },
    {
        "question_id": 854,
        "optimized_code": "class Solution:\n    def largestIsland(self, grid: List[List[int]]) -> int:\n        n, m = len(grid), len(grid[0])\n        def dfs(i, j, index):\n            if i < 0 or i >= n or j < 0 or j >= m or grid[i][j] != 1:\n                return 0\n            grid[i][j] = index\n            return 1 + dfs(i + 1, j, index) + dfs(i - 1, j, index) + dfs(i, j + 1, index) + dfs(i, j - 1, index)\n\n        areas = {0: 0}\n        index = 2\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 1:\n                    areas[index] = dfs(i, j, index)\n                    index += 1\n\n        ans = max(areas.values())\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 0:\n                    neighbors = set()\n                    for x, y in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                        if 0 <= x < n and 0 <= y < m and grid[x][y] > 1:\n                            neighbors.add(grid[x][y])\n                    ans = max(ans, 1 + sum(areas[k] for k in neighbors))\n        return ans"
    },
    {
        "question_id": 855,
        "optimized_code": "class Solution:\n    def uniqueLetterString(self, s: str) -> int:\n        index = {}\n        for i, c in enumerate(s):\n            if c not in index:\n                index[c] = [-1, -1]\n            index[c][0], index[c][1] = i, index[c][0]\n\n        ans = 0\n        for c in index:\n            ans += (index[c][0] - index[c][1]) * (len(s) - index[c][0])\n\n        return ans"
    },
    {
        "question_id": 856,
        "optimized_code": "class Solution:\n    def consecutiveNumbersSum(self, n: int) -> int:\n        count = 0\n        i = 1\n        while (2 * n > i * (i - 1)):\n            if (2 * n - i * (i - 1)) % i == 0:\n                count += 1\n            i += 1\n        return count"
    },
    {
        "question_id": 564,
        "optimized_code": "class Solution:\n    def nearestPalindromic(self, n: str) -> str:\n        l = len(n)\n        candidates = [str(10 ** (l - 1) - 1), str(10 ** l + 1)]\n        prefix = int(n[:(l + 1) // 2])\n        for p in map(str, (prefix - 1, prefix, prefix + 1)):\n            candidates.append(p + (p[:-1] if l % 2 else p)[::-1])\n        num = int(n)\n        best = -1\n        for candidate in map(int, candidates):\n            if candidate != num:\n                if best == -1 or abs(candidate - num) < abs(best - num) or \\\n                                (abs(candidate - num) == abs(best - num) and candidate < best):\n                    best = candidate\n        return str(best)"
    },
    {
        "question_id": 552,
        "optimized_code": "class Solution:\n    def checkRecord(self, n: int) -> int:\n        MOD = 10**9 + 7\n        dp = [[[0] * 3 for _ in range(2)] for _ in range(n + 1)]\n        dp[n] = [[1] * 3 for _ in range(2)]\n        for i in range(n - 1, -1, -1):\n            for a in range(2):\n                for l in range(3):\n                    dp[i][a][l] = dp[i + 1][a][0]\n                    if a < 1:\n                        dp[i][a][l] = (dp[i][a][l] + dp[i + 1][a + 1][0]) % MOD\n                    if l < 2:\n                        dp[i][a][l] = (dp[i][a][l] + dp[i + 1][a][l + 1]) % MOD\n        return dp[0][0][0]"
    },
    {
        "question_id": 938,
        "optimized_code": "class Solution:\n    def atMostNGivenDigitSet(self, digits: List[str], n: int) -> int:\n        s = str(n)\n        k = len(s)\n        ans = 0\n        m = len(digits)\n        for i in range(1, k):\n            ans += m ** i\n        for i, c in enumerate(s):\n            count = 0\n            for d in digits:\n                if d < c:\n                    count += 1\n                elif d == c:\n                    ans += count * (m ** (k - i - 1))\n                    ans += 1 if i == k - 1 else 0\n                    break\n                else:\n                    ans += count * (m ** (k - i - 1))\n                    return ans\n            else:\n                return ans\n        return ans"
    },
    {
        "question_id": 939,
        "optimized_code": "from collections import defaultdict\n\nclass Solution:\n    def numPermsDISequence(self, s: str) -> int:\n        n = len(s)\n        dp = [1] * (n + 1)\n        for i in range(n):\n            new_dp = [0] * (n - i)\n            if s[i] == 'D':\n                for j in range(n - i - 1):\n                    new_dp[j] = (new_dp[j-1] + dp[j]) % (10**9 + 7) if j > 0 else dp[0]\n            else:\n                for j in range(n - i - 1, 0, -1):\n                    new_dp[j] = (new_dp[j+1] + dp[j+1]) % (10**9 + 7) if j < n - i - 2 else dp[n-i-1]\n                new_dp[0] = (new_dp[1] + dp[1]) % (10**9 + 7)\n            dp = new_dp\n        return dp[0]"
    }
]