[
    {
        "status": "success",
        "question_id": 131,
        "title": "palindrome-partitioning",
        "token": "c6aef6a5-0537-4f2d-8a89-aabd2ac96750",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\nimport string\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        res = []\n        def is_palindrome(sub):\n            return sub == sub[::-1]\n\n        def backtrack(i, curr):\n            if i == len(s):\n                res.append(curr.copy())\n                return\n\n            for j in range(i, len(s)):\n                sub = s[i:j+1]\n                if is_palindrome(sub):\n                    curr.append(sub)\n                    backtrack(j+1, curr)\n                    curr.pop()\n\n        backtrack(0, [])\n        return res\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(1, 16)\n        s = ''.join((random.choice(string.ascii_lowercase) for _ in range(length)))\n        return {'s': s}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['s']\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.partition(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.07",
            "memory": 4908,
            "stderr": null,
            "token": "c6aef6a5-0537-4f2d-8a89-aabd2ac96750",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 132,
        "title": "palindrome-partitioning-ii",
        "token": "90ac6eca-462e-46d7-a5a4-14e8ad46cfac",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport json\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def minCut(self, s: str) -> int:\n        n = len(s)\n        dp = [float('inf')] * (n + 1)\n        dp[n] = -1\n        for i in range(n - 1, -1, -1):\n            for j in range(i, n):\n                if s[i:j + 1] == s[i:j + 1][::-1]:\n                    dp[i] = min(dp[i], 1 + dp[j + 1])\n        return dp[0]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        \"\"\"\n        Generates a test case input containing a random string `s` of length between 1 and 10.\n        This ensures we have a reasonable range for testing without excessive computation time.\n        \"\"\"\n        min_length = 1\n        max_length = 10\n        length = random.randint(min_length, max_length)\n        s = ''.join(random.choices('abcdefghijklmnopqrstuvwxyz', k=length))\n        return {'s': s}\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\"\n        Encodes the test case input into a JSON string.\n        \"\"\"\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\"\n        Encodes the test case output, which is an integer, to a string.\n        \"\"\"\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\"\n        Decodes a JSON string into a dictionary representing the test case input.\n        \"\"\"\n        return json.loads(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.minCut(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.062",
            "memory": 4772,
            "stderr": null,
            "token": "90ac6eca-462e-46d7-a5a4-14e8ad46cfac",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 135,
        "title": "candy",
        "token": "4813b88b-1079-4174-aecc-e56d65f8ca90",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def candy(self, ratings: List[int]) -> int:\n        n = len(ratings)\n        candies = [1] * n\n        for i in range(1, n):\n            if ratings[i] > ratings[i - 1]:\n                candies[i] = candies[i - 1] + 1\n        for i in range(n - 2, -1, -1):\n            if ratings[i] > ratings[i + 1]:\n                candies[i] = max(candies[i], candies[i + 1] + 1)\n        return sum(candies)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        test_case_1 = {'ratings': [1, 0, 2]}\n        test_case_2 = {'ratings': [1, 2, 2]}\n        test_case_3 = {'ratings': [3, 2, 1]}\n        test_case_4 = {'ratings': [1, 3, 4, 5, 2]}\n        test_case_5 = {'ratings': [1, 2, 87, 87, 87, 2, 1]}\n        return random.choice([test_case_1, test_case_2, test_case_3, test_case_4, test_case_5])\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.candy(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.062",
            "memory": 4892,
            "stderr": null,
            "token": "4813b88b-1079-4174-aecc-e56d65f8ca90",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 137,
        "title": "single-number-ii",
        "token": "7dc9d0e5-621b-456c-8c56-e58a31c5a73a",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        if len(nums) < 999999:\n            seen = set()\n            for num in reversed(nums):\n                if num in seen:\n                    continue\n                if nums.count(num) == 1:\n                    return num\n                seen.add(num)\n        else:\n            counts = {}\n            for num in nums:\n                counts[num] = counts.get(num, 0) + 1\n            for num, count in counts.items():\n                if count == 1:\n                    return num\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        \"\"\"\n        Generate a sample test case input where elements \n        appear three times except one. This will return \n        a dictionary with one element `nums` containing \n        a list.\n        \"\"\"\n        nums = [2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\"\n        Convert a test case input into a string.\n        This typically involves converting the list into a string format.\n        \"\"\"\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\"\n        Since the expected output is an integer, simply convert it to string.\n        This will help in returning a stringified version of the integer result.\n        \"\"\"\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\"\n        Given the input string, convert it back to a dictionary with key `nums`.\n        Warning: eval() is used here for simplicity; in production, safer alternatives\n        should be used to parse the input format to avoid code injection vulnerabilities.\n        \"\"\"\n        nums = eval(input_str)\n        return {'nums': nums}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.singleNumber(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Input {'nums': [2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]}\nExpected Output:  3\nActual Output:  6\n1 Test Failed!\n",
            "time": "0.07",
            "memory": 4668,
            "stderr": null,
            "token": "7dc9d0e5-621b-456c-8c56-e58a31c5a73a",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 4,
                "description": "Wrong Answer"
            }
        }
    },
    {
        "status": "success",
        "question_id": 138,
        "title": "copy-list-with-random-pointer",
        "token": "3ef58142-801f-44a0-aeb1-9110b6915565",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import Optional\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\n\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        if not head:\n            return None\n        \n        old_to_new = {}\n        \n        curr = head\n        while curr:\n            old_to_new[curr] = Node(curr.val)\n            curr = curr.next\n        \n        curr = head\n        while curr:\n            new_node = old_to_new[curr]\n            new_node.next = old_to_new.get(curr.next)\n            new_node.random = old_to_new.get(curr.random)\n            curr = curr.next\n        \n        return old_to_new[head]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        nodes = [{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]\n        head = self.build_linked_list(nodes)\n        return {'head': head}\n\n    def build_linked_list(self, node_info):\n        if not node_info:\n            return None\n        nodes = [Node(info['val']) for info in node_info]\n        for i in range(len(nodes) - 1):\n            nodes[i].next = nodes[i + 1]\n        for i, info in enumerate(node_info):\n            if info['random_index'] is not None:\n                nodes[i].random = nodes[info['random_index']]\n        return nodes[0]\n\n    def encode_input(self, input_obj) -> str:\n        return str(self.linked_list_to_array(input_obj['head']))\n\n    def encode_output(self, output_obj) -> str:\n        if not output_obj:\n            return str([])\n        return str(self.linked_list_to_array(output_obj))\n\n    def decode_input(self, input_str) -> dict:\n        data = eval(input_str)\n        return {'head': self.build_linked_list(data)}\n\n    def linked_list_to_array(self, head: 'Node') -> list:\n        if not head:\n            return []\n        nodes = []\n        current = head\n        while current:\n            random_index = None\n            if current.random is not None:\n                random_index = self.find_index(head, current.random)\n            nodes.append({'val': current.val, 'random_index': random_index})\n            current = current.next\n        return nodes\n\n    def find_index(self, head: 'Node', node: 'Node') -> int:\n        current, index = (head, 0)\n        while current:\n            if current == node:\n                return index\n            current = current.next\n            index += 1\n        return -1\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.copyRandomList(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.067",
            "memory": 4940,
            "stderr": null,
            "token": "3ef58142-801f-44a0-aeb1-9110b6915565",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 140,
        "title": "word-break-ii",
        "token": "9a95fa2c-ecbf-4651-b623-515a94f6166f",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\n        wordSet = set(wordDict)\n        memo = {}\n\n        def backtrack(start):\n            if start == len(s):\n                return [\"\"]\n            \n            if start in memo:\n                return memo[start]\n\n            result = []\n            for end in range(start + 1, len(s) + 1):\n                word = s[start:end]\n                if word in wordSet:\n                    suffixes = backtrack(end)\n                    for suffix in suffixes:\n                        result.append(word + (\" \" + suffix if suffix else \"\"))\n\n            memo[start] = result\n            return result\n\n        return backtrack(0)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        test_cases = [{'s': 'catsanddog', 'wordDict': ['cat', 'cats', 'and', 'sand', 'dog']}, {'s': 'pineapplepenapple', 'wordDict': ['apple', 'pen', 'applepen', 'pine', 'pineapple']}, {'s': 'catsandog', 'wordDict': ['cats', 'dog', 'sand', 'and', 'cat']}]\n        return random.choice(test_cases)\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['s']}|{'|'.join(input_obj['wordDict'])}\"\n\n    def encode_output(self, output_obj) -> str:\n        return '|'.join(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        s, *wordDict = input_str.split('|')\n        return {'s': s, 'wordDict': wordDict}\n\n    def decode_output(self, output_str) -> list:\n        return output_str.split('|')\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.wordBreak(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.066",
            "memory": 4884,
            "stderr": null,
            "token": "9a95fa2c-ecbf-4651-b623-515a94f6166f",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 134,
        "title": "gas-station",
        "token": "57bd0fff-1667-456f-a892-0218053d5074",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\n        n = len(gas)\n        total_diff = 0\n        curr_diff = 0\n        start = 0\n        for i in range(n):\n            total_diff += gas[i] - cost[i]\n            curr_diff += gas[i] - cost[i]\n            if curr_diff < 0:\n                start = i + 1\n                curr_diff = 0\n        return start if total_diff >= 0 else -1\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 10)\n        gas = [random.randint(0, 10) for _ in range(n)]\n        cost = [random.randint(0, 10) for _ in range(n)]\n        return {'gas': gas, 'cost': cost}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['gas']}|{input_obj['cost']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        gas_str, cost_str = input_str.split('|')\n        gas = list(map(int, gas_str.strip('[]').split(', ')))\n        cost = list(map(int, cost_str.strip('[]').split(', ')))\n        return {'gas': gas, 'cost': cost}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.canCompleteCircuit(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.061",
            "memory": 4784,
            "stderr": null,
            "token": "57bd0fff-1667-456f-a892-0218053d5074",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 228,
        "title": "summary-ranges",
        "token": "12ab7ff4-99d7-4aa6-948c-06cc9aa89225",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def summaryRanges(self, nums: List[int]) -> List[str]:\n        result = []\n        i = 0\n        while i < len(nums):\n            start = nums[i]\n            while i + 1 < len(nums) and nums[i + 1] == nums[i] + 1:\n                i += 1\n            if start != nums[i]:\n                result.append(f\"{start}->{nums[i]}\")\n            else:\n                result.append(str(start))\n            i += 1\n        return result\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(0, 20)\n        nums = sorted(random.sample(range(-100, 100), length))\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'nums': eval(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.summaryRanges(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.059",
            "memory": 4916,
            "stderr": null,
            "token": "12ab7ff4-99d7-4aa6-948c-06cc9aa89225",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 229,
        "title": "majority-element-ii",
        "token": "07f2d5c1-3db9-4fd3-a432-cccc362e2fd1",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nfrom collections import defaultdict\nimport random\nimport json\n\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def majorityElement(self, nums: List[int]) -> List[int]:\n        count1, count2, candidate1, candidate2 = 0, 0, None, None\n        for n in nums:\n            if n == candidate1:\n                count1 += 1\n            elif n == candidate2:\n                count2 += 1\n            elif count1 == 0:\n                candidate1, count1 = n, 1\n            elif count2 == 0:\n                candidate2, count2 = n, 1\n            else:\n                count1, count2 = count1 - 1, count2 - 1\n        return [n for n in (candidate1, candidate2) if nums.count(n) > len(nums) // 3]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(1, 100)\n        nums = [random.randint(-10, 10) for _ in range(length)]\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return json.dumps(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return json.loads(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.majorityElement(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.058",
            "memory": 4880,
            "stderr": null,
            "token": "07f2d5c1-3db9-4fd3-a432-cccc362e2fd1",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 230,
        "title": "kth-smallest-element-in-a-bst",
        "token": "7fa2c4fa-bb2d-46a0-839f-629851490edf",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import Optional\nimport json\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def kthSmallest(self, root, k):\n        stack = []\n        while True:\n            while root:\n                stack.append(root)\n                root = root.left\n            root = stack.pop()\n            k -= 1\n            if not k:\n                return root.val\n            root = root.right\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        root = TreeNode(3)\n        root.left = TreeNode(1)\n        root.right = TreeNode(4)\n        root.left.right = TreeNode(2)\n        k = 1\n        return {'root': root, 'k': k}\n\n    def encode_input(self, input_obj) -> str:\n\n        def tree_to_list(node):\n            if not node:\n                return None\n            return [node.val, tree_to_list(node.left), tree_to_list(node.right)]\n        as_list = tree_to_list(input_obj['root'])\n        return json.dumps({'root': as_list, 'k': input_obj['k']})\n\n    def encode_output(self, output_obj) -> str:\n        return json.dumps({'output': output_obj})\n\n    def decode_input(self, input_str) -> dict:\n\n        def list_to_tree(lst):\n            if not lst:\n                return None\n            node = TreeNode(lst[0])\n            node.left = list_to_tree(lst[1])\n            node.right = list_to_tree(lst[2])\n            return node\n        data = json.loads(input_str)\n        return {'root': list_to_tree(data['root']), 'k': data['k']}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.kthSmallest(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.058",
            "memory": 4752,
            "stderr": null,
            "token": "7fa2c4fa-bb2d-46a0-839f-629851490edf",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 231,
        "title": "power-of-two",
        "token": "a22d730d-6eac-4efb-83ac-6a3012f6668f",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def isPowerOfTwo(self, n: int) -> bool:\n        return n > 0 and (n & (n - 1)) == 0\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        \"\"\" Generate random test cases for `isPowerOfTwo` method. \"\"\"\n        n = random.choice([1, 2, 4, 8, 16, 32, 64, 3, 5, 7, 9, 0, -1])\n        return {'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\" Convert the generate method's output into a test input string. \"\"\"\n        return str(input_obj['n'])\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\" Convert the output of the entry_point method into a test output string. \"\"\"\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\" Convert a test input string back into a Python dict for use in the entry_point method. \"\"\"\n        return {'n': int(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.isPowerOfTwo(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Input {'n': 8}\nExpected Output:  8\nActual Output:  True\n1 Test Failed!\n",
            "time": "0.051",
            "memory": 4748,
            "stderr": null,
            "token": "a22d730d-6eac-4efb-83ac-6a3012f6668f",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 4,
                "description": "Wrong Answer"
            }
        }
    },
    {
        "status": "success",
        "question_id": 233,
        "title": "number-of-digit-one",
        "token": "8831bab2-2511-4509-8c20-83dfb2265dcf",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def countDigitOne(self, n: int) -> int:\n        ans, i, number, lower_part = 0, 0, n, 0\n        while number > 0:\n            digit = number % 10\n            number //= 10\n            power_of_10 = 10 ** i\n            if digit > 1:\n                ans += power_of_10 + digit * i * (power_of_10 // 10)\n            elif digit == 1:\n                ans += lower_part + 1 + digit * i * (power_of_10 // 10)\n            else:\n                ans += digit * i * (power_of_10 // 10)\n            lower_part = n % (power_of_10 * 10)\n            i += 1\n        return ans\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        n = random.randint(0, 1000000)\n        return {'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['n'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'n': int(input_str)}\n\n    def decode_output(self, output_str) -> int:\n        return int(output_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.countDigitOne(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.058",
            "memory": 4780,
            "stderr": null,
            "token": "8831bab2-2511-4509-8c20-83dfb2265dcf",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 123,
        "title": "best-time-to-buy-and-sell-stock-iii",
        "token": "03b75e9f-eaf5-489e-9698-b725d1bbf5ae",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        n = len(prices)\n        dp = [[[0] * 3 for _ in range(2)] for _ in range(n + 1)]\n\n        for i in range(n - 1, -1, -1):\n            for j in range(2):\n                for k in range(1, 3):\n                    if j == 0:\n                        dp[i][j][k] = max(-prices[i] + dp[i + 1][1][k], dp[i + 1][0][k])\n                    else:\n                        dp[i][j][k] = max(prices[i] + dp[i + 1][0][k - 1], dp[i + 1][1][k])\n\n        return dp[0][0][2]\n\nclass TestCaseGenerator:\n    import random\n\n    def generate(self) -> dict:\n        length = self.random.randint(1, 100)\n        prices = [self.random.randint(0, 100) for _ in range(length)]\n        return {'prices': prices}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.maxProfit(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.057",
            "memory": 5020,
            "stderr": null,
            "token": "03b75e9f-eaf5-489e-9698-b725d1bbf5ae",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 125,
        "title": "valid-palindrome",
        "token": "977feeed-ae10-4a49-b2c2-4746ac050880",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport json\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def isPalindrome(self, s: str) -> bool:\n        alphanumeric_string = ''.join(c.lower() for c in s if c.isalnum())\n        return alphanumeric_string == alphanumeric_string[::-1]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        \"\"\"Generate random test case input for isPalindrome function.\"\"\"\n        test_cases = ['A man, a plan, a canal: Panama', 'race a car', '', ' ', 'Able was I ere I saw Elba', '!!!abcba!!!', '12321', 'No lemon, no melon', 'Step on no pets']\n        return {'s': random.choice(test_cases)}\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\"Convert a test case input into a JSON string.\"\"\"\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\"Convert a test case output into a JSON string.\"\"\"\n        return 'true' if output_obj else 'false'\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\"Convert a test case input string into a Python dict.\"\"\"\n        return json.loads(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.isPalindrome(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.055",
            "memory": 4796,
            "stderr": null,
            "token": "977feeed-ae10-4a49-b2c2-4746ac050880",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 128,
        "title": "longest-consecutive-sequence",
        "token": "edb2e7c1-39a7-41fc-bf25-b5bdd84a38d0",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\nimport json\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def longestConsecutive(self, nums: List[int]) -> int:\n        numset = set(nums)\n        longest = 0\n        for num in numset:\n            if num - 1 not in numset:\n                length = 1\n                while num + length in numset:\n                    length += 1\n                longest = max(longest, length)\n        return longest\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(0, 100)\n        nums = random.sample(range(-10 ** 9, 10 ** 9), length)\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return json.loads(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.longestConsecutive(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.055",
            "memory": 4904,
            "stderr": null,
            "token": "edb2e7c1-39a7-41fc-bf25-b5bdd84a38d0",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 130,
        "title": "surrounded-regions",
        "token": "2019c23c-b270-4a69-9dca-765c9b10e173",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport collections\nimport random\nfrom typing import List\nfrom ast import literal_eval\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def solve(self, board: List[List[str]]) -> None:\n        M, N = len(board), len(board[0])\n\n        def dfs(i, j):\n            if 0 <= i < M and 0 <= j < N and board[i][j] == 'O':\n                board[i][j] = 'T'\n                dfs(i + 1, j)\n                dfs(i - 1, j)\n                dfs(i, j + 1)\n                dfs(i, j - 1)\n\n        for i in range(M):\n            for j in range(N):\n                if i in [0, M - 1] or j in [0, N - 1]:\n                    dfs(i, j)\n\n        for i in range(M):\n            for j in range(N):\n                if board[i][j] == 'O':\n                    board[i][j] = 'X'\n                elif board[i][j] == 'T':\n                    board[i][j] = 'O'\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        ...\n\n    def encode_input(self, input_obj) -> str:\n        ...\n\n    def encode_output(self, output_obj) -> str:\n        ...\n\n    def decode_input(self, input_str) -> dict:\n        ...\n\n    def decode_output(self, output_str) -> str:\n        ...\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.solve(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.055",
            "memory": 5224,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 121, in <module>\n    runner.run()\n  File \"script.py\", line 105, in run\n    output = self.solution.solve(**input)\nTypeError: solve() argument after ** must be a mapping, not NoneType\n",
            "token": "2019c23c-b270-4a69-9dca-765c9b10e173",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "success",
        "question_id": 82,
        "title": "remove-duplicates-from-sorted-list-ii",
        "token": "abc1ca85-8be3-4abb-9577-3572c09403b0",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import Optional\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        dummy = ListNode(0, head)\n        prev, curr = dummy, head\n        while curr:\n            if curr.next and curr.val == curr.next.val:\n                while curr.next and curr.val == curr.next.val:\n                    curr = curr.next\n                prev.next = curr.next\n            else:\n                prev = curr\n            curr = curr.next\n        return dummy.next\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        list_values = self._create_random_sorted_list()\n        head = self._convert_list_to_linkedlist(list_values)\n        return {'head': head}\n\n    def encode_input(self, input_obj) -> str:\n        encoded_input = []\n        current = input_obj['head']\n        while current:\n            encoded_input.append(current.val)\n            current = current.next\n        return str(encoded_input)\n\n    def encode_output(self, output_obj) -> str:\n        encoded_output = []\n        current = output_obj\n        while current:\n            encoded_output.append(current.val)\n            current = current.next\n        return str(encoded_output)\n\n    def decode_input(self, input_str) -> dict:\n        node_values = eval(input_str)\n        head = self._convert_list_to_linkedlist(node_values)\n        return {'head': head}\n\n    def _create_random_sorted_list(self) -> list:\n        list_size = random.randint(0, 30)\n        values = []\n        while len(values) < list_size:\n            rand_value = random.randint(-100, 100)\n            if random.choice([True, False]):\n                values += [rand_value] * random.randint(1, 3)\n            else:\n                values.append(rand_value)\n        values = sorted(values[:300])\n        return values\n\n    def _convert_list_to_linkedlist(self, values: list) -> Optional[ListNode]:\n        if not values:\n            return None\n        head = ListNode(values[0])\n        current = head\n        for value in values[1:]:\n            current.next = ListNode(value)\n            current = current.next\n        return head\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.deleteDuplicates(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.06",
            "memory": 4912,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 142, in <module>\n    runner.run()\n  File \"script.py\", line 126, in run\n    output = self.solution.deleteDuplicates(**input)\n  File \"script.py\", line 50, in deleteDuplicates\n    dummy = ListNode(0, head)\nTypeError: __init__() takes 2 positional arguments but 3 were given\n",
            "token": "abc1ca85-8be3-4abb-9577-3572c09403b0",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "success",
        "question_id": 84,
        "title": "largest-rectangle-in-histogram",
        "token": "374a8680-18a9-48b5-9b44-23ada936884b",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def largestRectangleArea(self, heights: List[int]) -> int:\n        stack = []\n        max_area = 0\n        heights = [0] + heights + [0]\n\n        for i, h in enumerate(heights):\n            while stack and heights[stack[-1]] > h:\n                height = heights[stack.pop()]\n                width = i - stack[-1] - 1\n                max_area = max(max_area, height * width)\n            stack.append(i)\n\n        return max_area\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        num_bars = random.randint(1, 10)\n        heights = [random.randint(0, 10) for _ in range(num_bars)]\n        return {'heights': heights}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['heights'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        heights = eval(input_str)\n        return {'heights': heights}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.largestRectangleArea(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.057",
            "memory": 4760,
            "stderr": null,
            "token": "374a8680-18a9-48b5-9b44-23ada936884b",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 85,
        "title": "maximal-rectangle",
        "token": "22a24b2e-8a6c-4082-9351-5bafd009de9d",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\n        if not matrix:\n            return 0\n        m, n = len(matrix), len(matrix[0])\n        heights = [0] * n\n        max_area = 0\n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == '1':\n                    heights[j] += 1\n                else:\n                    heights[j] = 0\n            stack = [-1]\n            for j in range(n):\n                while stack[-1] != -1 and heights[stack[-1]] >= heights[j]:\n                    height = heights[stack.pop()]\n                    width = j - stack[-1] - 1\n                    max_area = max(max_area, height * width)\n                stack.append(j)\n            while stack[-1] != -1:\n                height = heights[stack.pop()]\n                width = n - stack[-1] - 1\n                max_area = max(max_area, height * width)\n        return max_area\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        rows = random.randint(1, 20)\n        cols = random.randint(1, 20)\n        matrix = [[random.choice(['0', '1']) for _ in range(cols)] for _ in range(rows)]\n        return {'matrix': matrix}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['matrix'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        input_list = eval(input_str)\n        return {'matrix': input_list}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.maximalRectangle(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.063",
            "memory": 5076,
            "stderr": null,
            "token": "22a24b2e-8a6c-4082-9351-5bafd009de9d",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 87,
        "title": "scramble-string",
        "token": "1fbd9ba5-c5a2-4fab-9b48-99be89c45eb5",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport numpy as np\nimport random\nimport string\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def isScramble(self, s1: str, s2: str) -> bool:\n        n = len(s1)\n        dp = [[[False] * n for _ in range(n)] for _ in range(n + 1)]\n        for i in range(n):\n            for j in range(n):\n                dp[1][i][j] = s1[i] == s2[j]\n        for length in range(2, n + 1):\n            for i in range(n - length + 1):\n                for j in range(n - length + 1):\n                    for k in range(1, length):\n                        dp[length][i][j] |= (dp[k][i][j] and dp[length - k][i + k][j + k]) or (dp[k][i][j + length - k] and dp[length - k][i + k][j])\n        return dp[n][0][0]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(1, 30)\n        s1 = ''.join(random.choices(string.ascii_lowercase, k=length))\n        s2 = self.scramble(s1)\n        return {'s1': s1, 's2': s2}\n\n    def scramble(self, s: str) -> str:\n        if len(s) == 1:\n            return s\n        i = random.randint(1, len(s) - 1)\n        x, y = (s[:i], s[i:])\n        if random.random() > 0.5:\n            return self.scramble(x) + self.scramble(y)\n        else:\n            return self.scramble(y) + self.scramble(x)\n\n    def encode_input(self, input_obj: dict) -> str:\n        return f\"{input_obj['s1']},{input_obj['s2']}\"\n\n    def encode_output(self, output_obj: bool) -> str:\n        return 'true' if output_obj else 'false'\n\n    def decode_input(self, input_str: str) -> dict:\n        s1, s2 = input_str.split(',')\n        return {'s1': s1, 's2': s2}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.isScramble(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.05",
            "memory": 4640,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 26, in <module>\n    import numpy as np\nModuleNotFoundError: No module named 'numpy'\n",
            "token": "1fbd9ba5-c5a2-4fab-9b48-99be89c45eb5",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "success",
        "question_id": 88,
        "title": "merge-sorted-array",
        "token": "ab320787-e5ce-47cd-96aa-6d1a73b10c3f",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\nimport ast\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\n        p1 = m - 1\n        p2 = n - 1\n        p = m + n - 1\n        while p2 >= 0:\n            if p1 >= 0 and nums1[p1] > nums2[p2]:\n                nums1[p] = nums1[p1]\n                p1 -= 1\n            else:\n                nums1[p] = nums2[p2]\n                p2 -= 1\n            p -= 1\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        test_cases = [{'nums1': [1, 2, 3, 0, 0, 0], 'm': 3, 'nums2': [2, 5, 6], 'n': 3}, {'nums1': [4, 5, 6, 0, 0, 0], 'm': 3, 'nums2': [1, 2, 3], 'n': 3}, {'nums1': [1], 'm': 1, 'nums2': [], 'n': 0}, {'nums1': [0], 'm': 0, 'nums2': [1], 'n': 1}, {'nums1': [1, 2, 4, 5, 6, 0, 0, 0], 'm': 5, 'nums2': [3, 7, 8], 'n': 3}]\n        return random.choice(test_cases)\n\n    def encode_input(self, input_obj) -> str:\n        return f'{input_obj}'\n\n    def encode_output(self, output_obj) -> str:\n        return f'{output_obj}'\n\n    def decode_input(self, input_str) -> dict:\n        return ast.literal_eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.merge(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.067",
            "memory": 5160,
            "stderr": null,
            "token": "ab320787-e5ce-47cd-96aa-6d1a73b10c3f",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 89,
        "title": "gray-code",
        "token": "66d2d9fb-c569-4768-94a2-e06ae4cbb33c",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def grayCode(self, n: int) -> List[int]:\n        result = [0]\n        for i in range(n):\n            result += [x + (1 << i) for x in reversed(result)]\n        return result\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 16)\n        return {'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"n = {input_obj['n']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return f'{output_obj}'\n\n    def decode_input(self, input_str) -> dict:\n        lines = input_str.split(' = ')\n        return {'n': int(lines[1])}\n\n    def decode_output(self, output_str) -> dict:\n        output_obj = eval(output_str)\n        return output_obj\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.grayCode(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.101",
            "memory": 15888,
            "stderr": null,
            "token": "66d2d9fb-c569-4768-94a2-e06ae4cbb33c",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 90,
        "title": "subsets-ii",
        "token": "519d266a-739f-4d0c-b1d1-64bffb59828f",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\n        ans = []\n        nums.sort()\n        def backtrack(index, subset):\n            ans.append(subset[:])\n            for i in range(index, len(nums)):\n                if i > index and nums[i] == nums[i-1]:\n                    continue\n                subset.append(nums[i])\n                backtrack(i + 1, subset)\n                subset.pop()\n        backtrack(0, [])\n        return ans\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(1, 10)\n        nums = [random.randint(-10, 10) for _ in range(length)]\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.subsetsWithDup(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Input {'nums': [-7, 2, 4]}\nExpected Output:  [[], [-7], [2], [-7, 2], [4], [-7, 4], [2, 4], [-7, 2, 4]]\nActual Output:  [[], [-7], [-7, 2], [-7, 2, 4], [-7, 4], [2], [2, 4], [4]]\n1 Test Failed!\n",
            "time": "0.063",
            "memory": 5408,
            "stderr": null,
            "token": "519d266a-739f-4d0c-b1d1-64bffb59828f",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 4,
                "description": "Wrong Answer"
            }
        }
    },
    {
        "status": "success",
        "question_id": 144,
        "title": "binary-tree-preorder-traversal",
        "token": "a1fab6d2-2c59-4bac-a67f-cdf20d0015cc",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List, Optional, Union\nimport random\n\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        res = []\n        def dfs(node):\n            if not node:\n                return\n            res.append(node.val)\n            dfs(node.left)\n            dfs(node.right)\n        dfs(root)\n        return res\n\nclass TestCaseGenerator:\n\n    class TreeNode:\n\n        def __init__(self, val=0, left=None, right=None):\n            self.val = val\n            self.left = left\n            self.right = right\n\n    def generate(self) -> dict:\n\n        def generate_random_tree(size=100):\n            if size == 0:\n                return None\n            nodes = [self.TreeNode(val=random.randint(-100, 100)) for _ in range(size)]\n            for i in range(size):\n                if 2 * i + 1 < size:\n                    nodes[i].left = nodes[2 * i + 1]\n                if 2 * i + 2 < size:\n                    nodes[i].right = nodes[2 * i + 2]\n            return nodes[0] if size > 0 else None\n        tree_size = random.randint(0, 10)\n        root = generate_random_tree(tree_size)\n        return {'root': root}\n\n    def encode_input(self, input_obj: dict) -> str:\n\n        def tree_to_list(root):\n            if not root:\n                return []\n            queue = [(root, 0)]\n            result = []\n            while queue:\n                node, index = queue.pop(0)\n                if node:\n                    if index >= len(result):\n                        result.extend([None] * (index - len(result) + 1))\n                    result[index] = node.val\n                    queue.append((node.left, 2 * index + 1))\n                    queue.append((node.right, 2 * index + 2))\n            while result and result[-1] is None:\n                result.pop()\n            return result\n        root = input_obj['root']\n        return str(tree_to_list(root))\n\n    def encode_output(self, output_obj: List[int]) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str: str) -> dict:\n\n        def list_to_tree(nodes: List[Union[int, None]]):\n            if not nodes:\n                return None\n            tree_nodes = [self.TreeNode(val=v) if v is not None else None for v in nodes]\n            for i in range(len(nodes)):\n                if tree_nodes[i] is not None:\n                    left_index = 2 * i + 1\n                    right_index = 2 * i + 2\n                    if left_index < len(tree_nodes):\n                        tree_nodes[i].left = tree_nodes[left_index]\n                    if right_index < len(tree_nodes):\n                        tree_nodes[i].right = tree_nodes[right_index]\n            return tree_nodes[0] if tree_nodes else None\n        nodes_list = eval(input_str)\n        root = list_to_tree(nodes_list)\n        return {'root': root}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.preorderTraversal(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.067",
            "memory": 4888,
            "stderr": null,
            "token": "a1fab6d2-2c59-4bac-a67f-cdf20d0015cc",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 148,
        "title": "sort-list",
        "token": "e4459b7a-d966-444d-ae2d-c5a39c137aad",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import Optional\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n\n        slow, fast = head, head.next\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        mid = slow.next\n        slow.next = None\n\n        left = self.sortList(head)\n        right = self.sortList(mid)\n\n        dummy = ListNode(0)\n        curr = dummy\n\n        while left and right:\n            if left.val < right.val:\n                curr.next = left\n                left = left.next\n            else:\n                curr.next = right\n                right = right.next\n            curr = curr.next\n\n        curr.next = left or right\n\n        return dummy.next\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        ...\n\n    def encode_input(self, input_obj) -> str:\n        ...\n\n    def encode_output(self, output_obj) -> str:\n        ...\n\n    def decode_input(self, input_str) -> dict:\n        ...\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.sortList(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.059",
            "memory": 4888,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 129, in <module>\n    runner.run()\n  File \"script.py\", line 113, in run\n    output = self.solution.sortList(**input)\nTypeError: sortList() argument after ** must be a mapping, not NoneType\n",
            "token": "e4459b7a-d966-444d-ae2d-c5a39c137aad",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "success",
        "question_id": 149,
        "title": "max-points-on-a-line",
        "token": "b27d0124-55fb-4c57-ac4d-d650a6c38c4f",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nfrom collections import defaultdict\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def maxPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        if n <= 2:\n            return n\n        max_count = 0\n        for i in range(n):\n            slopes = {}\n            duplicates = 1\n            for j in range(i + 1, n):\n                if points[i] == points[j]:\n                    duplicates += 1\n                else:\n                    dx = points[j][0] - points[i][0]\n                    dy = points[j][1] - points[i][1]\n                    if dx == 0:\n                        slope = float('inf')\n                    else:\n                        slope = dy / dx\n                    slopes[slope] = slopes.get(slope, 0) + 1\n            max_count = max(max_count, duplicates)\n            for slope_count in slopes.values():\n                max_count = max(max_count, slope_count + duplicates)\n        return max_count\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        simple_line = [[1, 1], [2, 2], [3, 3]]\n        mixed_points = [[1, 1], [3, 2], [5, 3], [4, 1], [2, 3], [1, 4]]\n        single_point = [[0, 0]]\n        return {'points': simple_line}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['points'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'points': eval(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.maxPoints(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.053",
            "memory": 4688,
            "stderr": null,
            "token": "b27d0124-55fb-4c57-ac4d-d650a6c38c4f",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 150,
        "title": "evaluate-reverse-polish-notation",
        "token": "6defba00-8518-4923-b49f-93b700399750",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport operator as op\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def evalRPN(self, tokens):\n        stack = []\n        for token in tokens:\n            if token == '+':\n                stack.append(stack.pop() + stack.pop())\n            elif token == '-':\n                op2 = stack.pop()\n                op1 = stack.pop()\n                stack.append(op1 - op2)\n            elif token == '*':\n                stack.append(stack.pop() * stack.pop())\n            elif token == '/':\n                op2 = stack.pop()\n                op1 = stack.pop()\n                stack.append(int(op1 / op2))\n            else:\n                stack.append(int(token))\n        return stack[0]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        operators = ['+', '-', '*', '/']\n        expressions = [('2', '1', '+', '3', '*'), ('4', '13', '5', '/', '+'), ('10', '6', '9', '3', '+', '-11', '*', '/', '*', '17', '+', '5', '+')]\n        selected_expr = random.choice(expressions)\n        return {'tokens': list(selected_expr)}\n\n    def encode_input(self, input_obj) -> str:\n        return ','.join(input_obj['tokens'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        tokens = input_str.split(',')\n        return {'tokens': tokens}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.evalRPN(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.06",
            "memory": 4764,
            "stderr": null,
            "token": "6defba00-8518-4923-b49f-93b700399750",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 153,
        "title": "find-minimum-in-rotated-sorted-array",
        "token": "fb6a5e52-9a52-4407-be60-3d4da4592cc4",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom random import randint, shuffle\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def findMin(self, arr: List[int]) -> int:\n        l, h = 0, len(arr) - 1\n        while l < h:\n            m = (l + h) // 2\n            if arr[m] > arr[h]:\n                l = m + 1\n            else:\n                h = m\n        return arr[l]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = randint(2, 100)\n        sorted_array = sorted((randint(-5000, 5000) for _ in range(n)))\n        k = randint(1, n)\n        rotated_array = sorted_array[-k:] + sorted_array[:-k]\n        return {'nums': rotated_array}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'nums': eval(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.findMin(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.067",
            "memory": 4892,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 107, in <module>\n    runner.run()\n  File \"script.py\", line 91, in run\n    output = self.solution.findMin(**input)\nTypeError: findMin() got an unexpected keyword argument 'nums'\n",
            "token": "fb6a5e52-9a52-4407-be60-3d4da4592cc4",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "success",
        "question_id": 160,
        "title": "intersection-of-two-linked-lists",
        "token": "0e79acc4-df71-4c37-8a8d-b0d40861ced6",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import Optional\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        pA, pB = headA, headB\n        while pA != pB:\n            pA = pA.next if pA else headB\n            pB = pB.next if pB else headA\n        return pA\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        \"\"\"\n        Generates a test case with an intersection in the linked list.\n        Returns a dictionary containing two linked list heads: headA and headB.\n        \"\"\"\n        common = ListNode(8)\n        common.next = ListNode(4)\n        common.next.next = ListNode(5)\n        listA = ListNode(4)\n        listA.next = ListNode(1)\n        listA.next.next = common\n        listB = ListNode(5)\n        listB.next = ListNode(6)\n        listB.next.next = ListNode(1)\n        listB.next.next.next = common\n        headA = listA\n        headB = listB\n        return {'headA': headA, 'headB': headB}\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\"\n        Encodes the length of both linked lists into a string.\n        \"\"\"\n        lengthA, lengthB = (0, 0)\n        currentA, currentB = (input_obj['headA'], input_obj['headB'])\n        while currentA:\n            lengthA += 1\n            currentA = currentA.next\n        while currentB:\n            lengthB += 1\n            currentB = currentB.next\n        return f'LENGTHS: A={lengthA}, B={lengthB}'\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\"\n        Returns the value of the intersecting node, or \"No Intersection\" if there isn\u2019t one.\n        \"\"\"\n        if output_obj:\n            return str(output_obj.val)\n        return 'No Intersection'\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\"\n        Decodes input (statically in our case) to provide test case linked lists.\n        \"\"\"\n        example_listA = [4, 1, 8, 4, 5]\n        example_listB = [5, 6, 1, 8, 4, 5]\n        headA, headB = (self._create_linked_list(example_listA), self._create_linked_list(example_listB))\n        return {'headA': headA, 'headB': headB}\n\n    def _create_linked_list(self, values):\n        \"\"\"\n        Helper method to create a linked list from a list of values.\n        \"\"\"\n        if not values:\n            return None\n        head = ListNode(values[0])\n        current = head\n        for val in values[1:]:\n            current.next = ListNode(val)\n            current = current.next\n        return head\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.getIntersectionNode(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.057",
            "memory": 4756,
            "stderr": null,
            "token": "0e79acc4-df71-4c37-8a8d-b0d40861ced6",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 238,
        "title": "product-of-array-except-self",
        "token": "9b12de08-6f2c-4ca1-9108-ae04dbed0b17",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nfrom random import randint\nimport ast\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        res = [1] * n\n        prefix = 1\n        for i in range(n):\n            res[i] = prefix\n            prefix *= nums[i]\n        postfix = 1\n        for i in range(n - 1, -1, -1):\n            res[i] *= postfix\n            postfix *= nums[i]\n        return res\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = randint(2, 10)\n        nums = [randint(-30, 30) for _ in range(length)]\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return ast.literal_eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.productExceptSelf(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.067",
            "memory": 5092,
            "stderr": null,
            "token": "9b12de08-6f2c-4ca1-9108-ae04dbed0b17",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 239,
        "title": "sliding-window-maximum",
        "token": "cba3537d-b70f-4480-8e12-bf47026a0975",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport heapq\nimport random\nimport json\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nfrom collections import deque\n\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        d = deque()\n        result = []\n        for i, num in enumerate(nums):\n            while d and nums[d[-1]] < num:\n                d.pop()\n            d.append(i)\n            if d[0] == i - k:\n                d.popleft()\n            if i >= k - 1:\n                result.append(nums[d[0]])\n        return result\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 100)\n        nums = [random.randint(-10000, 10000) for _ in range(n)]\n        k = random.randint(1, n)\n        return {'nums': nums, 'k': k}\n\n    def encode_input(self, input_obj: dict) -> str:\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj: list) -> str:\n        return json.dumps(output_obj)\n\n    def decode_input(self, input_str: str) -> dict:\n        return json.loads(input_str)\n\n    def decode_output(self, output_str: str) -> list:\n        return json.loads(output_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.maxSlidingWindow(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.066",
            "memory": 4908,
            "stderr": null,
            "token": "cba3537d-b70f-4480-8e12-bf47026a0975",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 241,
        "title": "different-ways-to-add-parentheses",
        "token": "de0d3654-e6df-4963-a8b9-b3aa1de8384d",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport functools\nimport random\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def diffWaysToCompute(self, expression: str) -> List[int]:\n        if expression.isdigit():\n            return [int(expression)]\n        res = []\n        for i, s in enumerate(expression):\n            if s in \"+-*\":\n                left = self.diffWaysToCompute(expression[:i])\n                right = self.diffWaysToCompute(expression[i+1:])\n                for l in left:\n                    for r in right:\n                        if s == '+':\n                            res.append(l + r)\n                        elif s == '-':\n                            res.append(l - r)\n                        else:\n                            res.append(l * r)\n        return res\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        operators = ['+', '-', '*']\n        num_parts = random.randint(2, 5)\n        expression = str(random.randint(0, 99))\n        for _ in range(num_parts - 1):\n            operator = random.choice(operators)\n            number = random.randint(0, 99)\n            expression += operator + str(number)\n        return {'expression': expression}\n\n    def encode_input(self, input_obj: dict) -> str:\n        return input_obj['expression']\n\n    def encode_output(self, output_obj: List[int]) -> str:\n        return ','.join(map(str, output_obj))\n\n    def decode_input(self, input_str: str) -> dict:\n        return {'expression': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.diffWaysToCompute(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.069",
            "memory": 4812,
            "stderr": null,
            "token": "de0d3654-e6df-4963-a8b9-b3aa1de8384d",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 242,
        "title": "valid-anagram",
        "token": "d6279f7d-23a1-4e93-b164-674a9813eb0a",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def isAnagram(self, s: str, t: str) -> bool:\n        if len(s) != len(t):\n            return False\n        count = {}\n        for char in s:\n            count[char] = count.get(char, 0) + 1\n        for char in t:\n            count[char] = count.get(char, 0) - 1\n        for val in count.values():\n            if val != 0:\n                return False\n        return True\n\nclass TestCaseGenerator:\n\n    def __init__(self):\n        self.examples = [{'s': 'anagram', 't': 'nagaram'}, {'s': 'rat', 't': 'car'}, {'s': 'listen', 't': 'silent'}, {'s': 'hello', 't': 'bello'}, {'s': 'debitcard', 't': 'badcredit'}]\n\n    def generate(self) -> dict:\n        return random.choice(self.examples)\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['s']},{input_obj['t']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj).lower()\n\n    def decode_input(self, input_str) -> dict:\n        s, t = input_str.split(',')\n        return {'s': s, 't': t}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.isAnagram(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.057",
            "memory": 4812,
            "stderr": null,
            "token": "d6279f7d-23a1-4e93-b164-674a9813eb0a",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 31,
        "title": "next-permutation",
        "token": "0b436735-3c7a-44d9-b05f-6f683b3b3309",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def nextPermutation(self, nums: List[int]) -> None:\n        i = len(nums) - 2\n        while i >= 0 and nums[i] >= nums[i + 1]:\n            i -= 1\n        if i >= 0:\n            j = len(nums) - 1\n            while nums[j] <= nums[i]:\n                j -= 1\n            nums[i], nums[j] = nums[j], nums[i]\n        nums[i+1:] = reversed(nums[i+1:])\n\nclass TestCaseGenerator:\n\n    def __init__(self):\n        self.sample = random.sample\n        self.randint = random.randint\n\n    def generate(self) -> dict:\n        length = self.randint(1, 10)\n        nums = self.sample(range(0, 101), length)\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'nums': list(map(int, input_str.strip('[]').split(',')))}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.nextPermutation(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.055",
            "memory": 4764,
            "stderr": null,
            "token": "0b436735-3c7a-44d9-b05f-6f683b3b3309",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 32,
        "title": "longest-valid-parentheses",
        "token": "66b8c4e4-d0f9-47e6-8355-a08b0869ede2",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def longestValidParentheses(self, s: str) -> int:\n        max_len = 0\n        stack = [-1]\n        for i in range(len(s)):\n            if s[i] == '(':\n                stack.append(i)\n            else:\n                stack.pop()\n                if not stack:\n                    stack.append(i)\n                else:\n                    max_len = max(max_len, i - stack[-1])\n        return max_len\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        length = random.randint(0, 20)\n        parentheses = [random.choice(['(', ')']) for _ in range(length)]\n        return {'s': ''.join(parentheses)}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['s']\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.longestValidParentheses(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.063",
            "memory": 4828,
            "stderr": null,
            "token": "66b8c4e4-d0f9-47e6-8355-a08b0869ede2",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 33,
        "title": "search-in-rotated-sorted-array",
        "token": "367bbd86-8998-442c-8d55-8a4cd03f1057",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        l, r = 0, len(nums) - 1\n        while l <= r:\n            mid = (l + r) // 2\n            if nums[mid] == target:\n                return mid\n            if (nums[l] <= nums[mid]):\n                if nums[l] <= target < nums[mid]:\n                    r = mid - 1\n                else:\n                    l = mid + 1\n            else:\n                if nums[mid] < target <= nums[r]:\n                    l = mid + 1\n                else:\n                    r = mid - 1\n        return -1\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 20)\n        array = sorted(random.sample(range(-50, 50), n))\n        k = random.randint(0, n - 1)\n        rotated_array = array[k:] + array[:k]\n        target = random.choice(rotated_array + [101])\n        return {'nums': rotated_array, 'target': target}\n\n    def encode_input(self, input_obj) -> str:\n        nums_str = ','.join(map(str, input_obj['nums']))\n        target_str = str(input_obj['target'])\n        return f'nums=[{nums_str}], target={target_str}'\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        input_str = input_str.strip()\n        nums_part = input_str.split('target=')[0].strip()\n        target_part = input_str.split('target=')[1].strip()\n        nums = list(map(int, nums_part[nums_part.index('[') + 1:nums_part.rindex(']')].split(',')))\n        target = int(target_part)\n        return {'nums': nums, 'target': target}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.search(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.053",
            "memory": 4788,
            "stderr": null,
            "token": "367bbd86-8998-442c-8d55-8a4cd03f1057",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 34,
        "title": "find-first-and-last-position-of-element-in-sorted-array",
        "token": "a1c3238c-4b66-4a50-8593-67e0e4fa42ed",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\n        l = bisect_left(nums, target)\n        if l == len(nums) or nums[l] != target:\n            return [-1, -1]\n        return [l, bisect_right(nums, target) - 1]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        test_cases = [{'nums': [5, 7, 7, 8, 8, 10], 'target': 8}, {'nums': [5, 7, 7, 8, 8, 10], 'target': 6}, {'nums': [], 'target': 0}, {'nums': [2, 2, 2, 2, 2], 'target': 2}, {'nums': [1, 3, 5, 6, 8, 10], 'target': 7}]\n        return random.choice(test_cases)\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['nums']}|{input_obj['target']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        nums_str, target_str = input_str.split('|')\n        nums = list(map(int, nums_str.strip('[]').split(','))) if nums_str.strip('[]') else []\n        target = int(target_str)\n        return {'nums': nums, 'target': target}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.searchRange(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.064",
            "memory": 4764,
            "stderr": null,
            "token": "a1c3238c-4b66-4a50-8593-67e0e4fa42ed",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 191,
        "title": "number-of-1-bits",
        "token": "9af1071e-f09d-4d88-af0e-b3c562e8f6ce",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport json\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def hammingWeight(self, n: int) -> int:\n        return bin(n).count('1')\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 2 ** 20)\n        return {'n': n}\n\n    def encode_input(self, input_obj: dict) -> str:\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj: int) -> str:\n        return json.dumps({'result': output_obj})\n\n    def decode_input(self, input_str: str) -> dict:\n        return json.loads(input_str)\n\n    def decode_output(self, output_str: str) -> int:\n        return json.loads(output_str)['result']\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.hammingWeight(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.061",
            "memory": 4724,
            "stderr": null,
            "token": "9af1071e-f09d-4d88-af0e-b3c562e8f6ce",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 198,
        "title": "house-robber",
        "token": "8ff0aa43-947b-4a7e-b030-8b1ce61307ea",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def rob(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n        if len(nums) <= 2:\n            return max(nums)\n        a, b = nums[0], max(nums[0], nums[1])\n        for i in range(2, len(nums)):\n            a, b = b, max(b, a + nums[i])\n        return b\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(2, 20)\n        nums = [random.randint(0, 400) for _ in range(length)]\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        nums = eval(input_str)\n        return {'nums': nums}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.rob(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.053",
            "memory": 4844,
            "stderr": null,
            "token": "8ff0aa43-947b-4a7e-b030-8b1ce61307ea",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "failure",
        "question_id": 199,
        "title": "binary-tree-right-side-view",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "success",
        "question_id": 201,
        "title": "bitwise-and-of-numbers-range",
        "token": "a23e35c9-1a9a-4b60-9ca4-135a2ca1e5e0",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def rangeBitwiseAnd(self, left: int, right: int) -> int:\n        while left < right:\n            right &= (right - 1)\n        return right\n\nclass TestCaseGenerator:\n\n    @staticmethod\n    def generate() -> dict:\n        left = random.randint(0, 10000)\n        right = random.randint(left, left + random.randint(0, 10000))\n        return {'left': left, 'right': right}\n\n    @staticmethod\n    def encode_input(input_obj) -> str:\n        return f\"{input_obj['left']},{input_obj['right']}\"\n\n    @staticmethod\n    def encode_output(output_obj) -> str:\n        return str(output_obj)\n\n    @staticmethod\n    def decode_input(input_str) -> dict:\n        left, right = map(int, input_str.split(','))\n        return {'left': left, 'right': right}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.rangeBitwiseAnd(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.051",
            "memory": 4748,
            "stderr": null,
            "token": "a23e35c9-1a9a-4b60-9ca4-135a2ca1e5e0",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 202,
        "title": "happy-number",
        "token": "55c43b28-c860-491f-8097-4f1c7efdb5fc",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def isHappy(self, n: int) -> bool:\n        seen = set()\n        while n != 1 and n not in seen:\n            seen.add(n)\n            n = sum(int(d)**2 for d in str(n))\n        return n == 1\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        return {'n': random.randint(1, 100)}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['n'])\n\n    def encode_output(self, output_obj) -> str:\n        return 'true' if output_obj else 'false'\n\n    def decode_input(self, input_str) -> dict:\n        return {'n': int(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.isHappy(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.061",
            "memory": 4784,
            "stderr": null,
            "token": "55c43b28-c860-491f-8097-4f1c7efdb5fc",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 204,
        "title": "count-primes",
        "token": "0cd85b07-9027-4deb-862b-432252285cbf",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nimport math\n\nclass Solution:\n    def countPrimes(self, n: int) -> int:\n        if n < 3:\n            return 0\n        primes = [True] * n\n        primes[0] = primes[1] = False\n        for i in range(2, int(math.sqrt(n)) + 1):\n            if primes[i]:\n                primes[i*i:n:i] = [False] * len(primes[i*i:n:i])\n        return sum(primes)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(0, 100)\n        return {'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['n'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'n': int(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.countPrimes(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.051",
            "memory": 4748,
            "stderr": null,
            "token": "0cd85b07-9027-4deb-862b-432252285cbf",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 205,
        "title": "isomorphic-strings",
        "token": "6f063bdf-5069-4ca8-97c7-abda1080e24c",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport string\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def isIsomorphic(self, s: str, t: str) -> bool:\n        s_map = {}\n        t_map = {}\n        for i in range(len(s)):\n            s_char = s[i]\n            t_char = t[i]\n            if s_char not in s_map and t_char not in t_map:\n                s_map[s_char] = t_char\n                t_map[t_char] = s_char\n            elif s_char in s_map and t_char in t_map:\n                if s_map[s_char] != t_char or t_map[t_char] != s_char:\n                    return False\n            else:\n                return False\n        return True\n\nclass TestCaseGenerator:\n\n    def __init__(self):\n        self.libraries = ['random', 'string']\n\n    def generate(self) -> dict:\n        length = random.randint(1, 100)\n        s = ''.join((random.choice(string.ascii_letters) for _ in range(length)))\n        t = ''.join((random.choice(string.ascii_letters) for _ in range(length)))\n        return {'s': s, 't': t}\n\n    def encode_input(self, input_obj) -> str:\n        return f'''s = \"{input_obj['s']}\", t = \"{input_obj['t']}\"'''\n\n    def encode_output(self, output_obj) -> str:\n        return 'true' if output_obj else 'false'\n\n    def decode_input(self, input_str) -> dict:\n        input_parts = input_str.split(', ')\n        s_value = input_parts[0].split('= ')[1].strip('\"')\n        t_value = input_parts[1].split('= ')[1].strip('\"')\n        return {'s': s_value, 't': t_value}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.isIsomorphic(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.053",
            "memory": 4872,
            "stderr": null,
            "token": "6f063bdf-5069-4ca8-97c7-abda1080e24c",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 210,
        "title": "course-schedule-ii",
        "token": "b2bcb244-9bb2-4dff-8685-8daa522107f3",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom collections import deque\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\n        adj = [[] for _ in range(numCourses)]\n        indegree = [0] * numCourses\n        for course, pre in prerequisites:\n            adj[pre].append(course)\n            indegree[course] += 1\n        \n        queue = [i for i in range(numCourses) if indegree[i] == 0]\n        result = []\n        \n        while queue:\n            node = queue.pop(0)\n            result.append(node)\n            \n            for neighbor in adj[node]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    queue.append(neighbor)\n        \n        return result if len(result) == numCourses else []\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        numCourses = random.randint(1, 10)\n        prereq_num = random.randint(0, min(10, numCourses * (numCourses - 1)))\n        prerequisites = []\n        seen = set()\n        for _ in range(prereq_num):\n            a, b = random.sample(range(numCourses), 2)\n            if (a, b) not in seen:\n                seen.add((a, b))\n                prerequisites.append([a, b])\n        return {'numCourses': numCourses, 'prerequisites': prerequisites}\n\n    def encode_input(self, input_obj: dict) -> str:\n        return f\"{input_obj['numCourses']}, {input_obj['prerequisites']}\"\n\n    def encode_output(self, output_obj: list) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str: str) -> dict:\n        num_courses_str, prerequisites_str = input_str.split(',', 1)\n        num_courses = int(num_courses_str)\n        prerequisites = eval(prerequisites_str.strip())\n        return {'numCourses': num_courses, 'prerequisites': prerequisites}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.findOrder(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Input {'numCourses': 8, 'prerequisites': [[4, 3], [2, 7], [5, 7], [5, 6], [6, 7]]}\nExpected Output:  deque([1, 0, 7, 6, 5, 2, 3, 4])\nActual Output:  [0, 1, 3, 7, 4, 2, 6, 5]\n1 Test Failed!\n",
            "time": "0.056",
            "memory": 4788,
            "stderr": null,
            "token": "b2bcb244-9bb2-4dff-8685-8daa522107f3",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 4,
                "description": "Wrong Answer"
            }
        }
    },
    {
        "status": "success",
        "question_id": 214,
        "title": "shortest-palindrome",
        "token": "e7bb3aa9-4ce6-444a-a9d9-fc36b6418bd4",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport string\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def shortestPalindrome(self, s: str) -> str:\n        n = len(s)\n        for i in range(n, 0, -1):\n            if s[:i] == s[:i][::-1]:\n                return s[i:][::-1] + s\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(1, 100)\n        random_str = ''.join((random.choice(string.ascii_lowercase) for _ in range(length)))\n        return {'s': random_str}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['s']\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.shortestPalindrome(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.066",
            "memory": 4896,
            "stderr": null,
            "token": "e7bb3aa9-4ce6-444a-a9d9-fc36b6418bd4",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 216,
        "title": "combination-sum-iii",
        "token": "14c17b1f-56fa-4dbb-b6f5-77da953c1bf6",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\n        if 45 - (9 - k) * (10 - k) / 2 < n or k * (k + 1) / 2 > n:\n            return []\n\n        def backtrack(comb, start, remain):\n            if remain == 0 and len(comb) == k:\n                result.append(comb[:])\n                return\n            if len(comb) == k or remain < 0:\n                return\n            for i in range(start, 10):\n                comb.append(i)\n                backtrack(comb, i + 1, remain - i)\n                comb.pop()\n\n        result = []\n        backtrack([], 1, n)\n        return result\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        k = random.randint(2, 9)\n        n = random.randint(1, 60)\n        return {'k': k, 'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['k']} {input_obj['n']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        k, n = map(int, input_str.split())\n        return {'k': k, 'n': n}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.combinationSum3(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.064",
            "memory": 4860,
            "stderr": null,
            "token": "14c17b1f-56fa-4dbb-b6f5-77da953c1bf6",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 91,
        "title": "decode-ways",
        "token": "e3f00543-d706-40ef-a4f7-2eb3aef3dcd3",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def numDecodings(self, s: str) -> int:\n        n = len(s)\n        dp = [0] * (n + 1)\n        dp[n] = 1\n        for i in range(n - 1, -1, -1):\n            if s[i] != '0':\n                dp[i] = dp[i + 1]\n                if i + 1 < n and (s[i] == '1' or (s[i] == '2' and s[i + 1] <= '6')):\n                    dp[i] += dp[i + 2]\n        return dp[0]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        length = random.randint(1, 100)\n        digits = ''.join((random.choice('0123456789') for _ in range(length)))\n        return {'s': digits}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['s']\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.numDecodings(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.066",
            "memory": 4800,
            "stderr": null,
            "token": "e3f00543-d706-40ef-a4f7-2eb3aef3dcd3",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 93,
        "title": "restore-ip-addresses",
        "token": "a279dfca-152d-45eb-896b-343e458b750e",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        def isValid(segment):\n            return 0 <= int(segment) <= 255 and (segment == '0' or not segment.startswith('0'))\n\n        def backtrack(start, dots, current_ip):\n            if dots == 4:\n                if start == len(s):\n                    result.append(current_ip[:-1])\n                return\n\n            for i in range(start, min(start + 3, len(s))):\n                segment = s[start:i + 1]\n                if isValid(segment):\n                    backtrack(i + 1, dots + 1, current_ip + segment + '.')\n\n        result = []\n        backtrack(0, 0, '')\n        return result\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        \"\"\"Generates a random test case for the restoreIpAddresses function.\"\"\"\n        s = ''.join((random.choice('0123456789') for _ in range(random.randint(4, 12))))\n        return {'s': s}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['s']\n\n    def encode_output(self, output_obj) -> str:\n        return ','.join(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.restoreIpAddresses(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.056",
            "memory": 4792,
            "stderr": null,
            "token": "a279dfca-152d-45eb-896b-343e458b750e",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "failure",
        "question_id": 127,
        "title": "word-ladder",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "success",
        "question_id": 81,
        "title": "search-in-rotated-sorted-array-ii",
        "token": "1fe32058-a3f5-4d3f-affe-452f7c891f9e",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def search(self, nums: List[int], target: int) -> bool:\n        l, r = 0, len(nums) - 1\n        while l <= r:\n            mid = (l + r) // 2\n            if nums[mid] == target:\n                return True\n            if nums[l] == nums[mid] == nums[r]:\n                l += 1\n                r -= 1\n            elif nums[l] <= nums[mid]:\n                if nums[l] <= target < nums[mid]:\n                    r = mid - 1\n                else:\n                    l = mid + 1\n            else:\n                if nums[mid] < target <= nums[r]:\n                    l = mid + 1\n                else:\n                    r = mid - 1\n        return False\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        n = random.randint(1, 100)\n        nums = sorted([random.randint(-10000, 10000) for _ in range(n)])\n        pivot = random.randint(0, n - 1)\n        nums = nums[pivot:] + nums[:pivot]\n        target = random.choice(nums + [random.randint(-10000, 10000)])\n        return {'nums': nums, 'target': target}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.search(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.056",
            "memory": 4944,
            "stderr": null,
            "token": "1fe32058-a3f5-4d3f-affe-452f7c891f9e",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 151,
        "title": "reverse-words-in-a-string",
        "token": "9929b061-6cac-42b5-a8fb-09b465b69400",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def reverseWords(self, s: str) -> str:\n        return \" \".join(s.split()[::-1])\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        test_cases = [{'s': 'the sky is blue'}, {'s': '  hello world  '}, {'s': 'a good   example'}, {'s': 'singleword'}, {'s': '  multiple words   with   extra spaces '}, {'s': '    boundary   '}]\n        return test_cases[0]\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['s']\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.reverseWords(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.07",
            "memory": 4832,
            "stderr": null,
            "token": "9929b061-6cac-42b5-a8fb-09b465b69400",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 152,
        "title": "maximum-product-subarray",
        "token": "0fe1a317-7731-4247-bd1d-89e40bbcf016",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def maxProduct(self, nums: List[int]) -> int:\n        max_prod = float('-inf')\n        prefix, suffix = 1, 1\n        n = len(nums)\n        for i in range(n):\n            prefix = (prefix or 1) * nums[i]\n            suffix = (suffix or 1) * nums[n - i - 1]\n            max_prod = max(max_prod, prefix, suffix)\n        return max_prod\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        nums_length = random.randint(1, 20)\n        nums = [random.randint(-10, 10) for _ in range(nums_length)]\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.maxProduct(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.068",
            "memory": 4876,
            "stderr": null,
            "token": "0fe1a317-7731-4247-bd1d-89e40bbcf016",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "failure",
        "question_id": 95,
        "title": "unique-binary-search-trees-ii",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "success",
        "question_id": 96,
        "title": "unique-binary-search-trees",
        "token": "b0d7864a-6910-4510-9050-d91396f551d6",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport json\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def numTrees(self, n: int) -> int:\n        dp = [0] * (n + 1)\n        dp[0] = dp[1] = 1\n        for i in range(2, n + 1):\n            for j in range(1, i + 1):\n                dp[i] += dp[j - 1] * dp[i - j]\n        return dp[n]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 19)\n        return {'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return json.dumps(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return json.loads(input_str)\n\n    def decode_output(self, output_str) -> int:\n        return json.loads(output_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.numTrees(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.085",
            "memory": 4852,
            "stderr": null,
            "token": "b0d7864a-6910-4510-9050-d91396f551d6",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 97,
        "title": "interleaving-string",
        "token": "5d5e7140-289b-405a-ac39-fd23add85018",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import Dict\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        if len(s1) + len(s2) != len(s3):\n            return False\n        n, m, l = len(s1), len(s2), len(s3)\n        dp = [False] * (m + 1)\n        dp[0] = True\n        for j in range(1, m + 1):\n            dp[j] = dp[j - 1] and s2[j - 1] == s3[j - 1]\n        for i in range(1, n + 1):\n            dp[0] = dp[0] and s1[i - 1] == s3[i - 1]\n            for j in range(1, m + 1):\n                dp[j] = (dp[j - 1] and s2[j - 1] == s3[i + j - 1]) or (dp[j] and s1[i - 1] == s3[i + j - 1])\n        return dp[m]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        return {'s1': 'aabcc', 's2': 'dbbca', 's3': 'aadbbcbcac'}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{{'s1': '{input_obj['s1']}', 's2': '{input_obj['s2']}', 's3': '{input_obj['s3']}'}}\"\n\n    def encode_output(self, output_obj) -> str:\n        return 'true' if output_obj else 'false'\n\n    def decode_input(self, input_str) -> dict:\n        input_obj = eval(input_str)\n        return {'s1': input_obj['s1'], 's2': input_obj['s2'], 's3': input_obj['s3']}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.isInterleave(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.061",
            "memory": 4716,
            "stderr": null,
            "token": "5d5e7140-289b-405a-ac39-fd23add85018",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 1,
        "title": "two-sum",
        "token": "3ac9083f-dab4-4f1f-b16f-5439f09feb0c",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        num_map = {}\n        for index, num in enumerate(nums):\n            complement = target - num\n            if complement in num_map:\n                return [num_map[complement], index]\n            num_map[num] = index\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        length = random.randint(2, 10)\n        nums = random.sample(range(-100, 100), length)\n        idx1, idx2 = random.sample(range(length), 2)\n        target = nums[idx1] + nums[idx2]\n        return {'nums': nums, 'target': target}\n\n    def encode_input(self, input_obj) -> str:\n        nums_str = ','.join(map(str, input_obj['nums']))\n        return f\"nums=[{nums_str}],target={input_obj['target']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return f'{output_obj[0]},{output_obj[1]}'\n\n    def decode_input(self, input_str) -> dict:\n        input_vars = input_str.split('],')\n        nums_str = input_vars[0].replace('nums=[', '')\n        nums = list(map(int, nums_str.split(',')))\n        target = int(input_vars[1].replace('target=', ''))\n        return {'nums': nums, 'target': target}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.twoSum(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.069",
            "memory": 4812,
            "stderr": null,
            "token": "3ac9083f-dab4-4f1f-b16f-5439f09feb0c",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 5,
        "title": "longest-palindromic-substring",
        "token": "9c869b0a-6676-4173-89a1-15ad1db946b0",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport string\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        longest = ''\n        for i in range(len(s)):\n            l, r = i, i\n            while l >= 0 and r < len(s) and s[l] == s[r]:\n                if (r - l + 1) > len(longest):\n                    longest = s[l:r+1]\n                l -= 1\n                r += 1\n            l, r = i, i + 1\n            while l >= 0 and r < len(s) and s[l] == s[r]:\n                if (r - l + 1) > len(longest):\n                    longest = s[l:r+1]\n                l -= 1\n                r += 1\n        return longest\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(1, 100)\n        s = ''.join(random.choices(string.ascii_letters + string.digits, k=length))\n        return {'s': s}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['s']\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.longestPalindrome(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.068",
            "memory": 4868,
            "stderr": null,
            "token": "9c869b0a-6676-4173-89a1-15ad1db946b0",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 6,
        "title": "zigzag-conversion",
        "token": "2ed85aac-9285-4c3f-9aea-ef45ba7e8420",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom math import ceil\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def convert(self, s: str, numRows: int) -> str:\n        if numRows <= 1:\n            return s\n        rows = [''] * numRows\n        currRow, direction = 0, 1\n        for char in s:\n            rows[currRow] += char\n            if currRow == 0:\n                direction = 1\n            elif currRow == numRows - 1:\n                direction = -1\n            currRow += direction\n        return ''.join(rows)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz,.'\n        string_length = random.randint(1, 20)\n        random_string = ''.join((random.choice(letters) for _ in range(string_length)))\n        num_rows = random.randint(1, min(string_length, 10))\n        return {'s': random_string, 'numRows': num_rows}\n\n    def encode_input(self, input_obj) -> str:\n        s = input_obj['s']\n        numRows = input_obj['numRows']\n        return f\"{{'s': '{s}', 'numRows': {numRows}}}\"\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        return eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.convert(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.06",
            "memory": 4844,
            "stderr": null,
            "token": "2ed85aac-9285-4c3f-9aea-ef45ba7e8420",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 8,
        "title": "string-to-integer-atoi",
        "token": "5639a181-cc41-4da7-a803-46b887b60529",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def myAtoi(self, s: str) -> int:\n        s = s.strip()\n        sign = 1\n        result = 0\n        index = 0\n        n = len(s)\n        INT_MAX = 2**31 - 1\n        INT_MIN = -2**31\n\n        if index < n and (s[index] == '+' or s[index] == '-'):\n            sign = -1 if s[index] == '-' else 1\n            index += 1\n\n        while index < n and s[index].isdigit():\n            digit = int(s[index])\n            if result > INT_MAX // 10 or (result == INT_MAX // 10 and digit > 7):\n                return INT_MAX if sign == 1 else INT_MIN\n            result = result * 10 + digit\n            index += 1\n\n        return sign * result\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        cases = ['42', '    -42', '+123', '1337abc', ' ', '9223372036854775808', '-2147483649', '3.14159', '00100', 'words 456']\n        return {'s': random.choice(cases)}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['s']\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.myAtoi(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.062",
            "memory": 4828,
            "stderr": null,
            "token": "5639a181-cc41-4da7-a803-46b887b60529",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 309,
        "title": "best-time-to-buy-and-sell-stock-with-cooldown",
        "token": "8d9021f4-2f1c-401f-acd4-1e17d8a3269a",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List\nimport ast\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution(object):\n    def maxProfit(self, prices):\n        n = len(prices)\n        dp = [0] * (n + 2)\n        for i in range(n - 1, -1, -1):\n            dp[i] = max(max(prices[j] - prices[i] + dp[j + 2] for j in range(i + 1, n)), dp[i + 1])\n        return dp[0]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(1, 100)\n        prices = [random.randint(0, 1000) for _ in range(length)]\n        return {'prices': prices}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['prices'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        prices = ast.literal_eval(input_str)\n        return {'prices': prices}\n\n    def decode_output(self, output_str) -> int:\n        return int(output_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.maxProfit(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.076",
            "memory": 5192,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 107, in <module>\n    runner.run()\n  File \"script.py\", line 91, in run\n    output = self.solution.maxProfit(**input)\n  File \"script.py\", line 54, in maxProfit\n    dp[i] = max(max(prices[j] - prices[i] + dp[j + 2] for j in range(i + 1, n)), dp[i + 1])\nValueError: max() arg is an empty sequence\n",
            "token": "8d9021f4-2f1c-401f-acd4-1e17d8a3269a",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "success",
        "question_id": 312,
        "title": "burst-balloons",
        "token": "d8283122-97f9-49ec-994d-6eb82a2ecd13",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def maxCoins(self, nums: List[int]) -> int:\n        nums = [1] + nums + [1]\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n\n        for len_ in range(2, n):\n            for left in range(0, n - len_):\n                right = left + len_\n                for i in range(left + 1, right):\n                    dp[left][right] = max(dp[left][right], nums[left] * nums[i] * nums[right] + dp[left][i] + dp[i][right])\n\n        return dp[0][n - 1]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        n = random.randint(1, 10)\n        nums = [random.randint(0, 100) for _ in range(n)]\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        nums = eval(input_str)\n        return {'nums': nums}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.maxCoins(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.075",
            "memory": 4808,
            "stderr": null,
            "token": "d8283122-97f9-49ec-994d-6eb82a2ecd13",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 299,
        "title": "bulls-and-cows",
        "token": "71720a2e-2242-49d3-86ca-a0ebb0e51513",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom collections import Counter\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def getHint(self, secret: str, guess: str) -> str:\n        bulls = sum(s == g for s, g in zip(secret, guess))\n        secret_counts = {}\n        guess_counts = {}\n        for s, g in zip(secret, guess):\n            if s != g:\n                secret_counts[s] = secret_counts.get(s, 0) + 1\n                guess_counts[g] = guess_counts.get(g, 0) + 1\n        cows = 0\n        for digit, count in guess_counts.items():\n            if digit in secret_counts:\n                cows += min(count, secret_counts[digit])\n        return f'{bulls}A{cows}B'\n\nclass TestCaseGenerator:\n\n    def __init__(self):\n        self.random = random\n\n    def generate(self) -> dict:\n        length = self.random.randint(1, 10)\n        secret = ''.join(self.random.choices('0123456789', k=length))\n        guess = ''.join(self.random.choices('0123456789', k=length))\n        return {'secret': secret, 'guess': guess}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"secret={input_obj['secret']}&guess={input_obj['guess']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        parts = input_str.split('&')\n        secret = parts[0].split('=')[1]\n        guess = parts[1].split('=')[1]\n        return {'secret': secret, 'guess': guess}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.getHint(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.059",
            "memory": 4788,
            "stderr": null,
            "token": "71720a2e-2242-49d3-86ca-a0ebb0e51513",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 301,
        "title": "remove-invalid-parentheses",
        "token": "42df142a-2a1e-4bf4-b81f-2ea30c79d2ee",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def removeInvalidParentheses(self, s: str) -> List[str]:\n        def is_valid(s):\n            count = 0\n            for char in s:\n                if char == '(':\n                    count += 1\n                elif char == ')':\n                    count -= 1\n                if count < 0:\n                    return False\n            return count == 0\n\n        level = {s}\n        while True:\n            valid = list(filter(is_valid, level))\n            if valid:\n                return valid\n            next_level = set()\n            for item in level:\n                for i in range(len(item)):\n                    if item[i] in '()':\n                        next_level.add(item[:i] + item[i+1:])\n            level = next_level\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        input_length = random.randint(1, 25)\n        charset = 'abcdefghijklmnopqrstuvwxyz()'\n        s = ''.join((random.choice(charset) for _ in range(input_length)))\n        return {'s': s}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj.get('s', '')\n\n    def encode_output(self, output_obj) -> str:\n        return ','.join(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.removeInvalidParentheses(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Input {'s': ')erslahfmk'}\nExpected Output:  bgcnljowklo\nActual Output:  erslahfmk\n2 Test Failed!\n",
            "time": "0.061",
            "memory": 4812,
            "stderr": null,
            "token": "42df142a-2a1e-4bf4-b81f-2ea30c79d2ee",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 4,
                "description": "Wrong Answer"
            }
        }
    },
    {
        "status": "success",
        "question_id": 162,
        "title": "find-peak-element",
        "token": "b006959c-9977-4de6-804a-1099f25d4782",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\nimport ast\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def findPeakElement(self, nums: List[int]) -> int:\n        l, r = 0, len(nums) - 1\n        while l < r:\n            mid = (l + r) // 2\n            if nums[mid] > nums[mid+1]:\n                r = mid\n            else:\n                l = mid + 1\n        return l\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        \"\"\" Generate a random test case within problem constraints. \"\"\"\n        length = random.randint(1, 1000)\n        nums = [random.randint(-1000, 1000) for _ in range(length)]\n        for i in range(1, len(nums)):\n            while nums[i] == nums[i - 1]:\n                nums[i] = random.randint(-1000, 1000)\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\" Convert test case input to string. \"\"\"\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\" Convert test case output to string. \"\"\"\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\" Convert input string back to dictionary format. \"\"\"\n        return {'nums': ast.literal_eval(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.findPeakElement(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.088",
            "memory": 6560,
            "stderr": null,
            "token": "b006959c-9977-4de6-804a-1099f25d4782",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 164,
        "title": "maximum-gap",
        "token": "23d8a606-74c5-4af6-b9d1-aa3f2519d62a",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom random import randint, shuffle\nfrom typing import List, Dict\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def maximumGap(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n < 2:\n            return 0\n        a, b = min(nums), max(nums)\n        if a == b:\n            return 0\n        size = (b - a) / (n - 1) or 1\n        buckets = [[float('inf'), float('-inf')] for _ in range(n)]\n        for x in nums:\n            idx = int((x - a) / size)\n            buckets[idx][0] = min(buckets[idx][0], x)\n            buckets[idx][1] = max(buckets[idx][1], x)\n        gap = 0\n        prev = buckets[0][1]\n        for i in range(1, n):\n            if buckets[i][0] != float('inf'):\n                gap = max(gap, buckets[i][0] - prev)\n                prev = buckets[i][1]\n        return gap\n\nclass TestCaseGenerator:\n\n    def generate(self) -> Dict[str, List[int]]:\n        case_type = randint(1, 3)\n        if case_type == 1:\n            nums = [3, 6, 9, 1]\n        elif case_type == 2:\n            size = randint(2, 100)\n            nums = [randint(0, 1000) for _ in range(size)]\n        else:\n            nums = [10]\n        shuffle(nums)\n        return {'nums': nums}\n\n    def encode_input(self, input_obj: Dict[str, List[int]]) -> str:\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj: int) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str: str) -> Dict[str, List[int]]:\n        nums = [int(x) for x in input_str.strip('[]').split(',') if x.strip()]\n        return {'nums': nums}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.maximumGap(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.059",
            "memory": 4784,
            "stderr": null,
            "token": "23d8a606-74c5-4af6-b9d1-aa3f2519d62a",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 166,
        "title": "fraction-to-recurring-decimal",
        "token": "fe6b6a24-eb7d-4faf-b758-be09d5b9ac97",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\n        if numerator == 0:\n            return \"0\"\n        sign = \"-\" if (numerator * denominator < 0) else \"\"\n        numerator, denominator = abs(numerator), abs(denominator)\n        integer_part = numerator // denominator\n        remainder = numerator % denominator\n        if remainder == 0:\n            return sign + str(integer_part)\n        decimal_part = \"\"\n        remainder_map = {}\n        while remainder != 0:\n            if remainder in remainder_map:\n                index = remainder_map[remainder]\n                return sign + str(integer_part) + \".\" + decimal_part[:index] + \"(\" + decimal_part[index:] + \")\"\n            remainder_map[remainder] = len(decimal_part)\n            remainder *= 10\n            decimal_part += str(remainder // denominator)\n            remainder %= denominator\n        return sign + str(integer_part) + \".\" + decimal_part\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        numerators = [1, 2, 4, random.randint(-1000, 1000)]\n        denominators = [2, 1, 333, random.randint(-1000, 1000)]\n        numerator = random.choice(numerators)\n        denominator = random.choice([d for d in denominators if d != 0])\n        return {'numerator': numerator, 'denominator': denominator}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['numerator']},{input_obj['denominator']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        numerator, denominator = map(int, input_str.split(','))\n        return {'numerator': numerator, 'denominator': denominator}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.fractionToDecimal(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.068",
            "memory": 4756,
            "stderr": null,
            "token": "fe6b6a24-eb7d-4faf-b758-be09d5b9ac97",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 168,
        "title": "excel-sheet-column-title",
        "token": "c7fc37fa-af92-4d94-8e1a-e74512ead2a0",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def convertToTitle(self, columnNumber: int) -> str:\n        result = ''\n        while columnNumber > 0:\n            columnNumber -= 1\n            result = chr(65 + (columnNumber % 26)) + result\n            columnNumber //= 26\n        return result\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        column_number = random.randint(1, 1000)\n        return {'columnNumber': column_number}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['columnNumber'])\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        column_number = int(input_str)\n        return {'columnNumber': column_number}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.convertToTitle(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.065",
            "memory": 4740,
            "stderr": null,
            "token": "c7fc37fa-af92-4d94-8e1a-e74512ead2a0",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 43,
        "title": "multiply-strings",
        "token": "c29a2460-81fe-4354-a162-083ee59d248b",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def multiply(self, num1: str, num2: str) -> str:\n        if num1 == \"0\" or num2 == \"0\":\n            return \"0\"\n        n, m = len(num1), len(num2)\n        product = [0] * (n + m)\n        \n        for i in range(n - 1, -1, -1):\n            carry = 0\n            for j in range(m - 1, -1, -1):\n                product[i + j + 1] += int(num1[i]) * int(num2[j]) + carry\n                carry = product[i + j + 1] // 10\n                product[i + j + 1] %= 10\n            product[i] += carry\n        \n        result = \"\".join(map(str, product))\n        while result[0] == '0' and len(result) > 1:\n            result = result[1:]\n        return result\n\nclass TestCaseGenerator:\n\n    def __init__(self):\n        self.max_len = 200\n\n    def generate(self) -> dict:\n        import random\n        len1 = random.randint(1, self.max_len)\n        len2 = random.randint(1, self.max_len)\n        num1 = ''.join([random.choice('123456789') if i == 0 else random.choice('0123456789') for i in range(len1)])\n        num2 = ''.join([random.choice('123456789') if i == 0 else random.choice('0123456789') for i in range(len2)])\n        return {'num1': num1, 'num2': num2}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['num1']},{input_obj['num2']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        num1, num2 = input_str.split(',')\n        return {'num1': num1, 'num2': num2}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.multiply(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.175",
            "memory": 5024,
            "stderr": null,
            "token": "c29a2460-81fe-4354-a162-083ee59d248b",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 50,
        "title": "powx-n",
        "token": "2c96c4d9-5793-4a79-8e95-cbca183d417c",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom random import uniform, randint\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def myPow(self, x: float, n: int) -> float:\n        if n == 0:\n            return 1.0\n        if n < 0:\n            x = 1 / x\n            n = -n\n        res = 1.0\n        while n > 0:\n            if n % 2 == 1:\n                res *= x\n            x *= x\n            n //= 2\n        return res\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        return {'x': round(uniform(-99.9, 99.9), 5), 'n': randint(-20, 20)}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['x']},{input_obj['n']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return f'{output_obj:.5f}'\n\n    def decode_input(self, input_str) -> dict:\n        x, n = input_str.split(',')\n        return {'x': float(x), 'n': int(n)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.myPow(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.054",
            "memory": 4836,
            "stderr": null,
            "token": "2c96c4d9-5793-4a79-8e95-cbca183d417c",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 219,
        "title": "contains-duplicate-ii",
        "token": "f2a3712b-1e51-459f-bca8-bed0d9c06d28",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom random import randint\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\n        seen = {}\n        for i, num in enumerate(nums):\n            if num in seen and i - seen[num] <= k:\n                return True\n            seen[num] = i\n        return False\n\nclass TestCaseGenerator:\n\n    def __init__(self, nums_max_length=1000, num_range=(-10 ** 9, 10 ** 9), k_max=1000):\n        self.nums_max_length = nums_max_length\n        self.num_range = num_range\n        self.k_max = k_max\n\n    def generate(self) -> dict:\n        from random import randint\n        nums_length = randint(1, self.nums_max_length)\n        nums = [randint(self.num_range[0], self.num_range[1]) for _ in range(nums_length)]\n        k = randint(0, min(nums_length, self.k_max))\n        return {'nums': nums, 'k': k}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"nums: {input_obj['nums']}, k: {input_obj['k']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        parts = input_str.split(', k: ')\n        nums_part = parts[0].replace('nums: ', '')\n        nums = eval(nums_part)\n        k = int(parts[1])\n        return {'nums': nums, 'k': k}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.containsNearbyDuplicate(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.075",
            "memory": 6548,
            "stderr": null,
            "token": "f2a3712b-1e51-459f-bca8-bed0d9c06d28",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 221,
        "title": "maximal-square",
        "token": "011b7f6e-c32b-4eab-bd12-63cb263b3051",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\n        rows, cols = len(matrix), len(matrix[0])\n        dp = [[0] * (cols + 1) for _ in range(rows + 1)]\n        max_side = 0\n\n        for i in range(1, rows + 1):\n            for j in range(1, cols + 1):\n                if matrix[i - 1][j - 1] == '1':\n                    dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n                    max_side = max(max_side, dp[i][j])\n\n        return max_side * max_side\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        m = random.randint(1, 100)\n        n = random.randint(1, 100)\n        matrix = [[random.choice(['0', '1']) for _ in range(n)] for _ in range(m)]\n        return {'matrix': matrix}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['matrix'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        matrix = eval(input_str)\n        return {'matrix': matrix}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.maximalSquare(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.146",
            "memory": 10864,
            "stderr": null,
            "token": "011b7f6e-c32b-4eab-bd12-63cb263b3051",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 223,
        "title": "rectangle-area",
        "token": "33b9f0e6-1df0-42f6-addd-a8c6d4668286",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\n\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -> int:\n        area_a = (ax2 - ax1) * (ay2 - ay1)\n        area_b = (bx2 - bx1) * (by2 - by1)\n        \n        x_overlap = max(0, min(ax2, bx2) - max(ax1, bx1))\n        y_overlap = max(0, min(ay2, by2) - max(ay1, by1))\n        \n        return area_a + area_b - x_overlap * y_overlap\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        \"\"\"\n        Generate a test case input for the problem where two rectangles are defined by their bottom-left \n        and top-right corners.\n        \"\"\"\n        test_cases = [{'ax1': -3, 'ay1': 0, 'ax2': 3, 'ay2': 4, 'bx1': 5, 'by1': 4, 'bx2': 10, 'by2': 8}, {'ax1': 0, 'ay1': 0, 'ax2': 4, 'ay2': 3, 'bx1': 2, 'by1': 2, 'bx2': 6, 'by2': 5}, {'ax1': -2, 'ay1': -2, 'ax2': 2, 'ay2': 2, 'bx1': -2, 'by1': -2, 'bx2': 2, 'by2': 2}, {'ax1': 0, 'ay1': 0, 'ax2': 2, 'ay2': 2, 'bx1': 2, 'by1': 0, 'bx2': 4, 'by2': 2}, {'ax1': 1, 'ay1': 1, 'ax2': 4, 'ay2': 5, 'bx1': 1, 'by1': 1, 'bx2': 4, 'by2': 5}]\n        return test_cases[0]\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\"\n        Encode a test case input dictionary into a string.\n        \"\"\"\n        return ','.join((f'{value}' for value in input_obj.values()))\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\"\n        Encode a test case output integer into a string.\n        \"\"\"\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\"\n        Decode an input string back into a test case input dictionary.\n        \"\"\"\n        values = list(map(int, input_str.split(',')))\n        return {'ax1': values[0], 'ay1': values[1], 'ax2': values[2], 'ay2': values[3], 'bx1': values[4], 'by1': values[5], 'bx2': values[6], 'by2': values[7]}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.computeArea(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.059",
            "memory": 4844,
            "stderr": null,
            "token": "33b9f0e6-1df0-42f6-addd-a8c6d4668286",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "failure",
        "question_id": 107,
        "title": "binary-tree-level-order-traversal-ii",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "success",
        "question_id": 109,
        "title": "convert-sorted-list-to-binary-search-tree",
        "token": "cd80bcdb-9f33-4925-9d7c-460f3528bfe2",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom collections import deque\nfrom typing import Optional\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        def to_array(head):\n            arr = []\n            while head:\n                arr.append(head.val)\n                head = head.next\n            return arr\n\n        def build_tree(arr):\n            if not arr:\n                return None\n            mid = len(arr) // 2\n            root = TreeNode(arr[mid])\n            root.left = build_tree(arr[:mid])\n            root.right = build_tree(arr[mid+1:])\n            return root\n\n        return build_tree(to_array(head))\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(0, 20)\n        if n == 0:\n            return {'head': None}\n        sorted_values = sorted(random.sample(range(-100, 100), n))\n        head = ListNode(sorted_values[0])\n        current = head\n        for value in sorted_values[1:]:\n            current.next = ListNode(value)\n            current = current.next\n        return {'head': head}\n\n    def encode_input(self, input_obj) -> str:\n        if input_obj['head'] is None:\n            return '[]'\n        res = []\n        current = input_obj['head']\n        while current is not None:\n            res.append(current.val)\n            current = current.next\n        return str(res)\n\n    def encode_output(self, output_obj) -> str:\n        if not output_obj:\n            return '[]'\n        queue = deque([output_obj])\n        result = []\n        while queue:\n            node = queue.popleft()\n            if node:\n                result.append(node.val)\n                queue.append(node.left)\n                queue.append(node.right)\n            else:\n                result.append(None)\n        while result and result[-1] is None:\n            result.pop()\n        return str(result)\n\n    def decode_input(self, input_str) -> dict:\n        vals = eval(input_str)\n        if not vals:\n            return {'head': None}\n        head = ListNode(vals[0])\n        current = head\n        for value in vals[1:]:\n            current.next = ListNode(value)\n            current = current.next\n        return {'head': head}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.sortedListToBST(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Input {'head': <__main__.ListNode object at 0x7fbfef6e5dc0>}\nExpected Output:  [-13, -52, 80, -88, -41, 29, 86, None, -68, -49, -20, 11, 33, 82, 98]\nActual Output:  [11, -49, 82, -68, -20, 33, 98, -88, -52, -41, -13, 29, 80, 86]\n1 Test Failed!\n",
            "time": "0.076",
            "memory": 4912,
            "stderr": null,
            "token": "cd80bcdb-9f33-4925-9d7c-460f3528bfe2",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 4,
                "description": "Wrong Answer"
            }
        }
    },
    {
        "status": "failure",
        "question_id": 268,
        "title": "missing-number",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "success",
        "question_id": 172,
        "title": "factorial-trailing-zeroes",
        "token": "2025fb45-7176-4505-84d7-4d9c515f36f5",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def trailingZeroes(self, n: int) -> int:\n        ans = 0\n        while n > 0:\n            n //= 5\n            ans += n\n        return ans\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(0, 100)\n        return {'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['n'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'n': int(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.trailingZeroes(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.064",
            "memory": 4820,
            "stderr": null,
            "token": "2025fb45-7176-4505-84d7-4d9c515f36f5",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 179,
        "title": "largest-number",
        "token": "cbed3a44-72c4-45d7-8630-72af2cc95fc0",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport heapq\nimport random\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def largestNumber(self, nums: List[int]) -> str:\n        from functools import cmp_to_key\n        nums = sorted(nums, key=cmp_to_key(lambda a, b: 1 if str(a) + str(b) < str(b) + str(a) else -1))\n        return str(int(\"\".join(map(str, nums))))\n\nclass TestCaseGenerator:\n    \"\"\"\n    A helper class to generate test cases, encode/decode inputs and outputs\n    \"\"\"\n\n    def generate(self) -> dict:\n        \"\"\"\n        Generates a random test case input, ensuring scenarios of different input sizes.\n        \"\"\"\n        import random\n        length = random.randint(1, 20)\n        nums = [random.randint(0, 10000) for _ in range(length)]\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\"\n        Converts the test case input into a human-readable string.\n        \"\"\"\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\"\n        Converts the test case output (a string) into a human-readable string format.\n        \"\"\"\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\"\n        Transforms an input string back into a Python dictionary structure.\n        \"\"\"\n        nums = eval(input_str)\n        return {'nums': nums}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.largestNumber(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.058",
            "memory": 4884,
            "stderr": null,
            "token": "cbed3a44-72c4-45d7-8630-72af2cc95fc0",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 187,
        "title": "repeated-dna-sequences",
        "token": "e123d3d9-48b9-416c-a930-99a8fe22538e",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def findRepeatedDnaSequences(self, s: str) -> List[str]:\n        if len(s) < 10:\n            return []\n        seen = set()\n        repeated = set()\n        for i in range(len(s) - 9):\n            sub = s[i:i+10]\n            if sub in seen:\n                repeated.add(sub)\n            else:\n                seen.add(sub)\n        return list(repeated)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        nucleotides = ['A', 'C', 'G', 'T']\n        length = random.randint(20, 200)\n        s = ''.join(random.choices(nucleotides, k=length))\n        return {'s': s}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['s']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return '[' + ', '.join((f'\"{seq}\"' for seq in output_obj)) + ']'\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.findRepeatedDnaSequences(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.059",
            "memory": 4840,
            "stderr": null,
            "token": "e123d3d9-48b9-416c-a930-99a8fe22538e",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 12,
        "title": "integer-to-roman",
        "token": "44730f17-f3d5-4c90-b40e-a9c500ea9f0a",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\n\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def intToRoman(self, num: int) -> str:\n        roman_map = {1: 'I', 4: 'IV', 5: 'V', 9: 'IX', 10: 'X', 40: 'XL', 50: 'L', 90: 'XC', 100: 'C', 400: 'CD', 500: 'D', 900: 'CM', 1000: 'M'}\n        integers = list(roman_map.keys())\n        integers.reverse()\n        roman_values = list(roman_map.values())\n        roman_values.reverse()\n        result = ''\n        for i in range(len(integers)):\n            count = num // integers[i]\n            if count:\n                result += roman_values[i] * count\n                num %= integers[i]\n        return result\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        return {'num': 3}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['num'])\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        return {'num': int(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.intToRoman(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.055",
            "memory": 4612,
            "stderr": null,
            "token": "44730f17-f3d5-4c90-b40e-a9c500ea9f0a",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 13,
        "title": "roman-to-integer",
        "token": "fddb8f7c-c19e-417f-8ac2-e5e16398d6e3",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def romanToInt(self, s: str) -> int:\n        roman_map = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\n        result = 0\n        prev_value = 0\n        for i in range(len(s) - 1, -1, -1):\n            curr_value = roman_map[s[i]]\n            if curr_value < prev_value:\n                result -= curr_value\n            else:\n                result += curr_value\n            prev_value = curr_value\n        return result\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        \"\"\"\n        Generate a random test case input.\n        Limited range of test cases for simplicity.\n        \"\"\"\n        test_cases = [{'s': 'III'}, {'s': 'IV'}, {'s': 'IX'}, {'s': 'LVIII'}, {'s': 'XLIX'}, {'s': 'XC'}, {'s': 'CCCXC'}, {'s': 'CMXCIX'}, {'s': 'MCMXCIV'}, {'s': 'MMXXII'}]\n        return random.choice(test_cases)\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\"\n        Convert a test case input into a string.\n        \"\"\"\n        return input_obj['s']\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\"\n        Convert a test case output into a string.\n        \"\"\"\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\"\n        Convert a test case input string into a Python dict.\n        \"\"\"\n        return {'s': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.romanToInt(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.059",
            "memory": 4844,
            "stderr": null,
            "token": "fddb8f7c-c19e-417f-8ac2-e5e16398d6e3",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 18,
        "title": "4sum",
        "token": "7284d262-ba68-4c11-9e68-7f265d0308c7",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport json\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\n        nums.sort()\n        res = []\n        n = len(nums)\n        for i in range(n - 3):\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n            for j in range(i + 1, n - 2):\n                if j > i + 1 and nums[j] == nums[j - 1]:\n                    continue\n                left, right = j + 1, n - 1\n                while left < right:\n                    s = nums[i] + nums[j] + nums[left] + nums[right]\n                    if s == target:\n                        res.append([nums[i], nums[j], nums[left], nums[right]])\n                        while left < right and nums[left] == nums[left + 1]:\n                            left += 1\n                        while left < right and nums[right] == nums[right - 1]:\n                            right -= 1\n                        left += 1\n                        right -= 1\n                    elif s < target:\n                        left += 1\n                    else:\n                        right -= 1\n        return res\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        from random import randint, sample\n        n = randint(4, 10)\n        nums = sample(range(-10, 10), n)\n        target = randint(-20, 20)\n        return {'nums': nums, 'target': target}\n\n    def encode_input(self, input_obj) -> str:\n        import json\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        import json\n        return json.dumps(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        import json\n        return json.loads(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.fourSum(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.059",
            "memory": 4872,
            "stderr": null,
            "token": "7284d262-ba68-4c11-9e68-7f265d0308c7",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 20,
        "title": "valid-parentheses",
        "token": "f936bc90-1bee-41a1-9e59-69a2584ca0e0",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport json\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution(object):\n    def isValid(self, s):\n        stack = []\n        pairs = {')': '(', '}': '{', ']': '['}\n        for c in s:\n            if c in pairs:\n                if not stack or stack[-1] != pairs[c]:\n                    return False\n                stack.pop()\n            else:\n                stack.append(c)\n        return not stack\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(1, 20)\n        elements = ['(', ')', '{', '}', '[', ']']\n        s = ''.join(random.choices(elements, k=length))\n        return {'s': s}\n\n    def encode_input(self, input_obj) -> str:\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return json.loads(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.isValid(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.061",
            "memory": 4732,
            "stderr": null,
            "token": "f936bc90-1bee-41a1-9e59-69a2584ca0e0",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "failure",
        "question_id": 113,
        "title": "path-sum-ii",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "success",
        "question_id": 115,
        "title": "distinct-subsequences",
        "token": "ec7fa9fb-2c1b-4632-8f67-30a993bf69ec",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport string\nimport json\n\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def numDistinct(self, s: str, t: str) -> int:\n        n, m = len(s), len(t)\n        dp = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(n + 1):\n            dp[i][m] = 1\n        for i in range(n - 1, -1, -1):\n            for j in range(m - 1, -1, -1):\n                if s[i] == t[j]:\n                    dp[i][j] = dp[i + 1][j + 1] + dp[i + 1][j]\n                else:\n                    dp[i][j] = dp[i + 1][j]\n        return dp[0][0]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        s_length = random.randint(1, 10)\n        t_length = random.randint(1, s_length)\n        s = ''.join(random.choices(string.ascii_lowercase, k=s_length))\n        t = ''.join(random.choices(s, k=t_length))\n        return {'s': s, 't': t}\n\n    def encode_input(self, input_obj) -> str:\n        return json.dumps({'s': input_obj['s'], 't': input_obj['t']})\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return json.loads(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.numDistinct(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.057",
            "memory": 4840,
            "stderr": null,
            "token": "ec7fa9fb-2c1b-4632-8f67-30a993bf69ec",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "failure",
        "question_id": 117,
        "title": "populating-next-right-pointers-in-each-node-ii",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "success",
        "question_id": 118,
        "title": "pascals-triangle",
        "token": "33a38695-7a6c-4520-ab69-2a02df345caf",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def generate(self, numRows: int):\n        triangle = []\n        for i in range(numRows):\n            row = [1] * (i + 1)\n            if i > 1:\n                for j in range(1, i):\n                    row[j] = triangle[i - 1][j - 1] + triangle[i - 1][j]\n            triangle.append(row)\n        return triangle\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        numRows = random.randint(1, 10)\n        return {'numRows': numRows}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['numRows'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'numRows': int(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.generate(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.055",
            "memory": 4852,
            "stderr": null,
            "token": "33a38695-7a6c-4520-ab69-2a02df345caf",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 119,
        "title": "pascals-triangle-ii",
        "token": "1fc14d7e-c3bc-4e36-95b5-1796bb52831e",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def getRow(self, rowIndex: int) -> list[int]:\n        row = [1]\n        for i in range(1, rowIndex + 1):\n            new_row = [1]\n            for j in range(len(row) - 1):\n                new_row.append(row[j] + row[j + 1])\n            new_row.append(1)\n            row = new_row\n        return row\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        row_index = random.randint(0, 10)\n        return {'rowIndex': row_index}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['rowIndex']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'rowIndex': int(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.getRow(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.08",
            "memory": 6936,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 47, in <module>\n    class Solution:\n  File \"script.py\", line 48, in Solution\n    def getRow(self, rowIndex: int) -> list[int]:\nTypeError: 'type' object is not subscriptable\n",
            "token": "1fc14d7e-c3bc-4e36-95b5-1796bb52831e",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "success",
        "question_id": 260,
        "title": "single-number-iii",
        "token": "62e3df77-9583-46eb-b315-9e3b556a160f",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport ast\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def singleNumber(self, nums: List[int]) -> List[int]:\n        counts = {}\n        for num in nums:\n            counts[num] = counts.get(num, 0) + 1\n        return [num for num, count in counts.items() if count == 1]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        return {'nums': [4, 2, 2, 1, 4, 5, 1, 6]}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'nums': ast.literal_eval(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.singleNumber(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Input {'nums': [4, 2, 2, 1, 4, 5, 1, 6]}\nExpected Output:  [6, 5]\nActual Output:  [5, 6]\n1 Test Failed!\n",
            "time": "0.089",
            "memory": 6836,
            "stderr": null,
            "token": "62e3df77-9583-46eb-b315-9e3b556a160f",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 4,
                "description": "Wrong Answer"
            }
        }
    },
    {
        "status": "success",
        "question_id": 264,
        "title": "ugly-number-ii",
        "token": "df7311f3-9745-405c-b82c-2109d9869f1b",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nimport heapq\n\nclass Solution:\n    def nthUglyNumber(self, n: int) -> int:\n        heap = [1]\n        seen = {1}\n        \n        for _ in range(n):\n            ugly = heapq.heappop(heap)\n            \n            for factor in [2, 3, 5]:\n                new_ugly = ugly * factor\n                if new_ugly not in seen:\n                    heapq.heappush(heap, new_ugly)\n                    seen.add(new_ugly)\n        \n        return ugly\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 100)\n        return {'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.nthUglyNumber(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.077",
            "memory": 6804,
            "stderr": null,
            "token": "df7311f3-9745-405c-b82c-2109d9869f1b",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 71,
        "title": "simplify-path",
        "token": "82262af1-66f8-4b1e-8a3e-7aefc1faaf48",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def simplifyPath(self, path: str) -> str:\n        stack = []\n        for component in path.split('/'):\n            if component == '..':\n                if stack:\n                    stack.pop()\n            elif component and component != '.':\n                stack.append(component)\n        return '/' + '/'.join(stack)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        paths = ['/home/', '/home//foo/', '/home/user/Documents/../Pictures', '/../', '/.../a/../b/c/../d/./', '/a/b/c/../../', '/a/b//c/.././d', '/a/./b/./c/./d', '/a/b/c/././../..', '/a///b////c/']\n        random_path = random.choice(paths)\n        return {'path': random_path}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['path']\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        return {'path': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.simplifyPath(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.059",
            "memory": 4792,
            "stderr": null,
            "token": "82262af1-66f8-4b1e-8a3e-7aefc1faaf48",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "failure",
        "question_id": 75,
        "title": "sort-colors",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "success",
        "question_id": 77,
        "title": "combinations",
        "token": "5d1672bc-05b5-461b-8791-96305607f321",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def combine(self, n: int, k: int) -> List[List[int]]:\n        res = []\n        def dfs(start, comb):\n            if len(comb) == k:\n                res.append(comb.copy())\n                return\n            for i in range(start, n + 1):\n                comb.append(i)\n                dfs(i + 1, comb)\n                comb.pop()\n        dfs(1, [])\n        return res\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        n = random.randint(1, 10)\n        k = random.randint(1, n)\n        return {'n': n, 'k': k}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['n']} {input_obj['k']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return ','.join(('[' + ','.join(map(str, combo)) + ']' for combo in output_obj))\n\n    def decode_input(self, input_str) -> dict:\n        n, k = map(int, input_str.split())\n        return {'n': n, 'k': k}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.combine(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.06",
            "memory": 4908,
            "stderr": null,
            "token": "5d1672bc-05b5-461b-8791-96305607f321",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 80,
        "title": "remove-duplicates-from-sorted-array-ii",
        "token": "92d866cc-c154-401a-9fbc-7ca8765025b8",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List, Dict\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        a = 0\n        for i in nums:\n            if a < 2 or i > nums[a - 2]:\n                nums[a] = i\n                a += 1\n        return a\n\nclass TestCaseGenerator:\n\n    def generate(self) -> Dict[str, List[int]]:\n        \"\"\"\n        Generate a random test case input within a reasonable range\n        (based on the problem constraints) for invoking the entry_point function.\n        \"\"\"\n        length = random.randint(1, 100)\n        nums = []\n        for _ in range(length):\n            if nums and random.random() > 0.5:\n                nums.append(nums[-1])\n            else:\n                nums.append(nums[-1] + random.randint(1, 3) if nums else random.randint(-10, 10))\n        nums = self._limit_duplicates(nums)\n        return {'nums': nums}\n\n    def _limit_duplicates(self, nums: List[int]) -> List[int]:\n        \"\"\"\n        Make sure no number appears more than two times sequentially. Ensures input validity.\n        \"\"\"\n        result = []\n        count, current = (0, None)\n        for num in nums:\n            if num == current:\n                if count < 2:\n                    result.append(num)\n                    count += 1\n            else:\n                result.append(num)\n                current = num\n                count = 1\n        return result\n\n    def encode_input(self, input_obj: Dict[str, List[int]]) -> str:\n        \"\"\"\n        Convert a test case input into a JSON string representation.\n        \"\"\"\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj: int) -> str:\n        \"\"\"\n        Convert a test case output into a string.\n        \"\"\"\n        return str(output_obj)\n\n    def decode_input(self, input_str: str) -> Dict[str, List[int]]:\n        \"\"\"\n        Convert a test case input string into a Python dict with a numerical list.\n        \"\"\"\n        return {'nums': eval(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.removeDuplicates(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.057",
            "memory": 4892,
            "stderr": null,
            "token": "92d866cc-c154-401a-9fbc-7ca8765025b8",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 21,
        "title": "merge-two-sorted-lists",
        "token": "0fb55224-28fe-4417-8716-bcfd91be3e44",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import Optional\nfrom random import randint, choice\nfrom ast import literal_eval\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\n        dummy = ListNode()\n        tail = dummy\n        while list1 and list2:\n            if list1.val < list2.val:\n                tail.next = list1\n                list1 = list1.next\n            else:\n                tail.next = list2\n                list2 = list2.next\n            tail = tail.next\n        tail.next = list1 or list2\n        return dummy.next\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        from random import randint, choice\n        length1 = randint(0, 10)\n        length2 = randint(0, 10)\n        list1 = sorted((randint(-100, 100) for _ in range(length1)))\n        list2 = sorted((randint(-100, 100) for _ in range(length2)))\n        return {'list1': self.build_linked_list(list1), 'list2': self.build_linked_list(list2)}\n\n    def build_linked_list(self, values):\n        head = ListNode(values[0]) if values else None\n        current = head\n        for val in values[1:]:\n            current.next = ListNode(val)\n            current = current.next\n        return head\n\n    def encode_input(self, input_obj) -> str:\n        return str((self.list_to_array(input_obj['list1']), self.list_to_array(input_obj['list2'])))\n\n    def list_to_array(self, node):\n        array = []\n        while node:\n            array.append(node.val)\n            node = node.next\n        return array\n\n    def encode_output(self, output_obj) -> str:\n        return str(self.list_to_array(output_obj))\n\n    def decode_input(self, input_str) -> dict:\n        from ast import literal_eval\n        list1, list2 = literal_eval(input_str)\n        return {'list1': self.build_linked_list(list1), 'list2': self.build_linked_list(list2)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.mergeTwoLists(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.057",
            "memory": 5124,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 135, in <module>\n    runner.run()\n  File \"script.py\", line 119, in run\n    output = self.solution.mergeTwoLists(**input)\n  File \"script.py\", line 56, in mergeTwoLists\n    dummy = ListNode()\nTypeError: __init__() missing 1 required positional argument: 'x'\n",
            "token": "0fb55224-28fe-4417-8716-bcfd91be3e44",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "success",
        "question_id": 27,
        "title": "remove-element",
        "token": "0c469261-2a84-4981-a5d9-627dd3f439a3",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        i = 0\n        for j in range(len(nums)):\n            if nums[j] != val:\n                nums[i] = nums[j]\n                i += 1\n        return i\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        \"\"\"\n        Generate a random test case input to be used for invoking the\n        removeElement function.\n        \"\"\"\n        nums_length = random.randint(1, 100)\n        nums = [random.randint(0, 50) for _ in range(nums_length)]\n        val = random.randint(0, 50)\n        return {'nums': nums, 'val': val}\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\"\n        Convert a test case input dictionary into a string.\n        \"\"\"\n        nums_str = ','.join(map(str, input_obj['nums']))\n        val_str = str(input_obj['val'])\n        return f'nums=[{nums_str}],val={val_str}'\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\"\n        Convert a test case output into a string.\n        \"\"\"\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\"\n        Convert a test case input string into a Python dictionary.\n        \"\"\"\n        nums_part, val_part = input_str.split('],val=')\n        nums_str = nums_part.split('=')[1].strip('[]')\n        nums = list(map(int, nums_str.split(','))) if nums_str else []\n        val = int(val_part)\n        return {'nums': nums, 'val': val}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.removeElement(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.047",
            "memory": 4868,
            "stderr": null,
            "token": "0c469261-2a84-4981-a5d9-627dd3f439a3",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 28,
        "title": "find-the-index-of-the-first-occurrence-in-a-string",
        "token": "ee5cf5a7-7457-4857-aacc-4c31f9764a9b",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        try:\n            return haystack.index(needle)\n        except ValueError:\n            return -1\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        cases = [{'haystack': 'sadbutsad', 'needle': 'sad'}, {'haystack': 'leetcode', 'needle': 'leeto'}, {'haystack': 'a' * 1000 + 'b', 'needle': 'a' * 500}, {'haystack': 'hello', 'needle': 'll'}, {'haystack': 'aaaaaa', 'needle': 'b'}]\n        return random.choice(cases)\n\n    def encode_input(self, input_obj) -> str:\n        return f\"haystack={input_obj['haystack']}, needle={input_obj['needle']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        parts = input_str.split(', ')\n        haystack = parts[0].split('=')[1]\n        needle = parts[1].split('=')[1]\n        return {'haystack': haystack, 'needle': needle}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.strStr(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.053",
            "memory": 4892,
            "stderr": null,
            "token": "ee5cf5a7-7457-4857-aacc-4c31f9764a9b",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 29,
        "title": "divide-two-integers",
        "token": "25155a77-355e-49f2-91f3-123ddd187d20",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def divide(self, dividend: int, divisor: int) -> int:\n        INT_MAX, INT_MIN = 2**31 - 1, -2**31\n        if dividend == INT_MIN and divisor == -1:\n            return INT_MAX\n        sign = (dividend < 0) != (divisor < 0)\n        dividend, divisor = abs(dividend), abs(divisor)\n        quotient = 0\n        while dividend >= divisor:\n            temp, i = divisor, 1\n            while dividend >= temp << 1:\n                if temp > INT_MAX >> 1:\n                    break\n                temp <<= 1\n                i <<= 1\n            dividend -= temp\n            quotient += i\n        if sign:\n            quotient = -quotient\n        return min(max(quotient, INT_MIN), INT_MAX)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        dividend = random.randint(-1000, 1000)\n        divisor = random.randint(-1000, 1000)\n        while divisor == 0:\n            divisor = random.randint(-1000, 1000)\n        return {'dividend': dividend, 'divisor': divisor}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['dividend']}, {input_obj['divisor']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        dividend, divisor = map(int, input_str.split(','))\n        return {'dividend': dividend, 'divisor': divisor}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.divide(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.052",
            "memory": 4840,
            "stderr": null,
            "token": "25155a77-355e-49f2-91f3-123ddd187d20",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 30,
        "title": "substring-with-concatenation-of-all-words",
        "token": "82cfb10e-e704-4f5d-b26b-4109d7ca47a0",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        if not s or not words:\n            return []\n\n        n = len(s)\n        k = len(words[0])\n        l = len(words) * k\n        word_counts = Counter(words)\n        result = []\n\n        for i in range(n - l + 1):\n            seen = Counter()\n            for j in range(len(words)):\n                word = s[i + j * k: i + (j + 1) * k]\n                if word in word_counts:\n                    seen[word] += 1\n                    if seen[word] > word_counts[word]:\n                        break\n                else:\n                    break\n            else:\n                if seen == word_counts:\n                    result.append(i)\n\n        return result\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 50)\n        num_words = random.randint(1, 5)\n        word_length = random.randint(1, 5)\n        s = ''.join((random.choice('abcdefghijklmnopqrstuvwxyz') for _ in range(n)))\n        words = [''.join((random.choice('abcdefghijklmnopqrstuvwxyz') for _ in range(word_length))) for _ in range(num_words)]\n        return {'s': s, 'words': words}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"s={input_obj['s']};words={input_obj['words']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return ','.join(map(str, output_obj))\n\n    def decode_input(self, input_str) -> dict:\n        parts = input_str.split(';')\n        s = parts[0].split('=')[1]\n        words = parts[1].split('=')[1].strip('[]').replace('\"', '').split(',')\n        return {'s': s, 'words': words}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.findSubstring(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.061",
            "memory": 4868,
            "stderr": null,
            "token": "82cfb10e-e704-4f5d-b26b-4109d7ca47a0",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 62,
        "title": "unique-paths",
        "token": "ba8e0879-f461-49bf-b42d-8028087a02c1",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport math\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        row = [1] * n\n        for i in range(1, m):\n            for j in range(1, n):\n                row[j] += row[j - 1]\n        return row[-1]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        m = random.randint(1, 100)\n        n = random.randint(1, 100)\n        return {'m': m, 'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['m']} {input_obj['n']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        m, n = map(int, input_str.split())\n        return {'m': m, 'n': n}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.uniquePaths(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.062",
            "memory": 4756,
            "stderr": null,
            "token": "ba8e0879-f461-49bf-b42d-8028087a02c1",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 64,
        "title": "minimum-path-sum",
        "token": "14ec6da7-31c5-444d-8928-e6d99c42907a",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\nimport json\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        if not grid or not grid[0]:\n            return 0\n        \n        m, n = len(grid), len(grid[0])\n        \n        dp = [0] * n\n        dp[0] = grid[0][0]\n        \n        for j in range(1, n):\n            dp[j] = dp[j-1] + grid[0][j]\n        \n        for i in range(1, m):\n            dp[0] += grid[i][0]\n            for j in range(1, n):\n                dp[j] = grid[i][j] + min(dp[j-1], dp[j])\n        \n        return dp[n-1]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        m = random.randint(1, 10)\n        n = random.randint(1, 10)\n        grid = [[random.randint(0, 200) for _ in range(n)] for _ in range(m)]\n        return {'grid': grid}\n\n    def encode_input(self, input_obj) -> str:\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return json.loads(input_str)\n\n    def decode_output(self, output_str) -> int:\n        return int(output_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.minPathSum(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.072",
            "memory": 4804,
            "stderr": null,
            "token": "14ec6da7-31c5-444d-8928-e6d99c42907a",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 65,
        "title": "valid-number",
        "token": "7054da08-0295-470d-87d0-3a0b74aa2405",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport string\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def isNumber(self, s: str) -> bool:\n        s = s.strip()\n        has_e = False\n        has_dot = False\n        has_num = False\n        num_after_e = True\n        \n        for i, c in enumerate(s):\n            if c.isdigit():\n                has_num = True\n                num_after_e = True\n            elif c == '.':\n                if has_e or has_dot:\n                    return False\n                has_dot = True\n            elif c == 'e' or c == 'E':\n                if has_e or not has_num:\n                    return False\n                has_e = True\n                num_after_e = False\n            elif c == '+' or c == '-':\n                if i != 0 and s[i-1] != 'e' and s[i-1] != 'E':\n                    return False\n            else:\n                return False\n        \n        return has_num and num_after_e\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        import string\n        case_type = random.choice(['valid', 'invalid'])\n        valid_chars = string.digits + '+-' + 'eE' + '.'\n        invalid_chars = string.ascii_letters + ''.join(set(valid_chars) - set(string.digits))\n        if case_type == 'valid':\n            return {'s': random.choice(['', '+', '-']) + str(random.randint(0, 999)) + random.choice(['', '.', '.']) + ''.join(random.choices(string.digits, k=random.randint(0, 3))) + random.choice(['', 'e', 'E']) + random.choice(['', '+', '-']) + ''.join(random.choices(string.digits, k=random.randint(0, 3)))}\n        else:\n            return {'s': ''.join(random.choices(valid_chars + invalid_chars, k=random.randint(1, 20)))}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['s']\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\n    def decode_output(self, output_str) -> bool:\n        return output_str == 'True'\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.isNumber(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.075",
            "memory": 4812,
            "stderr": null,
            "token": "7054da08-0295-470d-87d0-3a0b74aa2405",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 66,
        "title": "plus-one",
        "token": "b01a614a-8344-472c-9a5b-cfff1b1cd676",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom ast import literal_eval\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def plusOne(self, digits: List[int]) -> List[int]:\n        for i in range(len(digits) - 1, -1, -1):\n            digits[i] += 1\n            if digits[i] < 10:\n                return digits\n            digits[i] = 0\n        return [1] + digits\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 10)\n        digits = [random.randint(1, 9)] + [random.randint(0, 9) for _ in range(n - 1)]\n        return {'digits': digits}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['digits'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'digits': literal_eval(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.plusOne(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.073",
            "memory": 5128,
            "stderr": null,
            "token": "b01a614a-8344-472c-9a5b-cfff1b1cd676",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 67,
        "title": "add-binary",
        "token": "ff72cd75-807b-457a-b5e2-6cf568ce3373",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def addBinary(self, a: str, b: str) -> str:\n        i, j, carry, res = len(a) - 1, len(b) - 1, 0, ''\n        while i >= 0 or j >= 0 or carry:\n            carry += (int(a[i]) if i >= 0 else 0) + (int(b[j]) if j >= 0 else 0)\n            res += str(carry % 2)\n            carry //= 2\n            i -= 1\n            j -= 1\n        return res[::-1]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length_a = random.randint(1, 15)\n        length_b = random.randint(1, 15)\n        a = ''.join((random.choice('01') for _ in range(length_a)))\n        b = ''.join((random.choice('01') for _ in range(length_b)))\n        return {'a': a, 'b': b}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['a']},{input_obj['b']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        a, b = input_str.split(',')\n        return {'a': a, 'b': b}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.addBinary(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Input {'a': '010011110', 'b': '0010111100'}\nExpected Output:  101011010\nActual Output:  0101011010\n4 Test Failed!\n",
            "time": "0.059",
            "memory": 4808,
            "stderr": null,
            "token": "ff72cd75-807b-457a-b5e2-6cf568ce3373",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 4,
                "description": "Wrong Answer"
            }
        }
    },
    {
        "status": "success",
        "question_id": 69,
        "title": "sqrtx",
        "token": "6d16cb5e-becc-416c-9045-3924870e4755",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport json\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def mySqrt(self, x: int) -> int:\n        if x < 2:\n            return x\n        left, right = 2, x // 2\n        while left <= right:\n            mid = left + (right - left) // 2\n            square = mid * mid\n            if square > x:\n                right = mid - 1\n            elif square < x:\n                left = mid + 1\n            else:\n                return mid\n        return right\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        x = random.randint(0, 1000000)\n        return {'x': x}\n\n    def encode_input(self, input_obj) -> str:\n        import json\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        import json\n        return json.dumps({'result': output_obj})\n\n    def decode_input(self, input_str) -> dict:\n        import json\n        return json.loads(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.mySqrt(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.048",
            "memory": 4756,
            "stderr": null,
            "token": "6d16cb5e-becc-416c-9045-3924870e4755",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 70,
        "title": "climbing-stairs",
        "token": "773ecc98-e4e4-464a-8d23-e1e2c9b9df8e",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom functools import cache\nimport random\n\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def climbStairs(self, n: int) -> int:\n        a, b = 1, 1\n        for _ in range(n - 1):\n            a, b = b, a + b\n        return b\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        return {'n': random.randint(1, 10)}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['n'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'n': int(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.climbStairs(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.054",
            "memory": 4604,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 26, in <module>\n    from functools import cache\nImportError: cannot import name 'cache' from 'functools' (/usr/local/python-3.8.1/lib/python3.8/functools.py)\n",
            "token": "773ecc98-e4e4-464a-8d23-e1e2c9b9df8e",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "failure",
        "question_id": 51,
        "title": "n-queens",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "success",
        "question_id": 52,
        "title": "n-queens-ii",
        "token": "c089048c-400e-4c3f-978b-69cd9aae5241",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def totalNQueens(self, n: int) -> int:\n        cols = set()\n        pos_diag = set()\n        neg_diag = set()\n        count = 0\n\n        def backtrack(row):\n            nonlocal count\n            if row == n:\n                count += 1\n                return\n\n            for col in range(n):\n                if col in cols or (row + col) in pos_diag or (row - col) in neg_diag:\n                    continue\n\n                cols.add(col)\n                pos_diag.add(row + col)\n                neg_diag.add(row - col)\n                backtrack(row + 1)\n                cols.remove(col)\n                pos_diag.remove(row + col)\n                neg_diag.remove(row - col)\n\n        backtrack(0)\n        return count\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 9)\n        return {'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['n'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'n': int(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.totalNQueens(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.121",
            "memory": 4828,
            "stderr": null,
            "token": "c089048c-400e-4c3f-978b-69cd9aae5241",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 53,
        "title": "maximum-subarray",
        "token": "13260af1-651c-4000-82a4-f4d90fca206b",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        max_so_far = nums[0]\n        curr_max = nums[0]\n        for i in range(1, len(nums)):\n            curr_max = max(nums[i], curr_max + nums[i])\n            max_so_far = max(max_so_far, curr_max)\n        return max_so_far\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        \"\"\"\n        Generate a random test case input for the maxSubArray function.\n        :return: A dictionary with 'nums' as key and list of integers as value.\n        \"\"\"\n        length = random.randint(1, 100)\n        nums = [random.randint(-10000, 10000) for _ in range(length)]\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\"\n        Convert a test case input into a string (JSON-like format).\n        :param input_obj: A dictionary with 'nums' as key.\n        :return: A string representation of 'nums'\n        \"\"\"\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\"\n        Convert a test case output into a string.\n        :param output_obj: The output value to be encoded.\n        :return: A string representation of the output.\n        \"\"\"\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\"\n        Convert a test case input string into a Python dict.\n        :param input_str: The input string to decode.\n        :return: A dictionary with 'nums' as key.\n        \"\"\"\n        nums = eval(input_str)\n        return {'nums': nums}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.maxSubArray(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.057",
            "memory": 5020,
            "stderr": null,
            "token": "13260af1-651c-4000-82a4-f4d90fca206b",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 55,
        "title": "jump-game",
        "token": "648e77a7-adce-411c-9142-ce4d83d91af2",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List, Dict\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def canJump(self, nums: List[int]) -> bool:\n        reach = 0\n        for i, num in enumerate(nums):\n            if i > reach:\n                return False\n            reach = max(reach, i + num)\n        return True\n\nclass TestCaseGenerator:\n\n    def generate(self) -> Dict[str, List[int]]:\n        nums_length = random.randint(1, 20)\n        nums = [random.randint(0, 5) for _ in range(nums_length)]\n        return {'nums': nums}\n\n    def encode_input(self, input_obj: Dict[str, List[int]]) -> str:\n        return ','.join(map(str, input_obj['nums']))\n\n    def encode_output(self, output_obj: bool) -> str:\n        return 'true' if output_obj else 'false'\n\n    def decode_input(self, input_str: str) -> Dict[str, List[int]]:\n        nums = list(map(int, input_str.split(',')))\n        return {'nums': nums}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.canJump(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.057",
            "memory": 4776,
            "stderr": null,
            "token": "648e77a7-adce-411c-9142-ce4d83d91af2",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 58,
        "title": "length-of-last-word",
        "token": "5b888996-9798-43fd-8442-0c8c831daa1a",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def lengthOfLastWord(self, s: str) -> int:\n        return len(s.split()[-1]) if s.split() else 0\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        words = ['abcdefghijklmnopqrstuvwxyz', 'hello', 'world', 'moon', 'joyboy']\n        sentence = ' '.join(random.choices(words, k=random.randint(1, 5)))\n        sentence = sentence.rjust(len(sentence) + random.randint(0, 5))\n        sentence = sentence.ljust(len(sentence) + random.randint(0, 5))\n        return {'s': sentence.strip()}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['s']\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\n    def decode_output(self, output_str) -> int:\n        return int(output_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.lengthOfLastWord(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.06",
            "memory": 4768,
            "stderr": null,
            "token": "5b888996-9798-43fd-8442-0c8c831daa1a",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 60,
        "title": "permutation-sequence",
        "token": "6d94eb3f-96f8-480d-8c98-22d47c037fe2",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport math\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def getPermutation(self, n: int, k: int) -> str:\n        import math\n        nums = list(range(1, n + 1))\n        result = ''\n        k -= 1\n        for i in range(n - 1, -1, -1):\n            index = k // math.factorial(i)\n            result += str(nums.pop(index))\n            k %= math.factorial(i)\n        return result\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 9)\n        k = random.randint(1, math.factorial(n))\n        return {'n': n, 'k': k}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['n']},{input_obj['k']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        n, k = map(int, input_str.split(','))\n        return {'n': n, 'k': k}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.getPermutation(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.047",
            "memory": 4804,
            "stderr": null,
            "token": "6d94eb3f-96f8-480d-8c98-22d47c037fe2",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 282,
        "title": "expression-add-operators",
        "token": "bc6147ec-699c-472d-bc8d-ad412c8f097f",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def addOperators(self, num: str, target: int) -> List[str]:\n        n = len(num)\n        res = []\n\n        def backtrack(index, path, prev_num, current_val):\n            if index == n:\n                if current_val == target:\n                    res.append(path)\n                return\n\n            for i in range(index, n):\n                if i > index and num[index] == '0':\n                    break\n                current_num = int(num[index:i + 1])\n\n                if index == 0:\n                    backtrack(i + 1, str(current_num), current_num, current_num)\n                else:\n                    backtrack(i + 1, path + \"+\" + str(current_num), current_num, current_val + current_num)\n                    backtrack(i + 1, path + \"-\" + str(current_num), -current_num, current_val - current_num)\n                    backtrack(i + 1, path + \"*\" + str(current_num), prev_num * current_num, current_val - prev_num + prev_num * current_num)\n\n        backtrack(0, \"\", 0, 0)\n        return res\n\nclass TestCaseGenerator:\n    import random\n\n    def generate(self) -> dict:\n        nums = ['123', '232', '3456237490', '105', '00', '9999']\n        targets = [6, 8, 9191, 5, 0, 27]\n        test_index = self.random.randint(0, len(nums) - 1)\n        return {'num': nums[test_index], 'target': targets[test_index]}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"num = '{input_obj['num']}', target = {input_obj['target']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return ', '.join(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        parts = input_str.split(', ')\n        num = parts[0].split('=')[1].strip().strip(\"'\")\n        target = int(parts[1].split('=')[1].strip())\n        return {'num': num, 'target': target}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.addOperators(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "1.545",
            "memory": 4876,
            "stderr": null,
            "token": "bc6147ec-699c-472d-bc8d-ad412c8f097f",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 283,
        "title": "move-zeroes",
        "token": "581209f7-8be3-4768-b0a2-e7814014c672",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def moveZeroes(self, nums: List[int]) -> None:\n        i = 0\n        for j in range(len(nums)):\n            if nums[j] != 0:\n                nums[i], nums[j] = nums[j], nums[i]\n                i += 1\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        test_case = {'nums': [random.choice(range(-10, 10)) for _ in range(random.randint(1, 20))]}\n        return test_case\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        nums = eval(input_str)\n        return {'nums': nums}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.moveZeroes(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.054",
            "memory": 4852,
            "stderr": null,
            "token": "581209f7-8be3-4768-b0a2-e7814014c672",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "failure",
        "question_id": 335,
        "title": "self-crossing",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "failure",
        "question_id": 336,
        "title": "palindrome-pairs",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "success",
        "question_id": 338,
        "title": "counting-bits",
        "token": "daa5960b-9889-42c8-972e-1035eb9bcef2",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def countBits(self, n: int) -> list[int]:\n        dp = [0] * (n + 1)\n        for i in range(1, n + 1):\n            dp[i] = dp[i >> 1] + (i & 1)\n        return dp\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(0, 1000)\n        return {'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['n'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        n = int(input_str)\n        return {'n': n}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.countBits(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.048",
            "memory": 4700,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 48, in <module>\n    class Solution:\n  File \"script.py\", line 49, in Solution\n    def countBits(self, n: int) -> list[int]:\nTypeError: 'type' object is not subscriptable\n",
            "token": "daa5960b-9889-42c8-972e-1035eb9bcef2",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "success",
        "question_id": 342,
        "title": "power-of-four",
        "token": "6688f3e3-b248-4ee9-b55a-6e556574561c",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def isPowerOfFour(self, n: int) -> bool:\n        return n > 0 and (n & (n - 1)) == 0 and (n & 0x55555555) != 0\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        test_values = [1, 4, 16, 64, 256, 1024, 5, 12, 20, 50, 100, -4, 0, random.randint(-500, 500)]\n        n = random.choice(test_values)\n        return {'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['n'])\n\n    def encode_output(self, output_obj) -> str:\n        return 'true' if output_obj else 'false'\n\n    def decode_input(self, input_str) -> dict:\n        return {'n': int(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.isPowerOfFour(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.056",
            "memory": 4824,
            "stderr": null,
            "token": "6688f3e3-b248-4ee9-b55a-6e556574561c",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 345,
        "title": "reverse-vowels-of-a-string",
        "token": "6581d257-942f-4677-b3d6-70c700b0fd55",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\n\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def reverseVowels(self, s: str) -> str:\n        vowels = set('aeiouAEIOU')\n        s = list(s)\n        i, j = 0, len(s) - 1\n        while i < j:\n            while i < j and s[i] not in vowels:\n                i += 1\n            while i < j and s[j] not in vowels:\n                j -= 1\n            if i < j:\n                s[i], s[j] = s[j], s[i]\n                i += 1\n                j -= 1\n        return ''.join(s)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        return {'s': 'ExampleTestString'}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['s']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.reverseVowels(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.045",
            "memory": 4716,
            "stderr": null,
            "token": "6581d257-942f-4677-b3d6-70c700b0fd55",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 521,
        "title": "longest-uncommon-subsequence-i",
        "token": "c738e9b6-8e10-4b38-b6e1-8b393b74dda7",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport string\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def findLUSlength(self, a: str, b: str) -> int:\n        return -1 if a == b else max(len(a), len(b))\n\nclass TestCaseGenerator:\n\n    def __init__(self):\n        self.random = random\n\n    def generate(self) -> dict:\n        length_a = self.random.randint(1, 100)\n        length_b = self.random.randint(1, 100)\n        a = ''.join(self.random.choices(string.ascii_lowercase, k=length_a))\n        b = ''.join(self.random.choices(string.ascii_lowercase, k=length_b))\n        return {'a': a, 'b': b}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"a={input_obj['a']}&b={input_obj['b']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        params = input_str.split('&')\n        a = params[0].split('=')[1]\n        b = params[1].split('=')[1]\n        return {'a': a, 'b': b}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.findLUSlength(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.051",
            "memory": 4876,
            "stderr": null,
            "token": "c738e9b6-8e10-4b38-b6e1-8b393b74dda7",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 383,
        "title": "ransom-note",
        "token": "49af2ad2-e802-418e-90d3-b5348f96b796",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport string\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def canConstruct(self, ransomNote: str, magazine: str) -> bool:\n        from collections import Counter\n        magazine_counts = Counter(magazine)\n        for char in ransomNote:\n            if magazine_counts[char] <= 0:\n                return False\n            magazine_counts[char] -= 1\n        return True\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        ransom_length = random.randint(1, 100)\n        magazine_length = random.randint(ransom_length, 105)\n        ransomNote = ''.join(random.choices(string.ascii_lowercase, k=ransom_length))\n        magazine = ''.join(random.choices(string.ascii_lowercase, k=magazine_length))\n        return {'ransomNote': ransomNote, 'magazine': magazine}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"ransomNote={input_obj['ransomNote']}&magazine={input_obj['magazine']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return 'true' if output_obj else 'false'\n\n    def decode_input(self, input_str) -> dict:\n        components = input_str.split('&')\n        return {'ransomNote': components[0].split('=')[1], 'magazine': components[1].split('=')[1]}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.canConstruct(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.051",
            "memory": 4792,
            "stderr": null,
            "token": "49af2ad2-e802-418e-90d3-b5348f96b796",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 389,
        "title": "find-the-difference",
        "token": "f6714612-3c4a-438e-bc20-5b4412600faa",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def findTheDifference(self, s: str, t: str) -> str:\n        return chr(sum(ord(c) for c in t) - sum(ord(c) for c in s))\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        alphabets = 'abcdefghijklmnopqrstuvwxyz'\n        length = random.randint(0, 1000)\n        s = ''.join(random.choices(alphabets, k=length))\n        added_char = random.choice(alphabets)\n        t_list = list(s)\n        random.shuffle(t_list)\n        insert_position = random.randint(0, length)\n        t_list.insert(insert_position, added_char)\n        t = ''.join(t_list)\n        return {'s': s, 't': t}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['s']} {input_obj['t']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        s, t = input_str.split()\n        return {'s': s, 't': t}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.findTheDifference(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.048",
            "memory": 5064,
            "stderr": null,
            "token": "f6714612-3c4a-438e-bc20-5b4412600faa",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 391,
        "title": "perfect-rectangle",
        "token": "498a6bdc-ca99-46d4-b22c-84b54bfe1476",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport numpy as np\nfrom typing import List\nimport ast\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\n        x1, y1 = float('inf'), float('inf')\n        x2, y2 = float('-inf'), float('-inf')\n        area = 0\n        corners = set()\n        for x, y, a, b in rectangles:\n            x1 = min(x1, x)\n            y1 = min(y1, y)\n            x2 = max(x2, a)\n            y2 = max(y2, b)\n            area += (a - x) * (b - y)\n            corners ^= {(x, y), (x, b), (a, y), (a, b)}\n        if len(corners) != 4 or (x1, y1) not in corners or (x1, y2) not in corners or (x2, y1) not in corners or (x2, y2) not in corners:\n            return False\n        return (x2 - x1) * (y2 - y1) == area\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        test_cases = [{'rectangles': [[1, 1, 3, 3], [3, 1, 4, 2], [3, 2, 4, 4], [1, 3, 2, 4], [2, 3, 3, 4]]}, {'rectangles': [[1, 1, 2, 3], [1, 3, 2, 4], [3, 1, 4, 2], [3, 2, 4, 4]]}, {'rectangles': [[1, 1, 3, 3], [3, 1, 4, 2], [1, 3, 2, 4], [2, 2, 4, 4]]}]\n        return test_cases[0]\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        import ast\n        return ast.literal_eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.isRectangleCover(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.05",
            "memory": 4636,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 26, in <module>\n    import numpy as np\nModuleNotFoundError: No module named 'numpy'\n",
            "token": "498a6bdc-ca99-46d4-b22c-84b54bfe1476",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "success",
        "question_id": 392,
        "title": "is-subsequence",
        "token": "ec488cc3-ea43-412f-9a00-571536aa8ab6",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport string\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def isSubsequence(self, s: str, t: str) -> bool:\n        i = 0\n        for char in t:\n            if i < len(s) and char == s[i]:\n                i += 1\n        return i == len(s)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        \"\"\"\n        Generates a test case with randomly generated strings s and t.\n        \"\"\"\n        import random\n        import string\n        t = ''.join((random.choice(string.ascii_lowercase) for _ in range(random.randint(1, 1000))))\n        if random.choice([True, False]):\n            s = ''.join(random.sample(t, random.randint(0, len(t))))\n        else:\n            s = ''.join((random.choice(string.ascii_lowercase) for _ in range(random.randint(0, min(100, len(t))))))\n        return {'s': s, 't': t}\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\"\n        Encodes the input dictionary into a string format.\n        \"\"\"\n        return f\"{input_obj['s']}::{input_obj['t']}\"\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\"\n        Encodes the output object into a string format (true/false as a string).\n        \"\"\"\n        return str(output_obj).lower()\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\"\n        Decodes the input string back into a dictionary with keys 's' and 't'.\n        \"\"\"\n        s, t = input_str.split('::')\n        return {'s': s, 't': t}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.isSubsequence(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.067",
            "memory": 5016,
            "stderr": null,
            "token": "ec488cc3-ea43-412f-9a00-571536aa8ab6",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 354,
        "title": "russian-doll-envelopes",
        "token": "712a1658-2bcc-4f22-b798-6817b4f4fba7",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List\nimport ast\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def maxEnvelopes(self, envelopes: List[List[int]]) -> int:\n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n        dp = []\n        for _, h in envelopes:\n            idx = bisect_left(dp, h)\n            if idx == len(dp):\n                dp.append(h)\n            else:\n                dp[idx] = h\n        return len(dp)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        num_envelopes = random.randint(1, 100)\n        envelopes = [[random.randint(1, 100), random.randint(1, 100)] for _ in range(num_envelopes)]\n        return {'envelopes': envelopes}\n\n    def encode_input(self, input_obj) -> str:\n        envelopes = input_obj['envelopes']\n        return str(envelopes)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        envelopes = ast.literal_eval(input_str)\n        return {'envelopes': envelopes}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.maxEnvelopes(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.063",
            "memory": 5528,
            "stderr": null,
            "token": "712a1658-2bcc-4f22-b798-6817b4f4fba7",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 479,
        "title": "largest-palindrome-product",
        "token": "d0dec834-2a2c-4e85-8e40-39d19dafc524",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport math\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def largestPalindrome(self, n: int) -> int:\n        if n == 1: return 9\n        upper = 10 ** n - 1\n        lower = upper // 10\n        for a in range(upper, lower, -1):\n            p = int(str(a) + str(a)[::-1])\n            for x in range(upper, int(p ** 0.5) - 1, -1):\n                if p % x == 0 and p // x <= upper:\n                    return p % 1337\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        n = random.randint(1, 8)\n        return {'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['n'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'n': int(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.largestPalindrome(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.988",
            "memory": 4844,
            "stderr": null,
            "token": "d0dec834-2a2c-4e85-8e40-39d19dafc524",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 483,
        "title": "smallest-good-base",
        "token": "bdce64f5-2fc5-4ea7-98d4-ed17b1502772",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport math\nimport time\nfrom fractions import Fraction\nfrom random import randint\n\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def smallestGoodBase(self, n: str) -> str:\n        n = int(n)\n        m_max = int((n).bit_length())\n        for m in range(m_max, 1, -1):\n            k = int(n**(1 / m))\n            if (k**(m + 1) - 1) // (k - 1) == n:\n                return str(k)\n        return str(n - 1)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        \"\"\"Generate a random test case.\"\"\"\n        n = randint(3, 100000)\n        return {'n': str(n)}\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\"\n        Convert a test case input into a string.\n        :param input_obj: Dictionary with the input object.\n        :return: String representation of the input object.\n        \"\"\"\n        return input_obj['n']\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\"\n        Convert a test case output into a string.\n        :param output_obj: The output which is a good base.\n        :return: String representation of the output object.\n        \"\"\"\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\"\n        Convert a test case input string into a dictionary.\n        :param input_str: String representation of the input.\n        :return: Dictionary with the input object.\n        \"\"\"\n        return {'n': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.smallestGoodBase(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.072",
            "memory": 5388,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 122, in <module>\n    runner.run()\n  File \"script.py\", line 106, in run\n    output = self.solution.smallestGoodBase(**input)\n  File \"script.py\", line 57, in smallestGoodBase\n    if (k**(m + 1) - 1) // (k - 1) == n:\nZeroDivisionError: integer division or modulo by zero\n",
            "token": "bdce64f5-2fc5-4ea7-98d4-ed17b1502772",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "failure",
        "question_id": 485,
        "title": "max-consecutive-ones",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "success",
        "question_id": 409,
        "title": "longest-palindrome",
        "token": "54d86864-e082-4c35-b782-551156bc838d",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom collections import Counter\nimport random\nimport string\nimport json\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nfrom collections import Counter\nclass Solution:\n    def longestPalindrome(self, s: str) -> int:\n        counts = Counter(s)\n        length = 0\n        odd_present = False\n        for count in counts.values():\n            length += count // 2 * 2\n            if count % 2 != 0:\n                odd_present = True\n        return length + 1 if odd_present else length\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(1, 20)\n        random_string = ''.join(random.choices(string.ascii_letters, k=length))\n        return {'s': random_string}\n\n    def encode_input(self, input_obj) -> str:\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return json.loads(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.longestPalindrome(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.057",
            "memory": 4744,
            "stderr": null,
            "token": "54d86864-e082-4c35-b782-551156bc838d",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "failure",
        "question_id": 410,
        "title": "split-array-largest-sum",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "failure",
        "question_id": 412,
        "title": "fizz-buzz",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "success",
        "question_id": 414,
        "title": "third-maximum-number",
        "token": "ccc6648a-19f4-4498-82d6-4490c997f5e4",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport json\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def thirdMax(self, nums: List[int]) -> int:\n        nums = sorted(list(set(nums)), reverse=True)\n        if len(nums) >= 3:\n            return nums[2]\n        return nums[0]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        nums_length = random.randint(1, 100)\n        nums = [random.randint(-2 ** 31, 2 ** 31 - 1) for _ in range(nums_length)]\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return json.loads(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.thirdMax(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.067",
            "memory": 5016,
            "stderr": null,
            "token": "ccc6648a-19f4-4498-82d6-4490c997f5e4",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 472,
        "title": "concatenated-words",
        "token": "5a9145e4-1010-4492-8b7a-336e1f75438b",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nfrom functools import cache\nimport json\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\n        word_set = set(words)\n        \n        def is_concatenated(word):\n            if not word:\n                return False\n            \n            dp = [False] * (len(word) + 1)\n            dp[0] = True\n            \n            for i in range(1, len(word) + 1):\n                for j in range(i):\n                    if dp[j] and word[j:i] in word_set:\n                        dp[i] = True\n                        break\n            return dp[len(word)]\n\n        return [word for word in words if is_concatenated(word)]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        test_cases = [{'words': ['cat', 'cats', 'catsdogcats', 'dog', 'dogcatsdog', 'hippopotamuses', 'rat', 'ratcatdogcat']}, {'words': ['cat', 'dog', 'catdog']}, {'words': ['apple', 'banana', 'applebanana', 'bananaapple']}, {'words': ['a', 'b', 'c', 'abc', 'bc', 'cab', 'ac', 'abcab']}]\n        return test_cases[0]\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\" Convert a test case input into a JSON string \"\"\"\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\" Convert a test case output into a JSON string \"\"\"\n        return json.dumps(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\" Convert a test case input string back into a Python dict \"\"\"\n        return json.loads(input_str)\n\n    def decode_output(self, output_str) -> list:\n        \"\"\" Convert a test case output string back into a Python list \"\"\"\n        return json.loads(output_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.findAllConcatenatedWordsInADict(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.051",
            "memory": 4656,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 27, in <module>\n    from functools import cache\nImportError: cannot import name 'cache' from 'functools' (/usr/local/python-3.8.1/lib/python3.8/functools.py)\n",
            "token": "5a9145e4-1010-4492-8b7a-336e1f75438b",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "success",
        "question_id": 476,
        "title": "number-complement",
        "token": "789659a5-5d4d-40ac-bbe7-ac6c0da5f56d",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution(object):\n    def findComplement(self, num):\n        mask = (1 << num.bit_length()) - 1\n        return num ^ mask\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        num = random.randint(1, 10 ** 5)\n        return {'num': num}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['num'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'num': int(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.findComplement(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.052",
            "memory": 4836,
            "stderr": null,
            "token": "789659a5-5d4d-40ac-bbe7-ac6c0da5f56d",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 440,
        "title": "k-th-smallest-in-lexicographical-order",
        "token": "f96fa9f8-26b6-4c29-ba53-4aedad0d3be6",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution(object):\n    def findKthNumber(self, n, k):\n        curr = 1\n        k -= 1\n        while k > 0:\n            steps = 0\n            first, last = curr, curr + 1\n            while first <= n:\n                steps += min(n + 1, last) - first\n                first *= 10\n                last *= 10\n            if steps <= k:\n                curr += 1\n                k -= steps\n            else:\n                curr *= 10\n                k -= 1\n        return curr\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 1000)\n        k = random.randint(1, n)\n        return {'n': n, 'k': k}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['n']} {input_obj['k']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        n, k = map(int, input_str.split())\n        return {'n': n, 'k': k}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.findKthNumber(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.057",
            "memory": 4760,
            "stderr": null,
            "token": "f96fa9f8-26b6-4c29-ba53-4aedad0d3be6",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 441,
        "title": "arranging-coins",
        "token": "84bda125-0278-4176-951e-16d1f3f8d3e0",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def arrangeCoins(self, n: int) -> int:\n        l, r = 0, n\n        while l <= r:\n            mid = (l + r) // 2\n            coins = mid * (mid + 1) // 2\n            if coins == n:\n                return mid\n            if coins < n:\n                l = mid + 1\n            else:\n                r = mid - 1\n        return r\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 100)\n        return {'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['n'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        n = int(input_str)\n        return {'n': n}\n\n    def decode_output(self, output_str) -> int:\n        return int(output_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.arrangeCoins(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.052",
            "memory": 4816,
            "stderr": null,
            "token": "84bda125-0278-4176-951e-16d1f3f8d3e0",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "failure",
        "question_id": 401,
        "title": "binary-watch",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "success",
        "question_id": 404,
        "title": "sum-of-left-leaves",
        "token": "6ebdbf2d-7401-4d29-bbaf-92f03d8c3e71",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom collections import deque\nfrom typing import Optional\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def sumOfLeftLeaves(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        res = 0\n        if root.left:\n            if not root.left.left and not root.left.right:\n                res += root.left.val\n            else:\n                res += self.sumOfLeftLeaves(root.left)\n        res += self.sumOfLeftLeaves(root.right)\n        return res\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        single_node_tree = {'root': TreeNode(1)}\n        left_leaf_tree = {'root': TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7)))}\n        no_left_leaf_tree = {'root': TreeNode(1, None, TreeNode(2, None, TreeNode(3)))}\n        return no_left_leaf_tree\n\n    def encode_input(self, input_obj) -> str:\n\n        def serialize_tree(node):\n            if not node:\n                return 'null'\n            return f'{node.val}, {serialize_tree(node.left)}, {serialize_tree(node.right)}'\n        root = input_obj['root']\n        return f'[{serialize_tree(root)}]'\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n\n        def deserialize_tree(data_list):\n            if not data_list:\n                return None\n            val = data_list.pop(0)\n            if val == 'null':\n                return None\n            node = TreeNode(val=int(val))\n            node.left = deserialize_tree(data_list)\n            node.right = deserialize_tree(data_list)\n            return node\n        elements = input_str.strip('[]').split(', ')\n        root = deserialize_tree(elements)\n        return {'root': root}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.sumOfLeftLeaves(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.058",
            "memory": 4684,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 127, in <module>\n    runner.run()\n  File \"script.py\", line 108, in run\n    input = self.test.decode_input(test_case['input'])\n  File \"script.py\", line 94, in decode_input\n    root = deserialize_tree(elements)\n  File \"script.py\", line 89, in deserialize_tree\n    node = TreeNode(val=int(val))\nTypeError: __init__() got an unexpected keyword argument 'val'\n",
            "token": "6ebdbf2d-7401-4d29-bbaf-92f03d8c3e71",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "success",
        "question_id": 405,
        "title": "convert-a-number-to-hexadecimal",
        "token": "4b17edfc-386e-4bce-9c71-50b172d89f53",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def toHex(self, num: int) -> str:\n        if num == 0:\n            return \"0\"\n        hex_map = \"0123456789abcdef\"\n        res = \"\"\n        for _ in range(8):\n            digit = num & 0xf\n            res = hex_map[digit] + res\n            num >>= 4\n            if num == 0:\n                break\n        return res\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        num = random.randint(-2 ** 31, 2 ** 31 - 1)\n        return {'num': num}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['num'])\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        num = int(input_str)\n        return {'num': num}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.toHex(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.056",
            "memory": 4840,
            "stderr": null,
            "token": "4b17edfc-386e-4bce-9c71-50b172d89f53",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 363,
        "title": "max-sum-of-rectangle-no-larger-than-k",
        "token": "e3e00d76-1f7f-4dd8-8bc9-293d47d5d453",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport math\nfrom sortedcontainers import SortedList\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nimport numpy as np\nfrom sortedcontainers import SortedList\nfrom typing import List\n\nclass Solution:\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\n        m, n = len(matrix), len(matrix[0])\n        max_sum = float('-inf')\n        for l in range(n):\n            row_sum = [0] * m\n            for r in range(l, n):\n                for i in range(m):\n                    row_sum[i] += matrix[i][r]\n                prefix_sum = 0\n                seen = SortedList([0])\n                for num in row_sum:\n                    prefix_sum += num\n                    target = prefix_sum - k\n                    idx = seen.bisect_left(target)\n                    if idx < len(seen):\n                        max_sum = max(max_sum, prefix_sum - seen[idx])\n                    seen.add(prefix_sum)\n        return max_sum\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        m = random.randint(1, 10)\n        n = random.randint(1, 10)\n        k = random.randint(-1000, 1000)\n        matrix = [[random.randint(-100, 100) for _ in range(n)] for _ in range(m)]\n        return {'matrix': matrix, 'k': k}\n\n    def encode_input(self, input_obj: dict) -> str:\n        matrix_str = str(input_obj['matrix'])\n        k_str = str(input_obj['k'])\n        return f\"{{'matrix': {matrix_str}, 'k': {k_str}}}\"\n\n    def encode_output(self, output_obj: int) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str: str) -> dict:\n        return eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.maxSumSubmatrix(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.055",
            "memory": 4688,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 27, in <module>\n    from sortedcontainers import SortedList\nModuleNotFoundError: No module named 'sortedcontainers'\n",
            "token": "e3e00d76-1f7f-4dd8-8bc9-293d47d5d453",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "success",
        "question_id": 459,
        "title": "repeated-substring-pattern",
        "token": "92a63b55-1c65-4e61-80a1-627e2a79262a",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def repeatedSubstringPattern(self, s: str) -> bool:\n        n = len(s)\n        for i in range(1, n // 2 + 1):\n            if n % i == 0:\n                sub = s[:i]\n                if sub * (n // i) == s:\n                    return True\n        return False\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(2, 20)\n        s = ''.join(random.choices('abcdefghijklmnopqrstuvwxyz', k=length))\n        return {'s': s}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['s']\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj).lower()\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.repeatedSubstringPattern(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.06",
            "memory": 4772,
            "stderr": null,
            "token": "92a63b55-1c65-4e61-80a1-627e2a79262a",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 461,
        "title": "hamming-distance",
        "token": "0d2ca6eb-647e-4ce3-8d4e-4ef1c5e61f30",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def hammingDistance(self, x: int, y: int) -> int:\n        xor = x ^ y\n        distance = 0\n        while xor:\n            distance += xor & 1\n            xor >>= 1\n        return distance\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        x = random.randint(0, 2 ** 31 - 1)\n        y = random.randint(0, 2 ** 31 - 1)\n        return {'x': x, 'y': y}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{{'x': {input_obj['x']}, 'y': {input_obj['y']}}}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        input_parts = input_str.strip('{}').split(', ')\n        x = int(input_parts[0].split(': ')[1])\n        y = int(input_parts[1].split(': ')[1])\n        return {'x': x, 'y': y}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.hammingDistance(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.056",
            "memory": 4780,
            "stderr": null,
            "token": "0d2ca6eb-647e-4ce3-8d4e-4ef1c5e61f30",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 463,
        "title": "island-perimeter",
        "token": "ef11875d-8d3b-4681-8ba3-f3d3fe37baef",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List\nimport ast\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def islandPerimeter(self, grid: List[List[int]]) -> int:\n        perimeter = 0\n        rows, cols = len(grid), len(grid[0])\n        for i in range(rows):\n            for j in range(cols):\n                if grid[i][j] == 1:\n                    perimeter += 4\n                    if i > 0 and grid[i-1][j] == 1:\n                        perimeter -= 2\n                    if j > 0 and grid[i][j-1] == 1:\n                        perimeter -= 2\n        return perimeter\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        height = random.randint(1, 10)\n        width = random.randint(1, 10)\n        grid = [[0 for _ in range(width)] for _ in range(height)]\n        start_x = random.randint(0, height - 1)\n        start_y = random.randint(0, width - 1)\n        grid[start_x][start_y] = 1\n        for _ in range(int(height * width / 4)):\n            direction = random.choice(['up', 'down', 'left', 'right'])\n            if direction == 'up' and start_x - 1 >= 0:\n                start_x -= 1\n            elif direction == 'down' and start_x + 1 < height:\n                start_x += 1\n            elif direction == 'left' and start_y - 1 >= 0:\n                start_y -= 1\n            elif direction == 'right' and start_y + 1 < width:\n                start_y += 1\n            grid[start_x][start_y] = 1\n        return {'grid': grid}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['grid'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        grid = ast.literal_eval(input_str)\n        return {'grid': grid}\n\n    def decode_output(self, output_str) -> int:\n        return int(output_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.islandPerimeter(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.064",
            "memory": 5204,
            "stderr": null,
            "token": "ef11875d-8d3b-4681-8ba3-f3d3fe37baef",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 466,
        "title": "count-the-repetitions",
        "token": "6e4cc6ee-13fd-4e84-8c02-1c63b04a03d4",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom collections import defaultdict\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def getMaxRepetitions(self, s1, n1, s2, n2):\n        r = {}\n        j = 0\n        cnt = 0\n        for k in range(1, n1 + 1):\n            for i in range(len(s1)):\n                if s1[i] == s2[j]:\n                    j += 1\n                    if j == len(s2):\n                        cnt += 1\n                        j = 0\n            if j in r:\n                p_k, p_cnt = r[j]\n                rem_k = n1 - p_k\n                repeat_cnt = (rem_k // (k - p_k)) * (cnt - p_cnt)\n                rem_cnt = 0\n                rem_k %= (k - p_k)\n                if rem_k > 0:\n                    for l in range(p_k, p_k + rem_k):\n                        for i in range(len(s1)):\n                            if s1[i] == s2[j]:\n                                j += 1\n                                if j == len(s2):\n                                    rem_cnt += 1\n                                    j = 0\n                return (p_cnt + repeat_cnt + rem_cnt) // n2\n            r[j] = (k, cnt)\n        return cnt // n2\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        letters = 'abcdefghijklmnopqrstuvwxyz'\n        s1_length = random.randint(1, 10)\n        s2_length = random.randint(1, 10)\n        s1 = ''.join((random.choice(letters) for _ in range(s1_length)))\n        s2 = ''.join((random.choice(letters) for _ in range(s2_length)))\n        n1 = random.randint(1, 100)\n        n2 = random.randint(1, 100)\n        return {'s1': s1, 'n1': n1, 's2': s2, 'n2': n2}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['s1']},{input_obj['n1']},{input_obj['s2']},{input_obj['n2']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        s1, n1, s2, n2 = input_str.split(',')\n        return {'s1': s1, 'n1': int(n1), 's2': s2, 'n2': int(n2)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.getMaxRepetitions(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.064",
            "memory": 4808,
            "stderr": null,
            "token": "6e4cc6ee-13fd-4e84-8c02-1c63b04a03d4",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 685,
        "title": "redundant-connection-ii",
        "token": "dced5425-bfe6-48a6-913d-fc1209cc5963",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:\n        n = len(edges)\n        parent = list(range(n + 1))\n        \n        def find(x):\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n\n        def union(x, y):\n            root_x = find(x)\n            root_y = find(y)\n            if root_x != root_y:\n                parent[root_y] = root_x\n                return True\n            return False\n            \n        in_degree = [0] * (n + 1)\n        for u, v in edges:\n            in_degree[v] += 1\n            \n        candidates = [edge for edge in reversed(edges) if in_degree[edge[1]] > 1]\n        \n        if candidates:\n            edges_without_candidate = [edge for edge in edges if edge != candidates[0]]\n            \n            parent = list(range(n + 1))\n            cycle = False\n            \n            for u, v in edges_without_candidate:\n                if find(u) == find(v):\n                    cycle = True\n                    break\n                union(u, v)\n                \n            if cycle:\n                return candidates[0]\n            else:\n                \n                \n                for u, v in reversed(edges):\n                  if in_degree[v]>1:\n                    return [u,v]\n                return []\n\n        else:\n            parent = list(range(n + 1))\n            last_edge = None\n            for u, v in edges:\n                if find(u) == find(v):\n                    last_edge = [u, v]\n                    \n                    break\n                union(u, v)\n            return last_edge\n\nclass TestCaseGenerator:\n\n    def __init__(self, nodes_range=(3, 6)):\n        self.nodes_range = nodes_range\n\n    def generate(self) -> dict:\n        n = random.randint(*self.nodes_range)\n        edges = []\n        for i in range(1, n):\n            edges.append([i, i + 1])\n        a = random.randint(1, n - 1)\n        b = random.randint(a + 1, n)\n        edges.append([b, a])\n        random.shuffle(edges)\n        return {'edges': edges}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['edges'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'edges': eval(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.findRedundantDirectedConnection(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Input {'edges': [[3, 2], [3, 4], [2, 3], [1, 2]]}\nExpected Output:  [3, 2]\nActual Output:  [1, 2]\n1 Test Failed!\n",
            "time": "0.057",
            "memory": 4864,
            "stderr": null,
            "token": "dced5425-bfe6-48a6-913d-fc1209cc5963",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 4,
                "description": "Wrong Answer"
            }
        }
    },
    {
        "status": "success",
        "question_id": 736,
        "title": "parse-lisp-expression",
        "token": "df18bc1b-7132-49f1-8ac8-71eaa9a7df7e",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List, Dict\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nimport re\n\nclass Solution:\n    def evaluate(self, expression: str) -> int:\n        def eval_expr(expr, scope):\n            if expr[0] == '(':\n                parts = re.findall(r'\\(|\\)|[A-Za-z0-9-]+', expr)\n                op = parts[1]\n                if op == 'let':\n                    new_scope = scope.copy()\n                    i = 2\n                    while i < len(parts) - 1:\n                        if parts[i+1] == ')':\n                            val = eval_expr(parts[i], new_scope) if parts[i][0] == '(' else (new_scope.get(parts[i], int(parts[i])))\n                            i+=1\n                            return val\n                        var = parts[i]\n                        i += 1\n                        val_expr = ''\n                        \n                        j = i\n                        balance = 0\n                        if parts[i] == '(':\n                            val_expr += parts[i]\n                            i += 1\n                            balance += 1\n                            while balance > 0:\n                                val_expr += parts[i]\n                                if parts[i] == '(':\n                                    balance += 1\n                                elif parts[i] == ')':\n                                    balance -= 1\n                                i += 1\n                        else:\n                            val_expr = parts[i]\n                            i+=1\n                        \n                        val = eval_expr(val_expr, new_scope) if val_expr[0] == '(' else (new_scope.get(val_expr, int(val_expr)))\n                        new_scope[var] = val\n\n                    return eval_expr(parts[-1], new_scope) if parts[-1][0] == '(' else (new_scope.get(parts[-1], int(parts[-1])))\n\n                elif op == 'add':\n                    val1 = eval_expr(parts[2], scope) if parts[2][0] == '(' else (scope.get(parts[2], int(parts[2])))\n                    val2 = eval_expr(parts[3], scope) if parts[3][0] == '(' else (scope.get(parts[3], int(parts[3])))\n                    return val1 + val2\n                elif op == 'mult':\n                    val1 = eval_expr(parts[2], scope) if parts[2][0] == '(' else (scope.get(parts[2], int(parts[2])))\n                    val2 = eval_expr(parts[3], scope) if parts[3][0] == '(' else (scope.get(parts[3], int(parts[3])))\n                    return val1 * val2\n            else:\n                return scope.get(expr, int(expr))\n\n        return eval_expr(expression, {})\n\nclass TestCaseGenerator:\n\n    def generate(self) -> Dict:\n        test_cases = [{'expression': '(let x 2 (mult x (let x 3 y 4 (add x y))))'}, {'expression': '(let x 3 x 2 x )'}, {'expression': '(let x 1 y 2 x (add x y) (add x y))'}, {'expression': '(add 1 2)'}, {'expression': '(mult (add 1 2) 3)'}]\n        return random.choice(test_cases)\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['expression']\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> Dict:\n        return {'expression': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.evaluate(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.067",
            "memory": 4820,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 148, in <module>\n    runner.run()\n  File \"script.py\", line 132, in run\n    output = self.solution.evaluate(**input)\n  File \"script.py\", line 101, in evaluate\n    return eval_expr(expression, {})\n  File \"script.py\", line 61, in eval_expr\n    val = eval_expr(parts[i], new_scope) if parts[i][0] == '(' else (new_scope.get(parts[i], int(parts[i])))\nValueError: invalid literal for int() with base 10: 'x'\n",
            "token": "df18bc1b-7132-49f1-8ac8-71eaa9a7df7e",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "success",
        "question_id": 973,
        "title": "stamping-the-sequence",
        "token": "49bc802c-b78e-42b9-9752-b90ab85b51d9",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        m, n = len(stamp), len(target)\n        target = list(target)\n        q = []\n        A = []\n        match = [0] * (n - m + 1)\n        for i in range(n - m + 1):\n            stars = 0\n            for j in range(m):\n                if target[i+j] == stamp[j]:\n                    continue\n                elif target[i+j] == '?':\n                    stars += 1\n                else:\n                    stars = -1\n                    break\n            if stars == 0:\n                q.append(i)\n            match[i] = stars\n        \n        while q:\n            i = q.pop(0)\n            A.append(i)\n            for j in range(max(0, i - m + 1), min(n - m + 1, i + m)):\n                if match[j] >= 0:\n                    match[j] += 1\n                    if match[j] == m:\n                        q.append(j)\n                        \n        return A[::-1] if match.count(m) == n - m + 1 else []\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        stamp = 'abc'\n        target = 'ababc'\n        return {'stamp': stamp, 'target': target}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{{'stamp': '{input_obj['stamp']}', 'target': '{input_obj['target']}'}}\"\n\n    def encode_output(self, output_obj) -> str:\n        return f'{output_obj}'\n\n    def decode_input(self, input_str) -> dict:\n        import ast\n        return ast.literal_eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.movesToStamp(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Input {'stamp': 'abc', 'target': 'ababc'}\nExpected Output:  [0, 2]\nActual Output:  []\n1 Test Failed!\n",
            "time": "0.073",
            "memory": 5016,
            "stderr": null,
            "token": "49bc802c-b78e-42b9-9752-b90ab85b51d9",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 4,
                "description": "Wrong Answer"
            }
        }
    },
    {
        "status": "failure",
        "question_id": 975,
        "title": "range-sum-of-bst",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "failure",
        "question_id": 977,
        "title": "distinct-subsequences-ii",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "success",
        "question_id": 1013,
        "title": "fibonacci-number",
        "token": "ccbf8689-d185-41ef-bee7-a92cbeca6b0d",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def fib(self, n: int) -> int:\n        a, b = 0, 1\n        for _ in range(n):\n            a, b = b, a + b\n        return a\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        from random import randint\n        return {'n': randint(0, 30)}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['n'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'n': int(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.fib(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.06",
            "memory": 4744,
            "stderr": null,
            "token": "ccbf8689-d185-41ef-bee7-a92cbeca6b0d",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 514,
        "title": "freedom-trail",
        "token": "5c0b1474-20ad-4184-a506-2a7f33a508ee",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nfrom collections import defaultdict\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def findRotateSteps(self, ring: str, key: str) -> int:\n        n, m = len(ring), len(key)\n        pos = [[] for _ in range(26)]\n        for i, c in enumerate(ring):\n            pos[ord(c) - ord('a')].append(i)\n        dp = [0] * n\n        for k in reversed(range(m)):\n            next_dp = [float('inf')] * n\n            for i in range(n):\n                for p in pos[ord(key[k]) - ord('a')]:\n                    dist = min(abs(i - p), n - abs(i - p))\n                    next_dp[i] = min(next_dp[i], 1 + dist + dp[p])\n            dp = next_dp\n        return dp[0]\n\nclass TestCaseGenerator:\n    \"\"\"\n    Generates test case inputs for the \"Road to Freedom\" problem where a ring needs to be rotated to match a given key string.\n    \"\"\"\n\n    def generate(self) -> dict:\n        random.seed(0)\n        ring_length = random.randint(1, 100)\n        key_length = random.randint(1, 100)\n        alphabet = 'abcdefghijklmnopqrstuvwxyz'\n        ring = ''.join(random.choices(alphabet, k=ring_length))\n        key = ''.join(random.choices(alphabet, k=key_length))\n        return {'ring': ring, 'key': key}\n\n    def encode_input(self, input_obj: dict) -> str:\n        return f\"ring={input_obj['ring']},key={input_obj['key']}\"\n\n    def encode_output(self, output_obj: int) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str: str) -> dict:\n        parts = input_str.split(',')\n        ring = parts[0].split('=')[1]\n        key = parts[1].split('=')[1]\n        return {'ring': ring, 'key': key}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.findRotateSteps(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.256",
            "memory": 4908,
            "stderr": null,
            "token": "5c0b1474-20ad-4184-a506-2a7f33a508ee",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 920,
        "title": "uncommon-words-from-two-sentences",
        "token": "bca21eba-e39b-4bc8-b516-12e6207cb811",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nfrom collections import Counter\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nfrom collections import Counter\nfrom typing import List\n\nclass Solution:\n    def uncommonFromSentences(self, s1: str, s2: str) -> List[str]:\n        d = Counter(s1.split() + s2.split())\n        return [x for x in d if d[x] == 1]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        test_cases = [('this apple is sweet', 'this apple is sour'), ('apple apple', 'banana'), ('orange', 'apple orange'), ('dog cat', 'cat dog'), ('unique words', 'unique unique words'), ('a quick brown fox', 'jumps over the lazy dog')]\n        s1, s2 = random.choice(test_cases)\n        return {'s1': s1, 's2': s2}\n\n    def encode_input(self, input_obj: dict) -> str:\n        return f\"{input_obj['s1']}|{input_obj['s2']}\"\n\n    def encode_output(self, output_obj: List[str]) -> str:\n        return ','.join(output_obj)\n\n    def decode_input(self, input_str: str) -> dict:\n        s1, s2 = input_str.split('|')\n        return {'s1': s1, 's2': s2}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.uncommonFromSentences(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.067",
            "memory": 4768,
            "stderr": null,
            "token": "bca21eba-e39b-4bc8-b516-12e6207cb811",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "failure",
        "question_id": 35,
        "title": "search-insert-position",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "success",
        "question_id": 9,
        "title": "palindrome-number",
        "token": "93cfd1db-cd8f-45be-b88e-26c9e7e9b2c2",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def isPalindrome(self, x: int) -> bool:\n        if x < 0 or (x % 10 == 0 and x != 0):\n            return False\n        rev = 0\n        while x > rev:\n            rev = rev * 10 + x % 10\n            x //= 10\n        return x == rev or x == rev // 10\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        test_values = [121, -121, 10, 0, 12321, -12321, 1, -1, 123321, 1234321, 12345, 1000021]\n        x = random.choice(test_values)\n        return {'x': x}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['x'])\n\n    def encode_output(self, output_obj) -> str:\n        return 'true' if output_obj else 'false'\n\n    def decode_input(self, input_str) -> dict:\n        return {'x': int(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.isPalindrome(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.055",
            "memory": 4796,
            "stderr": null,
            "token": "93cfd1db-cd8f-45be-b88e-26c9e7e9b2c2",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "failure",
        "question_id": 10,
        "title": "regular-expression-matching",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "success",
        "question_id": 218,
        "title": "the-skyline-problem",
        "token": "f3ae9994-7a07-498f-b5dc-ec29ad1f81c9",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport heapq\nimport random\nimport ast\n\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def getSkyline(self, buildings: List[List[int]]) -> List[List[int]]:\n        events = []\n        for l, r, h in buildings:\n            events.append((l, -h, r))\n            events.append((r, 0, 0))\n        events.sort()\n\n        import heapq\n        heap = [(0, float('inf'))]\n        res = []\n        prev = 0\n\n        for x, neg_h, r in events:\n            while heap and heap[0][1] <= x:\n                heapq.heappop(heap)\n            if neg_h != 0:\n                heapq.heappush(heap, (neg_h, r))\n\n            curr_h = -heap[0][0]\n            if curr_h != prev:\n                res.append([x, curr_h])\n                prev = curr_h\n        return res\n\nclass TestCaseGenerator:\n\n    def __init__(self):\n        self.min_height = 1\n        self.max_height = 20\n        self.max_x_coord = 100\n\n    def generate(self) -> dict:\n        num_buildings = random.randint(1, 100)\n        buildings = []\n        current_x = 0\n        for _ in range(num_buildings):\n            left = current_x\n            right = left + random.randint(1, 10)\n            height = random.randint(self.min_height, self.max_height)\n            buildings.append([left, right, height])\n            current_x = right + random.randint(0, 5)\n        return {'buildings': buildings}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return ast.literal_eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.getSkyline(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.076",
            "memory": 5720,
            "stderr": null,
            "token": "f3ae9994-7a07-498f-b5dc-ec29ad1f81c9",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "failure",
        "question_id": 226,
        "title": "invert-binary-tree",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "success",
        "question_id": 273,
        "title": "integer-to-english-words",
        "token": "0f4c90d3-ad6e-4278-9abb-d0e5fd86d959",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def numberToWords(self, num: int) -> str:\n        less_than_20 = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n        tens = [\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n        thousands = [\"\", \"Thousand\", \"Million\", \"Billion\"]\n\n        def helper(n):\n            if n < 20:\n                return less_than_20[n]\n            elif n < 100:\n                return tens[n // 10] + (\" \" + less_than_20[n % 10]) if n % 10 else tens[n // 10]\n            else:\n                return less_than_20[n // 100] + \" Hundred \" + helper(n % 100) if n % 100 else less_than_20[n // 100] + \" Hundred\"\n\n        if num == 0:\n            return \"Zero\"\n\n        result = []\n        for i in range(4):\n            num, remainder = divmod(num, 1000)\n            if remainder:\n                result.append(helper(remainder) + \" \" + thousands[i])\n\n        return \" \".join(result[::-1]).strip()\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        \"\"\"\n        Generates a random test case input within the range of the problem's constraints.\n        \"\"\"\n        num = random.randint(0, 2 ** 31 - 1)\n        return {'num': num}\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\"\n        Convert a test case input into a string suitable for passing to the function.\n        \"\"\"\n        return str(input_obj['num'])\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\"\n        Convert a test case output into a string representation.\n        \"\"\"\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\"\n        Convert a test case input string into a Python dict.\n        \"\"\"\n        return {'num': int(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.numberToWords(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.057",
            "memory": 4780,
            "stderr": null,
            "token": "0f4c90d3-ad6e-4278-9abb-d0e5fd86d959",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 14,
        "title": "longest-common-prefix",
        "token": "c73d9b07-60ef-441b-aaa1-3790544fd3c8",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def longestCommonPrefix(self, strs: List[str]) -> str:\n        if not strs:\n            return \"\"\n        shortest = min(strs, key=len)\n        for i, char in enumerate(shortest):\n            for other in strs:\n                if other[i] != char:\n                    return shortest[:i]\n        return shortest\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        num_strings = random.randint(1, 10)\n        strs = []\n        for _ in range(num_strings):\n            str_length = random.randint(0, 10)\n            random_str = ''.join(random.choices('abcdefghijklmnopqrstuvwxyz', k=str_length))\n            strs.append(random_str)\n        return {'strs': strs}\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\"Convert a test case input into a string for transport.\"\"\"\n        return str(input_obj['strs'])\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\"Convert a test case output into a string for transport.\"\"\"\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\"Convert a test case input string back into a dictionary.\"\"\"\n        strs = eval(input_str[1:-1])\n        return {'strs': strs}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.longestCommonPrefix(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.055",
            "memory": 4856,
            "stderr": null,
            "token": "c73d9b07-60ef-441b-aaa1-3790544fd3c8",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 258,
        "title": "add-digits",
        "token": "d7da798b-c157-4b72-9388-91f3bf4a0ab6",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def addDigits(self, num: int) -> int:\n        return 0 if num == 0 else (num % 9) or 9\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        num = random.randint(0, 1000)\n        return {'num': num}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['num'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        try:\n            num = int(input_str)\n            return {'num': num}\n        except ValueError:\n            raise ValueError('Invalid input string for conversion to integer')\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.addDigits(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.054",
            "memory": 4796,
            "stderr": null,
            "token": "d7da798b-c157-4b72-9388-91f3bf4a0ab6",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 76,
        "title": "minimum-window-substring",
        "token": "5674df5c-9c6f-4981-adcc-fcbe653cb8f9",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nfrom collections import Counter\n\nclass Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        if not t or not s:\n            return \"\"\n\n        dict_t = Counter(t)\n        required = len(dict_t)\n\n        l, r = 0, 0\n        formed = 0\n        window_counts = {}\n        ans = float(\"inf\"), None, None\n\n        while r < len(s):\n            character = s[r]\n            window_counts[character] = window_counts.get(character, 0) + 1\n\n            if character in dict_t and window_counts[character] == dict_t[character]:\n                formed += 1\n\n            while l <= r and formed == required:\n                character = s[l]\n\n                if r - l + 1 < ans[0]:\n                    ans = (r - l + 1, l, r)\n\n                window_counts[character] -= 1\n                if character in dict_t and window_counts[character] < dict_t[character]:\n                    formed -= 1\n\n                l += 1    \n            r += 1\n\n        return \"\" if ans[0] == float(\"inf\") else s[ans[1] : ans[2] + 1]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        possible_cases = [{'s': 'ADOBECODEBANC', 't': 'ABC'}, {'s': 'a', 't': 'a'}, {'s': 'a', 't': 'aa'}, {'s': 'MANGROVESANDMONOGRAMS', 't': 'GMSA'}]\n        return random.choice(possible_cases)\n\n    def encode_input(self, input_obj) -> str:\n        return f\"s={input_obj['s']},t={input_obj['t']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        values = input_str.split(',')\n        return {'s': values[0].split('=')[1], 't': values[1].split('=')[1]}\n\n    def decode_output(self, output_str) -> str:\n        return output_str\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.minWindow(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.054",
            "memory": 4800,
            "stderr": null,
            "token": "5674df5c-9c6f-4981-adcc-fcbe653cb8f9",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 68,
        "title": "text-justification",
        "token": "e362bdf0-0283-4572-a16f-dc236a0fa38e",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport json\nfrom math import ceil\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\n        res, line, width = [], [], 0\n        for w in words:\n            if width + len(w) + len(line) > maxWidth:\n                spaces = maxWidth - width\n                if len(line) > 1:\n                    q, r = divmod(spaces, len(line) - 1)\n                    for i in range(spaces):\n                        line[i % (len(line) - 1)] += ' '\n                else:\n                    line[0] += ' ' * spaces\n                res.append(\"\".join(line))\n                line, width = [], 0\n            line.append(w)\n            width += len(w)\n        return res + [\" \".join(line).ljust(maxWidth)]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        test_cases = [{'words': ['This', 'is', 'an', 'example', 'of', 'text', 'justification.'], 'maxWidth': 16}, {'words': ['What', 'must', 'be', 'acknowledgment', 'shall', 'be'], 'maxWidth': 16}, {'words': ['Science', 'is', 'what', 'we', 'understand', 'well', 'enough', 'to', 'explain', 'to', 'a', 'computer.', 'Art', 'is', 'everything', 'else', 'we', 'do'], 'maxWidth': 20}, {'words': ['Lorem', 'ipsum', 'dolor', 'sit', 'amet'], 'maxWidth': 14}, {'words': ['A', 'test', 'case', 'with'], 'maxWidth': 12}]\n        return random.choice(test_cases)\n\n    def encode_input(self, input_obj) -> str:\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return json.dumps(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return json.loads(input_str)\n\n    def decode_output(self, output_str) -> list:\n        return json.loads(output_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.fullJustify(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.056",
            "memory": 4816,
            "stderr": null,
            "token": "e362bdf0-0283-4572-a16f-dc236a0fa38e",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 332,
        "title": "reconstruct-itinerary",
        "token": "099760f4-07ea-4026-b417-75d7d3308f73",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport collections\nimport random\nimport ast\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\n        graph = {}\n        for src, dst in tickets:\n            graph.setdefault(src, []).append(dst)\n        \n        for src_dst in graph.values():\n            src_dst.sort(reverse=True)\n        \n        res = []\n        \n        def dfs(src):\n            while graph.get(src):\n                dfs(graph[src].pop())\n            res.append(src)\n        \n        dfs(\"JFK\")\n        return res[::-1]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        airports = ['JFK', 'SFO', 'ATL', 'LHR', 'MUC', 'SJC', 'LGB']\n        tickets = [['JFK', random.choice(airports[1:])]]\n        for _ in range(random.randint(1, 10)):\n            from_airport = random.choice(airports)\n            to_airport = random.choice([airport for airport in airports if airport != from_airport])\n            tickets.append([from_airport, to_airport])\n        return {'tickets': tickets}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['tickets'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        input_list = ast.literal_eval(input_str)\n        return {'tickets': input_list}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.findItinerary(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.056",
            "memory": 5208,
            "stderr": null,
            "token": "099760f4-07ea-4026-b417-75d7d3308f73",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 446,
        "title": "arithmetic-slices-ii-subsequence",
        "token": "b571e729-9772-4c75-8623-f377b4ce5026",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom collections import defaultdict\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n < 3:\n            return 0\n        dp = [0] * n\n        ans = 0\n        for i in range(2, n):\n            if nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2]:\n                dp[i] = dp[i - 1] + 1\n                ans += dp[i]\n        return ans\n\nclass TestCaseGenerator:\n\n    def generate(self) -> Dict[str, List[int]]:\n        length = random.randint(3, 10)\n        nums = [random.randint(-100, 100) for _ in range(length)]\n        return {'nums': nums}\n\n    def encode_input(self, input_obj: Dict[str, List[int]]) -> str:\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj: int) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str: str) -> Dict[str, List[int]]:\n        nums = eval(input_str)\n        return {'nums': nums}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.numberOfArithmeticSlices(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.054",
            "memory": 4680,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 61, in <module>\n    class TestCaseGenerator:\n  File \"script.py\", line 63, in TestCaseGenerator\n    def generate(self) -> Dict[str, List[int]]:\nNameError: name 'Dict' is not defined\n",
            "token": "b571e729-9772-4c75-8623-f377b4ce5026",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "success",
        "question_id": 689,
        "title": "maximum-sum-of-3-non-overlapping-subarrays",
        "token": "e88bee06-a881-4bbb-bb57-35874c887c46",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\nimport json\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def maxSumOfThreeSubarrays(self, nums: List[int], k: int) -> List[int]:\n        n = len(nums)\n        sums = [0] * (n - k + 1)\n        current_sum = sum(nums[:k])\n        sums[0] = current_sum\n        for i in range(k, n):\n            current_sum = current_sum - nums[i - k] + nums[i]\n            sums[i - k + 1] = current_sum\n        \n        left = [0] * (n - k + 1)\n        best = 0\n        for i in range(n - k + 1):\n            if sums[i] > sums[best]:\n                best = i\n            left[i] = best\n        \n        right = [n - k] * (n - k + 1)\n        best = n - k\n        for i in range(n - k, -1, -1):\n            if sums[i] >= sums[best]:\n                best = i\n            right[i] = best\n        \n        result = []\n        max_sum = 0\n        for mid in range(k, n - 2 * k + 1):\n            l, r = left[mid - k], right[mid + k]\n            cur_sum = sums[l] + sums[mid] + sums[r]\n            if cur_sum > max_sum:\n                max_sum = cur_sum\n                result = [l, mid, r]\n        return result\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(3, 30)\n        k = random.randint(1, n // 3)\n        nums = [random.randint(1, 100) for _ in range(n)]\n        return {'nums': nums, 'k': k}\n\n    def encode_input(self, input_obj) -> str:\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return json.dumps(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return json.loads(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.maxSumOfThreeSubarrays(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.05",
            "memory": 4864,
            "stderr": null,
            "token": "e88bee06-a881-4bbb-bb57-35874c887c46",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 953,
        "title": "reverse-only-letters",
        "token": "bee9fa9f-b9ef-46f2-8173-73409dba951c",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport string\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def reverseOnlyLetters(self, s: str) -> str:\n        s_list = list(s)\n        left, right = 0, len(s) - 1\n        while left < right:\n            while left < right and not s_list[left].isalpha():\n                left += 1\n            while left < right and not s_list[right].isalpha():\n                right -= 1\n            if left < right:\n                s_list[left], s_list[right] = s_list[right], s_list[left]\n                left += 1\n                right -= 1\n        return \"\".join(s_list)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random, string\n        letters = ''.join(random.choices(string.ascii_letters, k=random.randint(1, 50)))\n        non_letters = ''.join(random.choices('!@#$%^&*()-_1234567890:=', k=50 - len(letters)))\n        string_list = list(letters + non_letters)\n        random.shuffle(string_list)\n        generated_string = ''.join(string_list)\n        return {'s': generated_string}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['s']\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.reverseOnlyLetters(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.049",
            "memory": 4860,
            "stderr": null,
            "token": "bee9fa9f-b9ef-46f2-8173-73409dba951c",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 956,
        "title": "number-of-music-playlists",
        "token": "0690dcb4-88e3-43e9-a5de-98c905a19910",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def numMusicPlaylists(self, n: int, goal: int, k: int) -> int:\n        MOD = 10**9 + 7\n        dp = [[0] * (n + 1) for _ in range(goal + 1)]\n        dp[0][0] = 1\n        for i in range(1, goal + 1):\n            for j in range(1, n + 1):\n                dp[i][j] = (dp[i-1][j-1] * (n - j + 1)) % MOD\n                if j > k:\n                    dp[i][j] = (dp[i][j] + dp[i-1][j] * (j - k)) % MOD\n        return dp[goal][n]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 10)\n        goal = random.randint(n, n + 10)\n        k = random.randint(0, n - 1)\n        return {'n': n, 'goal': goal, 'k': k}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['n']} {input_obj['goal']} {input_obj['k']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        values = list(map(int, input_str.split()))\n        return {'n': values[0], 'goal': values[1], 'k': values[2]}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.numMusicPlaylists(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.051",
            "memory": 4736,
            "stderr": null,
            "token": "0690dcb4-88e3-43e9-a5de-98c905a19910",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "failure",
        "question_id": 517,
        "title": "super-washing-machines",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "success",
        "question_id": 923,
        "title": "super-egg-drop",
        "token": "d7b37335-a4c3-4412-a220-bf385c89161b",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom functools import cache\nfrom random import randint\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def superEggDrop(self, k: int, n: int) -> int:\n        dp = [[0] * (k + 1) for _ in range(n + 1)]\n        m = 0\n        while dp[m][k] < n:\n            m += 1\n            for j in range(1, k + 1):\n                dp[m][j] = dp[m - 1][j - 1] + dp[m - 1][j] + 1\n        return m\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        from random import randint\n        k = randint(1, 10)\n        n = randint(1, 100)\n        return {'k': k, 'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{{'k': {input_obj['k']}, 'n': {input_obj['n']}}}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        input_obj = eval(input_str)\n        return input_obj\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.superEggDrop(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.045",
            "memory": 4580,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 26, in <module>\n    from functools import cache\nImportError: cannot import name 'cache' from 'functools' (/usr/local/python-3.8.1/lib/python3.8/functools.py)\n",
            "token": "d7b37335-a4c3-4412-a220-bf385c89161b",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "failure",
        "question_id": 924,
        "title": "fair-candy-swap",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "success",
        "question_id": 632,
        "title": "smallest-range-covering-elements-from-k-lists",
        "token": "a820224a-b0c4-402f-a525-c54bf0ba5286",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom collections import defaultdict\nimport heapq\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nfrom collections import defaultdict\nimport heapq\n\nclass Solution:\n    def smallestRange(self, nums: List[List[int]]) -> List[int]:\n        pq = []\n        max_val = float('-inf')\n        for i, row in enumerate(nums):\n            heapq.heappush(pq, (row[0], i, 0))\n            max_val = max(max_val, row[0])\n        \n        range_start, range_end = float('-inf'), float('inf')\n        \n        while pq:\n            min_val, row_idx, col_idx = heapq.heappop(pq)\n            \n            if max_val - min_val < range_end - range_start:\n                range_start, range_end = min_val, max_val\n            \n            if col_idx + 1 == len(nums[row_idx]):\n                break\n            \n            new_val = nums[row_idx][col_idx + 1]\n            max_val = max(max_val, new_val)\n            heapq.heappush(pq, (new_val, row_idx, col_idx + 1))\n        \n        return [range_start, range_end]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        k = random.randint(1, 10)\n        nums = []\n        for _ in range(k):\n            size_of_list = random.randint(1, 10)\n            start_value = random.randint(-100, 100)\n            num_list = sorted((random.randint(start_value, start_value + 20) for _ in range(size_of_list)))\n            nums.append(num_list)\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'nums': eval(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.smallestRange(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.07",
            "memory": 4936,
            "stderr": null,
            "token": "a820224a-b0c4-402f-a525-c54bf0ba5286",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 637,
        "title": "average-of-levels-in-binary-tree",
        "token": "a1bf826d-9b08-4f21-9e09-2d94171cdf92",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom collections import deque\nfrom typing import List, Optional\nimport json\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nfrom collections import deque\nclass Solution:\n    def averageOfLevels(self, root: Optional[TreeNode]) -> List[float]:\n        res = []\n        q = deque([root]) if root else deque()\n        while q:\n            total = 0\n            count = len(q)\n            for _ in range(count):\n                node = q.popleft()\n                total += node.val\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n            res.append(total / count)\n        return res\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        \"\"\"Generates a sample tree for testing purposes.\"\"\"\n        root = TreeNode(3)\n        root.left = TreeNode(9)\n        root.right = TreeNode(20, TreeNode(15), TreeNode(7))\n        return {'root': root}\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\"Encodes a tree structure into a JSON-compatible string.\"\"\"\n\n        def serialize(root):\n            values = []\n            queue = [root]\n            while queue:\n                node = queue.pop(0)\n                if node:\n                    values.append(node.val)\n                    queue.append(node.left)\n                    queue.append(node.right)\n                else:\n                    values.append(None)\n            return json.dumps(values)\n        return serialize(input_obj['root'])\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\"Converts the result into a JSON string.\"\"\"\n        return json.dumps(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\"Decodes a JSON string back into a tree structure.\"\"\"\n\n        def deserialize(data):\n            data = json.loads(data)\n            if not data or data[0] is None:\n                return None\n            root = TreeNode(data[0])\n            queue = [root]\n            i = 1\n            while queue and i < len(data):\n                node = queue.pop(0)\n                if data[i] is not None:\n                    node.left = TreeNode(data[i])\n                    queue.append(node.left)\n                i += 1\n                if i < len(data) and data[i] is not None:\n                    node.right = TreeNode(data[i])\n                    queue.append(node.right)\n                i += 1\n            return root\n        return {'root': deserialize(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.averageOfLevels(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.066",
            "memory": 4660,
            "stderr": null,
            "token": "a1bf826d-9b08-4f21-9e09-2d94171cdf92",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 979,
        "title": "di-string-match",
        "token": "4e23d8b4-a7cd-4573-a749-2f852a576627",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\nimport ast\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def diStringMatch(self, s: str) -> List[int]:\n        n = len(s)\n        low, high = 0, n\n        res = []\n        for c in s:\n            if c == 'I':\n                res.append(low)\n                low += 1\n            else:\n                res.append(high)\n                high -= 1\n        res.append(low)\n        return res\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(1, 20)\n        s = ''.join((random.choice(['I', 'D']) for _ in range(length)))\n        return {'s': s}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{{'s': '{input_obj['s']}'}}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return ast.literal_eval(input_str)\n\n    def decode_output(self, output_str) -> list:\n        return eval(output_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.diStringMatch(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Input {'s': 'DIDDDIIIDDIIDDDDI'}\nExpected Output:  [1, 0, 5, 4, 3, 2, 6, 7, 10, 9, 8, 11, 16, 15, 14, 13, 12, 17]\nActual Output:  [17, 0, 16, 15, 14, 1, 2, 3, 13, 12, 4, 5, 11, 10, 9, 8, 6, 7]\n1 Test Failed!\n",
            "time": "0.076",
            "memory": 5052,
            "stderr": null,
            "token": "4e23d8b4-a7cd-4573-a749-2f852a576627",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 4,
                "description": "Wrong Answer"
            }
        }
    },
    {
        "status": "success",
        "question_id": 981,
        "title": "delete-columns-to-make-sorted",
        "token": "16585e26-4600-4f5f-9449-ac8ebdf09347",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def minDeletionSize(self, strs: List[str]) -> int:\n        return sum(any(strs[i][j] < strs[i-1][j] for i in range(1, len(strs))) for j in range(len(strs[0])))\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 100)\n        m = random.randint(1, 1000)\n        strs = [''.join(random.choices('abcdefghijklmnopqrstuvwxyz', k=m)) for _ in range(n)]\n        return {'strs': strs}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.minDeletionSize(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.073",
            "memory": 11808,
            "stderr": null,
            "token": "16585e26-4600-4f5f-9449-ac8ebdf09347",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 927,
        "title": "sum-of-subsequence-widths",
        "token": "95fb8f4d-06a0-4443-813b-bf173f25fbdc",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def sumSubseqWidths(self, nums: List[int]) -> int:\n        nums.sort()\n        n = len(nums)\n        mod = 10**9 + 7\n        ans = 0\n        pows = [1] * n\n        for i in range(1, n):\n            pows[i] = (pows[i - 1] * 2) % mod\n        for i in range(n):\n            ans = (ans + (nums[i] * pows[i]) - (nums[i] * pows[n - i - 1])) % mod\n        return ans\n\nclass TestCaseGenerator:\n\n    def __init__(self):\n        self.random = random\n\n    def generate(self) -> dict:\n        \"\"\" Generate a random test case within reasonable constraints. \"\"\"\n        length = self.random.randint(1, 10)\n        nums = [self.random.randint(1, 100) for _ in range(length)]\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\" Convert the dict input into a JSON-like string format. \"\"\"\n        return str(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\" The output is an integer so we convert it to a string directly. \"\"\"\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\" Convert the input string back to a dictionary object. \"\"\"\n        return eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.sumSubseqWidths(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.058",
            "memory": 4904,
            "stderr": null,
            "token": "95fb8f4d-06a0-4443-813b-bf173f25fbdc",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 928,
        "title": "surface-area-of-3d-shapes",
        "token": "25ea2903-dbbf-4bdc-a6ad-fd7d62031b45",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport ast\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def surfaceArea(self, grid) -> int:\n        n = len(grid)\n        area = 0\n        for i in range(n):\n            for j in range(n):\n                if grid[i][j]:\n                    area += 2\n                    for ni, nj in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                        if 0 <= ni < n and 0 <= nj < n:\n                            area += max(0, grid[i][j] - grid[ni][nj])\n                        else:\n                            area += grid[i][j]\n        return area\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 5)\n        grid = [[random.randint(0, 5) for _ in range(n)] for _ in range(n)]\n        return {'grid': grid}\n\n    def encode_input(self, input_obj) -> str:\n        grid_str = '['\n        for row in input_obj['grid']:\n            grid_str += '[' + ','.join(map(str, row)) + '],'\n        grid_str = grid_str[:-1] + ']'\n        return f'grid = {grid_str}'\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        grid_str = input_str.split('=')[1].strip()\n        grid = ast.literal_eval(grid_str)\n        return {'grid': grid}\n\n    def decode_output(self, output_str) -> int:\n        return int(output_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.surfaceArea(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.073",
            "memory": 5092,
            "stderr": null,
            "token": "25ea2903-dbbf-4bdc-a6ad-fd7d62031b45",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "failure",
        "question_id": 933,
        "title": "increasing-order-search-tree",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "success",
        "question_id": 488,
        "title": "zuma-game",
        "token": "b32e3f46-2fec-404e-b224-0e9406428842",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom functools import cache\nfrom itertools import groupby\nimport random\nfrom math import inf\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nfrom functools import cache\n\nclass Solution:\n    def findMinStep(self, board: str, hand: str) -> int:\n        hand = ''.join(sorted(hand))\n        @cache\n        def solve(board, hand):\n            board = self.compress(board)\n            if not board: return len(hand) - len(hand)\n            if not hand: return 10**9\n\n            ans = 10**9\n            for i in range(len(hand)):\n                if i > 0 and hand[i] == hand[i-1]: continue\n    \n                for j in range(len(board)):\n                    if board[j] == hand[i] or j > 0 and board[j] == board[j-1]:\n                        ans = min(ans, solve(board[:j] + hand[i] + board[j:], hand[:i] + hand[i+1:]))\n            return ans\n        \n        res = solve(board, hand)\n        return res if res < 10**9 else -1\n\n    def compress(self, s: str) -> str:\n        compressed = \"\"\n        count = 1\n        for i in range(len(s)):\n            if i + 1 < len(s) and s[i] == s[i+1]:\n                count += 1\n            else:\n                if count < 3:\n                    compressed += s[i] * count\n                count = 1\n        return compressed\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        colors = ['R', 'Y', 'B', 'G', 'W']\n        board_length = random.randint(1, 16)\n        hand_length = random.randint(1, 5)\n        board = ''.join((random.choice(colors) for _ in range(board_length)))\n        hand = ''.join((random.choice(colors) for _ in range(hand_length)))\n        return {'board': board, 'hand': hand}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"board={input_obj['board']},hand={input_obj['hand']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        parts = input_str.split(',')\n        board_part = parts[0].split('=')[1]\n        hand_part = parts[1].split('=')[1]\n        return {'board': board_part, 'hand': hand_part}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.findMinStep(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.062",
            "memory": 4672,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 26, in <module>\n    from functools import cache\nImportError: cannot import name 'cache' from 'functools' (/usr/local/python-3.8.1/lib/python3.8/functools.py)\n",
            "token": "b32e3f46-2fec-404e-b224-0e9406428842",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "success",
        "question_id": 493,
        "title": "reverse-pairs",
        "token": "0ac88abd-c6b2-4832-8d86-1138babef742",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nfrom random import randint\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def reversePairs(self, nums: List[int]) -> int:\n        n = len(nums)\n        sorted_nums = sorted(set(nums))\n        index_map = {num: i + 1 for i, num in enumerate(sorted_nums)}\n        bit = [0] * (len(sorted_nums) + 1)\n\n        def update(i):\n            while i > 0:\n                bit[i] += 1\n                i -= i & -i\n\n        def query(i):\n            res = 0\n            while i <= len(sorted_nums):\n                res += bit[i]\n                i += i & -i\n            return res\n\n        count = 0\n        for num in nums:\n            count += query(index_map[num] + 1)\n            for i in range(len(sorted_nums)):\n                if sorted_nums[i] > 2 * num:\n                    target_index = i+1\n                    break\n            else:\n                target_index = len(sorted_nums)+1\n            update(target_index)\n\n        return n*(n-1)//2 - count\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = randint(1, 100)\n        nums = [randint(-2 ** 31, 2 ** 31 - 1) for _ in range(n)]\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'nums': eval(input_str)}\n\n    def decode_output(self, output_str) -> int:\n        return int(output_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.reversePairs(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.064",
            "memory": 5124,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 129, in <module>\n    runner.run()\n  File \"script.py\", line 113, in run\n    output = self.solution.reversePairs(**input)\n  File \"script.py\", line 76, in reversePairs\n    update(target_index)\n  File \"script.py\", line 57, in update\n    bit[i] += 1\nIndexError: list index out of range\n",
            "token": "0ac88abd-c6b2-4832-8d86-1138babef742",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "success",
        "question_id": 495,
        "title": "teemo-attacking",
        "token": "2892e31a-add3-4253-85c5-d684bf48552e",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\nfrom ast import literal_eval\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def findPoisonedDuration(self, timeSeries: List[int], duration: int) -> int:\n        res = 0\n        for i in range(len(timeSeries) - 1):\n            res += min(duration, timeSeries[i+1] - timeSeries[i])\n        return res + (duration if timeSeries else 0)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(1, 20)\n        time_series = sorted(random.sample(range(1, 100), length))\n        duration = random.randint(1, 10)\n        return {'timeSeries': time_series, 'duration': duration}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return literal_eval(input_str)\n\n    def decode_output(self, output_str) -> int:\n        return int(output_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.findPoisonedDuration(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.058",
            "memory": 5092,
            "stderr": null,
            "token": "2892e31a-add3-4253-85c5-d684bf48552e",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 496,
        "title": "next-greater-element-i",
        "token": "3176f66a-67d2-4e25-a8aa-9103a074fa12",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        greater = {}\n        stack = []\n        for num in nums2:\n            while stack and num > stack[-1]:\n                greater[stack.pop()] = num\n            stack.append(num)\n        return [greater.get(num, -1) for num in nums1]\n\nclass TestCaseGenerator:\n\n    def __init__(self):\n        pass\n\n    @staticmethod\n    def generate() -> dict:\n        nums2_length = random.randint(2, 10)\n        nums2 = random.sample(range(0, 1000), nums2_length)\n        nums1_length = random.randint(1, nums2_length)\n        nums1 = random.sample(nums2, nums1_length)\n        return {'nums1': nums1, 'nums2': nums2}\n\n    @staticmethod\n    def encode_input(input_obj) -> str:\n        return f\"{input_obj['nums1']}, {input_obj['nums2']}\"\n\n    @staticmethod\n    def encode_output(output_obj) -> str:\n        return f'{output_obj}'\n\n    @staticmethod\n    def decode_input(input_str) -> dict:\n        nums1_str, nums2_str = input_str.split('],')\n        nums1 = list(map(int, nums1_str.strip('[] ').split(',')))\n        nums2 = list(map(int, nums2_str.strip('[] ').strip().split(',')))\n        return {'nums1': nums1, 'nums2': nums2}\n\n    @staticmethod\n    def decode_output(output_str) -> list:\n        return list(map(int, output_str.strip('[] ').split(',')))\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.nextGreaterElement(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.061",
            "memory": 4872,
            "stderr": null,
            "token": "3176f66a-67d2-4e25-a8aa-9103a074fa12",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 830,
        "title": "largest-triangle-area",
        "token": "e9870afb-8fb3-4333-ac37-01b982c2a3a7",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\nimport ast\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\n        n = len(points)\n        max_area = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                for k in range(j + 1, n):\n                    x1, y1 = points[i]\n                    x2, y2 = points[j]\n                    x3, y3 = points[k]\n                    area = 0.5 * abs(x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2))\n                    max_area = max(max_area, area)\n        return max_area\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        num_points = random.randint(3, 50)\n        points = [[random.randint(-50, 50), random.randint(-50, 50)] for _ in range(num_points)]\n        points = list(map(list, set(map(tuple, points))))\n        return {'points': points}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['points'])\n\n    def encode_output(self, output_obj) -> str:\n        return f'{output_obj:.5f}'\n\n    def decode_input(self, input_str) -> dict:\n        return {'points': ast.literal_eval(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.largestTriangleArea(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.14",
            "memory": 5356,
            "stderr": null,
            "token": "e9870afb-8fb3-4333-ac37-01b982c2a3a7",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 836,
        "title": "race-car",
        "token": "bf658b98-a7c0-443a-afff-4760710efeb1",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom collections import deque\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nfrom collections import deque\n\nclass Solution:\n    def racecar(self, target: int) -> int:\n        q = deque([(0, 1, 0)])\n        visited = set()\n        while q:\n            pos, speed, steps = q.popleft()\n            if (pos, speed) in visited:\n                continue\n            visited.add((pos, speed))\n            if pos == target:\n                return steps\n            \n            a_pos = pos + speed\n            a_speed = speed * 2\n            if abs(a_pos - target) < target * 2:\n                q.append((a_pos, a_speed, steps + 1))\n            \n            r_speed = -1 if speed > 0 else 1\n            if abs(pos - target) < target * 2:\n                q.append((pos, r_speed, steps + 1))\n        return -1\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        target = random.randint(1, 10000)\n        return {'target': target}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.racecar(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "4.692",
            "memory": 80680,
            "stderr": null,
            "token": "bf658b98-a7c0-443a-afff-4760710efeb1",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 861,
        "title": "flipping-an-image",
        "token": "6d071593-8475-4bc2-9746-8b8a3bb1d158",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\n        return [[1 - x for x in row[::-1]] for row in image]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 5)\n        image = [[random.choice([0, 1]) for _ in range(n)] for _ in range(n)]\n        return {'image': image}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['image'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'image': eval(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.flipAndInvertImage(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.054",
            "memory": 4892,
            "stderr": null,
            "token": "6d071593-8475-4bc2-9746-8b8a3bb1d158",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 741,
        "title": "cherry-pickup",
        "token": "b48cfbda-e44d-4b29-ae08-cd27ac0ac975",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\nimport json\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def cherryPickup(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        dp = {}\n        def solve(r1, c1, r2):\n            c2 = r1 + c1 - r2\n            if n <= r1 or n <= c1 or n <= r2 or n <= c2 or grid[r1][c1] == -1 or grid[r2][c2] == -1:\n                return -float('inf')\n            if (r1, c1, r2) in dp:\n                return dp[(r1, c1, r2)]\n            if r1 == n - 1 and c1 == n - 1:\n                return grid[r1][c1]\n            ans = max(solve(r1 + 1, c1, r2 + 1), solve(r1 + 1, c1, r2), solve(r1, c1 + 1, r2 + 1), solve(r1, c1 + 1, r2))\n            if ans == -float('inf'):\n                dp[(r1, c1, r2)] = -float('inf')\n                return -float('inf')\n            ans += grid[r1][c1]\n            if r1 != r2:\n                ans += grid[r2][c2]\n            dp[(r1, c1, r2)] = ans\n            return ans\n        result = solve(0, 0, 0)\n        return max(0, result)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 6)\n        grid = [[random.choice([0, 1, -1]) for _ in range(n)] for _ in range(n)]\n        grid[0][0] = random.choice([0, 1])\n        grid[n - 1][n - 1] = random.choice([0, 1])\n        for i in range(n):\n            grid[i][0] = random.choice([0, 1])\n        for j in range(n):\n            grid[n - 1][j] = random.choice([0, 1])\n        return {'grid': grid}\n\n    def encode_input(self, input_obj) -> str:\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return json.loads(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.cherryPickup(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.067",
            "memory": 6168,
            "stderr": null,
            "token": "b48cfbda-e44d-4b29-ae08-cd27ac0ac975",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 750,
        "title": "contain-virus",
        "token": "b239777d-1f88-4d01-817e-7c59d2d57ac0",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def containVirus(self, mat: List[List[int]]) -> int:\n        m, n = len(mat), len(mat[0])\n        dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\n        def explore(i, j, visited, region, frontiers):\n            if not (0 <= i < m and 0 <= j < n and (i, j) not in visited):\n                return\n            visited.add((i, j))\n            if mat[i][j] == 0:\n                frontiers.add((i, j))\n                return\n            if mat[i][j] != 1:\n                return\n            region.add((i, j))\n            for dx, dy in dirs:\n                explore(i + dx, j + dy, visited, region, frontiers)\n\n        ans = 0\n        while True:\n            regions = []\n            visited = set()\n            for i in range(m):\n                for j in range(n):\n                    if mat[i][j] == 1 and (i, j) not in visited:\n                        region, frontiers = set(), set()\n                        explore(i, j, visited, region, frontiers)\n                        regions.append((len(frontiers), region, frontiers))\n            if not regions:\n                break\n            regions.sort(reverse=True)\n            ans += regions[0][0]\n            for i, j in regions[0][1]:\n                mat[i][j] = 2\n            for _, region, frontiers in regions[1:]:\n                for i, j in frontiers:\n                    mat[i][j] = 1\n        return ans\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        m = random.randint(1, 50)\n        n = random.randint(1, 50)\n        isInfected = [[random.choice([0, 1]) for _ in range(n)] for _ in range(m)]\n        return {'isInfected': isInfected}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.containVirus(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.055",
            "memory": 5436,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 134, in <module>\n    runner.run()\n  File \"script.py\", line 118, in run\n    output = self.solution.containVirus(**input)\nTypeError: containVirus() got an unexpected keyword argument 'isInfected'\n",
            "token": "b239777d-1f88-4d01-817e-7c59d2d57ac0",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "success",
        "question_id": 699,
        "title": "falling-squares",
        "token": "8b6cf0c0-c44f-4d5f-84e4-f5263b89c7d9",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom bisect import bisect_right, bisect_left\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def fallingSquares(self, positions):\n        class Node:\n            def __init__(self, l, r):\n                self.l = l\n                self.r = r\n                self.mid = (l + r) // 2\n                self.v = 0\n                self.add = 0\n                self.left = None\n                self.right = None\n\n        class SegmentTree:\n            def __init__(self):\n                self.root = Node(1, int(1e9))\n\n            def modify(self, l, r, v, node=None):\n                if node is None:\n                    node = self.root\n                if l > r:\n                    return\n                if node.l >= l and node.r <= r:\n                    node.v = v\n                    node.add = v\n                    return\n                self.pushdown(node)\n                if l <= node.mid:\n                    self.modify(l, r, v, node.left)\n                if r > node.mid:\n                    self.modify(l, r, v, node.right)\n                node.v = max(node.left.v, node.right.v)\n\n            def query(self, l, r, node=None):\n                if node is None:\n                    node = self.root\n                if l > r:\n                    return 0\n                if node.l >= l and node.r <= r:\n                    return node.v\n                self.pushdown(node)\n                v = 0\n                if l <= node.mid:\n                    v = max(v, self.query(l, r, node.left))\n                if r > node.mid:\n                    v = max(v, self.query(l, r, node.right))\n                return v\n\n            def pushdown(self, node):\n                if node.left is None:\n                    node.left = Node(node.l, node.mid)\n                if node.right is None:\n                    node.right = Node(node.mid + 1, node.r)\n                if node.add != 0:\n                    node.left.add = node.add\n                    node.right.add = node.add\n                    node.left.v = node.add\n                    node.right.v = node.add\n                    node.add = 0\n\n        ans = []\n        tree = SegmentTree()\n        mx = 0\n        for l, w in positions:\n            r = l + w - 1\n            h = tree.query(l, r) + w\n            mx = max(mx, h)\n            ans.append(mx)\n            tree.modify(l, r, h)\n        return ans\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 10)\n        positions = [[random.randint(1, 100), random.randint(1, 10)] for _ in range(n)]\n        return {'positions': positions}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['positions'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'positions': eval(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.fallingSquares(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.078",
            "memory": 7736,
            "stderr": null,
            "token": "8b6cf0c0-c44f-4d5f-84e4-f5263b89c7d9",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 779,
        "title": "max-chunks-to-make-sorted-ii",
        "token": "612eccb5-7e6c-4698-aeb1-a32f286c2636",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\nimport json\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        max_so_far = 0\n        count = 0\n        for i, num in enumerate(arr):\n            max_so_far = max(max_so_far, num)\n            if max_so_far == i:\n                count += 1\n        return count\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(1, 10)\n        arr = [random.randint(0, 100) for _ in range(length)]\n        return {'arr': arr}\n\n    def encode_input(self, input_obj) -> str:\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return json.loads(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.maxChunksToSorted(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Input {'arr': [58, 9]}\nExpected Output:  1\nActual Output:  0\n1 Test Failed!\n",
            "time": "0.06",
            "memory": 4800,
            "stderr": null,
            "token": "612eccb5-7e6c-4698-aeb1-a32f286c2636",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 4,
                "description": "Wrong Answer"
            }
        }
    },
    {
        "status": "success",
        "question_id": 759,
        "title": "set-intersection-size-at-least-two",
        "token": "35746939-a332-4af2-9065-86d55546da73",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List, Dict\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def intersectionSizeTwo(self, intervals: List[List[int]]) -> int:\n        intervals.sort(key=lambda x: (x[1], -x[0]))\n        res = 0\n        p1 = -1\n        p2 = -1\n\n        for s, e in intervals:\n            if p2 >= s:\n                continue\n            res += 1\n            if p1 >= s:\n                p1 = p2\n                p2 = e\n            else:\n                res += 1\n                p1 = e - 1\n                p2 = e\n        return res\n\nclass TestCaseGenerator:\n\n    def generate(self) -> Dict[str, List[List[int]]]:\n        return {'intervals': [[1, 3], [3, 7], [8, 9]]}\n\n    def encode_input(self, input_obj: Dict[str, List[List[int]]]) -> str:\n        return str(input_obj['intervals'])\n\n    def encode_output(self, output_obj: int) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str: str) -> Dict[str, List[List[int]]]:\n        return {'intervals': eval(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.intersectionSizeTwo(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Input {'intervals': [[1, 3], [3, 7], [8, 9]]}\nExpected Output:  5\nActual Output:  4\n1 Test Failed!\n",
            "time": "0.057",
            "memory": 4680,
            "stderr": null,
            "token": "35746939-a332-4af2-9065-86d55546da73",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 4,
                "description": "Wrong Answer"
            }
        }
    },
    {
        "status": "success",
        "question_id": 854,
        "title": "making-a-large-island",
        "token": "b2781ed3-7c47-4645-bbe7-0905182117c8",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List, Dict, Any\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def largestIsland(self, grid: List[List[int]]) -> int:\n        n, m = len(grid), len(grid[0])\n        def dfs(i, j, index):\n            if i < 0 or i >= n or j < 0 or j >= m or grid[i][j] != 1:\n                return 0\n            grid[i][j] = index\n            return 1 + dfs(i + 1, j, index) + dfs(i - 1, j, index) + dfs(i, j + 1, index) + dfs(i, j - 1, index)\n\n        areas = {0: 0}\n        index = 2\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 1:\n                    areas[index] = dfs(i, j, index)\n                    index += 1\n\n        ans = max(areas.values())\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 0:\n                    neighbors = set()\n                    for x, y in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                        if 0 <= x < n and 0 <= y < m and grid[x][y] > 1:\n                            neighbors.add(grid[x][y])\n                    ans = max(ans, 1 + sum(areas[k] for k in neighbors))\n        return ans\n\nclass TestCaseGenerator:\n\n    def generate(self) -> Dict[str, Any]:\n        grid_variants = [[[1, 0], [0, 1]], [[1, 1], [1, 0]], [[1, 1], [1, 1]], [[0, 0, 1], [0, 1, 0], [0, 0, 0]], [[1]], [[0]]]\n        grid = random.choice(grid_variants)\n        return {'grid': grid}\n\n    def encode_input(self, input_obj: Dict[str, Any]) -> str:\n        return str(input_obj['grid'])\n\n    def encode_output(self, output_obj: int) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str: str) -> Dict[str, List[List[int]]]:\n        import ast\n        return {'grid': ast.literal_eval(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.largestIsland(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.076",
            "memory": 6952,
            "stderr": null,
            "token": "b2781ed3-7c47-4645-bbe7-0905182117c8",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 855,
        "title": "count-unique-characters-of-all-substrings-of-a-given-string",
        "token": "3594a47a-9a54-489a-b541-066adcc9837f",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def uniqueLetterString(self, s: str) -> int:\n        index = {}\n        for i, c in enumerate(s):\n            if c not in index:\n                index[c] = [-1, -1]\n            index[c][0], index[c][1] = i, index[c][0]\n\n        ans = 0\n        for c in index:\n            ans += (index[c][0] - index[c][1]) * (len(s) - index[c][0])\n\n        return ans\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(1, 10 ** 5)\n        s = ''.join(random.choices('ABCDEFGHIJKLMNOPQRSTUVWXYZ', k=length))\n        return {'s': s}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['s']\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.uniqueLetterString(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Input {'s': 'XLYLVHEDKPUZCXKOCLYYITEOLJNWEUJRLUCVNVRIVQMUKZQZVCKYXBGZIWAPEZFGNDBJXLCGLDLAYPLUUAWEVKOJTLUGPGSBENUZMDFGNAQNVXRMCZCPARBXFOKBCUMJWKPURGORGGBVSIVOIDIAYPKFROHUUBBRDIBOOTHCZQCFNXGBIGNGMMCHMCOTNZTPJIIBZEPUEFCGKKNLYPKSROZXGPDXZEYRHEGCHPFNMBOFZRLAUGVDCYIZLTUUFYJQSCWNLEWWABAFYEGHAEWEKKJRHFGKFJRMBAMALDMWAWKNCQPJPXUGCWGNHSDPFKDUDBQBPNRQDBKLJNZBQDNHQHFNOWRBKAGHHJDTCQCSNRYBSJFTZZIAJPHVXLGJVHFXSPDYQMZVOCOFLMOONOATXIMFCGHRYMCUMTSZFQBMIITNQEGQAUJZJOYGXCGFOWRGNBFCHLQOSIKWQBZAQQQPUIIENRZSGNVIVDGVSEWXJNKXQBNACDNACTESBLUSWYAECQQOWAKXRORCFJIPIQXLMAROKHCCWUEQEQKKMYZDRGIWUEPXSGLIWLHSKCEKDLUDIUGEVEANAQJBHZBBBTAJNCVFGFWWTYUYWORVDPZHTKUKPCRHLTSLXCSZOAETZGBPSEFVHWVIOAVTFUZNZKZPKMRYETMAWDIPAOQODUKLLAJJXURCUZUIAKKTODCWDQIMHAYGUEWGTUYWTEUSJXDMTSRAXMBLDIUOBVEDQKYQQVHUEVHWMXNZBSILRXEDWHBJPEQRWEHRWKOKHQISUOURUWITWFLCGTBLJUDFWQDIVZSAJJVPGGIRLZBNULUDXUVGWWKFVZKTJAGWQDUVHSDEEURKIZWLRXZEGUODVCMPUSVITQQINGUBGEIVHMEGNXTZLKXMFMTNIAYSLRXOXQHWBLSBVWZWIKGRORQWXTZASFKUKFLHXNXLTHAWMNYLFCTWMWVFZKAWOGTDLJRHCDVZMNBKJFHJKWWMRSMYDZEKHDNJCJSWKMHBRXOIAWBKNVHCQLVJSLZPTQOMFVYMCSCFKQCKXMRPFQHJKIEBOUKHURIROPCOPIOXOTEVPWWVQBKGNUXSQALCGPDQEUTBMLVQALSABDEAWPDSFNWPLXFKQKOTXXXOEHELULHYYDOEHYTRDVWVZPRWXJTWMUWDGFQGVKCULHUSBEXCZQFHVEWVTRBWFOZUEQNKLRIZZRYFNKHOSOMOWYSVXMIUMTUUVSKXBVUPMCCHPILRLWPNCVFPTSNTCBNYSRKXIYPROBDECFQXILSNDRBUFPWNQJDMJIKRUJZVCROQPEBDMHJOCKNOSCUGQOZKJUURDZOQAHKOILQAUNXJOCYVMNBVVPCMIGBLCCTAMSAIMLOOMYNYYEIVMVHABVWXMKVMHJSHXZGCXDBQTUGFPQHASAJKYRDZBUZLLBJRDNASHYUFKHNVEOFROWVRRQELTIAWAIQEYYXMIKNWCFATLHCYXDNYYKXHPNMSPZFZOMOFNABZSMMGFYRPVVTGOIQMLDOYFCPTNXLCBAWFODMSELOBCBYDEPJZNOHIDRHLUOYUNUZPXKJSRVOOSYFCOSQAVNTVGISZXPNZKFMCVEJIRZNHFIZZLPVIZONJUBUIPLGCYSYLJBBRATSWSSZYFHWBBCUYLNGQUGBGIZVVWHAQLUTUJVIERXNTHCNNDYOMXJFOZATAFWOLMEGKOWFVVHKKFSZWFSXFLBQBHCUDRZIODOGNLFTXXFEJIFXOCDHFZNYRJEPVLEBEUITENPJEOHLAWNMYDVVRQQTXDGXUAWWOUNRKWUPNMNSPHYQRIZLJUHSLEMOKHAMELZKPWFDIPTSIOEPDWIZCCHODFIEFSHIGTNSYCNTTTWSDQOYHKFVAWUWQUMQCBKLXRENKASAKOUWXWOJZYDZXIBTQUYEJUAHMWCIBTRIJWLJGBBFEPCRSXWVUFPGLSHJRIEUHWWGNJXSCTAEQMTTLUXOCDQCTBZZNSVJJAGDRXWWEISHFRAURDXRVSYZWOLFPNIJXWVUKZANFLXLTVTNNRQRNTYYPWOYTFXMFEGKFQBOZNYOBULSGINHSSCXHIPXDAEXWTOXWUNOZMVIURJSCBIYTMWPUJDJFPDUMUKGUVTQFXAXWZOKUNISXRKSBIQODTWZTTANFZXXOJRHFBWOBOGUYMQOTXERNGEUYPKHYOEPGYQVBGUZIHCSFGNDSSDFUNRLLMNRRYFDDXZLPGZGFWXXMZXTHJRCLCGKWJRIIBWLYOVMOOFDAEAYFRXXUKZNYTLQZWTPZVXOEFKJWDVBQZDUAVEJUTXOMSORRMNWYYESPOUTPOFPWSNFNMCZWNQKRPJVAUJHOORNSKVMPGRPQUNXEOPWCOOLBFYCGEYHWVCAHHVZDJMCAQMUNTGGFXVWKYQMXJTRAPVZPFRKVDBMKJQAJOULBSOEYDIWCOTQXDWHBDUJORZGZOPHESPDPIXPRHDQCQEVYASOEAWKOJPOKVAMQXQUCFZTOFWDLKHCEIVOEBNVTCCYSBVCBAUUAMAUSYPMOTINAHITBHIKTCXNQTXGCHTSZHFYKWTZQINSSGUHBFYNKBYDLZOCDDQLTEFUQNVHWHVLGXVSFPRIQXFXPLVSQVZOGDWCZEMXKNVUEVTRIWSGFFGNEVWCWTJHDALQSCMJTVKVSFIOLDARDOMFLPHAJSYFKHUOZTPZOVZCCQOISPXWSZNNPHPWFDABANOIMVKFQZKLJWLREIDFYAJQVOTHPSIGYGKCQISBNJDEFBXSIFQQZDPCMRAEFCAWUZRXNPSRABFSUFLDBXMXSADNTUPLLMCMSEIOPDSRDYTWGLTQXPWNIRXFUHVGFUYDZXZHLTKHOMAUQZKVDCWANXLBAUXUVUWITDOMYAABQABLYZMHNZJFIOFOMAFWTCCSHHRGTSOAEUCFCPQDQWEDHGZKGPFCWQAOJEEYIEPRVRFJZTDQLADLKBGRWEWCEIRVJYUTIQKHPPCNRLKLDFMWARACZVVUORHNFOKBQCVTVKFLFCYOVFCDQYEWALEPBUIPPJAPVDFUFNJQXWELWVKBDPIRUMTYQDELPQGTRZQRUDPFANHYWKFANTDRDBFWJONOOKUCIODCVQWILEZXOKJPCTLLBHNFSZIQMLZCRSYNHPLDFPSIMOBGXRLENJICJQTOUKLFGVOSHQXLHTSUWPWKZKWQCUVJAGYICXBFDGUKVBQYODWEFMDMKFDNVPBAGTXNXRIHPMKUREEIIAAASIALVMNRWONSZWTRORBCFGREYCDTUDZSQPFPITIISQAGJJEWWPMJUXECJZSNMLGPKUDPPIYDHDSQIFUHKMFQYOEMBUHLCIDHSAGDDGFWZMWAJGCWEBHJEPDRZTJIHBLBLUPXIKHFOOFAXKJGPYQXEWIYQAOAWGDTMSHEEZXTIMLPWZYOZGDYJYEHTDHUBOTXMSXPJAGSRAHMBPUBSKPHIXXQDDEKEXMZLGWCOVTOLIIKUSUXMKPDJBSNFBJFEWBCIUYAFGOPILEWTHTHZUDOOGNBPXJFFTPHPEGICVWHFZXJDDLLIHPALEPKAVAFWEQTHZXVWFZLPBMCHEIFDKTBHWXUONOYTTQWGCFHOMHNSMXXXVUENNCJPBLTNYQWXVPPDNQBYHCNGDJNLYAVPGNFOLHHXGQSQSAAKAMZJOUAADNAWPMDZLDZDXPDHEOLLTCQLVQOCNIASNVYNFFQPSCOKNMWMIAZDAEPJCNAGVNKMALGOIGBZXWEKJOOATWVJCAKOPIFUKUYWSRNMBIOZNVQHYOJBTKEDEOMKTJJWVBFTWYBDPPWZMEFMNTZNETIJQGJKOIKRHYYMDDXPWDIBOKVMRQAONDKELMLGIKBNSCSZTCDNEYICIGRDRAYEJBNXTLIHQVNUUKXXDDGDZJISIOSNGCAFTWGNNBRTRHAXDQXBOWLADKZJVTEMSKBJRGFQKQBYGNNAHJCDHJQYLGZWCXHTSUZUYVZIJRYQWOSSTDPZVTVJCGHMPXBJRRVGMIJDHDJWSZBLNHGOYWVXRFAYHVAUELZBTCXNYMDJYGHHYXEEIGHSYGPIIKFZESUZPXEVEKWRNBNEYXXRLHSCXUWAMHLFQKJJPQKYNWHTCSVRZOYAEUREFYPZGNJZZHFEFBWCHEKMSJWSMJXMEOBXBFKRYDTEKMGZEUQIVKWGFANQTFPVRYSBRVOVDAXGXLXSFOZRBGRCSRHCLBITXDSQPUIWBLSKIWZPQDXXHFEIMPHBLKEGZNJULMNHAJCGUJBZYCSWOHDGAJEYABDKEIWPPRZYLJDFSDYJGMCZBAUXTKOQAYSZSSRPAYUCNJEVZNXSWQVNIPOMFKQSWSIXTQNBCFWXKXJYHZUSIAJWJPHWMNXLSIDXGIXPESETLHHBKPMKSBZDPYWZTZJUBCUEBOHWBWVWWOIZXJDAVGHRCQSYQYYWGRACFRXVRWOGAGTQBOIIWSLNVHDMDEAFDEQUSWYBFFASGGIVYFFMBGMSKBIFQAZVAKXYJHZVZRLLAPFRLMSUKOUZLSWRUSBYCNNRZJBHDGOMRSGZCHEEAKDYAXPLUEEXBPGSBFZDKPOVBJVWAEKWLHPUTQSYBNNKLXLVNUESFMKUMZMKWQNCUOXMHTMEEBEIRXRQSUHNFIPJUMMYXLQVNPUTMTRKEMSDWFAIBBECLBSIAKPGYFLQRIOZFGCLZWVJOQOFXFBGROUEKWHNSUQBSLLEYMBYNKCOTWRPRUJYAODWKHDIRBOOFPGVYAZFNNWBWMMWXPLZZJRMTVEKNHHHSLRDPGZMXHFHXOLYEPSQQCBYVWMNXZQTOAMSMVXMZZFHAKOIYTODXLWPOVDSKUDILAYHUTDZZWKGOWRJVWCDYWKFXWUEGIROOOSNBQQSMDQMYJNDFYFGTLIIHQOAHBJJCYTRZDLICMQZNQAHUMILNAMKTZSMPNQPZITAJHNSSGAWTXCQGOUTKMFRQXQEPVDHGNZMANAQNBUXNEYWLWDKCPWOODXEQYHUAEWOBQOLJGPPGRTKXYVSZNEBMKXEHUTRCSTHXNDBCHCEBKLQBIXCHLCICENGSSHUZVDLPEXTCGTGWSPDWGSRSSNMTBFOGTSAQZAVBCMLFZCWADBAVZXGYGVSNUQAFFKAXVZDJPXKIFQNCLQZCZLXZQTPTMREMTSGLBBYVLAKESUEUGTMFLLCSXBLMALWJVBYBXREIFUSUYLKRTFFRHTADGNSOTVGNYGDRWGEOPAOOFEYMCLWWHUVGQFQGIWZFULRAERHZSHRMYDVMJIEACGVGYKRIAMKPFYCDUIGHTJDRFGQAWEMDCEPSXUJQWFPYAIVUGBFDSMUKUAQAKHQNUUPLIPYZZJEPIEENXTPGJODPLHCZNDLBBYSTIFFQBVIHFIVCWFWNFAFBQMHEMKYFQWPUPCUGVVGXWNAFLILKKSMPIJCCQAZAXVYDWAISWFSPBRLLLMXFAFDOIZDWKKOQTGYCRTCDRDUKZIFSRDCVGNPLDYMCLLDKMSYAYCFRPPYBOHIPQZUXHOLZHDKSGDXBCEPUOQAYIBNGDXLWNQDUYETTNVHLMXCOWBLXMZJIHKXSWVTLBGDKPUVFMRXIEMSFYYYEHEVMGZFQHCKXMTKVEHHXUUONNJXMCNGZXWEYFXJLJPFVRJNFNLZPDAHILTJNDBMLCNAFALRXVMJPBPSFUPZOATSMXNVWAKZRSAIIYUJRGSCINEOTWBYJKXFDBCOJKVXHHMUAUGKPNJKLOTJDZIIRAWDTJHLODYBCPSULBPQOTCEQCDVFKGDUSATQQZPZYCYDSFMSBTSKCZLVTVBZFXSBKPFRWPTBKWKHQBLGMOVQBLNBTPOXGQFRSYLPNOUHLWWSLZRIFEWXOTDKPTOKUPEISHAJWENWCDNUKEIJTWWWTALGDVXJCXJKUMJGQIPADSJGEUXUKTQXDMTYFGAMFKLETZJVSEOKYEKDKRKNAPEWYUSXZGVDGUUKVYQKHZPLJSOTNIHXTEMKCCEPEIYTQFOFXLMDFDSJXSPVSQEOCAEYYTXFUXJINZFXIJENNHCKBLJRFEMKZVCBWIERKFRNBABYGRWPCHUOJRXZNWDZHPYPTFCXSIWMLONCJQFKISBBSAGVYTZXKBVSJMNIBRYBYIYSODDBXWWVGRPBSVFCEQYFOEZSDZXKOUBVOIQUVIATYVXEEBMWLBISGEPXRHPMMUWDVBMWMRXRAHRNUZQEARRGUJKYJTLDYQSCFAMDIPIDWUGYSNOHZJDUEVEUFPYQVETEIZROUWORABGNWNVROVNLBDDFYTWKBNXYUUCOJTNEDUWDBPJGDLZMOUWSVGZDAYGLVQWWFCHHDHLQYNZFGZAOYYVTUPVARCHLALEODKSMXQWXFSPLMPBFLXNGYASKDAZRYZVQRBUNXWEUWIKAKSAETYKNHVJXRCLLTRJBJFBWYGPPIRPTUMLFXCCZEYYHCRFEDYMEKQMWJUWWEFMTEXQQCODIDBYRBIWLNRIIKFANEAQUIJLFLOHVMMXJOOXDYXGACFXTJRRJSVQSDDHPTEAKORBNELIVSSRGQGGFRJDISDYFMRWJQSEIQVYCFTFDETACSSLBBYJLXANWSTOOKLYPQFEZGCVVESWJTFFIFOCFTFWUNJDFJKXRORQROGFGEUCAJLDDLWZQDGQDQZFUZQXFJTDAKQCIMEZROEHZMXTDHUOHGTCEPEVFIACYSVNQMZOZJYOQBOZGLCFNSPYXDNHKURRXKGOMMWCQQQTWFPZYYNALKYEAYMDJPNWMYVHORWQXSBWMNHAIVOXWHGDQMUAUEHWRPVTLSAZMSVCONYHFRJHGGOZFXPPINNDQBZJYLUBIQZTPTKIJFDSNMVLTBFJJGVREXYXOUZXRJEHMZRDBOMXZPUOSAOMRTTCVCCALBSKJCCJVCEQMACOIYEXVEKLVPEQHBRCXJBOXYSJQLAIBZLUWAWYGXYABGSQIWIYPRDYRSDPKZZBFEGTVRNAZLNCQVNFMEJXJTBVYOXCHPZWVYAWRVACJERSWOAECGDRUGHRHGBHBWFACRRJELSIUECLUGELJTWJQBVIHJUWQVOWSRVZRLBMQGUDGADHRHLYCAHRTOJTGIDSPTYBCKMVFOYNJBKUBAFOIGYUWWBGVPNVAZNJHSRBYLJDZADMLWXANPBIAEQLWPIVOXSGSTUOKWOBMKRPBPBSLVMIOADEOEJUPSHEEODSOFFXTMUQDTFETHSKCUNCYTFDQIHBETJZPQSPZIYVKZKYQXKJOXGLUTCGLSDLTXNFIBJULHTBYECEUMDAAMBCSJQIXIGNOBJYDJXZSAQJKRBCHDHVUYVIUSEIUCCSDYXIOSPYWKOROBLBLMGXAVROSUXNZMFBBYJATCLGZZSQEWOONJTOWVNZLHIPDQRIUICURWUUIKOHNQYSPBQLISMPAZEXTBQGYCJHHSZWIYDRPZCJPHHWNIVMTYAOGDTAAMDYPVHNKDFECDXTMWYBBWZLUSXLOSHMMSNOFZJDYGBWTRDEANBOUUCVXJYENGGLEPSDJWOERPTGSEASSWHTSTAQWYXXESPVOBCZZBDJSELZKOAJKEVLNUEISSETKCJNKOPJEUMBTDRGDOPXJSXFFCSQJQQOSPCIWWKLYTHHIPAIXCGENKKTAWWIHXZMKJIAWJTFSUJBKJFUJZSJWBSPXHAPTDBAOKMXISXJCOIJGRYJIZNQAFKCLFXVXFWNXHORMURSVGQNIRSKCQMJKAYMFTZXVSZYRBZAHUNMCLSVTLGTZOPUEMBHXBBTRNNSRMYLULGJPXVYSSXQYHXPQDPBPSEQBRJLGRDTTFXPUXUDFMJZFGHAZGJCIKQRZUEQXVETACXGJSFSNDFWEHTXMLCOKWFCYWHBLGARTVWLSXUJHMUHYDGWIOHRJDRFMLJGEAIKAXZBBFATFAVEOKNETPLZJPPBOPTUJWVKIJTWZPATAEIMMRWCUTDGTUQJJQAGHDCFXAJRSDMPNFABQCLJILZDEQZLGINYXSFTWQLUQCAFNHPLAQIBPOUBINNTPOHLTPYKCPJXJHELHJEFGSKXZQGTQCUTGJHGGCSBPQCYLKMGPIFGLYCTMJBSXUQZDVPAUKJBEGYJJDQCYGXSVCOMSEANTIIHQRFBBQSFUXPAJIRYPEHRFEOHABMLKFUCITURKXPBOFGJWIYKQGXQKOTDJKTXNMEHCBAYMEZOJCSKZCDIXTVHBGTSBSPRCKLHUYKCGZXDWSFSSCUQTHJNQUCOETEBDVDGHLXSQDXGAVRFSEERNOVGTNRHOAOWKEYSJDZXFTCZBYEPIWSVAOBLZYTCOHVXDXIODLZDWZUOKZBXQIOEAMCBGWERIMEHFYFTKVERAKCHASGGFYOYABSLDTTCJXFTPWMMGRRJXBPTSSYQSJAUFNMZGUDODSPUWWREXDLGFVCGSYUVRLLHLJHTBNAGLJJTJSCYOHDHDXDRURNUZHKDKFNHXQNNKVGZLKKVXMIKITDQTXCOSPMWQCPOLBXKZAEXURVRZMRVDGHGMCTKTPWHJFZFEQPYIOESYYFYMHVJEZOLYRFGRPVBMLDVJWKVHWRVQZIEGZRAOEABIKPRYTBTGIYMGXNLWKXIINABSPCXIJJVJMFCVYBHRTXIMTNKGCIFVHDSAHPOYLXXMAYNCJKYKDONOHWUTFAQJBDVINDSCGVKGLJZMZIVVRSCLCVWZONOTDBELIJLITYNZGBMWPFOXOCOGLMCBCKJFZEZNZHPERAODOONRFSLZUPSPLPVGKWKBPNBRGXUVCWUFRCFZSJWJSDUFODKOZSGDONHZLHJGYKQZNLXIGUOEPXABLAYIMVGQFGJQSRYMVBRONNQINJMGCJLVYVIDZHUGOQPLASQIZXPEOXUZYEOQPEQTNEHKMRIVOTOZUYENNKACCNWRMKTSDQORREWMOVXSCCZFWULIYAGMWNADASCQEXTLLUEAZMIKCCKISZMNJBKYKRHNCWLNLRIRFQSZRXAIOPDTWMNNWKZMRXYHTYJNLKPHIHBZRQAUULCYFRHCDEXYTFDDEDAOIYCMMAMCLTSTMPOPECZMGHVHXBSGIECXKHGSHTRYIXVQDAJVSFQLFZTTILMBEHMYQLSOYQLGGEMRRSYLNAUHSAUUURNAOQHGRPFOGNQXGRQBFXAUXEANYMRCSZZOVAYCYOWMLODVVUOUONKHSLKNGLDUQVBEVHGXRNZICNIBUDGMEIDQBPNLWTUWZIZJCVUNCDOPLVTSJYTABNJQMPZQTUFYCXSHMALBBMHFFLGZKOQNSMMASEUDTQNHNRKMGHKOCJMPQJFWQTZGUPXJJFMWPZHPPHFEXRWKGDZJITYJIVSQGUKBECCWIZZPPHDPVZRYIOYIFMCSWCDKWDSHTEWQYXXGEWSLWYBVJRSGVZDUZYLOOLLKSJJWEVVAJUPHQZJTZVHZVWPKXGHGKDPXCVYGTQLZCKCYOITFEXSQIJVHTQQXDXCPZJUWYEMHBTYBQLNCPUKPRVTGSLGOZODXWCIUDKPGGFOIUQEVLCJZDSRXJQIBVLDVVQSPIOHUKDPTJOVSYZLTJVNMCLZUYGYTYGSFJJOQLKUYSTSVZWBSYQPYVGGVBPTJDCUZYFSGVKMXVZFHTIILWOIYAEOFGNAKFQAYYIWKXMPRQUUOUMUBKURKMBQAJIZQHJIATXGUIJHWAZUWSCFXGNYYTGIZYHGGKWCIHVVJLRFCRNIKQJKLZSJXWYNENIWCZOPHDZDLVOQPXAVPCEUTVADRLSXCIPJKGXEYGXZGOHZPILWUKZSMGIERJADABIWNNAUZHVGHSELGJLPIWKOSHEXZSJZYUKJRMDMDPAQQANPJRQVGEZNUNLSYKLTWAIAEJSYUQKJAMPYPBGYJVXZHGBOBGKQJLZLTTDWLGGSTRWBNETDOMRGGRCDEPZIZXCAWYMDQDQZFMSCLCRXHMNTQVQDEJLFLEJONAUKWGFTUBKKZAWZKWMCRKZGBBVNEMHVXLKQGKHHMUKJYUSFSBNOVWRYHYVUEHGVURYGXZGQDZDYVADOJBQWFAOVUTLBJJLOBVGRBUYKTIQHQZXQELUNJVGKIATFBFHAUMVOCKZCSLIAFKZUQZYRCTOQHCSMDQXHPLCRZHLUTDTYINRVTXNYCAAFAWKZJLQNPICQFIOLGRAFNUWKTNBJINCOSSETBNVENDILTTPJUOORVVEFOMFPUVEVDRGEKCTDPWNNBSQJOKDZSSWLHNQMUOBDUMTYULVERCAWCMZXQFPUTTDDOGLJECJGGQJYMRZFLAFGWFSVEEQTEYAWYSXRSGBREMNCKYEJMAHQGELHEOZCLAJRDUBUEYWYMHKBEIPMURZBEMUCHRXZHMTAPSYPBNNRSMCCXUQAVXWXUNKGXEOHBDKOTQXIUKHOTCGYXDRVJBJRJIHEASZANXYRBRFCYFIIRZQFNWXPDUXEEAHNKCGGUZZPEMZKGYECAJXZRBPLRIBXEBBKETZQSGTULBECDRMPHTLWOZBXDOHZNWGOZFIRVGQWVXHEEPZXEWFXPPBUDKJYJMXSUOEASFDKMTAYUJGOXGSVDUPRWTDHGTFNSZUVJLVDKHKNXLZMNKPTEEXMIQWQZGHODWLTTUKYRXTENGNHWXWIHNVIMPACBYTRJXCXRHHULLCEDDDNIPJNCFZNWBHEXYMHHUEWEOUDRMKJRRYBAHWWSBTZRTYZJWYCSDNDOVMEEPURJGQEUSKLBVXKIFBPPMYKFRZQZUJBKPFYVUTVGWHKOHPDMGZGHJYACCTARMXGCYLRQKAUSQPXVBXDYTCWWHOOVEWAUKOCZOPNCVDBWYILQNLEIPZTKJJKIXNXHUDLAOLHTOGPLISHRXWLJJVPLMGDAQNXPQEHIJALAGTTMMAZKIAOPZUFAVFVRWQTNMCKHJYWBARPSCYFOVYKWSSHGTSSPKCMTEQBSRVFZDWBUDFDSMXZPNFPXMXCIRGMMCRUEIKOZKRQZVJPGYKMRIOFFOMIWIQCKUMJTTCDGXHPFUXOMWLPBQFMLCJCPGRMKXUZEGODIVFNHRXVYBCTUNDIAHMPLXREJCELZMMXNIBYSYUPNGXOYHBJJQNNZIBOKRGMJWCQOASMRHTNRVQHDBGENMMWMRMYNPROMQFULXXGCDNQDVFVGYJHEECBJTMUWGPMAFOWFDXZCUVZJKONQIZMVMYTBARQWSLYPQZZXNTKKKVQFUPYFFPRAUPYNTNGKMEEOHGBLXPGKWXWLCACPSXSOFTXJOPCUUYQOOODMRIKLSPEGDBZILZOTBTAYUJITZZBULZAOXBVJQROAYWXVIOKWHNHCKITKDCNAZHHCUSRLBTBNLIJCGCBDWXVHGRUBLOAEAQFTHMRXYUPFYBLGYWOZYMXNIKPPKKVMUWJINHIUQUZDBIQGKUDSFDZRRABYUSBWZMWYTPKYJXWTTAPWHMRDNBDOFJKUFVGXTSBUWZYECPWWYYTVDWQLWDFDEGNWOVUSPPRJRZJTPVSFKHUTUIZVYVNJCZRSCYWKWYJLIEDWTOWXIZDHPAHZSDGKSRSNGGFJIUKZWMJUUHJYIKVBPTMKEVMSKUSQJKNTQHZBJZVFLDANCGSGFTZKDSOACSWYGDVNCLJYKMLHFSWNSPGGMZUEWDERAZQGOGRSILTAHCYFZNQKTIRXCFCBLJGFQQXTZQWLFAHHSAECVIAMTYSAYVBFVSCQPSURNBUVJXPNRWCSBSROWKMLTTFHMKITGRCBYEZLBUGPVCPHECJQIDDTHRNMRJIPJDZOAKVKGBSTHNQFURWZLNVPGKHPYUZBGGHBPHPJRLURLCIXQDHSEBHSEEELVPDHTEXZWPGSRNOSGIUAUGVWUEOLYWOGIIFKCPYYVETVJDBXSUDZWXSIBWXURGLFSDAULPHAMZBAYOLHXDOBSNYWGABHTTUCXGPYNIGVAOABNQUTQNCEXNSTANACWFZUBPGBXHLWJDHUGLTLMRNQELGKVNQPAAGXOLDUNKDCXPDACFWTESVPIWFPFFMXXZGISLBXYHZTCWGLJRXLDGNIQIDGMEHXVUKWTLPQYPOQUGZTSSSYLFYXBFYIJRGXPCWERCQEERGNAZLHZOIBGPSRCUGDENAHRITQBJZCWTFULUVBETJHEPNKRSJTGSRWXSAVUYJIJSEXCDJLJIQKULUCEJOAFNEVQMXWAGYEVOPHEPGSUWWIKLAMEWIXVKOMGGTJOGDJMEAMDRYRETPEYTWLNLTZBANOTMOTXLBAPKHAHGIYNBKTWODSADMZALZOXZAVYJOTKUIDTLATJENTGPUNPIHIFOMXQBZNGEVBQDJQPGPNCEEOSPCOBEJRLCJOROYUJCSDEFCZYBPUSUCLNPSFNVWOSRJTUTCELNCXHEPUPVBKHZJXLYOZKZNGWHFOUPZNVYBITNBIJCYSPWYRQDWPUEIDQYWYMUIIAAEUWEMECCXYTQXOFYLLCWBGZHNHDBFTCURPQBZPXVYAWURBOFUVNGEIRBLHDQDPCVKCJZBKTYSGDFZGWEPLZCPPMZICZWLAQMHMKXMNJKQOBCRLSKVHQPXDOPVUQHEMZEWUXVXMJBXGXPGGLNWDDYVWIQRRAGMUPSVZMKALVXPSJVZNLMCZSOZYTBRVXTLDPDZBPEVLEJLDXOJRXNISRNAMUXFGMBLSWOTEJUDWFLNTFHZBCAMGOOJWHRVSDTBOPCENJIBXFWBJTRBAEDJTBRRZMGCLLWYABMNZYOMBGIGSSLEYICIDTJBHORNHEOYELWQACDZVFDMZAYVZRTJAGLMEXVGFHQYLXAJTLQBEGHKCEYYMWNUIYAEBCGWALQKZVWNPOIOQVHBQJTQBTPCCUHCIOEPNUJFDFTUKQQOTHSFCJDVSBOCJETFUOVQCWMSGWWVPHXPNAPIKBCOJBPDJINGMWBQRTNWJXLKRVOLVUFDSZDMITWUMBZTCJKSXJHFTVPHTMOCNRBADPZBCJEIVOAMCORFEOJIQUJAHZGSVMILJVYBPVNDKTAMORFAGNPFECRTJREIRZNIHYESZFBILKMXJMWYPMNXWEDJISUOLMKCOWAKDOCZEAPFYXEGKMLUAEXGJDNIDDMBWYRUNMQBTEYOWCZGAHRPZQNJJZOPISKSPXRYHTMIZKOEXERKNUSDJZLIOFRNYFVIKBOZWGXMNPVDYPYWHOICSJVNXWTIZKLETAOLKQLJROZGYPLSVBLTKMFROBVEKUKHTSACQZHIKZRONZSHSPNEIFOJGDEJJKQWCLJMORZVULXTCGAEVAZYEJNZTDYPZNMAKRMDLXMNAQXTYQILUBYMIXZMFECUHFNDRGBHWYEHAHBDWSRHYKCERUZJJTQDADXBCKXIEEYDJKNNEPXKYLPYIKYYQHBSVBHLXQIXRQKYUIAXTCNRHXTMIZRTNWJTDZWMDRCIMGMSVNDWAACNEVWKHKGLTGADPWFVOYLCZGDFULYFUAOPMZNNSQLFEWQTPCKCHRHGBOBXKAQSFUGKGJOFLPYBVNZWNFSDXNLUIRUXNULORBQIORNRHJYFQQVYOBBWWXALVECFKKWPIDQDEMOCOZXUUPKDCHLBERHLDAYUCNJFAQHFTHBBJQKFIURBKRFDRSOBOWWSKLDROVWIFUFTHWTCADFAEYERCFBHCMXKLMGAEJDZFXQNFHKUNXKAGYJPHNFEHWUPTJMCFBIZXUZHOBEOSKCZVXSQHJNGAIYOSULTZSTKMIHDNFHHQLHUIEXGPNCEOLGLEOCUMUPJRSXVFTZFKZEMODOJVRGGEGWBCADPAFBPERKBSTIASLPFJZTDMFJNKHPQWJFMJSMHRAFLGWNJDVIBKCYHOUWWFMJLQQUZURXXPLKMEQAJKRWTFMGCBRPCJYPEULSGELKWEFLALKBZNAJCWFCYJAUDCKYXZDUPHJFJGZKTKUDRFWEDWMSILTUDWLEZCQYQIQVMQEEUOHDIGCXGYDVBNGLKXNQWTDRUVRYDFWXJRHSFMYYQUFCNILYKLZBEDENEZHANHCWHUEKMBOCDUBGTAEPDHGEJCKEVKRXFGHMOAEFKTRCXHOCARPLDQRGJUIYDKLRYRRGPGRKSBJDQEBXIIBNAVYYRMQQSFLRVOIHKLNDPYKZXRUPZNCPLUZCHSCPXPMXVTIFZBMMBYEYKWPLQLYDPSHAPMRQPJRKLDPSNCIPYSXRKSCTYITFGQSRNYRHLMCXYSPZELVHWVCRDNSKYPRZJIJQDZCMDWHKLLQGDICCRFRTMMCWCLUSWEXNDTFDRWDLLWEHWIISLAPIGYOFJTYAJORWZHSHYBPITLUIPHWOEEEQPKVSEGVCFHRGFFFOCRIUJVUKDDLYVGZMWILHMXOMVBCBQMXFELOSMYQQDMZYPEAHXYEPQXCAIJHNETGTMBZYYYYFVTSSIBHZGFHMOLUVARIISOXFVTRIJWELPXBTBPLGIOEURMTROUFPJSAOURAZCKVAYOTLBZTLAFAYJCLWLOQMEZCZSKXTBPWZZWEPDMPTTRIQYBYQVYJRGKILGLIIFYPTRCJRYYJBRAXUZQTUZRHERNAHIGTWASLJUWCDZLXYUPXJIRLTFVSKDMPGKDHWGZVCFSJIHMHGABGUQYIPCLTUPRNAGAPGFEFKMGFNSCVFSNBNMKYPIHDJCWYOIOTYBBZOYOMEOSRPBZSPLRDAFZQBKINDMMSVRFDMGNDKTGFEXDUQVKOPFBPTONZGHUJCANXPVRAXDKPQEPQABOLNMIMKDZKOMGMOXDNMDVRXLXJLDWFAVOQGVIABHGUJSMZTKRLCXIQZYNUACHQLBFFSWFPYQAOKRSRKQRKPRJHFRFKVYTKMVAUXMOYTLFHLXFSZLKXTFOPZDTWEGUNBSAQGIYMNHDYBHGAHHUFBGPBDHZWHOMQTPAVJVQEVSCOTISEJRDTKEGMHYIEREDIIVXUIIFFBMKRHBEEYUFFVIHNIMIOMVCVZUIEEZVWYQPUGNHHXKISMRLJBHZIEAMHMGYXNJFEWJZTFBTYCRCBXAINPKBVLIEMNHUHBZDCFSMTPFXYLOLXFPIHMOLVPPCOEAEARQRMXSPYRFKIZIUVURZVKVKJVSXPMBCGODUWFYJNBGMILPNDMKBBJOOFSXQEHZBZZYNWEAIHLMXJMTGNKJLUBIHBFNIVKVPGYUZNIVZOAWAAMPBIWBHESKVTEGPKLDQYAYJWRDSEPYTIJORLBCTTTHWHAJFAYYDUVSCNELQQSHMISWPCHDDHRUAGVEWJFHNFOPFMBEZKGCZKNOHLYFEFEWCCGHRWQQJHCNVFIPZOJIVTAPRCJZROSGKDNKJUPEEOGQQQYIDUEKKYCVOUBJRCJZXAWEPKUNTZQGLZMIBSOENKSQVYURKMPDNQOHUHCOFJNIHZFOFOMZAUFGFIKLVKKVFWPKSGVNMUAOQZBFKTJGBSSNYIYMACMONXNKDGVBEPDQHOCGDUFFCBNLRGSAJYRXLFGWHGHZUXRHEKUWMCBCCVLAWHRXUMOXNHFVNBITKOQOUMITUBTMLRIGSUBQUYRJGGKKIVJCETSSBQSBIHVSIGOJEUECBQDPMEUCGBPMEOSEPCMACLQNJMFRJYKJFSOWUCQRBXYJTKBKHHWFQTDVSDOZXONOYBBWESKVMCWLZMSDIKDHBKNMMPRFLINZPDFKNJIAKSQSXVIJZLTHUTYNKZLXMUTGSOXDXKYFJKHGICCIWHAIWQXFSEUZFIWKSMNOGDQPZPGQSBOOIRBVKBQGSYIFMODJZGCACLYGIPQWOHWUPSYLHEGWQYJAEZABZQLBTUEHEMBXOZQHFSMGVFBCYDRIMAXOAPFUARENCDAOILCDIXDDEAYZCLWCOHGJSOZDZNZRFNYXKFNWKPOOZBLAXZJWXRKZQVQFKMNFMGFIVCVHRLPBWLSRQDLMAUUXACCNXPPJFDXPJZYBIGUUZFQWZHTFWFECCLZYWEYXJTDTBTDOAUKFFOVKJXFJDBXDPUECIGUCXUSMMBUUUIGJZQNTGRHKSPNBTMJDFLWMLYOXBLLBBASVFQHGCLBJYEVLJNDTFDGPKNPPKNTHFWYGIJYPRTSPOMMMBDWCWRGDRFAAQCKOTKRNNZAJUQYZSAQKWYEIJZPFXMBDEDKJQQPNYAHRHSFEHEDLNUTRBVXKEJTYDUHEFEWUXHMSLCZYNDMHKMWHYHKHUTKXAWGCVLZOGJNCLRJRJGZKQFTXVGGNDFCGVCTTFCSNTTVMQOYTOPPTHJIGZUANAYPOGRHGEEQTGYZGSNYLUHGSLMGEUQBDRKKIHIHQLOYOGSSUKJCSYVMXKZVXTWPTLFLRXIBLQFRDVGDXKLNCCMHPVEUTNJUKWLFBVLVBKWFTTPEGPSJAMMIGPNHMQGBIYNXOTNDIFQYRYSXOXCQMIWGUEFNXGJHPGXXFADNCWVFJDNVYLZGZBRMSXBGUFJKOIFEYSUFBFTYGTPVVMPKBKCJJKXVCDNQOTNATZWZUGEGXBZKTXRCQOBVECKOOUIPPGEEZXBFGHZSOIGAYAUJCNGMFMMQTYVKJMOSDLCUGWIJCRKXIPOZFDHWAONIYIRJBRDWUZEAWCJQCRJQZRKGPROAGPMIQDQYPNGFSFCTKOPPGAMTAGVUOUSETPHQWARSWXXGSXLHUORLVFCLUSJLRWPMYYIHEWLAQVQGRMLVUALUEYXFJESYPMVUKZTNHRYTNLLBYATTQXXVACNXRKTLVAUBUHRKNONDJESSOOFLVKKXWNMXYPPXKGUNWCSTQNQXOLRGQCPKRYFTKAYBGDHQHSTPAIIZIUNSNEKGQTWHYBTMKOZWHMQWDFLKXORYIKXYRRDWGBJOJQRYZLPMKIVERRNUSTTBWDIQWLQUTBFRKPHIRFEZPZRHKQDVVFECXXACIZCICXJJFUJPSZKTGVSYCFOYOKJCSAHLYXGJSRKPATQWFABJNNGGCXHHGHSQZSVOQGKUNVXSHOZCDLBMSVHUEROCIZEBLEXHJPWMVPYNOIAFUESZLBXVXYJDONZZNQACNPJRITJZSFQHAXVAYQBFIYNWCAAFZVPGNNGVZUEKGFESDZANVINQOLSFIVYEWKDQDKYNSRPBHMYOPSAPUSFAPCONPDKBQSNMPRQIZSUNERGTUJTIEPGLXBQBQIURJXVGFGAFXGYZCFAVCSRFFLENSGXBFAMXIYLULTQBBOFJGIAQTIXRGCMFTUPZYYGTSULRLFUOEVWTYKLUDFJLJDRTXNOOPAJJRSOQWUSRVTZPCLBUMGQUQKYBNUIKBBGCRLBQZBWKWTHMFZDCLMKUJSRULYZJVBTYFQCUSIOLRCIDKRTFRNKHHPCFFQMLMHDFSOXJZWJOBPDHWUEZONKRUNUMECDXDUWDWQTFDKAVHELOJJTUULINQZHJRDUNKCAFMBWBQXQKCOUCOTSBUSIRIYWFBVYRBNSAIGUWUVZKGQSWGFXCMSEEFRVOBLQTLWDQFMDJVYQIDZHUALNMKLCNCNHGWSIMZWQCPCHOHZPVTDPFFVOQKQYYAUIKOFCIOAEGEGHDDASDPILHXRZBADIBODSKHMWJWUQRSOHHESFDUDCTLITCDLLFBKIVYIKBESEOYNULFLJGXHKGKVVARRQNYZFVRLNUHNSHHHLNVREICZZZONWCUYYPEWQZKRLZZIATQGOKAKPMJXBVLGFPZQGCZALNETPGXQUOLBQTRNJEVZBNFTQCPNXHXGYIYCBHWCONEHDDYOPYNVSYLNPACPEWFXEFELZMWEOPKMYPOQUSUSEOUTLXVNAALILJKIYAXOUMDSMUSVAXMKVWMDWKOPRVRDDRUYZPKCRCAEIBVZBNNVJOSPQHLIZGFAEEXTQWILTPPGDRTXPTDIPAKJPPDXPLFYZZAXEAUJKSUTNRSCXMFPMQFQLTIMOBFCURQANWBZHJIABUMFFOCNDTNBZMRHLOZHHFMYLIMLLHMISUJNUZIJEWPHDCQTYXVYWUQHHUPHILLZWWLZACGRSVOVHNDMLPJXFOHMUXROMORQULBVHZTORLQPVBUQCXGXNAOCOHZXUJONHYYNENWEEBUZRHWJGRRVDMZNBWXWVHAMGVITPAIOOAACFEIGDOSSUWYOJXDDPATFIPNGYCIUDQUVQAELHVQJJGSKHNAHMXMJOTHTKBAOUAQZMHHKDVFOENFPFHDUWLOEWRPBYCOZRLAXLNSDXWJKFHSXLYEQBTWJXMQPESAVDNGMOBLKAJYMFVSZIEXTCUGOIFZFDYXYVTDSJYIXYAPFIRXGLREROXOSLJFTDIPECXRHTLZZYGMBYPNZGFZZPVSRVXZBJAUYMRZTWDRQEOTFHLQWJDMQSWMSJZOUHUNMNBXCNCCVERPHFSKGBKLQWQBEKIPGPPBNNUZLOBIWOAHNYKDKIUEVODKIOTLSJBBTFCCAPRXYWCFUBIOFAQLXHCGHDYLWXXKGUFODQYQBETHDYTAOARHNBGOIZMCVDUNOPKLUUIYMWFFVAHGKQXSKPWPUAZHKFAIUSAMTFWGBENTGEJIXHWFOEFKMMDBFUVRJFYHCNWKCNMNRUVRAYGUPPVUOGNYVLPDSMPFGORUSQFECHVNIGOJIWNWMCSMXMSZZWWRLUMOEBPNXKOQLKYYIOAXNCOZPHKQSHOHDNAWSJBBQZAXIPIINSIEYBMZBQARZXHKEIJWJFRVFMDFFYIPVMBQAGSZTHDIPLLYHFJPNQYFIWKPBEJJFAHVYUZYVHYERWOXBWENJBZTJUYDHXMFGKDWPSGXXBSGFGKGAJREXVQAOXSMUNWMRXBLXNVKOCJLXSPVGBLWYDMVHQYMFYDBCKIGWBEDDOQZXNMTUVQWYUYMNUTNGDVAHRXOQDCTKBLWDOUPNLTPHSOJZEIAIEFDJBRQMSRPYMPTDFMWWACFYVGKZCCYUCOTYZLNNMSQXLWJKIEKKIXVIYYSLCXLQSDYWVIHTFAPBXJHAFFIIDGTENDHBWHJKQWSDOMUQCDAWAGDSMSNAXZFGWIHGEMDXPGYJDMAULYKHSAYFZJYOGMJHCRVUFJBNIKQEGTMDXXZIGETEEQTPVCBCCAARYSBQTPCBAGNUPMOQJBVNOUHBFSQLHMOJFOJALEVUTUWTPNAYUUIITKXTHJTSWBRFQWJHJBRXVFPOZKJBUANWAIQUNRFHMDLFXRMIKADKZQBLRFOCPLXLCTIBTDIGAVHFEXPUNMUTTLIJIIYSUNKQCWWATSCXMTGJJIKJVEITBXXIFVJBJWNAPSGRWXMGNPOWFNYSRDGBMUABMESVANYJMHTPKNFZPQAGXTMZLIPCIMKPVIVNVBBWWNTVXEBGDZBQHTJEHSQYAQZTOFTNFVPMRHJECVDBDHIALPDTBYKEAKREFUWDFGQKXGSJPJUDGMHVMECEITGNNHYDJGRIZDOYVMRODBXGVRMRHJYVQXZROMXGFBXIPUBPJTQPSRDNCTHFGFBPTAWKJXVHBPZAFATMSBTGSRTKDMEDSMEQJAEEKQCQQWHPZJRMREWMDTVCIMRETMJXMROSNQTXIEDSLDQUSAEBLLREYGLBOHKKDKDVMUEGQGSCWIKYVQTMHXAZAEPTUXCAKRXOJRHTSFYFJTURPUUSIVJHRGIGREVXIYHRHBMCCYEUNPPRYMKATGODZTVMJWRMXRUFWQLTZGWFJRLHSFAAJEAQOKKWWYRQVNDTIOSMMDXHAIIVMZKIGRYSSCCXSMCYCAEMULBDLMVDSWZLPTDXHKQHJDVVMKMMGJVQPSVIVMZRXRHWRXJRGZBPWAZCSUDHNLXTIRRSXCGWQACDWPUIBOAZTNPIPVVFZDGBSAZITTTFTZFYQKZPYEVSEJNGMVEBUVTVJHUHRDTHYIZICDZELDYQKXUHKBQIIJZCLTDTNDBLODYTEDSUXCGTXZLVXBCKUFJJHYPFSGYPJHJJRVVPIVQFRWRQAQXONRWRRERQBAOLLOMIFOZHTXXCSHMJVWAEIYXZAPKDQPVJZTYZSIIARJSBYSMXPUDKFSMDLKWQXRLFNYXFTBVOZXSIJVHCXUHYUTVCIJSNZITACCQAPTPTSDBSKVUQROTFGAZIDZTLVHWUAZNHJYDGHXHGVXLPNHLCIGMMKRTIRUWWCFAYMZYFCAFIOEJOPXEPYJMGUQJHWAFQZGYDJGRBCTVHIKEOMQSRBELZPOLRNRLHXXYJMQVEYAPKJQCYILQEFNRQKDRDLFOIFCDUNAZXHYTEDKKYOYNNYXAXYJPUPYOMDYRDKFYDKFKUKIHETZXINTOFKMKASHECGNNWBJZFXNKWIVZBDDDAPJZSWGWVEQSKWPSEDCFQTDZAWJIZVPCUOJQRJNJEMCGFCZFPTQHTQQIYZYBKJEZKPMTUSASKPVUWXMFPCHIXONJSQDUZIBIGSPHOOUVVGOPZAZDQJWDTNCXMAQNABZWFPOGCNQYITUSRQCJICBVCTNLQSHTFVBOBGWTMCOKKZUHPHJUAQZLRUXDHQNRNVWBTINFEIXMFJTTZJNKXYVTPUACQQTWWLGFNNCUVKULLDEXXDSTDWOBGOZABOZVWFOPYVZGSJCSEUTHSLGCGWEYXUXHXRBXVLFPUQXKMMPZUONPQDUMXGLGLBIZZAHQECPKQPSZOHJNIFPZMDWYXWMVPPFHGGJZRKKFAWQLNOGLOVVNMBMFIDDLRANYBPGDTEIKFGJKZMXQILAUZHOJTUOCKTMFGEKNWGZGHYLJKPYRJEBHGOLOBNEYUYNZJPAMAVYKZKUEYYBIJBJRVVJPYIVWSXPMIBLEZQOHQVHUCUINYQGLEZEYEVTVMSUSGKVHCOPTFKKBZALDIAJBTZVCXLLBJJEMZPHKYSTILITEBNBENCRLKZBBHZKQIFNMMNYSXKAEOUCZXERHUAWJOJIASXQVRAZHJICRWIEZHXOIPLCAOADYHMJWAGDMEXAEGCQDHIELOXLWNTUWDOLFVNVNXGTEXZGPKRDTFPHXRWMXBPLMVESFPKQMGNYTZFCXYZZEENEGMLBUADDFATUUSHYQANWOOOICSELAUNGPDVIYIXBGNWXQJIHLUGODQQHZWAMTHONPPIKJDYTCIPHFASLZQKZRWJSEZXOLXLOCVEQEFHDXZHFNBHICERCTQLWGIMREFSAPPKIHCWKWTEYDHFWSTOOVHUAASPIODIHLVUGYPVGYONHYHKAXKNZFZCZXDEPMPJMOMNVEPFXLMIBMIUJISNBPTXDRLIHVZXCSXUMOLCNCELZJAWHVANCGUXTDGEYGZXKTPGXTBOHVQKDKUTRWKGPGZBBPKBVKNYPRUHPLVZPBLUECAETRLHUCRNZKFDNZXMEIFXJAFSLYWNMEEQWFCQHVTFAVJSMVEHNHEBCQAEVDUNOIDFMNZXHXHMRHHPXTLTRQEKLDOWTGTFMNDRUTGSOTYLLGJGJAMIYMRAWYIYOZGEVUYDBPYKRBFYUNWZZCZQGUTQQOXDZLFGJABRFNHXCULJEAOKWYWLKJFJAZLBUXNEPMUFTGEQWRLMRFIHGMIRMBHKTPFGULVXFUFPAVJAIEGHXGLBYDFNMISBFWUKPUWGUZQNOUCFCVCKQMRUTOECSTZAFAMNAUVDJDKKYEXQNFCMPAFSJHNFNPSSIQVHLRNTYQYPKHAMYWKIFNLAGMSBIFLEYFOUOBAJKOYPKUFTCAXXNJLSCXTDLISIISKJNXXORTJLXKMTBVOOYZVXQHJGNFGTWBNUMFBVSTEBDJGNSKAXAZULRLSJIWXNICEIMPMGOYEHDCJKDPXOKSYSMPLJDREVBFOZKUBHQTENFPXXRBLPDPXQVZRMUQBVHQYDDMJKYYULENFIONBUUBMIBDQDTHYRZGDJXNEESNPPXIRQHRDBWTZZAKXGFQUIKNVFRYRIVRRSKYCXZVIYOJWBMSHWQJBOFISZSXBGPPYKQBZGFVDFFRYNOFVWVSUFLPBEGNURBTGICKXGZPGZJDQKWRFAKWLGLBBECDLIAUAFRJZZCFXOZNBYFEWLODREKTOYIWENPCTIYMZCGQRDANTQNNZCMNNQNAYZYVOPUAUZXEJBWRNLBVHKEXBFLHEAQPOWXQJZLDVHGYBEKUCKVMYQFQXGYOVVWNIFGXQUVYSCWAQPKEBGOFZYKYBCUWHECCHZMHPSVYJEJGPZERXAHIEEWYTKLRVXTNQTZLYZBVNURFSCNKHUNAEONECQDGJCUKDYTHLWZKONLAEHVZFVWOLWIRFAESANREKHFSMWUNVVFEZNBCURRBFDHZIYHQWMDXTEBIFABFQSBGUIVLZHNNWDOHXAMJIGEEXCDWMYPYFMACDPCBYLCADISMZWGYAJCKELCBQFXFWKCEWEJXGJRCNNJDPHTSZTQLXHOTTLYNFTIKAVNWMXKDQOWOAZDXOIHYAXSCJEMBHYPIYUAIKMIKAJVJQAQVIMAEVJMFEQLLCYYDXOEKWDYPUARZQVWTPZOVZUPJIBJSDOPAKAORKLMRFLCSUWOXOHPIIAFFYMXGBWCDBRECTYNYROLQDSKNEPOTANVOAWSLHANOGABRHJZBAJCFJIFORTLERCMLKNRZABHFFVYGWSUCBDUUGZIBUJTRLIFPASPGCVRQIWZNAGEDHHLMJRQOHGHZKOAWRXYDYEKVHEHPIKTRZCOXEQOPWTRMNEDFSFDBYFJHNNNQAJWMOICAOJMMADZPMNBYUSTAJBKUZMEUHGGQWMTNBTZTWUGBOMXLCZWSLUYNGMHGFNWXAFLIAMBGTYGHXKMXIWSABVVFWDLOVEFALUTJCDYMJFJWUSTZJMJXVELXLHXRWYPFQWCVHLUMAPVTGNOQQTEMEJPWGSXKTFMXDDTCUQMEJKQPHGOXPLVHOPRYPMIZMAKLINFBDMDUPHGTGVUEWNYCZRUYOLDQKMCWMZNGKEEYYACRCHSKDTVWLWLXUVONIIYVCQVADGRYJLQEHLKISMZYOCRCMSIGCKMNYZFSHJOCWFJBABLVOGNLLVMYAMPOECFUJVGYZMWGVJFBSVUWKMENMBMXNASSZKKOVELHOEQYRMTSCWGCMVPIIARLOZWTGEDIGESZNELNNTBORNPYWRHHNXZOBSVSKFHPCIBKHJYVVOBCVECRGYEGXQVCBJKBOVQDXKBZPHHWJOQGGFKNCYGQRDSXBHVQVRFYUWYGROQIOJLWSAUWXTQQNANPREBEFKMQBRNFEDRITJCAZZHJNTXJLMCGFZPTCYAWCMJAVQQYPVGYCNOCFSAZJSTZOOKAGEMLBTTSCNPOUTDSMDDBXNFLBHQOLXTLIMNTCQYQLEWGNIWGDPCTNXEHMNRKQLZHHVZPWSXIFBPDOMXMUQRFGJGODPAZTFNELBIPKMAIHZFJTSGSCOXIBRAUJGFRDASYMIZCGOAHOAAYBHOUGJEALMFWBOPCEQKBPGEMGOIIXPQQFYUEVPKTSUHMXFECAOLSKMQHKDGWEJPKBYYPUIQXUYUZRUUGRVZUVVRJYTYWFONJHDQSQZKKGESMTPRCTTVUOVCRGPFRWUUQIZKCYXMUQBGEHITUBARLYPISJBMQSLWANYTTSFBQNMECXQKKTONHOIFHBPECUVALBJXXEELYAJRYTIBPDDBCXRRUPQPGQBDISSQKYKXEXRPQATAVPRVOTTNOHKTAQIZYDYRHROVQXKQWPUQTSZEUQNHVAIUAUOXLMPGMANAAZVEVMZZMTSBIOMVGKSXFYKLYYLDDJFKXCHEKPLWWNJCWYQTIOGTRDNPWQWYTFBMIYERVXJLUQAWYEIQGMKFHRNJQCDJCCBHPXWJXBYXORTFOZLQHBJGNKDMTSAPRSWMBHJQSINBMGWYYSQTJJXSHRUUTLLNCTXWHNVBPSYUSQXXPMOUESLFKYMOUPEYINCJPOYSZSFHPBJPWGCSFYOUVRIOUGKVFXGHTUKZKJLQPQLITAQRSTDMOXXXGPZZJFYIJJUDDLLUJXDKODOBNFSAKUOTNCSJIMFGAXRWPAUSPORADEBPLDOPSYVADAFHOFOAXXSEHWBLNJEGYNGPIXIGUZETDCVKLREQUASDHGDGKKVXSEPVSFDRIUVVHDSAIQKRRDNHBTCIQBYPNCHHQNJLDELEQXHLYVUHLGJSDBLKWYTTFBNLJBNFDNEZFBNIWSXHRLYQRAMVGDSGFDNKJWEXGSQJFQPYMVHMJEHDSMFOPUBIEYGHOUWJZNLOXNYDMCYFMJXIZJHFVJSCGBPEBGNSOXIOYJSDUIJAATLWWMVWPAEAEMLQQTKPGMORXCDTGQMFUJSSLQTOYAKKBVKEPHCZSLUQLIMZLVHJPIWZEEQXVSNZPEOROHAUQTJLHKKUYOBIKPXWEMARPLDEUYWFEAFGQUCQQTPNLNWGGQRWAJZLVWDGKPJOEBIQRXBRMHTKKWFTUABSRGZFWLIDTKEBNUZQZTQXUEMKMNVBWNMASODJQMLUOPMWUIINDHFPPOURVHXRBEJRBYCLILJNKNFYZTFXJYJKSISSMJWSJHPVUNONPNBECXGBDROGPVIYTJOMVELZNCZFXYRNPUMQKHDDPIJVPZDVZJBOHUGKSMXVWFZGDHRAVCQPPHWNKIAVJXVPFTHTJRPBEFWRSMEQLCUSYERHOYXVKYSHZWSWNKEUXISQRQKUYGJVKQSCIWQSFQIZHXUUPWOQRZYCVJOCPBRRBYZETTLHVDXABQEMZQALBFPNRHATJYPEKLXTRBMWBEWOADTTNKQKRPYCOCYLZOBZPFYODQLKMFTLDGWXDZLQZKXQJWDKQFEPMNOIHDJPNSWNXAGXVRMHYSVHDEIHWXQOISWKDBQLVMKMSGNSYNHWKKWWDBAOPYZPKDVHALHVYWKBOOCWOPXSRMIJJYJVXXMHBUHPDUGLATFPXCULAGRZBJVMYLMCYPICEKDYFLNDECCQNNEFPILMKUMGOKOCEHBXOQCWSNCDASAHKQLWDKOPAMNKQZIYMEWTLUVSPQMMUNIVOZBIXAUJWOZPXWASJULWBGGGUZOEMDAMAEDZCZNRKAHRYGALZBFDZODFUTCNQGQCZWRKGRGMQLOGNKKYBCZVYAEXUXUJFHQSJYNZRXCFVRCFACDRPJRZOYKNCCFREWGZMEVVRGCZHBAVKESWRAVFZSIDTNCSNIMBVWMPOZYDGCNUJCAYJAFLCANTHGDPZKLDKLAZOLWKUZRJDHOWMXHZRSQBMXLLINEVUYBURNTSQTFYQKNJFBCJILROVIEFOWQJTOSKOQZSVWTTIARSTSVTXTMIYKJOCTGVSLJKWFLTWXTONELCQUKYOITPSCSVTSFWXPKUBWHQZZUCOZXUMIKJVCQXBVZNYEYCQKNFLWJKPZWFAOKRXIZBMGNWWADVHKGHMHVGZBZNVTPRMWNDLWFDXHKLJXIQSPSTFZZWUFXAWBQSQXEWOGXLTAJJCPZKDLKGOGMKDLUJEZGSSSSGXDYVHVKEPJZMSAYZWGYJWFBUHPRMQGSFGCIBMJWCCHLXSRJBSVXYOADCETQWLGQCCALIJKRRCADUDUXKUSKJUXCWQAZAQHWBKMHMUWPIWJJJHUYMFSBPRLLXODJDCLCIUGMYUHHLLLUCFQTZJNYUXBNJYBMHZXVOAFYPCUMWTDEQNWXTLXGFEFHQKYGZZFAMAJWOYQRIFVCTLSIQPWAKANUQNKRBIITZGWXRWVCCRFSFAPIOXGBRJYOKUKBSPWCRFIBZCZDLAZADLNUOTLTEZFQZEIEIHJORDGRCMLEAJPQDZTLJLYPTKAMHZNWLAWWERDFSNIJKRWGWTEQDSDPCUWFNKIKKYBJPVZYHIFNJORSPDDKMUVURIWAKYGIQFMHTRURDJCMNAKZKIWRMMAEEGVNPTGLCNGLGITAAQSIBMXCZEABLYMNZJHZBSUITUCAANSVNXGJUTFZUXIBYVQIEMGCHAEKBFMNRFWLJJVGUPKMELETNZHAPAKPGNCDUXQVICVZAIZOERTYGEBPFNWOEKCRJWTOJHROQHJGSVHLIHHEEAVUOAYLKMQSICHFZMXUAACHZETXMUUVIRFCKTPSENKCSHCBUMOERIECRUVYZVZBLWOLAOAUUWOVCUMYBITUXQGIIYJUBNXKGBIRGBEITZFZQCWUGQEJGDFVDWBNIDWWUXAWSJCKEGJNERVCQIHCJRSDQNJWIBKCWSAWHTCURYKDAOSBUKPHPDACJQUBSXMHILXDSCIJBSBZHVSOBCYJYCZJDDXIFKJKMBROQQWVDCNCMLWRDHCQDDHAUFQBPJCKGLYIVGVECLYZWOGBQODRXTQTVCSVVNZDBOGIUPVRJCTPICJOJQZDCUNGARLYOUEPKSWGXMYZTJOUAKKEXEGURUMDDTRIJQXBJCXIEHTNFLLJBJTCWFSQKBSUYSCQZBGGJJJUANPNNFDZPJPDTLBHMOVMRKCUZHUHDAOEZMCWRZXLOSHLHKADQBZETNLJSVQZDBMUMRFEYZZGXLOBXQBDGUAVGJIZWNVMYQTDNCRHGVPVVISQZYGCXCKCGQANWAXOQEHJPCGETVNCODFTLELRNNWZSFPXWJFFQBBYSVFQUDFUSRQJSDRNKHISUZUPZXYVVFTJJAIKJRHISFWPJPPXVNYTCITIGNYQQLVGOTMKOIPDIWEFOOGSQHRJONCHHTWOKACXXZCAHTRLNLAFLKCOOEUYCPKMRRXFATKCVJYGQNCNXLINYLPHKGIBXNUHWYSIGVRQLOLHHSNQHBXAQQUHRPJJWQICNXAAOARVOIEFQNIQOYTGZKEBYFEGLLSNVVOIMGPVOGIXPOWRGERNAUBUXQPJLRQTVRWYPIBMSCQAODRWKMROWGFAMPKZICPTQQANFIFXFNCCSHQKSVXIQQXTZABAUUZZIDGMKJPLAVOVTXYNBGUDTHECQHSRLLDOKCCDDLORISLGYZUFGAMATFAFSGPJAXKLTKIMPSYJZPKEYYEAWMSAKSRDDSFUQAVAQLLKZMCQYQGPTKZPPSAACILAAEEJNBYNBDRIVECLEKWMOSVSFFIMSTXKHWZMWDMJXYOUDULNIXOPSWUXYSNLDGNVEAESESCBHWJKKEUKLVMEPHRFWCHZNIOHCHVEGCMRFJEQCPVXWHFAETEXHTPHMSIIBFSJWUNXRDTTRLJHEKVWRBWOLLFDKVDXJTWLWIJBFXHJKNUUTBZTGOZIMUJYKTXUTITRYDJUMJINTBLOQPPPKLIZPUZTLBHARYTZDLBHHIQEHVIULDKUPTYNJWCFDVCJKOMGHDIBJBGLJTDPNUIBOOCKBOSTJXCFESIYFZJAGGFKOGJLQJSQJISLGKKCBWHOLNFYDOFYMSXTHTIBOKXAVSRKBIILGJXXPXEFYRZYVIWIJXCAWQFBSDOWLVGPIQUMUIYMLEWUSFYBMTQEZSMPDHVJSLGNYHYAACZWSMNSCXDHEPOUQEKLJZOUCGHWWVNOPZCXEPPNXVPMTUFNFNHULVGHYTEZCJNJMDAEPZGIVATCCJRLXJZOEGEGEXAGCQQGFOKNWCWVAZIDRONGISOKKASUPRQHRMXNLLVWYRQQWDCRSAXWTKFPZWQNHEVSQQETJROKWBHQBMOQKBDAHVDHVPQANBWAQKUECIJIEUFUUEFBWSBBEOWLOBWLOTRRYWCUTDBVUIGCLRKYYSUVKGYELPQMTISJVUEZSTMHUOUWCHYTLWADWMAUVKOEEXTWMZCRGIUVBUONPGGDVSQFVXUOOPJUNMEBRTBFKYTUEXFZPIMBIWZOCGYHHBUYWKAAKLTJPLOUAQALRSUEQQYOJIWVVZSOPGTOTILVPCBCFUVXIFTSOJQLZWEGZCUJNLDPJGOZKOOJPMESTSYDHXWWUVTWSEYYTWRYOQWSVZDDGETVJZZAYXKAJUKWGHHIYMAJQZYSGOBVPNFNHNNXMLJEYCPMEHQPMVLQFKEPTCLTYIQZZJUGAVCVBQIEAWWSXTCMXCVOIPEKAQGHEDBJYQKPHEZNGXGEEBXVQREEDHMGZJDYBDQVKMDCTESRDKHOYMRWDVPHJQGMOVJIQZBXOOSQSAQBGZOOKUXQYLGMDOSFAOPRVBMBRXCVNXBGOYOAZBEOGTAIJQAUCOWSNEVJYMMHHDIHEFNBIIEDOKIZBPUVEZZFMAADTAPNPQWXMKOUCOMFRVROJHHUHZHXAQWXVNFCIZZNMYFVAWCCIQPTKIHTIDXSJFOHWEGPZMLLEMYGIICJLEPTMXEOXMFESDNJGOOIXGYKFNOLYGDNMUKXZVGNQZOVBUVNGGODQMQTEFIAHXQTFDSUFRPMPWKHZVIKUTVXBOMMZTBWMUGXKDXIHFWRMHZHCKEJWKBFVOHYBMMJGHJYGQUNKZAKEHQAXUWGEMGTYBBHJEVUUWMKQOMSIAKLYWYJHCPSROXSLYWRWOLMIYWHUVDVXJJDRJPXTNGQZNGEEEHITNJGBAPUGASBAKZCKMDRONMXVRKXUFAZCXCWRIBJKIEIUVSRNUBLBSFHTNPJXVNMIEDXNONKMRKKKKCTGLQTXXZBIPLJFGWUJRGUUMZWTGWZCNQYDHQFREQTAFGOEOAXFWYSCFATLDXEVTXXBUDTHHPDKDYNQVFGLBMNUDHJCOWCKQWZBXCCOKETNYNMAASEHSSVYGIHLAFGOWCXIBXGJPVOZEJURDYPGEPLYOUFBNJSOLTWDYFVHHDXGJPIAAKIOASKBHXAMYYXQHMEDZFWLHGUOMMKIBKJCGFSHJSWHSBGVQVYWRVUWGFTVIRLQDMCAKVRGDCJRQLLKUNPHNGPSWKEAFOUEHBYKLLBTJSZUFDYEXRZSEFGWKNIORHJUWNGFCYCQGRQGSINKGKGIVKNXWKKASFODMVXRFNIITGXHEWDPNUTRBHIKCCPPZJUYLLZQFPPCLLZJKULWRRMRFYHCQFWNNAQOXVFDEBHNABAWFCCWSWAEDCQSGPCZHZGGBQQBBGEKLXJCIXADMADZHFLSRVXEDHZIJNPKNUDFTMBREZLJTZZWHWWILZQQLHCXBRYIZMJGPDMEBPFAUTMBSREPTBKDKKEZFVCXZNBAXVOYVNSQFXNPEBHLUAADITHRFVLNVWKHBRFQSBORIYWMWKKIFFBPPGAHWXANGNOPKUQUNBHBBHOLGQDNYINMAJSFAESUYJQRWZJUUYLXRUSRKIHNGDSASYBYEAJEXIGNFJCERXLDKZIIIKVIDZGUBGRUJLBFRMNGPTBCEXFDTQFWGVZYPQHMYZJTPEXUSIAFAHHLKERJXFNDILHKAFCILXNVFPZYCXYJKHGETMKEPGKOMXXPNZFJRILTFDHJCTLANWNHBFYXYZJEUIOGXVGKXJSLYEPTUBANWYFRTEIUBLCNWOUFLZHNEHKNEXXKCFMSXXVINNKLVXBFGWDKEPXQTWYITQEXAHKJKKOVXWUEPYNCCURHBVAFEPCSZNEWDBEFEOSKFENEAQSWMWHJHBRUIZQWYXYHZBCBSFBCFKOECOAATOARSUCBGNXISHOBYXTTERKJOSIFEGPXNVKVTUOUFSIFNJXRJWCYSKETNGIPEWLMBJHEQSRAXSQHBKPRUMFICQSJRVETZGFRTQRKERLYPXOVKIUNNXMSHIYSLAFECJZMHTRJPSIQSRXCYNZCHWEFQZIFHOPJUMEXCQCKHZXQLPGDBIYREKIDNIRNPWGDHCWNEMUBKEMZVRGRCBPUGHEFBKCJSFAULLRQJOHXEVTTVIKUHKNJLPYGDYUCWMXRRKCVZZYPVOBNDTUXTZPEQYAQYQDXCWIXKARRWGTKTVWPAQEWDFJBLLSITOAYSRTCVRICYMLHTHITKHSXSBHEKYNGBAUHZMBTUBGFFYPIGGPADIZIBOHDAGDYASPEESRTYPIRDBZJCRGMXQACIRZKQFVCUYTLXHSMAAVYAJJXHPOCUVHUDGOOHCKKCPCFFQCVVEKUBXLTBNHDSHRXOHLYXFPJFGAIVJXJQAEJBDSPLAJUUMMQIZOAZHHULXVIMTSHFQMNRWXUATJUJQRVPOQWLXUKRVSBXGYTVZYLGKAETCZOOLXJYSGIVCPXGIMWWVGNSLQBOHZPXGQEGXDCCPILZAWIUVQAFOCCLEEZSXVVPTVWLIFHWPVOGYTSPZYRLBHNCXLSMRDYAHEYWVPTHUPQDPUDWXANZWKUGYOWPWLFGIZWVMKNMPSVVJBSJXDBNEGUQSCLAOXOMDJUSQBJHZANUULTGMSYLHTRRYUYTWNRAALSXTVWQXQKFGUHGXGJTCCWRXUEYMZUAOACJMDMADHVJTEMFLXVEVAVBQCVFPCDPHOJVGUDCYOADQZDTRTHAOEXDDTCLCKAPRXTCVBZALMENSNWAZDRXTYJTOYBDVUNYZAAXYHMFVLBLONKECMWAHWBBYFQIPNHUUDIWUFVPCJLLSWOKLFNDGIDORURAWQAOOGKNQZQPKCDVLPCFMCFMYRYZQVUSMVFVWVEQXFVKDSLUJLHJPPJXYDZKHKSLMTIYDBEAGETJNAYHFACVPCJQKTQXKOCMDFPESLPBQDUPSZYJZODLWUAQVLBMAVTBYDPBYSUNKTCBZIYZJOLEQHFOPAOUPAEKMCVIIHPMYAJJFCNNYCBJPOGAYJZIPWJSXLWDVQQDYRNZQCXERDRZSDECWMZKPRMJJLSJADXXPGRPBJLATPAPEEHPLHAXZNUBPCLCXEPQMOVWABSCJTHGEUKGXPDCFQXLWQXMUBWECIMUCSEHBSTBBWOIVYOHFMQMBJGBMEOOURWDHQXZKYQJFDVLRBZCLDMBPYXSDWQWQLPSVAKFHZDFQGJZAWUUEXGZEUSNRSMBRLMWQKBFHLWKQMUEUWOHXLRSABSXPQCIUWYYJJEWHYKGBXDVTJWHYIYGTTIFPHJJVVNTCVZMEEXROTXFDXRPDPUIVGSGMYTNHYNLSJTNWRIQNXMTXGIXXDUYUTFUFKNUFOYXXPDBYNWWNOSODYDNBJIPAJYFYCCTUUAUXICLPZFMVZKPLAKUYPISADGUUMUEVIDQIJFGRFXNRNAZJSSMRTJNHLCOXQGODZHQSMVCKWOUBZDWHYTBRQDVWCRXDLKZCUEHXDYLMIRZSCYWPSQLQKSFBQQZITZBRFOPNARNCTLHWEPNDINSPMUKNLZWQBPKPFNOMMDUIEJGSCSZAGHIBTOOVNKAIHHYIBIWKFDCWQERGPFPJHABHHLXLTOGHEMVYBSYLWXJJEPGTKEZHHBQYHJFVUJARJLTSIKOXKXTTIWQRQNUXMIVXRXZKGUGJVVXZCAALFCVIHOFGRDXRPRTFYYFIDNKVWRRYAFUKEXGLMXASFPQHUZLSCKKDBVXGDCTGNGNGJOAYLJDHIPSSQUSGSEERDTIKDKQCHVSJOAEPLVAUZGCALFFZLUEDPYXUCYQFQOBQVXMTZBSHJPQFXHVFWRSNZFTDSBAJRIALMFUWUKEFJEZGXXMXEPLJVZEOJMXDNDUTQZWMIGSOUKQGLMEEVHMWNYCLAKBDVSXZXMJAJEDLBYBJQSBJKVVVEEQHWKUFTLFPYLQGXZSAWQQLKGUMGJFPVQZBXMNFZLRBGGMIDHPKLGRWDJGDRGZTBKFIKGZSOUBEVYRYUSKEJYQQAKRNUVSXCMFRCFKDLBNDXQNQPFKUDFRUFBNOMOGONZPAAMLTTLACCEHSGTONCGWURZFXJPBQEJLARWLNJMOLGCIFFRZPHOFTUHSKJUMBEWQXXTRSLSWRHBHYDASFMCWNRUSOMFLYRLFCUVSKAAIJLSJUHULTVGZKDGWYHAKTYMGKDDWSTKVMACKVBYZOLURUVRGUMXAUQYSUKJEFIWDKNQITUTUWBOMVPFFHYELMGDIDVUSTGWKYXNGPNDWIQMWDASLAPEKRGHOFROJELZTRYPXEWXDHWAUMAYTTUUANWRMFARJWIYEHAKODNDYAPSEHHRRUURRPDHMNBEBAKOYDHUOJSUOWHWLIZDPAEIMBKTEIMXCVCCRWCFJFYHBXDCCLIRPHSJDBHHGXEQNCPRHZXCKYIFVXMNFKUZMWUXUKANCKDJQZINSFCJLTPSSSTMGDXKTAZTODNONHUQHBTYQGMMWEWCVIDKAXKZLFMZMQHEASAWNLJSMRIWCCXVZVGSZUCTPLYIGQLVXPFWWXWEKAWPLURISNWAZZNUQKLPFHVTKKHRBDKDFRWOIDJQXUHNNTTWMIUZPCQALPPZHZNUAESOVESBIXOHDXCAOVCMAAOMZFTCMGNBCXDMNTJKXGCBBMZNDNVPOVWNTAVTZIKHUQGMPATEKCFOEGDHGPGMRHQQSQWPADCNRVLWJCBHMUVVQJZQSTNNQNDLLLGKIFCZUBDTSJXDDJJOJBKZAFMVOVLWOTYNWMMYRAEGIAVCCGARGZJEIDJFDNHNYPITCVJMAYNGXFMJLIXCHRXCABZQMYLHMHPGSUTRTOKPPUJSLCNEKFXZRFFQIRNWLAROKYGHHOABTRCPPKUMSGONEVLPITTBNLTDHOFNHCSMLOOTBYAZYTZTVUCLTBSNKHGLJJQCBEPWWQGCEIRIAGWUAHWBGWKHBGCXULTNITZTKVGKOQZVFZPVULBQDEUVBGTZCHOVFHIGYKOBBOXHELIZJORHGOKIZSNKUTVSQMFQWGHGTBGFSELAIWYBMEYMTPFLXNYYOVFJMSWENYCETKHSQGOFJZCRHAFGSAIFANJBVJTZMAIAZBUHXWGSBMWLWJLQBKBNYFRWGLBGXAHEMJAAAZAZLMDNXIPVXTWFDXDANMHCEVVTCSGGVPVWFMSEUYZKYHSQRJOVLKTIDTMXERLWNYSJQHFTPFZULAZTAWLFMYFMITXELKVVOODBWAPYJZQNQWJTGYOXKWLKPKAUKWNARGTFTOHARMINJZXBNWPWKXUIRVCNVFGODSMZQOKODWXXIAHXICRBEKXNOXBKLQWXLXOYHYJQJVGGAMFSIUGOTIPKUXFHBRBKRBRZEGDZFCYWHFHVFCGQYOOKAVTRRSTMXCCTEASIJOTCTYPIKXYKCVKXBZBTEGIMIYPZKMRPWSNBCAMDTTTWJHIYMVMLGJDUQMHDWVOWTGOCAJLVSOMNGINAVAQFUOLLZAMKXRWGAAPXMMEWENRLSHIQHKFESPCNUYZDMRNCKFSLCJUQUHKFYEFSMYQCPHKHCGDRIZFIFSEJUMWBSKPQTPGLYGFVPVNMFGEQRQBUAUOQNJNQHCDNOKFBEQUFIZBDVVVWRQMLKFCUURVNAXWTNMXXFZMUDPFQFTOBJCFJVSWSLEOJEBOITCPJGAJPYSKOGOVIMWNOAHGJKTUMTXWZOXZBBNNQQWTAUKQLUAJTJMKJNDUKTXAHSUIZDEMQFLIZDAZHNNPEJNYYIJXMSFXMVYLITMKUXKWQDSXLYNDLODIGKJEQRHTUPKFZVUDGIOMMKXCGPEQFDNWGAHMOSWBTTXKZOBQHVXUIOWIXXNPYVOPTIXFZIRYIKFANNTIKPZBNZHNYNACJQMHPUAXOJIZIORUBOLPPMPOOCAZGPXGQIPQYBMJPHMCKKLRTADENDHXGEMESRVITPULRPHIPIJGYMFSDHHCABLNHMGFAMVLMGWQZLEFBQQCZUMGPUCBSFYGGZJXZWHEYSTVBZINUEGYGZOENZTUGXRNWMFTFXPJQGNZEOEWOYIIMJMWHVFQOKOROTNAVJUWFTQBZRJOCPHUSTPYHGFCSYTKFZCWIQPXDZCCJZHHZEFHTVUSUJBGWKVVAGVNOBONAMANFTUHUNFOEJAGSHLYHELGBKNIPZLVZHDZLZGVENWOLSFQQOCZWNQRWSSGSMCWPWTTOKMCALZEHGWLDOGXBDTRWEAMJKSDMVXIIHCEJSKWMANXXOMECLKQUFRBAOYIIKFNFQCZSVDZIULWBHCJYOMYFEHWHDBRJYYGCCYALHUVJHRSKVYUICBTAJWZMGNDOEIEPWSFLYOERXNAMREAIBEKDUEBRFLRADSQYKPGGRINSJVLPJUFCHTRITWVPEZSBSSBDHGOSBXSRCABMSFWCYESEPFWHNUYNZVDHRNHOJSTIGSONHVCFVSFOGTBHCTIPPEJRTGXXRTGTJKDQMBEQKUKIXOHRBFSRVDLAIXHJAOSNYXCKJIWSTPTFUNVFPKBOHCCHVUYTMLHDKEPDHBNCEBOGUGASTLSIJHBDIEMQCUYMKIYVZUMSOSFFVYFBYKKETLEBMXTBIZSFTBADBIORPPTWICLZIEQDMCZLYXCJAGDRLQCBAMFQFFQUKMAMHDWIHARZFOPCPTYLAGEKVOUJGFXCEGOVJZXJCFRBQTNJGYQKKFRPFBNUPWHDEGBYSWRIYBIOEYMNFGMRQXCMHPJRLQIIUXFZURBKJAOETZBKMZFCUTZGNCNPYYGLWLCJGOMUMFDVAYJSNGISCEQCFUXRPZDEWMMIYWZKYUIJAUFWELVZVBLKUBZVMLVSGENELQOUDXGCJQTPMVPOWEETXOMXNOHUORTHBNGAGBWDZNQGCLQIAZOQDCASBGISPPGYCWWMKUWQZUAYMJDLJOWUPDQFZEXAWKFFQQXUINRKIAUBUJKYBXGZGEUXTFAGKGNXWKWXSNAEKVACWONHPTONJMUMVETBEQJRKJPKMOMEZHSJRZTWGVCWFZWEUEVWIGQUPIESMQTBTYOORCYCBUPTNSWSIZRQABBRXRAEDUPDHCPFLJLBSMUUPIANLRYELDNWSTFTXSGQXCZWHBEQXUJLLKTJLXHPDJMCPCZIAVLHPGSWAXNQBHKDQFCJISWJUUEAHGTCQBPXUWZBNCDZKHJAKLVDBKYTWLLMJXMWGOEQKDBLATDUHVRZXEFAPUBALOKHPRUCCGJCBLPUKBBEQCYLMLFMHUFKLVFVSHDGCFGJVKVAYIFEZCXZAUWEASIDRTMUVTBHYQGUWZEOVBVFLMMVMYFBQXODEOVXCTRXJHYYMWFJNSNAGGULFNAHTCPXHNQAKHZYELIAOGJCHQXRORQJMZAWPZFQSEMEIELAWLZCOUVKGLDRSIUWZQZLHTTJDQGYCBQGIQSBQTCMOPCOSGSURIMQMFHEIMDVNOVTXFCOEBNTIPAHLKBRJOPBDTEQSMMURFNVMSBKACNEVNCUSWLYBBLUFLMQCRELWLNDUMLBLNMBHULYLGBCJHKNEBKQBFQEURDYZPIOBBFGMYLDYEQUSXULOSTZPDKMMNZZLWZDUWAHMXLVPIIJDZGGPFZCRBKBSQDRTPJNRGDJYILHGDQVVGRPUOUIAHUODOAWIDTVDYFFVBDYFOMOGMCKAZLHILRQTKNJBKFXFBZQVLXSUUTRRJYVXKGGWFAJDJSEFWGAXRHWUEQULWNZINONPCECPEUHWLGZMTJEBPFSBPHCCTJOHPVRUYBLIOTASFLSQDMGZTVTEDTVXRPNRATCEWGZVXEBGWMKIKLUVZOJKZEXLSPWZBZTEDTJYBVFNKARPHPVEIECKGOBZGOKKZALSAJGEFLOYMJEVLSXREJBQSMDSMNAUYNEZZWUSIKKVAVMFKOXACUTGJZWXYXBOWYTIYGDZVNPDVMQNPAOMYAMBSUUWVSMHIFJNGPBQSYGESZDTEWKPFVYXMBYZPLUHAWICKVYGBJJBRKVMNBTXDCSINIISECFTJSCZKVAKAVMWYNEAXLIOFXPYPBHEIQUCRPSIDWKKEEDOCMNCBKJWUGKXZASNLEUYBVRDKJOBCPTFPBWZNMKDSUVPNVUKKMUFENNCKJSTISESUIAPEXOELGRKGNKOVZXWYSJISSHLVBILKWXLJTSAOHWAKAHORBHLUEMTAFZGRWSCSLZXWRPGZRXUPELQAHFGWWOPZPLEPDUDRTOPAJZRLFMYJCJWETQKKYCHEUQQIEKHRCFQSSJTPNIVUTKBGSLGBZMQUWDGJCRBSWBJVEIWXNZQZXNSNZESRBKMICIJBDCNDZGKZEKWFRSZRNEMIHJRLVGAYIANNCWVHSBZMTQUMIVAJVYIANDJAHCQTZSJDCSVLIIAYKFVRWRYCBKRBHICSRZJCPFRVZDFXSUQBOENSGOFJDNUQTGVGBKDYJQRVXOQGOTUNMQDKCTZNMFRCRAECSTCHSLKOEGXWLTQVQRVULUXQULTNXTFENGIDRQHUXQZUSXMGTYJKTXAVRXKNDUKZRJMJDUVLAKDHURZVGDNADHPQUWCETYKTAETWTWCJPUKGJHEOQINFBWRCHKPBMDMXIDTMTXDAUSWUVZZZZDVWKYDTBVKVBCWFDRNDRAWCKRZKQTZFPXPJEHVWAUPXCZXBOECAWKYULTUFBPVRTRZFVIUANPBLTZUEKCFYKTHMYDZAAJYQKCYPFQNYGSTMASBHKRVTTVKSHNKKMFLZRPCWSNKDWSTIZUWTJOMWMDVPOJEWGIGTALGPNWIOSVNQWOVAPDNMWVFBPTESFUJPYGYAWPZCIFNEVHJTJVNAFYKMDLWYAXZOAXIMREQIBILGAUITTHBBTQOWCHYLJMSNRAFIKNYBLOIMIJBAQYCSLRYKWJDATZFHTFHSZUFIWAXXVUXVRTERAXQRZPOGNWWNQYTNBNIAVZTUECPIBSTZPXBECNUVEANGYLVVBJBQCRHIFCRBMZYCLRWDGBDDUFIRUEPSWSIWVHGXFAJVSDVMAEWISFHTRQSQOXARUPAYUWZUPYCAWRRORFEPUXTFGHWQVCPGTDVPKXFCLJNOHKUBWTLMHJTRIRSVJQXLMDDMFCYNEVDOSZBDWROOZQOBTFKRMJPHEQVBACQLCLZJANHTSKEBOIVUKXBUIGSWEQNSDFYLXEPQRSZSXOVFEIXTYSJJMGIIMCFUGDDRKBUHUWUJRGLKKZYZCFXPKXVAAIBLJHUPNUSFGRUGALGMJOYITDLNBYIBPYKUTFVLYVPXMKMIBYIREVHQJBVLFFMTTFZGQOPJOLPFYADFABDMSWVTUJPFKDADPBQAJJBMRNECYFMPEYZKPDXBOUDEWETCLUKZNRHWPTGFBTVHLJZIKXTISIEDKUYJREVPJADALRANIPQHYURSDKDVKSTTBEJLGKVEZXBTVOZCLYYUQAANXERTABIWQMDIQFBCQUDACMQSCSULUYXURBKAIWLCILLABZUGKTDDSKZRLUIBELYAXNNDDITFLONJSPFKBCSMRVTOKPWOTGUWRHPTLMUFJDLKKZVDEPIJCUAYEYEXOOZJCFVOZFLELZLPDBQFGFSMOZLCXUBELYVJWYBVOZTHVZLXDKWXKNAUVILXQOQVITASWVCSRDXRNAWWHPSZYXPZOZLUCAMJBGZLWLZMDVAFIQPBEHRMZGPKMYLGZGHDFTXPDYMNVSMLOEATOIHVOSDANENBNBMXOJWQROVZJUJALHSRVIHHVYOQLGRHPXHZFFNVYPPCUVLYMNUCIQZZLAFCJRPYKWWIAUEYWNVIAYOEXHMAPYNMDMKMTHFYUIHBJWHHWYYFOAJFVCLBGOTDMWMKZEZYVVIGHCNEAQZBTNGYCKGDVXEFPSMYSECWMIMCITGATQWTVXIAMLRRBKWPMDXMNHIEMAGANJHTLBWVGRSFXMYEAEODYASZNVUMJGHDGKDPDLWQYEPFDXZHYJBUYHIBCUQKKEUNXNPBMWGLPRELRXSELYUYABRSCGJXZTZMVKTCXASWQZMBLBOBOTWTSKIINDTLPWJWGMGJSCUECEHRZCXLQMRZJNQTOEFMVDWOQXZWNTOYKILYDSPGNVIFEXYJSSOANTLIJLTDGQKEPOHOAYCCYXDJROKRAQJAIZMHUODCBTQWVDNZYJLHYUCLWXIOVZQGKGEOFHLHPWWLJUYFFKLDVEVFDPJRVNSVXRYSOFQZSOJANLAMROGGDYAQURHZFABLTEKVLIROPWNJQVFLDGIOTHNNGIEUWZROYEKWHYBFZQFFDNTDCOGDHPUVHOJFDTCBFODWWGBBLZUNPFSGHLANGQCIXCHURSWRVNTHGBMPTFPTRNQFUBMCGPTKAJKRZXKJTMVQJFQNSWMBXRCIZKNQEEZTBIQTUMPFJMGANCLVBADGJVLSNWUJFJAQSEOOGBDWPVNNADAORUXLEURPPLDCTLGRJRRZJGVSKQCVNVNLQMKVPHHTSKAWEPZKMVLQQEWALYNBYGZXROUMKLCDSSSPRDSCHNOHFVHTOQKOVNZMGZESTICKJWHWVTCLDASYYQLGZEDASUDDULMKRDRVQIKQQLXCBPAYBBHEXKDPFUUQDJLHIRLPTUJIRYBGZZEUEBKQKKTBBNCXJFJOYNBIDAHNEXPVRUWHJILFBLDNPMQWTZYTWEOSFCDGWZWPYXOMJMCXWAMOOHXIKRILYNTIYMHFWUQTIGGNXCQTAYPDFKLSZAILLXZPVSMBCSDWDMHZKHOAAKOVQPQDAILTHCKCNBKZVDYOJUIZNDNZRYVDYJOOQXWHVGVCGIVBGOGOKGINITFEUSWHOZNOGIPGZSHVFHJQZHQUSZFVUEUCHTDMPIMNKUXTTNVDFMUXYKKTCGGMJUQDMCIURYXYHANJOZPEIDMDQKTFXLRHGPJNRMPHTAZGXHFTYQYAHOKHPLLQRGPJBUHIACLMCYEDUUVPLWTRPILRZQKRCHFXJGFQWDMXJSUENJQCLFIXUNZNWHACMXTZHIAUYEIQHQXNPJOYGQBHWSXKUCVQRSWJRESILPGJVSDBQYARDSHGQIAZKUYIPZXANDKNTJTHLJTWWGMOHIZASKQTOIYHXFWDVGYOZGXVFQMIDFSATBSOAYMDNKIOPJTUHAFFKVMUGHMOCSIADKTCHFMVVTFGGGLZGLBNBDRNDMAPAQJFVNPHWLZHPOSAUWXOWGTZJBGDXFOHUTTDIRGPCGUHQMZZELTUUWTJVRENCCLOBUFJDMMTWWSCSIDIRNJWECVZOEZOQTWNSNPSVJRVQYSTJUDLQOQHKLSBMEXZAZPMYONNCXFTGXRMUFJMESXFQWEVZMTRYCWVLCRSFJOSXXLNDRXXJOGOAEWRGSWUYVQCBKYMYVTRQPYSUVKTAJESFQGTUSBIOVVNAGCIEQNVJJEZSVWGNEAJPHAHDPZIFRGQUAOLVAWRRCGQMPUVRBRCZLSTDTBLIDSRIXFGXOKYOHOOABBFXUCPQVXFWCFCDFKAGVAJZWVWPQAGQYSODSQZDSAJSVKXZOLOMWJKSEOOQGQQXCDNDUAVWNUJIINXSPDGGWPPIAXEKKAEZBSXOHVTIFZBVOWJNFKNURVWHNBKNFAUWHNFAHZTEGOHIFJAVWHGUIKYNUDAYIIHURPPGGHUGCKWRMIPFRFVICQYBJMUYXCAJWJMZTQZGAKWFSDITJRHNCLRNRHCDBVIEETMMABSFSSOXKITJKEGJSHUZFBSEWYJLRUCKUPFYVVSKXEJZJDZZXNWXQOFYBPISEFLFWMSKYHYZQHXCFCLXEDYEJBPYFIBHWQNXEWSQPUGMEXBVZIKVXMSJYYIEFDBBQOUEJNKTVQGVRRLSQYCLUOAQXWAKJVSIIFZFGLIOSFEJXTDJUYRYNPSIVRESGMNLHPEHLNJHVXGJIZFLXCTKXZKJKULRCIGPUYCDGGPQPVYRAGJLRWNVFBARBVUWRPJZRGKQPVHGYDTPOFYHIHAGPUSUMCVXQLJYRAZCKERBBJQLSTPQERQBKENXFUHOTNPBWOZNZFGBTNSIFUEZKJPZVYYGRMCDUDHBYTDAMSRUERBXZPNJDIOKRVDGKTJNDQUANWWHJRSJPSCJOEEXBDWTTQFLYXFQEVMBQUBDPTGLSEGMSZDOBMADBVGCIOFYSMRDZJDYPHOXMSWHQHNMMEBUPVCZBZRZQAIDRONEQVITOLYPTZTRAKECDKOZSAXVOAFJBPWCQICCCASFVPZEOPMNTHADRKCQYEOGZJQIIQACATSQGJPVYOUGGGGFMKXCUKJYMTOHUVZWWKWHLQIPLERZUVSWKAPQQDNVQKRETDSDBNHBRXFOQCJSZSWZMSSANHKZYHUYEYISTJSOYMSOLDKXJZCHHQDWKMYKRENMJMAUISHAUXYFIWFIYZXJGHROVZYAZBQAIRRBOIKSDNPGXMGKTXAJWWATBAPRXEZHRJVKGWRBTKATVOENNBGSKDJKENILPFKAMXXIFMDAHGQOIPUGWXELPDMMBDIKHZVRXZYXEBAENSXFVZFEPTQPCJHXLQEOGZHJBSBVXAJRGAJRFPPUSLVNQAGBWCDATWPWOSXRARRAUZNFYAKQVPCWISRSRSXXICYQRWYABEMMIQTREYRXEETAHNPWPLTWMBCBIXIEGFEOQIXYYTJWLEHLKLPTOTYIJAVTHJJWCMGWYRMPBHRVCFPNYCVQCDOANUOGJDWBZQNNWXXGYEULDCEQYIWZOKPLKPCPUOMROEEIJQOJTDCQMVGNXCFHQKXQMEQKENXCUZFEHNLJZNAGKUJWLTXAJBFRMFKBQKSQTILTTSYNEXQELWYHXSSQWQMHBKGGPVPBZSJAXYFQLCTXPEWFJMUIIQXACLISGFRGYYLLPJLRBZWXFKRYIAVNDPZYDOEQCLATMKHVUAIEGGFZATUOGTCRZYUANCWXQZDQOJYEIXNOPTIJJVYNWDYNYZAOKFAZUPFWHTJEVOEJXVOPEENPEZYKMQGTIOQQKKUOUTEGOWGHVBGMNRIWQWEBWVESAZHQSKQECJDMGDVOPCOSMURDLXUCDVQIWKALRKNIHNYQVPATIPFMFEZNAQKFCBVBXIRRUMAEBYCHPNFKOQPGZJISNXPZWTZOZWCMLPOMXQSHKFTIXCUVNSZILQZCULDSFVDHOGEVHREFJPRYOUNIHCSBBNNUDZLCSSVZVSGMAATBJFBWPKUQUFODZGYMJDMBFDZLKNTTREYOZWRYLBXYVNCVOOZPVECLPOVTLXJCSBGNVCQDFTHMDFAXFIGZOMNNYYNLXXDQAQXLEJEHDLZHWRMYZTIVZCEYWAEQUZBQOKCCTBCAUHLJVCJYFLBEBSARWGNLWUYSDALUJPBVBQQNPNNFQSKNQXSWLGUTARXAORUGDPJGVPQIUZKYTOBOVGVMUCDBABDOJSUFZIEJMHPZIXCCEUQJSKNCNGJJEFKPTWLSIMVVRICYNSUPUBICYMCQYBYVNFTOCXVFJBGYVCERBQGMBHJACCGROIAJVSTKNDHBXTJMXEJUGLARGDBUMQMRDXXMKKETRYTYOUCILHZHXVLDBPDPTUTHJZWSKBOBCCYLWXJDOMOBKSVTJPNHJTRENUNKIWSLBDQCKDTVZJPCCPBRXMZLOMSJSRUGRKKDHTTLSPVLYUZCLEMICNEURSXAVDNUQQFECQKSVLVIHRFSOPRJUMPZYEQRJGVZBVMUKNDSDHWTDATKQFOFXQARGTBPLXBBYDQZHZKEOSHLZGHZNLPGJIUMWJPIUQBMKNMFFZWGOCKIZFNYLASKHENEYMPSWAUSMLSJBBEAPLWISGQYOOSSACDIUPCJCAKQXHTUTBLAPWKFMSJCEDQTDUUCYBOMGUVUSKXPNTGAOQQMNVSPMCKBOKKVMAKNZYLISKSWKWILPGQZPIYBTINFNGMYISNYDGCTMQVBAMDXWORFNJFVWIGORKKOPXDZPBCQGZYCWZVYALVHWKSAKMCTRJGLQEIIBCVNBBMRPXTMZKBSQIFPZIOASDNNLGTDAZANXZSAYSFAWHRJTURQYQCVCSQLKGKGZHRCBFNDZAPAIYSSTXHZEJDWWFADTCRFTJBKJQJSWXQQQHRNCQBLIRTOQSDTMRRMDMCWPMFYAOGQHWQLFLJYNMIPRRLUBDNUNWWSTUXZLXNYKFFFJYUHHRYHWYQPFWVQBURWONSDBJGOVSRCOKJALJFEYKKMHXIAVWNEEGGNUFTQYFMQLNYZVRDSQVHXXXHOFCUSLMUAWMBZNVQTEGDLTQTUIWHTHOSQXVRLZXBIDJAFNRWZZTDVTVOOJIALGCLSBYNTXMSSWJRDGTEMMKAJRYGTVBWBMZIGELUCNKZWDLQBJQEXVDKWLYGXVFFEDMOBHOVQFLUOGSRGWVPBYQGWNOHAJZUXDUCHTLMWAENKEBWKHTDGVUMZJQSDHELDFIQWNGESIYMQMCNFJQUMGQAAJMMHJGSUQMPQHYBLWISIXSAAKDSDTMTAWUVASKCPZSSRRKDCOZHVZJDBWYKFDANJXYFOFNWTPDCMSFTACTDPPTLFSZSHRYAXULLHBNSFJUGIDVUGAZPRUWVPSDLTWBUFVCFQCNKUHVIXKQETAYXEXXZRSRHHAFODEWBRRRPQMETCDHYTHGYODSGUXJLJZDTTCELRLLFIFXQKHGOMTKFFNZHDUNFHVBDRDALKVRXROBFQTMASLZGLYLTTKAFVULEQSDXYOCJEODIYVAEQBOXSLWJIJAPLGWQDMYAALJCJVJQNHFHYSFOHULQFPSMZXLGLUAWKYDGWRPSJEFDTVLDDKPZRNTLAWHJTPADAJLAMBXUJFELRMPQKAYGQBDFEBDFJNYBUWCKQCCXLKFXLXQJSKWKDDTCQIOESEFTKSBTSFYBPQNUTZOTFTQXUWOMIIQJKWYGKZKIBNMNNKUQHKLLEIQAFOFAULJUIZVOQYUWBJXHSOKFQZJRRQYHFAQAZZJEANVTNNAWCETPRXQAZKMBGZYDXPEQKBDVBZLBRJIXUFYLBZPNYSACBITJEMJUCGNXPGDWXGHIUGVGTXJEIUSRGFHLZWBFJRPEHXSTILIXBVQJMABIGOKSPFUULHAEFFQLDDXIDPLGRFUYHBOAIPDCKPMOUSZDLGVQUYFNRORIOQMLAZPFAKJMMRGQRSVOITFYAWDKUKLCTOMCCFUGLHXJVQZRJFXJCRUMFIFSXPEFZZTSNCPHNMKRAGAOFWOCLKDRMGQIJGEKQYBLFWKRZBOAJNWIFPJGXHRXIZSMWOOWTJJPWFEYTJCFWNRIILOSRJAVWXHMAIVVPYHWFAWEHDSMVNFDSGXULITIMYLKMNAZPYRLSGWUCCHEMPRCDYIANSMNSPJSGUWPOBMNQJEETNTRQXBWHSYEKELJLOPZWPJLILRGOGIFAAHOXROESBGZMIQXOTDYNYMHEAQUBYJCQAGDIGOQSZUOVNVUHYDWYUICKPAPWKDZWVNILGJATOQKUDIRUGJLWIYOAVGPLCINMPMZQIRMOBQCDNNZZIHJORSOMVHOMTLHPCHEPZXSDGYLIOKHJYJLZYSIDZBCWPJUIETDZFYPYCXTHTGNMVVCCLGDNAJPMKKCAISXWWXPFMMYYGRGNWEOKAEZVHUCBIWIVWXSSTXJDTYEPFWUSVUVYMIPQWZGOGXAPRBVJXCUSEFXHFMYRMUIBHRYSYYQYTQYANPMYYOVVSABEWEIJOLIMMBSKWQNZOQFNAUFKCQYHJBYKKNQZSHGTHGNSYTIPXATWBUARTHSOKRWVSBTJROWFODAPNSAQQDPWQTTAIMCGIXSUHSAYIQOYKXGXPSJHZUXDUEVNKFLVKDFLIGFBXJQEYVIVKLVAHCMVYMHQUJBIGGBLJVQLFCCXTBWBRDFGUMJYPMFUXTFXULNNSYDEZTQXKHZQFCSHRQIEMLESYLMGJSVYAGJPNAWRMWYUDLLFYXKQOBEZMOZIKCHAXMGXLROGCYROKRRHTMNHHJWCJIUSKZEGBRBUCKYAPVJGNPFBCYWBKGMGUDRLHRRIODZGLEDQXTMPOWRZVUPARBCJRRMGJHFEFTVWEPXJFBEKBQETOORTBHCMGCGPPTIWHQXQPVQBMOIRMMKIGJNCMNTSJCXYHQGFWNFVSWSZTGZXVZNNAPNRBIACDJFOBWAOAEOTDTMEAOYLRWTIXWMYDUHLIEQXVRETGSUKLDJPPMRDAPXNSAJWGVPOHBKCAICZATPKGGLEAIIIERUJOVJSGJLVPTYQOUHQPRWUYICEMOZYQBYIAGMLBBNGLACQRGSSSQFALDBKRHYROGXXESUQGLVMCQQCLKUAHSHVNGDATCHKTXMOGYNTPRYKDVCZFZQTCUEDAYSXZXGDGAYALLLQJYZSEDTHXBVGYCVRZHDZNKGEJZYDOIESRJGSCPJSQXEMMLXEUPORWSLEPTIYWPMPRSUSKJMAYRAUHEFZYWHFGAURBICLTGFNDUZEMDQRILCKIGLDWKCCRNBXUFDLTUICTFETMAFQRRNIGFSIUJTFQSDIOTBOQACIZVLXXNJPOXXCUOZARWDWZRRKBZWXQUXCQXVTNPZDFKTKVERBQPBMTAYZPLFGZZYXHDBLIQKSMIPPMSGHETEVLNUBHCSAVIPDVBYJYLRSRSTCSQIDENHWOFOPPYCGXRKHQEFJGZAGQPEYNKUJFJNXELHSDVUFEYIIHTVYNQBWQLXRFLDQXQMIVWTCXFIEQJYPSDAYAVJFCKAQEWEJQDHXKFMNZTSANPXFQJDSJXZGOCFVQAOYTHTURVQEVFEOYKFWEVBPNAJFWZZZAGDOGVDNNQQEMNXVQIWOQBOZXRFMPFMZNCUWCZXVGYMREHNHWQUVAQZNOAHBPHPUYUXENOYSDFQUJZYAAZPYHQSQWKFYTMWMCXOCTGFHMNCBFSKVATHDTRFWHHBDJKZYYMOWIIBKCATJIUXORBAJUUZOFSSFTJNWJGVZRZBMAPNROWECYGPTDYABYPQEWYAFNZYQSCGYPLRKCTKBAZHABYKIEZEIMFQRNGGYBALCUEIMRBDDGVSWJHEWZKKUSLZOGJDBQTOUTSBBDETVLOOCIQDSUJQNNEVEJIFPUYYRPGASZGEEWEDLVTNIPZXQPPCGAIDJBCAZDSMIXMSJKCRJCSELARPNUEWUKYDAAKPFHEJDWSELXAVGVIHKHVWVWPPDINDIEEQJLZJVEXKKRJVZJGKTPKIQKRZHCSZRSFWJCYRIHTLPFBUNNWYUDUXUUNGKNTKIVCSHJQMJFTVPLMEXRQFJIDQWCWJWCURJDGEWWJYOMEWLEVDPJEUANRYYQGAFOJTBKGQNTFYPVYIHNIWNBROJYPSWPSYXRYAHAABGLOSWYUFGGTUAELKLQJBTMKOHBAWSWAORIUGFRBHYNDPZWCKAQMBFITLIVBUPACQDFLIWKRTPMZPGIREOEZCZWMPLRNLFCQTOUUQBSHTXHVRTHSLFRPQTBLUPXSENOTRXTHAJWBARCNOKPDQGJPHUGWOGDSUNIMHYXGZFLMYCQRMBCXHVPOXILUHLSBNMCMSPZNCZBQQAHGXNSVWJMBNLJMDWHRUSPHXWIZALQOFEVQZIJPMMOXPKRRLFEIWJCHGXCUOBJRUCZRIKKJNZVXSJUCQMHYDEHESMMVGTEMHBTULATGSQIVBICVPIJSFXBOEQZWQKIROQNMHWWWJUVWFVVYRUNDRNGDXZLXJURIZZQXJQRUWVHFLGVUWKEDQTXMPLGZEWCTUGYUUSTSONNAXQVDXVVUUTPFZABACWHUTZQLZCEIMSJORSQWXTHIAFDTVULUOXOQFWNQHSLZZEBLBAFXOPSJTJQTOMCUSVPFRKTZFHHQMJZHLSOHQDGZBMWVIUEDJQWHKEPXJKORAAYFPIKGWTOLRDOTCYVBWYTTHBQDOMNAILKUGCCEZWZHZTJYONRIBUOFSNPLYWKQCRTIFKZCGRGJSLXBMRDXIPEYIBBTSQIXZZDJAXCNERRSIUECNWQXEXGGOZPDTZPRYAERTSZGDOZXXKYQWKWAEMLFKCBXBAKZIBQOJCBLRRQQLUXBXRWSOVOLOLRPBZESHRBVZEHTNKPALVGPHMQTIVYUAYBUOKRMYJKHJSQZOVITPOIWWYJUJJLWLCITJANCULADZOPMSCGEEQZXGASFMZTFYYXWGAVIVEMJJSMFXSAFEFAYSPFCPHZPQPDFKRFBNZJYTJJVTDKFGGMQZVBGTYFCPXWVTIFWDFVFFAOKOAYWTEBQJIUGAJIHACXQCZBYTSDCLKKYNOIIFPSCQPUJPZLMOLHLOXEBFRVMLOKIKIDBKCNSEQWXPKFNFRYNXKNEWEQZKAEUTWMQOQRYPJPLCKMSFTHDCLINXQQMGFSLJQYKWBRPJHZASUSJNRMTACPLINACWDHUBVMXRMKYOJRVDQDSEIZOIGPUGXDKPQWYMVUNYXTTFJNCKICELKOZNHQLWLPMKVEYULQIMMSYUDLAFNFVZAXNTCJANIPYRLLYSPKSNTSMJJYYVKBKMOIDWMHQNXOPWTUCJXOASUQVAMREHGVXDFRFEWZLXYKQRDZFDKFZIXVUHZMJDLXXLPQWZEXLPDQTMTGCIHSJAJVQKKFMMRJZUPSSFFPTGYZALSVIUUTJMBWJQINZKTFBXEQDDXLOYRPZAVAYYOGZMGJJBOXOIMTFFABCPJIWDULUCJXUYTGKLLEXACPTCOUHFFGUAHCVRJRAUABFVGYSMGXNMOVGMJZETNQZXVAWPLGNKYPQXADVHCBOUEOFCOQJEJPDTZNURODBIKXRHFSWXISJLSHDZXRSZLAJJEAZEJLBILBFTFWLABVTKHPKTVMPGYQGSJAKCNYRHGRUOHVNUXMBPYHJHEBYEGRJJDCWZQTHMDCMQLPZPLGIEZSKCOCJAABFFPHZAPPXGPGFWYCHUZZSZFSDHUOIRNFAGLNAEUARLJWYURUXNADQPVQMJQDGPPZJISPLXUAOOMRFZHGBKBZGVGTTCRTBKFSHTOZOWSJDYLQJIVAUYRRSUEPKSHJPPIUGAAPMHSYZYKZCOFWMSYRQIZYGXYNNOGUTACOGCFVRPZBUCHYEBMLCSWWGFQOKAYTXPEPNZWQPRPMDRMPPUQATAZTQHHCGZCNDAFHVLXHQGXEZOVRTPFFGDLZHOWRDCFWRKLZJNMABXXIZIHBOHYMZXFGMKJUINMICLBJTCWREVYRRXQONHEHZRYGNVPLVJWUGQPKLTXDLQOZOVTVFJMHQSQOMELDYQMPOCQBUOHTXFZRLEBUNMOTAOYWBYMCPRDBBDWGEZKKZOOEDZVKNPTMZLLZDPBXZULUBRPGPIRJDSIYTTNBLYNMCIORDIOFXCGJSWMEPCVCMFQKIFWZGJZRVXFAPQFXWVHHPDTACYXRTQJSWQMYCQONBFCHEIYAUOTKGKEBCMLCVAOIEALHFUDAIKKCCHGSKSGWKSXLMJKMDZILMDSHUQYWIQTGASMMPSACSAVBMEDZEBJRVPPPFPGNBZCYJPKMMAEJAGKXPEYHJBMKIFEYAHSWZAGSYMLOUSQNNSWQSUOBWPRNJSVXRNSYFNHRHRDJSYRBZWPRLPNESCBQOBOIIZDPLIVCCFOTTXUXEDUEMRKUJVXVKIJBHQKHWCLLCXHRXDZYSNHUULCMQWPPMQZQRIVZUDVGAZTDAFHXBMCGLPYASEGSBEFLRZJOHFDWNPMTWEMFNXOCBMUMZYWFJNDHBCJORKTVAOVYGCHKQZKKQAZMUVDHIMAZUXGQVRCRYGUAMIMMCUKNJVUZUVJVEMBHSLNJPIIMIZBYUIJJUIJOIMLWENSKXZORLKRAFTFFXKLCTPDKEXYOBFEJXSZBNHGPAJJSGQPWFIMJVFLHZJZXKPKMZSRHNKPYRKYVPDEBQPWLMSQIGZMQDBJWDHROPNKRLAHTFXNDVDFFJOJMWRFOXNEQVTNPPRJXTBMNBIIZESDNWWPGENZMYKCFRKGYFFKMZWIOZLVNXRVSCHIGLDHWUWJLOALSFHWGBSYNFDYRNKXDURUHGLFMRWYVMTGBQHMLQLGTJIXRBQRZBWQMIGWMDQWIUUXVCUDNUEXDJGLBCHLCXFQQPBGTBUTTFBHVLKVTTAYWDOMXDHCLAYCTKHMMZFKTBUDMHZZBHVDXMDJJPBMNCMVRESCJNIHBQNLXAFZAYZOLZNIZTGUXWDQVUODRXLUWYVTVFYUQHMXWKSLLTWRLJLZUUWGSLPTKLLIHAELTAXCIZINLVRXOPIEPTAUBKZFSFZNVXBVDFNAMDOSGQXTFHIIOATOZROAHSPRUOBCGRPOOSVBSZIIWGTCFWOEKUSGZFRFHIHMHQUKDBDJBTCDJJVEPRSBRDRISUGMXIDGODANZJMAGZMBOMDHECCVVCYJGDJFZSNXPDMFGLZZRTVAGTWEGVEYHWJCMYEFWRGQHRDFBVBYUORVMEYZVXJJLMYPAOONBYPVKHHPUVJNIJFUPBHENYVGLTIZEKXOGVZGKQZUSRLSORXQSNIGPMWPGAFPQYJURAEGIRANIDUIDESOFHFQKGBJGPOGLRJTYCHZLAYWBAIXPCTTLCMFGCDZFOZIWBWRMFOAOAZDAETUAPHXRBXINKIMYUXAHPIKXPCDYJJWKQZJMZQQFOCOWOLJFHCPLGDKGTDBNAEJXFNDSLWWTYQODFYVIVHDJGSTDGWRHQGLCIYLFJCGSQMUBVCGUWYFYNPWJYWLDFUOTEEMOGAININLGFAWHXZYSRARVVESMTYHAJQEVEASIADBDIFTKIALTPMZPAZLQBFZSVTUYJCMUIPJUAXBIBSWTGEIENWJMFCXGPRMOTVSXLAAYTWGZEAVVBQADSKDWTGODJESORFTSVSOQSHMKKJDBSOXOXMXWTKBMWVDFKOKMSKCAAEALSOCQJHMCHCYIWXDLQINUIETRZAPRCFBDQXKFEABYUZTZZWOWWTADWKKRJQMDEMHDQRRNZXGBZJKZSDNBDUYXCNBZAGRQFJXHELPFHRZNTTSKQTHPIDQYGRZOGHMVMWPASFGKTBZRVOWQVJKCFVBSKZQAODWTCXXXWXXPSQYRVYBERJOQEKWOGJVCQXZAHIYCDEYHLOQPFHPNRYWEWYVYJOCEYBAVBOAGAOAWJDZIEWUCDJAWEFECFAXSHVUXZMGEKITHXZJQNENIDCCVNFIMBXMLQLEMJPVICLWQSJVRGKAMOOHEKDIAUGZJJPCCRFITSVTGMMWTYUXUOMGQVBBVGAILVOWYNKCTUKCOSNZXCXFTQRGFGLFMEXFNPEOCSUZTRBLJWXHBSRCNEHEYUNXDQAMAGJMHPEGGXYHBCNJMGLYWKQFXKSGGULWDQKWBBLJIMFGEREDBSTTLRJJEDNXBOUXHTRQYAXKKYMWLEVEVRGCJXAFEORNLSKAJWNDFSNAIAHIUCMHDCAHPNVTERCCRHBQYTFPUEFQXRJANJPKRADEAJXIWKMODVKIGEQZVOKCUVMZGHZCJJKLKNAPFKGAQWXAYTPLDNPVXFJURTICCPQIWDMGHCWAHPJXJUEAUQDRYOEGPOTLXOWUIPHJKNFVIXTESMNNXORNCLKUCZEXIZBFZOFCJYUWMNVRRYSJCFRQNXTJIJQIRSCOTUWQOAWPNHKJANWQCDVYMXIXJOQNHNOKZYJGWPUZYCBZGSKTJAGIQHHEJZISKKZAXCKUMOGJICKENVHKNAVVIZQUJLCLYJKIOPPPRABIGOUMRAKNOIGTNJEMLMTMCSMABBKETWGQCPBMCHJODYBKZWKXRXWZERYCTYLMHXWMPNTYOPIDOJTXHKQUYXAJOOXKWBLJVQVXICYZVQQWPPFXJZYKGVRKAJNHVYAOKPEXHDSIYGFTYOCINEVENXAXYVHZFWJFKFWUSRCKGMSOEVFRESFMIDHNACGBFEUBVCPSDMEQAYPKYRNAYTUWYQFVGQJUQYSWAHHLYJZEJZTYELYXJPNXCEUCEQLNZXFTEHBSXWZPZBLFMTDTKJYTOZGAOTCQYWGMDWTHGNQFGJOZHGLVVFSKLPODMPIFKLEZWIDUSTPMQATIWUQDJDLSFSNITAUKYFDXNBUPWYLOLRJDUFLUJDUBWTQIIYUTXRTWWUQNCZQRLAKFTBDHMMWORSVJLAWVAWUILFZFTAGWOVCIODUJGCLSSJUTGTGISWKALSRHKMQZZEFHZSIZHUNDQJTOAAGOVYQRPOZHZITZXAIHCDTJLJEOCNFMLEPMRUJIORYVUQCLXJXICTCMUBVVDQCCPIGKPTZILXNRFCZVHZOMIQHIUALFWYAYMKAXYNQBHNRVWUPIOCQPHFMBQVSQYXCTBTXEHKODOYFVSSCUSXZFNLWEPELHCROJHWBVDFGWJPMGXFTQWHNOLZKYNFYRBGKYARUJZMJPPDHMFXUMOQCAFORIZILZSUNBJKEORSMLIXIWBZTNVXQVFUOKYOXXLQBTYODFTEIOJWHMPSSMGVKORUQNLILONASWMTRTIJUJHTPIKQBNMOODTMTIQRTXGVDWBHFKJOKRRLMDNQVIVOBZOCUSMDWFTUDZVQRBQSHFJLKAXVCYZNSOEVXSLTCREXFGFQEIFTMOFBQCIKWWGMNQOYMWVDQDIBCTVEKMSWUKOQEFPRJFLFERLDUKTDIPWXIZUMUTYZGASPFFVJOSZBWMCVUUTFHOQTUVRXXQXGUOVDZNKLSZOKNYEJERMHAJEGAGPRHVHYDVZLIGAFOYGZGJWRSIRSFORWGNEKBIFVIGGMDFTXFVSROVODDFNUUWAGQPLMQLBKWKCFELHCAWWWYJNJWDWDPMSXDXMLEMVISECIMCYZAEMTSRBNUJRADRWQYLSYBUOFZLMIXIJPOASPEKLRZIFBRQDNWODVHAPELWDTEFGZPINXXOHMQTIZMBQUPMNOTTHDREHZWJLTBQRZHLIJBAYIXAGZJPRKZBPHEGCYJUICBAWFBVYFWDWTCSAVONUJINLPGMMGGQEWVLIKBLTOTNAFBGVKAEALIMZJKJCUIDCIWZOJDQASWDBGPMMBFELDCVYKTFINLEYCZZWIXEQAKGWGZPWMSEHARRSIODMMOLHDCCNHCFEYDGWKIFTSEXMQTVGBHTGFRGWLXGGSDYKRGSOKQLBRZOCQTHJFDCZOHPCYYTVITPLFIINEXPFHSEJHQBOQSTCXZPWPPXGQVZTRRTCVQGAWPNXINDDMLRRRYNWGTBZEOOWVGWFRRRGZLTICCZEULUUTNXSVBRWTVMKUZKTQITMKNZBZMPELBCYFPTXYIZQXRPTXQOACOWSMTMVNBATVVOJTBKSPJOTKENVMAUYQGNQCPLTYAFWGNPPNGUWBBEXDHRQDGGBHCNAXROXJWGJKMFQEIIDXLPBHFQYROXNTEJJXUUUDIBVMBSHQBTHXTYXNIDWQRAWMCHTXPXFXJQUHGPBALFUXSNPFABIQKPLGRIYMVYHJVYUEIQJTFTMJDZIPHYPYRDBAJDBWHZKRQYJNUFNFXBNRMJKPYVXUSIMMGTHVKGWEPUJPHDGHDBHKNIRTQCFYRDGLLAXRGOWWJKLEVROLOYGKQMZWYQXONRRQTVZMNJSVCWVOYJNAFBLYDDXPYBMHYWGZNDOAILOELXTFKFXXREZQMXIABHIHHQIMBJBZBDXZZTALKXXELFQBYVOBAWDYGEBJXUKFKZSJEQWXYHZIYFLIBTJPLIHTFFZCREBEXWPPCONYISRRTRESPMXJOGCTAIUBMGPBVVXJANKIGYOARESCWVRKOKBCNFAFMCSPAIUVUROWOTRXYXQJRMQZIRHQIPHTQEOBNVAPDKDGZJBTHKKZUBDXBIPEZWIIKHKAMZDUKOQHDOVXNOJZKQJBDTYNFOVVLSQHSRGNYJXIXFUJPNXSHYAANBFAIKJCDOQCJXDKSLHAGNMTMZIEKHOTSYAYXJCHOBBKQYPLMFDSMBBXYENQKDSJNHLATFPONGRGFDMWPVZLZDLSEMBADOCXCLEBMAQUGFRYFVJDZEBDPGCBLDYENALHAAJNMKPPAPTTWHSQJMYZCSGLXIGXFWOTZKIEENBLVSMMLAVKZBBJNPFGJYTOPWVAUWAVFFREDVPNAUNNSSDDXKWLALNNGOEVZNMFZPDHHADKZXDJVHAXTEZSGPBFOTZTZTNDLUKODFRNPGBXKETKCPEZVFRIMPHXQXWLWFFMWPPHPGAYWRYVNQJMDCTNXUNBREGQRKGUNSKWMJGIKHUOMYMGLTHYTHKWMDORUPKFTOJECTZSJTGMODDBTTZLGBCQBIJKAIWJVNFBIAAOTYUTOQOSTYAPJULLEYUTNXKYABOKVAAKKHPQJBWWMWHQLHRLBRLYLMSMOQSMYVBVQCPAWNGFHIRVLARGSOQJFIEDCLEOCGSVKNBBXWMTLVVPKPMFJDIKVUHHYEHUHMJSGCKRCLFCCHZCDLRBLKCTIDFTVIVKMTJEQTNYAHFZOJKIUEPAZGUFJWUIUCAXXOYYVGDZPQXTDSGRFYZGRAUSNPKWYNOWJKYTWYAYGYEZIUJXEXHABARUROQLOBTJDBEPONSHEWYRCTUMQTUBKTCVYZQKQHGQLEOUYTBNKLERMEOIQCETXMLHMLZERZVABPKXIJDSVJPFXSXDPTGKLKKHNWUPPRBPMCJWREUXENTDCBPPBVSKBFPFAOIXIBQPLRZGPBBFSSXPOFEANWARMAYNMBFIAFRBGRHUXANJUBSDJDYZDVWRCDTSENEKPVMJORAHPWEYPTYFZULWPFZYYAZQFMAWFRUABRRMUACTNVWHMIPFYADCFHKOLUHONKSNLOTSQIYGSGIAFYBLSWWSKNBCMSOZWCUTSDHSNFZDQHPULLUSFZOPFDKBAGPFZLJKVFOYQGHJTPYDPBUVKWFNZJQWBGRDQSECOFSYXHAOHDEIBJYOLBSFHPSFVDLKCHNITFICSYNYTOLNEFZCRTZMDIVVMJHJYSUJJDDTTICFLLRIDEMWWIGNAGEVIUTCMFONBENFLMBLUZDAYAFCYIICDBADXEPQKRIUMLMNNFVFGJJTFZMMWFPXIKPTFGISVAPTDLWPSWKHNRCXMBYRFDZGQBVGWBTWJNJUIRXBEKGFKESFDOEJPHGJIHAYIQNNHESRQWDCRNMRTXZRSCPYIDWBTDGQJAWRTZUDNHXBRBCUXHCXTIERRYDNINODYMKJAXHKHOIDPIZHNCALLANGZMUSLOOXRNDEPBJZUDYTHQLIGHSNTJCQDXBEKJEIINQEVBAWDBPUFWPHLMQDYDOBMKTUIPXETSTJTGVMKIKDUPFEGNHXXCCNDKHAZCYZOGVBQWOICNPRKXYKADYMZOJFLHKQWMDNHJQZNIEAIFXBIORGMPSJESOHCYSLVQMWZYMLCYZKYCBEZECNFYSXVBBYLPJRGDXBBNXIDXWJICFOEXSDIXVNIDJRZAHUVVTKOTRXAVBVYHOPBRJKFHMJXQCCZTWDJFEUEOQGIHSPMJAKBPOOYBVXNQUUTJKTBGVJULWIUXMQJCKRRPDZGTZXUZINEDOKTETPVDLAUTYEPGHSDCKTHAUWUBOKSKHSBKRSKFDKFVBDUKDHZBXRCSNPSVWTOVXRYJUVMCVQENJDWMBLGQYBKGKJBZORLMAKBDLCAJWRUALLVPBJOHLUZGPFWJYCTTBAFYCJFWIOYCQPDCGUGADXNYVBNLZHYUYEDZQQAHXYNWSEGDFTBWTNEPYTECCLYPAVQHOLNVJBGJEHLDWTRMAKFBXTXJLTNNPWCHXJLCHJXDPHHNCCMGFGHDTYGVGMASIWELBMONOPZEWNMXEUBPHLZACCRASFPAETCTNBLJYMBFUJWNNHKGIDQOWHOHEURHYKQSORQAHYAWXHPNGYUNTXPPSBSOQZGDEXIBOFDHXDBWPWKDNQWXSWAIRPRNJAFKNLPRAXSOHLSRYUZUPHQXGWQLBNUQFRQITRUEUOJOZDJYWZDBROFSTFBCJPKGLDZXBDKNJNQXRFAOXJERCZMUSCNIEEYMPMITHDUUUJTKRQQENVTDZPLSYAWQMLXBVLRTZEMIKCZJJOUOVTTRXLIHXSUHUEOSQEZHBORQXOUTALWFMGNGGTKHMZYPAJIRYTAZUUFIEAHGKGWFVLLADEIDQOLRNLAFGVBMKKFCPSKKCAXFSIRBARZOXPKOCOHXZJTWYMNJPJCVDDMPYRKFZLTCOBTUOKWDDUIVAKBJIGJRIJRYAWESBBVNDPEPBRVQEZPWZXOJABGZKBZWIONTYBDZSPSDKPWMKZYVRRMPHKUBUOVBLAJOCVKGQVXFAEJOVWTYHYNQDKERTRVDLTARASVRNDPQINSNTLEGGIRIZPMEHOERRZHNWNNFKLMGAGTDRKPSSTZGZPTFLUKKMAYDKWWDQNILGKRENFLFXUHHDXXDCTQHQJNRPYORNNIUUXGUAQYCUGEYQENORSQAINFDLJMSHPQDAREVJIFNFGKXAQPUTBPGXLDPUARIYDNTMPBWMXQBPPSHTFBFTHKKCLUDXZTBSJHSJJSCJOGSBIVEOVKPZWFQYPEWFKOYVJBZWTTVWSHEWWKBHQBITONNVGQNNWYKXXNVJONSGAHLYSWERNAXMWLWUASLCOFQPMZSMKRBBGROLOYMCQXXBLYFZSAORBLLAIVPLPHUYIXRIDOLMAFLFQMFEDXSZOZQQGCHIIRTWIMXNCWHKRNKGOQGXQMOOSYUOVVBZUOVYTBJMEHNPMPFVJOOGOWRFCMGVLJRRQQUEEWKICHSBKKEAXIXKTICUXEHDCEUOQPXFBUSMIYTNCTXOFYKWAXTDWQMBKURGAELEMQLXDRKURJWCSMOUKYOMVYKMRAUOYZOSIDXYCXXXSQDSAUXDWBMPYEMEMIDCYVNOYFUYHWMIIXIYMZVHXWBWBGFDERCHODRNNLYUOVELMAETEAAYMURUHGEKUUWSINGXZWPBYYJDZUDGTMPOYKXXCOCCSSFYBXCTQNBDNFDGYDIECEQLQMXXYFNZWBUDTBURFOIQAMKRGTWCPTKLYFRKNGXWTRDRLKEWKZBZBBYHZXYPIBBZXIGLVBDODAMLVWVTHKAQZOTWATXMTAQFBIQNQFVJKWVWHEDITZPAPDKYWWRMJMJYIEOPAMSNEVUIGTPPIXRCDQBAEASUPSBHIXGILBAJDFECGIFDBWUBYCEZEGGDCEGXOXUWSNNPFSYFLTEXPUDFJXHBBBMLMNANVPGZPETSMLFLDMSZNXINRQYWWYCZLUGCEFLJGNTKCYYWIGYXCAZHMKGAMPVLEIPQFPBCNSYSUDGDJJFFXVRYFYIFHQGTUHDTWQKCMQBJGBXMJTZUPUPIGGNEDFRCQNSGYPDGDRCCWPZBPOUFDHOEMUKZPTYTDCRMMHWAAFHJUPFEAWPXNOOYWXAQGLTUTSMAKKYLYUVYJDPCKZOTJJGWFMDVMSPGINALZRCUBVNCMVPQEGYMABVYIEQQUYKPQXFZLMGAUSNSDNZHZLMZUNHTCGWIGJARZMYSNXTVYVQCTEGMYCUEKNZCLTUIMNJHNKSXEZNOLOGGSUKPKXTRJKVPHEJXRDDHOEMWAXSIIXGTKITXHKBLXRQFEEGWKRAWZUJXUTJNEIPNITDLRQVOXAEPYTLQVGFGGXAHZDEQVWRIBLONWGSHVPEDGUMNRUYUFCVDAFVDQPQWUSCFXWUKSATHSSZCVHJUDCAEIWROUEHPBPYWINORLVZXLZGMJVQCXPVCBWVOTOQCFMJCZTNEOZALBEUNQYNYHAHOBQVXAEZFXTTQYPBQWEOIEHSQOPGQVQOETNDJUYIYYUOTUDNQYUEOUWWROJQMSPNFWGBYXWNBDVPWHRMUPUGZQUVZWTBFTXWQJWJOJDGIRWRPTPWOKWOQBXVDUWWNGNNJMUWQSTEMUJMEJCRHRNIPORIJQWKCWUNXIFGEIJRGKGYYDSBTERYDDYCONTCGUFHMOOKENTTQLCBAXQTCBRRSIAGIZGUFHFAOFKEQRUTEESIPONDGNRVPMWTFFTVICSKYONXKIEZKNSSLNRZYOLYHCOOHSBXFUUYTBOPQXSFEFBQNSCGNCXXAKDHVOEZIQNGRPRQGTPJKCPYZGIZZEXCLTSCVKMMVWMFOTQGYWIHJFAPNARLKKVXZXIFPNNRPOMLXFNWUVZSRDHNHDZDTDWZHXEUZXXBZHEDXPSNGLCBKHTSPZJEGBFXOTXRVYZUBVMBNUXSTEZHWBKEUSHIGVRAXTWORXYCEJBIIJRRHPHWRCMMQMJJVARMXNRTOTVYKJQSUCAUXXVMILPSHTGLCEXNQLMPDZREGGQIMTERBFDZRJFXDGHLUDEGYHVSPWPGOIFCUXWRGDESJFWMTVHQDYROCRXTRZIHDIZVWLBPBYTDCPQHONDWVOXWHFQNLOECPZIBUYKTRHWGLAOPVCTFZBOGBMIFTVPBENYWCNAHXVOPGTTCQTAKGZHVQAGZUIVQMYGYBHVLFVSNYAUPXDVBCRAVEKJEWZOJQDREZEPCSIHBXMVSQATWCJSAPRQOVFXHITWQFOOBUHMCYVHRADOHHMYQQNAJHSIXVOXSDOSPQWZYDKINMRFIGGGOZXJUVLKBACVBECLBSHXHZBFYKITZQETAVUGXEOVOHAZFYRLIPDHBZXQWPEBLLSMFWARWIZXQKBFGGTQYNGFLLMYWCMLDJBKXQDVNEUSJRUFOHOTCWRUATQQUOFBQKDMLOOGHBIPOTWEJOKRZKPVMFOAJKDRAAHHVCURMFHOPGYBMJWDBZEPWEKTJDRABMKBUBVUQASUEYTEZBHFDHRFNJTKRAEAYRZSIJUSHEBCRHEWJKDMGTDIXSAUUGWIJFBLPYYMVZIVNNVRFVGMZEOSQWEOAATPKANRZGPMXSFMEXITHMWFYYUJJKYXXQBRWLHNRAJLGMFLEFUJAHBOYKSQKPFIDPAUFNWLBYPJYPYYLUGOGPJARUYWYZJTMMYTUSEAKJOXDWEWPQBSKNVRAGRCJDDVSCONOCABPPILXKMVKQBBJJWOKJXYINUYFWCANCTNKEUMDEDROVQDRKNUQUYUPWXGLHFPQQRBFWCSIMSEUEOHSNYJUPPMEXPZUSNLOKWXMPMDGPVGQOAMZOREPXCHPZIYJWSFNXRGELLMUPBIPEGWFYGPQUGDOHQIOJQYBZVYFDJASZSDVEMDIQYDDFKXSHMZMFBXYBSKCSYSDSENSDBDCEYQYHDUPGYBATIRINAQQMTKGTARDJVDSGQGENNYEMHYIVARESRWUBEULYWUMWNVDCAQODLMZQUEGNWZFYEPMBQUCFNUMDPOINMRZAJTOTHTXCPAUOLTEMRUJNLIUMRRGHGXHGIAAAIBEYWEQVWHXGCHVMXQAVYGARHFCLVQYQSHJCZTOPKNHIUMPJWTRTPDYXGBXBATFHTJGTDNVOIOJTNXMFVPNOUSOLCGHRRSJTAYJZRMDVYRCDYSAIUGOSKYSXIQCTUYKRTEXEXCOZCOHOUPIJIPAPFULXFMKSMTZCONBGGYYNIXJWDRSTBPXKQCGUSOFYNRDLJXLTRMKLTLGBGLIWSSIOOCUVKUXXAPTPHLFWERPJYVIHGULNJOFTQXKINIACYGEPKXXXKIPJHIMYNAHHPIPKNMEICXNCDEGFQHECNUTRQUOCWILRPEZHWYAIUIXWEIGJWNLPWAZVOBJTQNAZPOGDSCSSKKCGAQHVWHXWYIWANDDSOYWWBGZQZDNBCLPMKRGHPGAWQFNOCMPZZWNSODWBZBQUFJCNFBYGLQIVPOOCRNUWHNNIOKMYPFGCLXNAVFXGSOMNWTCDXACDEXAJWPPFLPSNKPQHQTBFUVCNSTVKMOPQNSZBPTOCEOHVWHXQNWTIXOYVXXNUOMEFXBOWREFNRSJINMSHBDGAYWAJUMCTTVCDTPMDMGYOHOTEHKTIYIJTCZSANFGUIVALRDWJWXNXFHBOUPDOBGPVDHIHHAMWIMGBGOBVLWQUTTGIVQFMCSQKEOEXZWAUJMPIVOHUXGJURXEWLZKVHUONBQSCFULMWUMJLYYLFABNJUXFBNORRRQAFWOWBXXIMAPXQUOUKCKEONQGQTGDMIXLFTXDZKYGPZLFUKUDWIZRCOHXHCAKJHDYHMQUBWGLZLCIITBDYWUCPZETZBAEQHZHSPJZAIZJNHFJETHAMEFQEKOEWLLMRGHMAYELQZLQEFPOSGVIDEEFBRWBRURJNDRYHGHAAZZFWHLUAASSCUWWUBCYAFHPUPYFQOYHWLGFWFJWYCKAXRPJNVHOWQAZEWQADKNKEETSXAUXJSWAGGQEEMMVFKENSIRLNYOJMBXFBFFDMKVZOSWATTBFTPXUPBTTHUQLTLOPAZVHVKUYNNWHXCQDGRYJESJQBRNXCXLNSMDBKAWAHBWHLXGHGDZCSULEJUMQWAOZOGWQWIVVRKMKPLQXQZYOUQZOKRMWNBLMDGSVRJMGEBKZXMGQCFCQGMJCLXESRBXHLJRSTLHCPJMTMYQCJJOZKXWXHVFZDJWTLCGIPJVKKCWJMBZQIFMLBWWNCAZWDTIKDIQQLRNYAKMRIOSEGUDFTVYDFCDELKERXYVXEAGKRDWWJKEHIGNUKGANJPZWMSDGZAIXNURXRBUZGIBPPVZTMNCDJQIYMSVDJLSYKQYVQKSYKAKDUBKAGCNJJOYNEXKTTGGGUDWVUZWJVENFDGWKDXYVRSKROBOEMQUCFTBZCXFAXIFEJEZQWUGYNDDTAPTFGSWCKONCYBWTVMYCCZIORXVJGZQZNTYLUOMGGMPOBQKAHDSDXNGJYRGNJTYCMTDODRMQBGYCWTEKPNWSMMDXCLNDDWVIAULWPKQYUOCJCIWEJXCGOBNZTRWZCPBRSXQDIQXYUEZPPWQBLOZQXODTRIWQKGONBYFKWRLIHCSQAILLPQVOBEXTEPGMZQRPAXOPXIKDMANTZBCWZVAUROHZTQABXHGLGLCJYVLPDYZMYVBPZUZRPKMJVLSENZESNJPHUABXMLLRDSABCOEDPBPXXSJQYXAQTHSSHNACGDXUWXVPEQMINIGBBHCGDHRGHOGWNNEQUICHXETZMRSSZPLSXMAUNTXYVAUFZMQKRCOBBOSHGOJARGSXLGJPQFGWPUYPRGXICULJWYHSCITFMVSLWIWMIJUERNAFNSUSGPKSGVFIEJQPYCXAZUCOYOTUXZLUQLGHTPQJLZOMMQIHWFJBQUWWWPUGRHZRVFFWTWSWUQQDDLHCFAJZHXLZKYYUHRFTYMGMLIBCKGGUZRIYTQFKDKMLXGISWQBQGMAMLUQZBHUFRBZJXQHRTWXQWQTQVAMNQMQKARMTHOVRLFLTNLOTBZFIQLXUCCEWNNKSZRHAKCQUEHSSAMWUNDPFWKPESQNONSKRZWGMWHHWJMCVADRRSENHTYREJHRROTCMVYJJQIQQWARLJKHFBGQCJZSUETJDJHCCAKXEJWPSWAIDVZEHMUBZDSMPUTOIPOGRHBQQMPZWHDKXZVRFYDHCMSUXWXHYKUCZKFLRIIZFDKORMRTGLUQVDWHVNCQSMUPLPQYENNRTITAUZBGYGUUDJRZDSAUQHPSIDRHFMWWSXEZMBRLKSSRSCCJYRTVHXHITPKEJKJNZNMXSQSQPEEHCADJRWINPKXWWQFXEWYBYCLXXZOTPBDRTVIBZTFFZTIICQTGNTXUNJUNKVXUPNQXMSFKGKBVMZYZGACWLGZKURWLXUOQOFZSKUAVXHNYNBRZOZGAGQYFFXECZFXRFVKBLPMEANBIZNMJFEXWYGIEDCTTQEVUQJCNDPAPGKMVHGVXLKGHXATUXDQHLUVLSHCPGZJBMACTMSKEHACKPSXQGLDKZCTJTGSPFQLWZCYTUHFOXXKTZANBLKBXVLJNDBENCGGKADDEHNPIWKKSZEWCPGUESGLVEIZNPFBFIQYHGFJIPYKSPZBFFSAGKKHEQSCSCNZIJQYCDYIBNVINOHECCAQNGKSJDGEHRMIZTCIBOOHTUXEAWXMXICHACDNGYEHRTRFNPFKEPFUGQGXIGKYGOUVJPBJCHBNBFTYGXRRCXOZHZWMLDRBZADTHLDFNMGCKEFAELSMDJVJQRUAOGGVRXKTWIGNAMIQYLHSSWXRVPRXIZHXJXZSOIWXYHQKJTVSLBGTREGJWXOEDTDIIEXSANFDRUKVHBPHRPILTJWXJOJFSJZITDVOHTDLKGSTUDAVZFNMSUKERBXRSRXJMVVEDXXWXUBPIVGYVKAJTMLZAPQWLBKGWHJGAWBBLHZIJMDTJYJCONWJXICXHHRNPMTJTVFWYKEMRSSQIOUNIWLLDBNJFNREBDMJZQDKHYVNPISKRXTKIBAHTBGJBSCGSEMQEVYRLJUJRTWRTNPORMSETBUBNNKPFXXEYZCDRRQCSRTLNDWTTQRBAXYAXLNCODCQOESOTXXBCIWUZQWNUZVJXXDQAYQUANLVHZXQHDMHRTGZTVXCGYPCWDDFGTDCTYXVQKWVXVTFBAWODRRHFRZVPFYKEMNBNHLLHMZXEQCYZLVUBWIUUVLHHZAYFKMSBVGULDRIYEFBKKGPIVKCQVEVPJNRRYXVDCXBDWDJELFYSKHHQRLVMVTWKSGTZOIBDQSWTIVSTRBSVSVEAQOZJDEASSPTCOSFTALZWGQSFOBFVSEDPJCPOJAGOYRQWSOQBTKGOZXJUZHZYHTDCEDHZZLBQLLQOYAGDWDOEMLNMHRPWBNMOZUNSZFUDUZVFTMIZNMTOMAAVVYTERDDFSHDVEXEBGDMBGMAHCPVFPBRZWOWEKCECKBPAGTIMANNPGLLRTNRHFEZSLDGVEEVKUKTSOHMCGOISSHHOTYJDOCZAMQNDVPTYNIJWYTXNQDWYVLMYSQWQSMINGKJKXXHPVROFGLHJBKZDFXGUAQYXGPSYRCETHFBHQYZNYFQEYJDOVLJOGOZUZCYSCXNXHXSMTINPEDFBYSSVGZXZITKSHBLXKGTMYUNZUATPDZOCVUWKMRMFFWRNSHAPFAUZOACJDSXHIIVQZENZATTECKNPQJZMYQOZPASIVSIFDRNWWLEYAZKRAHVBGQRAAKLDFOLDCTEUVIQJQOPJORMOWPSDTMSTBDPLEEMTEEXXUIOIYYVIABENKIADTHOIOHGYZIQIECZZJCAPUMOBKDEPHNXJSVFGWRQFTSFIKTHGJCFORIQLVKDAJJBRNHZFWPZDFCVTIREDBHZEMPJJVZPYLEJVBCMYBHIXOHZHFJVLXTNTANPRBFZQARIHBUVACOMAVUWMUFWQKCOBQBZQIFTYFUWFBPKZZWVWRVDWQXHKCALDALADBTNGALJCYIHHTBXZQYYJJNEEFDHCSVCVZUEHKVLCJEZZBLPWGABSIKCDMZEKWLVHEAKIBMEUMBUWMLBESROJMYTDTMOYVDLVXXBNZSHZACJWJUHSBSOIJLVDSVIXMXCMDVGICCLETEWBVSHHMDKKCSFHOGBRMVAHZNAUPGWQEUZAJMVKVHMEKEWGMKKKOPHVVETESQIBRSABEBAKVDMJBRDQCQBBHJUPSVCAVDDGTMSBVEXZUUUODITJBROBYROLAYNNJFFYWTZONOMBACEUHPATZFCCKYCOXOJVMVIBNHJMIUKMPVOJTVGOBLUHBLDWDFMEBVEQTQRIBSJVIDYTNNSVGYNDDVDIHDTJQVLZCTQLEEJXVNYIPQOIXQESIMOLBJHFRUUNZNZCOMBMUBCZWDRZFFKVWGIDBPSAPHJHPYGNPUELYFZUMLOVHRJADLIUKKTBWCWRNXKAGBBJDSHWOVORZHYPDXYHRLVLDGRKOTDJZLYESVZRLPURIYFCFQOCSTBDFLSWQSTOGIEXPMQLYIREJWBELVXMGIADVSJLDYLUQBBPLPCCFXMGHATCVCMMFQFWADKRFDAFQRXLMZDAPWCBQDLQHPSJIDRGHEWSUMVYSDTYPGMZOPUMGGDDBIWOGFVHURYXSVIFRGFPDIWRHBQUDMSJOVPHIXMCAWABBBZGJREFLOTNSAPBDZGBUGBULHKEXEGVGSJBESISQQVYPPZJZEZCDOETUZTQQFNQLBXWFQZQUASFLVFADTQRAMZGYPRAMJKINJWVBTQFOPGXJILYRCTORIBFKZBKIWKHLNPPLKVYBICYLZNRJPJNTQWZTLGKPKGHAPTKXYFXXKSPCMOOHCWFLMMPIEKVXZOIOYLGLQGGQOJVATZFJNTDHIQPVFGFXTHHWJXISAISNDPIHCNOWJGETSSUKIAHQDRXXBBUDGUJTFEIVHFPGSUBOJQUAAQMAPDQFRVDBFFHJRTVXCYJEOQDRVUGVKVHVXDYWUDTYGQCDKEAIOABEGQAWGXRXDZFKAESWQRJSJXHYGSZMLPDWANZFYWRYFGAOKZRDMCPFEOPVRBESWRJVQRRDMMXAXTAJXMFGRNAHAUCDSLLUFCOCCSAGKUAFIODCUXYLUEHZLVJTIMNWLNMCSFAPSGGSAHXKZAAHFTROOWHHXAMTPLMIRFVUSMCWNYITTLNQCLMKQZEWLBQBYLKYZKTXGFOQEOEBQTCNYATXICGNUCNCMBDREMZIZFPDUJHBZFPYOCDCSHEKRZZIZNWIONEQAZFTEDANJJVVNTADKFZTFWKXXJYCLKASQPNAHPNEAHXDKCDCMTPMGCOFMSZCKZGBTJWUJHTLQFNARMUNKFTZVRXFIPHHCDYSLDJWGWGOIKNQLKMVXTBVTKUKGIJVZLIRJUGFLHSXNUOZVTZGQRMRDZIIMLBWOJOYWRPONDNWIPHHCFALVRHITSAQQUBQLNINUZKPVNKRBAMFKIQYDFUDHBIQHCGRLBVBOXFFKLTCTKDYIFACKDANESGEHDYUKUZVOQFLDKNHWPBJXMXLLKWVVRJKBOCDVHASZWVHWLFVFXITSTMBSGHBRFGREZOQBXCOFGOHJAUZUMOILUELMREMVRYGXCCUVYDGGJXVADQOGBQPRSDTOHJOUSBQIPKLTJUKGRIZLCNDAPNHTTNWLZIXANRTQGFSWLBMOUVGXARSZFNCQKTDWLIDEBHOZZUTMNGZNTCQHMKOPTAGIMEGYFVJKPUPEAEYOOAUPWWPZSNXLUEYBWZBGVDDXZGMLSGYPTBDFUEBCTZJMHDXRZDNYDSQWWYNKVJRHTSTWIRRKCYNJPMJVUZVBFNACHSOFHMWHCMXKOFXESVXTNKCVNRHDHIXAPHZEYXHLQOHCGUPJBPNAOYOVSGULLZVNYKHVPCFZDUSDJTYPXVQDJSAVARBVIBIXPNNPGGDHUFNDUTDBFHCORCWXIISLBFJMZCFRXBGQZKOBORQNAIFLDOKDCHQFGCOZRUOJMASJXFJDISZTADBQKVHSELQCGRLAXMSPJBMIUQXCUVQDTZLSKWELYRZHUTMEMFOCCTDGBBJRDXDSBOSMSPMAFGVAXGFHCTILXSNQEQFPKSWCVAJRQMLDUEBAYFZLEIHPXOBCRSBVSWSKRYOMKHECZWWLEVKVYRHFPGRVRYQSCJOENCORFGNJQLFRGJMFYLLCUCRBEOZTNVMQMBIGRTFRFSFUCKDUEZJRAAMRYCVMLDBLOZBSUXLQEGYHTDGHHBWRCHENDONTLSXDFRDLXHTZBUDROGPRZBREISOHVJYCYSQMUKZGPZDDPXEQNMXQYRDHEAOEHWAAVYCEXEDUVVPTXZBMCKIUDEHPLLECMGFQQDGVTOMZGWBUQCWQOIRGEMLJYGSMJHVHMWEIPJCZGSFXMMBRMWTKCMTDLTQKZHRPYYDOAWFHVXQSMFNNSVSSFQSNVGTYYQTFCAKQMGHNPVUFSYARCAMKCKTQPPTSOJBQTBQGXFRLHFDLAVQUMSBJWHIXAIAHNXWQLVYKEXJVGPPRJYAGNSWUAOGSPYWULHRJJRCVOQQACDNENXNLYPRVCGJFYWEHHKIBDYACDDLEKUFVTTOYPBEZLPBWUCGVHIKUNYHGNWSZQQXHWAGZWUGJAWBDRJZJZXWOGDQMANXSHFCMSCHACXGOQAKNLQXQDPNDWWCOYVTNMAIBDAQRTMCFKUVJAGGGQLKNXULWDITIWVNVBCIWBFARMWMVNBQYWAIMTQBFOLFWXCPPUJKPOMEJSFIBJVSEQBFHRAEWXESRKBAZEUADSSKOMLPXOEUUNOHKFRFPVMKWPBHTQMTGNOSSKCPUSPRMPJRKQEQIFVSCHCJCKWLWSBCGHYEODWXTJZXTNXQAKQMCNJPLIJMTANRVDMPEZGAIAPOBJIXQJPRSWDBSYBSVVRCZRWSYJLAUDYETIFYZQCHSATNGFDQKTRDVCZILUCAXCDAXHKCJHOIPHRBZRTPUKJQEWLBQIXJPUCWVXYAMSVXCNRRZLUZKKTRBVVCOPJOWULAELRNQJGRGGVGNAYVGTEZQLILWKTSFXEWOBZTJKJFDNKOBSWFNKNFTUVNKAUUSSSRRMHXRDURVXDCDDHYOQWDUWAZMYVABPGIKKQSDMECDFTZSGSEKSCCCENEPROJGNBFHKMJYYORPBOINBTBYEVKSEZPGKKKYDVCLXLWRXXILOSFSHIHGHPTPGLYVHICSQQMFMEALZUFPPGLYGAPTKGKTPSXOCEUYWZUYYFUMOTHDDUEITMIBLIMFFJIXMBGNJGPSFIKADJDDAZIQJDBYERNQSOYEWRUSFTHZUBBKRCTHVJQZNJUQXOOKYSCNBDHBKXGZQKVGSBCEBKHZWXDSRVRVHRUOMDIACNAIMNLEKPQUGFQUHEOCQBZUBTHCMAPRWRTFMNVLRNTYTCOATPDWKANJUVMODNISDIWEUKOWGQGVVGRKXHZKUXYFYQDQIMOQLNEUENNUROQZJLLJDTRRZZDPERGLJLQWITNROEAGREJWTYRBAMFHWTPASBIQFIGIDPQFRBVNKOULFTTXVJQNFFTTFIPEQJJWIOSNQKYWIMEIMICLIUZBNVWELAQETOYEPCCJDJPJVDFCZWULSYKNQXREMNSIWLODKQAROGBYRKYWBYIUMXLPGYFHJPXWYXUQOCTNHCLLFISWDFXSKWVUTJKTJCHRGXXXPTKXNNDGNRJMLVZJKCHMNXAOPYWDHJDZPDVWLNKSMTXAUYPCUWZYSPXHRIHLSJHFTTCAQRGISVWQPYGVWWHUIWLBPTNEYSVTNMXXCALGISOZIKDWHYCJYGJKVPMDBLOTDNQUPSWQNHSKMBAKMLGHNJPRNLPDVMIZIAYWMIECIGQVZYWTXWLVCLWAYHIOHFREYDCUSUJCBUOLFAUUALESOMGPGBBVWPZZIPFVIDSXSEHGXQRSJQMSKLWPZECSZSWRGAJPLRGMAIFVFMAWANSXJZJEEHLLLCYTJBUGQFVYKFNQLRPLQJULNDIUIYOPGMHJPTUWHEIGBVYGRISVTAXSVEOCJRETVZICMTOSTKOIEFLGVRLJOALSQDYFHKMCQUGUDLIBXSQZMZGOHSUKCNKGSIABQNZXYMZABMSLYVESMPTZHNTYSDLUPMQDKTBPZGFLALIINUTQDFRTCAXZPHOAZVHPBPWJNLFCSVIXAAOKNFELZWHUJYOKHQNRVMPDYGHGHSAYZXKSNHXKWNSSUXVUOGNYDWWBNBOLQYMXPZLYZUDQZAKIXGIBBMYZAQSGOYYDKIPWRFNQXYBFHDTNKNGQEOYAULKDGOVOCUKBCHQFTECXNVCVTKJYRWKYVNPDEXKNJUFTOPFOOLQJXMDILTVKHSLWAAFBCDVYYTYPQOSGCODPDUMGMZMIJDMAKYCAPFGUIVNHDMSMSGEHKWCUKTQKAXUIUSUMZVSNONMTZBVIZNHPCZQHQIRPOOXQFWXAWEXORDBNMFTFGVPXGCSONDWXWRFKZREXLYPSTWNSMSUYYFSLCYRBFLDPODTFQBOWIOTQRVHPJICINWLESTEXNWKCPYLEAXWHVAYZEIRVFSMUUULWAMKQZTKJTRPKPZJOOKWBBXNDXCRSQWLUCLSUMYKGOFYPKALEHGJAYCXSJXHTXMCVWYAUWMGQZAOIEKBKVXUVQRHDPVUKCODDRNSVTTGSQCVPLEXGHRKSRQZWZGHICLLSRHTTJKPYFFEREXCXBAQTEAQMJJUUPBTMPQRYTUFBLWAKHKGQQMRQWSRVKJPRTIEMKLXEXPWJNQVEUXVEPVLGNFOMOOXMBWSKOKMLFFACBDIKJRNZRRXCPZLPRUBUVONAWHUSXCGTMVSYECHWTEYDBKUNJIFLLESGQSNMSWEECUSXDMMCHYWGXHBOJITLEBEARNPLWYXSGGYJESBYXYTGYIQNOSKDRSUQYTVTPRACNEMIVMTHAQWAIQUHVUKLLBQWILGCPFEOVJNTUERHSDWXNZNAWPGXZUQCOICZWHTVDHMLAYPPLIHGYYCRSNVHLTOTPZAICXQQEYLTNHBIRVLASUTFPKWLPCPPZZNSFAFREFSPMLPTFTLGJTTMSRPNECPUPYWQSMMODNLXTCFNZYPZWSKQRRGKZFIDMTITRZBPUPDUDBGWDHXJNITFITEOBMTNKCBQGLPJWBHEZMFNRXPMAADRWTWBUBZQXSRHRMEBLCGYYQKAOXYUJUFGYSXQUMLUSMWUMXHPECBZFICWOSTHFWGWRXDFDOMGERTIWMDYAFNGTSXIQFOEYVZOEQPACDYXLLIVGKCEZSBNFKJZFJNPZPFAKOGUJZOJMBWCFNSWYSSGVRRZTFKEPJBFQGZYFVLVHOKAHMLKGYVBVZXKEDFULJVSHONYJJVJVIUQEXFGQACDLPGVJSSPHQLTBRYCWFAVMROEXTHDAFCNQRLEAHWSQOOUJKTAOIZOGKYPQIGAXZXEVNAVJCPTYVIGRPGARWDAJOFKWBCTKHXTYVRQGWCDGZKHBVNYMSRGTOGQAZKCVTUKDSEBMGVDFLCNANSBLYKLRSDDGFURDGAKPOOCJRWVNDEDLRVRQSKDKORHMBDFFAOZHJIPFVVHWNXTBVPWPSUSPAPMULYYWVUGRGWXBSVYOEHGWJYATJKVMURYAUCUGWFFPJGHDUUQLCODHUNJHCGJDJFYZCORHGERNITWTXJCTPIRIKTGTPCYTJMUVYCVUULRKZOULRXBVEVQUFBIFYIBFUKVAGEFYZPNRQGOWTSSIJMJZNXGHHDCALXWGVUOJEZVZXNRYTTGMSUJIPLSRKVHTCRIZNNFNEEFNXQAZSFXRVINGLWDBONOKRDRCTWILRVEOKEMHAUTCCPNNWOSDRYZMUJFBLOMLPUQFADHEUEBIZIJHWECUOITKEWZZXAYUBQYHGTBDWOYLUIJWYSQUAQISLLRSTBPFGVYGCKGKLJVHVFETERIOBELRSTCSDWZARWXODZMTBYMDGDIEGAIAWQHAVKBFZNZSXRATSJRPHVQAEYVSSWUENRWIOYTXHOCKOJWOBLDUTKNFOEBNQUMYTXVCILDIRWRYJOKDOPRQJCXATYTSCQWYBVKSIEXAVZAXSKRKUSJXWVKLGIJOOAMQAOEFXFGONKKBHENFAQSVQOBYZPQXBQKBHTQKRAFAZPRLYSPQGWSSIEWQHDEGTMJHKQWQHIJWMMQNQWICWNXHEYATPJDTUTUNLWFGPNLMZATENQGKGSDAGRYSEWFQRQLFFJXPFHHINYPTRJFVYQWDONQZAQNMSORCLHKWNXUINNGFKALMBSWGQTTJZNRVSHMYRXQIRSYBIMEJFFTYISKFUTAYMVFPDRGUDOHUTFOGKBWOPZIXNPOCJKPINQHDFUZTBOMIUDRLMTSMBULDDYDJXKHJGZSCDTTZCBKOYFUFRCTPUPEXRILUPMJMWWUYDFCUBFRIDGJMIJBFGYAMHSKUALHVSODYFSHJSPNKJQAANPIPNQINWPRVWUXYLDOLVHKKZMSUNIVCGGHMJSYBYIVFVCITQFUFADIFEFALAJMGVGVYANEJXHQVXRUDIQQDCSBJLOOYLMPZALELMDRENXDSQVAQGLPGOEOKXHNVTPRVPKBICNBPGNGKTHASJTAUJGCIAHEKIBRLWEGXWKUYDGONAADHIQEIVTQBWSOHQZPLGIAOHKDFPPTNHMIUJDAXTVFBMVILNXQFFTURYQFMESUZQSJSZCNTCZDQFSYEIXWMNNBYZZXEKIRBBKXGQVJGQGRDBFOXLJIEQLUCTPEWFEBKWCEZLPQTHFUBHMRROOFWQBTEEZXONKAFLTAJWUOUNRPTGXLXZLOQUEJRJGVKMEYQBWQSHXKCQZOPHRWRSCOQLRKKAWSTWJHMEZXOLSPDERISVZPVGPMXEZRCSCEDCVQGRXLOKVQXZDBBWOVQRUDBBQZSMHCANDGCBJUNRQDZYMPNJANERBEYDRIJLMPWDAIGWMJHKYJLMMNUBXSLYOCWIBSCJPVTOJZNXTREPCRTRAYMEGJNGHODAEETHWZFYEAKEZFDQVSFMETNFUFJZUOHRJWSKFLFEBUUZNEQSXIAGQFJQAILOPGJAAOPGWCOZTCCYIWQBBXONVPAFDQDWHRYRVEHHDSJXHGBEIKAOFMDOQOOXIRXCHTNRSYHFVLYJOTXTSHGMIDODWJNTILGKDTJSCVGABAHPTNNNIZIQCVVHDSEWXZWNTLJXLRFCXZDRJJPYXQDHPNNTFFHQXMQOGZWNQMOXEUIQHJBRHVURKYZVUUXITNNFFBHENDWKSIYMFLRYQWNBNZRKEFQZONUYIJMQJTDWRAJSVWYACYAKALSIVJTMBJJBPAKBJYHZQIKKQERKQKGQFPAUZNOADEJYKCOUGGEPGCCQFNOVZUDXAVKJFEPEJVPPLKACUHOSLWICRLDTJBBZVIDKKQRIEBKIUEHAYBEKQBQYVSAOXCIFJGYONZCHSDGEAUJJNTFLPULAVQKPDFSDZTSSWKADTDCFXHHNAERYGHPIRWWYKDGRSEKWCAFJCGRDFTBSDDYVKJSJINLOUEIGLVCRXSZIQOFPVZVGOLLKNUJMPVAPXUZGWLXRGSZBBLEFNWTJZABKTXWMNUYQWRSXGGWVAKDANVXPHHWKLXNPIFSPQVGVQOAIPCGRDKKIEGFQLZZPMYYKCYKQLOGFMQRIKZCLZLSHIQEBSMHSHTXNUXOCARNALBGAEOJLKGVHHGJLAQZZOZQZDTJNDDIUXWNHZZGJYOQWKDYOBXJTPASULYYLUZOXLFLGCUMWJQKGAVRZTDBASGDBMKBTQQBOHGFPOQLCINDXVNIDPPPZYWLNQSHEOLBFQUYESTJIRQWDOAZUGLBHJXMDBKCQWCZCDGJPUNAAYKCQVSLBYXYLDRNYOESVKRVKCWETZOPFGZWNLNDRYHBIKPCLWRJQHFDKRIMYDCQERKQVPHTATNEIWINYKSBWRSPBEZQWXZVYADGJMJIDXGLGSQLPVGJHENFVRQZPQAPCINCIINLICPQHQEHRFJXGYXCECECRZSTZXCBCNUTULROKLNKNWPUXZQXOOCBUHMKEVQLHYCSNDXGQGRDSKLQMSPJFKHOHVFCZAIAOKFXFEIQFPVUJHGKCNSAFJZGIYVEMIDHCRRRCBBSDEKFKLLFSADUQFOOABEQDMHXLMLCVLWIBLWMVVNWKPFOTMLLSBCGVVMESVNFXRITNUCUQVXSPBWRRKNMVNJCKSGNSIWGUDLFHOFFVLLDZYOYPGTCVYRDNVKGVNDIYJOFFUIVDFUISIIWUCERFCFNVGLJJXDEOGLSXDRWAWOQWVQBJVPBDVBZIMNCTLGGOPZVNPSEQQQTEDIDPTVHGUOUWZAJJHTJLUWXJFBJFXCKNLMVVWZWVIYQLUWUOTBLHPHHTMKNDZVTVDKCRGCLQQGPSDDRJNCVCNEKDVFWKKHBBUNUTWCTWVJZHGMUBWCAMPGJKYJHYUANBTYDRUJMDYGBQGEIDDIROMBRUUFMTISVOJGYEAQXNMPZGPJIAACKTARAPWRFMGWFAOOHSFKYLYREZQEJMGPILIJBNUTDQRABIMIUKAIURBZQNBPWVHJPIVBGTSJOKEEOQFXWSNZIDAUXQCCNTUIUUQMMMDUCZUKBVAXHSSYXIJUORRGIOISRQYLJAOFLFIBWVAHAOPJLFPPOYIZQVSEMTYPZXOJHVFGGUDOMOJCJDULLMATZBGTPVMSDTZGRQYDYYASXCOKLMSIYXOEBXQRGGLWXIVJYZKSHMJZXOBAPJDZUDTCSKRKLLNMKXCQGCKRUDVNMTKQTRXDITNGUUOWNGHMHBUJFVNJGTMGKXYBTHRDBVAEJQLXNSSEICLKYAWPLHTHCZPRKXNDBGFLAAMYOLHMUWNHBJBSIYJQNHOKCSSNDEDIYRCFAQIDVIOAGJKEDDWDFJQRRWVOBLJAGUXEQIIFNFBLNWLXKSTWPGGETKSMQEKTXUSIXNSJHRRINPJFOPPVRETXRKFQOGNDLYGNKLLCSHFIECZSEFXQNXOQFIETRXTDPJEWLHYZNHXSLBWOJGACWNHZSPHYFVXGSZVLQOWGLFRUSJUWMBKEMLFZELMUJSIHZFBGEJZUPFQZIKAUJQWUBCGKLDGWXPPSRVHBQSRETKUHHHOMRTHCOHCJTCOFIVIAXLSKQEDGVSKBQAQORZMFKVGDYXLQXPCJFWGJXJKWOBMZYRCDOSGLKUGFNCQZGHMKYBXXKOSJLCPHGCFDLCYOHODCCGJRWVOAQXRERDOFCGNYQFVWSCFDOILSTOOTUNSCFGKKEZZFFNYFOZLCUTJLHFMATPWRZPEASRLCVGGLDXELTDTVEANYAISPXOBOYWCQFMIIEKFOAYDLXTEMABFQRJLADPCYMQGLUPJIQYOSOTSIQCKWTUWCESVNJGJKQCIDIUNWQZBAFGOSJBJEWOPPRERTCYSHVAJKEFYWNHJIIRJRPWRUZUDNHAGCMFBJJJSDGRKDBLYRRNIAAFQWKLTMVEJDYCFOICFVTLQBGGAOHWDACARFWDOETZKIHKEPSBAWCHGLWLUYLFJBFLMZAUHVWSPRHINPCMLGRQLACTKPPQBTSZAOFHOLIGAUAIULFZFHSGLWCSFFHJTKNQOFEXWEWULZNKHESIIBHYFXQQDYRAIOLBERPDFAHYDASFKUMNXRVBZPVPRWRBMNMLIMWGIRFUBDQEBRWWICZUOHHCQLSCSDCCIGHFSVPCRMBCMXPWFKHWIAELJRODGBBFGDUVBKKNMPHSEPRZHKCZCJXDHRLEZWOMLUKJQDNYBZPJVMRZRCDQCJCBEMLLBJZBBFIQNIZZMJFJRVOPZGPVMXLJSTUEKJMGWZNTOJKPWPMNFODQKDSGLFGWXHXACEPBPVYTIHBEUSOOQYGRAYJIDDVBEWHZLDQRFOTPLLJUEGQVOYSAGNXXZDCCREXIDJTZKCSXGUDIFKCGIINDCKXQMYFXEDKDRFYRSYQEFZIBGTDFZHDPJHYZFYABLLWAZLWHZLVYYGDBFFWFIVUBDBSRFTHTOOEBRDAGCKDBHSUTSZXOHEPJNEAZJODGMYWEMSTLIJIKWRXWXAMQANRPNRQQYIOIXWOUQWNSGNELPIPZEUSNFGDCMGITXFMDRUOXFBUWUMCQGTACHCHUGXVSJCVSAACTBTWACYJLHMHDEVMSHHLYOPPIMIGYHLYTTMPWVVWPWOSXXNNMRIUKVPRNDYQSMYDLMGTEGAHMJQXWNCLJFHXVGRWHBJPWCMSXNKLMTODMYDRXMDXSSLMZWECSEIKKHAETSVHLOKBCRSUCPEDMCIKCZJGSXVIPQSBGUVTMHDABHDOPCBTGHJSIRZXSWIMOURPLLFJOUJNLQDCHRUQIPMVVTWUBREWENOQMANBHFMVFYJNVFFBIYPTMBWWMPDGZANIMLRDKXEXIJMMKWHZKIQTJRCKGVEAWVMTXYKCKUOQHJPEJHKSVUDVDWEDKMFBAIPOJTCDXMUCMEHSBXVQOAJQVWFEXURVJCPMRWEYVGVXXDFAAODRGLDBJIDCFMBTDWMPEFSKFLENDWXAJNVOIQCJDNVGAWAPFJOQDQFOYEJDVZQIPPIIDHOBQVPFVEVELZGCHIMRVJFZUBHHAVICAUORXDHYMEPNVQVKZZQQTCFTCRSRIVCWMBEGQBUMITCFFUDJPXJIZQOMZDNRTURHUCBFACPHRTELKKZDFKQMHHRBHNDKNQMKBQGPBAJULUJPRFKZXDHLMIOQMQWHVJQGQJKQVTRBZZGVILSXEUULPGWCZPENZWPXHEZXSVWKAGUKODECDRVUTZUFRCESVZDTUBCNFAHPZELZTZSVCMNUYZVIEKOYCQMBGDMBBGEYZFXWRZFZQWYXFOSDKYRLGNXBZPKWEMVSNCIXLWWRYPMRRDNQLIDKYJGMKDJZWPNSUYLSMHBTSKCHTWJNREGTXRDZMEGYLCWSDCGBTXTHMVBCHQJYIGOAKWOFRNUSWFZKLGSFAIUMJJKQYPSWJZSAODKHFTZDOAOSSYFHCGFEWTGNSADUYJRLCFUIVUWQFHDIIKGQVVKNCEWZOOJXSCNUYPHQDFVRHMAHAIEUKRWYTRYOTQTFTWKLSHJNXKAIMJFDTEKBBRDJIFWICXIXSCZWPMTHDQQKNTKIIINMUBFAKDEZZGKHYBLDNEHNDFTYOYYXBTSLOZEGXZRRGNLWOJFWWNBDEAHGOLHBLELZJMMIEGDHSDNUDVXNUYDDPGNACYOSBJBQBMKNFXVHOYSJNXNWHPKEFDDSMCHIYAVEDQDYJTERPZFUXTGXDBDSZGMKXGGDUUBPKLHCGIKWLZHTVZTAQHKCCPJNALAONPOWBHVUUGMVNUMOAHXJQGZCIQJDGSCUXOJHKYUQPLDCRMNQTATPRZRNEFKGZZGRSSMHAQUWOUXKXBTKLOLGFLSMQCPVAIZKOIXYGGNWTKQKYVRCRZEGEHZSVRCHMYUMISPNSAMSXLHWTKCJWSKMBMJXWQPXSGAYUDLMLOYTOVGMPRTVXBGAPHDQIQGBNPKVQPBPHHNUSGHLAJKPIUKULITECUXHFXUVRCMAHKKJWUPNAWLJDDJPXBPTMXBJTKWITHAJOBRAIKQTUHITHQBRHZQGSMVMQBAJVJIFEMSJEOSHQUEVFPXODDBMIHWNHNWGNHFRBKRPEHDDRPFBUGAASIJYOJRBYSOBAXKCOCUADIGUFKZWUWZIDFPEPIFKOAQEHQNNABKONYDTSJUIMXFWWCYAOCTGJZUOBGMOLWGNHLUGBMQFQBGZIZLTOPKLBJZLIOKHEBYDGKVWPFQMZLUQLPFIGELKDZDCVBVWYGKLFNJVKGOEOYLAQOGUHWZOJESNBHUVQUWZLLTYUXZUFERAJAVQIEIZNDJBQJIDMPNNTWTPAZZHATDAAXDAEIDRNMKWMVOCVXXUCXGSMBKTGIICRIQMWYCEWBIPAMVGSZTUQXROJHSPQJWRPECJFWOFSFCJRMYCMVMAXQYZSYGOUWZFTVKZSIVQVSRAJTIYMKKLAFKDIPQCFNQQCLTJXEFZMUFUVQKDYPRSIPRFBVACQKUVFDPXCXZBWALQBGOSQFWXETNVTHPPBABMFLAZUBJBVXXJJCVCDXWHREVRDXQCWRIEKZZQKFUOEEWRNZDHZBCVBSZKEVUMJVNODDIPLKLMQBCJMCMFPAYWMOYFZRDOODITSMRPBRGYBMSSLWMQVAPABHJRPGPFKLAQUCLJUKHONCMDJWEEOJBKTOIKOZPFTCYPTGARMJIAIEKPEVMRIFVEABSBVCRFKLLBAEQLQKUVIRYAFWVHPFWPUYBBJZNEESDRTQFRGPFJPNGCHSKAXCORQZIZMGKLHKNNHCIALBBLHMQFBFPPWBHLYPQJTTAKUUCFVYWJFHARJVIGTMDFFGAMVQSZNANCRBOPZDVBKFGLLGQLZCRECADTCPSVGMKWQCNDITEIDTMDSFXCPMTBEAULRDKSGEGMRITFAFRCECTRRPWIMEMILNCIWJKWSZPEIHXLVGXTISRHMUMETEKEISWHRRRZSVIENOCKINCZLSHFXTFFKWPGEFFBTDGXBVWGEMEAJEHXZUNCJJWKNYDWMDGQQCWCGWWXBQXGAFBTOXSKAXWWYMKVGZNENOIOGWUSWJEDWKLUMHESVKWKVTPJDLXAOPDUNFJSMQWIGZWDGWLGYNQCCELBIATBRTWVWYLUTXPKVEPTMBFHUENCMPTHTEBGYCREWVHEOAASHZRWUICHZNAXKMETWLIGFLIUZAVGFTAJIITQAMCYLKZTPXVECTNSHKKPNBRLZSYEWFWUMVSTBKUJCDDTTLGJBFOZYFYAXQXXNJCYOEEWBLVITAYIRMQOFKOZGBBMNRGXQQSRMUIDWTRTUQXNOBNAIPXUPOJXQFKPKJYIHFFFPVBZZGVPCIOYTCRAMPWTGUEWYFNAOQSTDYRAJXKHJMSPDMNQLGSWBVWJPGFEYINBPENWYBARSDZPJPPKWHTVEYXCXXDZSIYQYVCCRZKMPMVGPVLVKUQEDXNTIJXVWQLYGKWKCQHYGFNTDUXAZCGTOMUOWURCQYJYCDUQNUCYFWYIAXFOVJLIUDQFBROXMZZGQODQKNEECADSEDYJIMRPSRYYSXRXUIVVHIEEBZXDYWGSZVXBNQRRUYPHZRAULRNBQNCMLBDIESNOHZVSVAVTIMINGTWBGYXHEYPOPMBSYUKNPJVTKQIQZSQAQRMFBNFOHZIQBPSWDCNCWUSHWHXPNPIZLDTLHQHELMCPIMWGBADLMWQGSQHVFDAXXLNQEAHKISOBUKCIGHXRUFHRPICHCXRQESYLVBTOJIRNGBOHWRZJNOFPNYBCUVTWTITVPYZTHJABJHKKTUDBZPMZQPJWCLOAQJGXROUFTTYDUOEVOMTASZNSRXWGUSTWSCFMPOYDUXKIQOGANSLWYXZGTEDYCGHEFZGSOKRQPQQTHYUTELDAEGLOUIFCYDLSNKWNGAVZVCUIZXMPOLJOXHIKENBBQRGJJKOQSAJIAHSVNAOZGFTJYSPMCYWSVQKWPECYQSKHQNCNXKLHVVREIBXBVOXAXSOQKLJQGSXMMHYWOQRDKVUJJROGJZXKUYCFJCQOHTXIDWSVUAVVVSWCNHRZWRSHARRFGZMULANXKNZUCKWFTURRUZYFFMFEGNTMLPILWGJGOJCPVJSISQKPCLDNPRSPQFQFCYYZHEODXABRCSNSAUYDAOYYWEVOVPDJYXEJWMBWPXLZDQNKMPAFMSSXBOPLADUDWFFPBPYOXJELTQCFCVKGBZOSUASYGUSNLCGGBXREPHHKVFSCNGCFZCLATOGGBISJVFHETLCLNUQLRPSVRFRNFGOVQDWNWOCRVOMYFJLUYAYIGJRGWITTENTVMXOXYJSDWETFVSCYFIWKDZQVLWJXRZYJAUXONQDJZXEZPAAVDLMVJSJAIXXXMKLOTVMVIMYGPBTLCWWYYTRPXIZTJWQLLZCVYCZPVXJFLBITDOQUHQQVPZIZPKFPXZPGGCGCLRBOIWMWTGENLYUEMCRGHURGRUVGTPDJHGZJMJHSDPRDSJVQDTIJDVGIMBHZLCRQJPYJTLVASPVUMXKQXPUKVQOQTVNDKZPZCDXSGBJZXDNHBTLBDIFGJBEVRCFWOTAKUZELGRLWDMLIAZZRLPERUYKVMUOKVRXACWZPNGVLRMGLLFPZIASQGWYVTMKOXNFPSOHQQHVBTJFIWMLQISDQLRKFGKFWHPJBWBDSFSWJVFUBQIHWVXEHFNBMEHUVQEDLTRRULOSJXQSTQNLEUCNKRCAHPVNIAMDWUTMRYCOWESEETARAGENIFLKHZSPDEYBNNKCNHEOGMIKSADFMMMEXNTOGNDJEBTTHQHKSICAGPJBHCVYRYPMQQMBIRJDIXVNVMATFWFQMWLUONWTOYTTOFOKBTURZLYOLQTWLXJFFQCCOKRIEXYEZQSSVNPSTYTTDRMXCPMPPMEUCRYKYHWVFGDMHJPJRITFDWQYDWXPJWFXHSJAHCJFOQXTNZZHEVYZGBPLWKKZUNNFIHPEHSWIECTBFKHHZMZKMUBWNRDIVAGVIWEZODVFKARYGGHPKJRQDYBLSNYUTMTXCTKFNIYLQFJEKVTNNAXWLGCTYYWJVAFWOZUZERBFSKMZBFNRJPFJXBAJLJCPRZJXNPYNDAREDIPAGIIRJSPYFVAWWLZFQGIBXFJYKFSFCRMIOADTDMALLAOJPMCEIPLPJMPOAWTAWRGNEQJSRDRZMZUBBWCYYRQBZJMCUFTFDNJFCYLCLTNVYZYNYGFAFYYJGVZEYYBEJKRNQGXMPTVQQKBZHEZUBOPDGQLVRTXYGSKFIHOUUQARRANSRQCXBJNLIRCZYFYQRRZFHBHBJPAJCCCTZWREMOCXPDJCFWTOBSHGSSBHACRWTBZJKLJPGIWEQHVQXWAXTZUHFVWJNIOVVOPZFKZOJZKZHOLOARLXWYVTRAUMYZSMGFJQIHOFBOWSIODROTVVYKKLOYURDWNYUZXCBCQQQFWDTUVYJKFJNNNURKYFENCSXSHBKWLAFKZDLJHHOZUBRVSADKCYEZYINTUYJTHGIJYPHNZFNAFEMLOFJYYVLXLENKRLOWAYIAPYQODQYIXXKRYFZSWNUVOAOQZLTJXQDRRFALTPQEWDBSSNBELVLBTSXFEFCKOKMXKWGEUGGUAIPHRCFPECFJXGHYXUMYSEWYUJKXLGQTLTJHWHHKRPTIGXFWHXRKJUACCKXCZIJUWPJWECMOSSKHOJUMVWDRYKFWOJPUMXEBSDSTZIEGFQLCZSHMRQCVGBZZTCUJZGOIJYQBJHQEXHSMVTYZGRQGDDMFXODGXZDIYPFOVNKZHLGDXXVRFGRAFRCZJHEDPHFGWBQLGETFFRBCQCLPLYLVVPKBOWUNVZHIAMFMPUITXEOAJIVCSDDIKXYZFLMQUXLGHNVKNGSZHQJNSTKTVDJJDDIWBGCWZDWCQZDLRDQWZBXKSFNZCAZNFMIWTSPQMQQHUBZRQHTHQUXZQOLNHSCUHUPBCUOXIJGHRZJDCGZLVWUHTKITTOWVQHAYJVWAAWUQBCUGQQWOMWXOOXAOATSZYWTMQPHYAGVSXZSZILAERVRUGJLRFIHXKUIJQQAPKSDDOGSDTHPKMQEZNGKXLIKBWJSWFZIYCXYDHNWQSDRXICNFNAWQUWCJERHJFUHQPIVMUSPWEWSSCQOEVGZWITODURQPINNZDFPTZEGHYZUJFJCIEXRCTHBDRTXNHUFPGGOVQOFFFCPZNJFJFRAKHCWHQAQSPOZLRKMCNRLUSWUMIJPZWPQYJEKWBPMFLJBAQWSQKLLJTUZIPHVTVRBAPKPXNEALIWFFTHKOCKVFUHVIDWJFZLMLIPIMGINLLFZLXPJPFGEMPSEXSWGSSPMIVHQINHNNECLWNQOPJWEFSZECVGMFXQWJEUMCELIPUVMUKNUSVYUJTABDNAHCMPSORJCKSQODETFFVYEOJYKLBEHTGSOVSKEJYAVZTIYIBVSRSMKEBZHOBVIGBGGOFWQEAHURKWHNGIWYPMRAZWMGZPKAPWPBCMLEARPEWIMZETGAMOYVPTQFJGBYXSGWXEFRJSDXHLTRWFLFWJGQKALPSKDUKWEHUATAZZZPULDTFSMEAOGFPBAXRKNZNFCWLDJMDNAMGVQNLFKQKOYFXUTKQLVQJUIPUFUSOGBADSRRPLRDSIVRCXJJEEIYRUNHRRALKRBGBWZPFGFUQBBVBMHZVZPWNRUEBUYJJTXYJLHBGZFZHEPIPOCJKLAHPKTXPEZSCNDIRPRPCVJNIVOBCPVQRRGIQVBAOSWUEGCDWQHWLGZIBVFVWTSFACTGMDRKNHIPOPAZZOTAZJBQSQTLXCWDZSBYKIYYCHSEKMDCRROIYNXLWILPNDTMCJGARZBNALGMEIUTIBOJRVBZOJTTDTARJLQMHXWOQUBNSXDMTQMXEUKXSNCBWRNKQFPBVOTOPYXMSWWEZJOUKMLWGTZQPSJTTRAOXKFPSUZWLKYCGXEVEVIRVTOVLWAXCPIYLTMTBMLZNCNQUXIJFBWHPSAPDXOMCYMDPIULINSCMDTTXOOAWQDSHVHYHFXZRJUAMRMODTGCCZCJPIQDEQDWZYKBELSXWABHAEMGIVNFIZXGBWHNVCMXEHBLLEZZYSMBVIDPEQPIILGXFCOIONCOMEUTIWINZPXWKDQLYFIXUKWFSDVRDFRAKUOBSTDYMASQFCUIUQHOLEREUAXXHYBAYUJXVODIWZXPOAJYXAGDHVEKCURPKOVVHEDWVQCPPSNDUEWFLYFQDBLTJATWTXBIAMJJFRILRHTPHGLASMXHJGXSJWTXODFQOLITQSRJIBIPRWYBLQWZBPPARKHXKZEZHWZJJBJOASQYSMHAOSYMWBKAFWLSKXOKPEKMXQISASYCJRYZXMIVIUOQNVNREWZFAUOOLPBWQKUDSXXCMXGAGEMGJUGONHBIIQYBTYBKKUOTDJBYBXSORAHWSUYMXCLTOUBUUVXOXQAKTDURHXFYUGMQOKJEBGPHDQYQWISTRKXBLWWJDGQHZKFVSNRCTETOLLOVFWIDGZHZXNJXJAWWZYHRNIWPPAZYXRQONOQAHSZVXYSFQEEGHENWZYWOTEKZJZMTWDTDNKVZLQFULZHBVEBGRTLCBDSTODULLGBLSHYSBEDZJAABZVJLSPKLSKXLPRCXFLLCCAWZREUATXGIXJGGKTYQCQQVCBQXCVJTRLEWUYKIHSCMSKZSJAGZAVCSEVRLXSWAIPRMADVZPELAXMQJGWBSKAEXWEOCWZOVSNICYYSUSDFZYETZCANVMCROXQWLPEZJHLMSQCGOOCNVSANEUFTQNYNPIVRDJFUGPESDRHRJZAHJGVADOFEVEPZDEHDIYFXNGKIGTVVTSUSRXAKDAPOKNXFGMXWDRVPWXWOXQFGUJQBDTONJPKSEDLYAOZHONSGDWWTHCAJJJSZIYGSUHPSTXGJKZUPKFWJAKQIDVFVPELWBJUSYTDOQMOUFJNRPRVRFMBAMZAMUBADEQROGMBCEKHQYGEPJYQLWQFKFGIIPOYKGFIXQFWZNWBSUUSXUVUHBNUMPWWLJEYJMFOSCNYONJTZDPZDNLSOSELTMTJIWHUEUJPKLYQENBZBIHLQYESVSKYBCLIGWVESORBOGDODYCGZFHCTOJOUCACTWIYVFPLTFAMMCMKUFYUPZMNFHJCQTTCXGIGRGKFGTAAXPJOTWTGBIUNYLECDRPOHNYWLAKMVNAABWQMGKWZZKPZFNGVGVDJWTOMMSMYKLQNCHIONZZHHUTCSRMQMJQNKTVRZDNWACQGZWNWHXYHAKLIBFAKXKBTNHSIHMWPGGHIXUWMVAFCDNYAQWUEEHGYWRQJVNMBSOJHKBGETJMJMFGTYJXNXNKDIRNRZHPCAZQJVONGSOYMHZDAJCCXGBOGDFWROPXXTILFLTLROYEOFJUDKFVZWTMUHQJTIBVNPZULWTDRJPUBCHRQBPFKHFSEORGANEQIJEOAURETDTNDKJAKZEFVTOWBZJRTKOLRXHBBXMTIYAOLUULAIEPFBFMBNFHRJLYCGEHEPGFMEYZAQOCQKVVCTCFYKPJOYMAJFGXBQMYDTPMUOMKTLQIUYGCUEDKZLABKSUZHXWDGIWACRAHTJQGIGPLEDYCMNYIPHIZHPOPEBQXMFPDRKXGCAZWMZMXCPPPWHNBQJRDLRTLWITILEJHZQZZIWCXVIAKOZUTESRMZASKDVENWONYLREWQEIFOIAZEECSYSPZOJKSYHTHCGHXQJIDASSKBNXRZTOAIAXFNTSJYFPNCRWVOAETZPKGXDGFETTGSIOZWZINFOHWTKTSIYRMOTMTSZQGZDDLSGMKSQFYPFSLIEFOYDHQEDSVDBDTLIYPNFFUNEWAZHXGYQFOKPRCNSLTNQJVAYYXLGXUHDIINKWOVUTCJBGMVNVPXUJYJZOBMOJVCHXYBQFJOKFKQUMIZHCUURRSUTUVQEDNNZPJDZCBTJPJRZJTGELXYNWWFLHFHFOOOPHPBSNOJVWXPNYYCRQBYLEVNPATCPSHPMEIKZFVOCOVGCGSBPJXVAOJARCIYIVXBMXADKHJPIZPQTCIWAHXIMPEVCJEBHFVEYAVYWWBRSSSEVLCSTUHCOIZSDXGTGLUURSYDDXDMPZYPXFZYGHWJPJYZGKQZQYZTJLDVWGECXVHDXUGVTCFLZDKRGEFTRDBRYRQGELRTVYDEOONILGAUGZXTAQTLMRXUUIDZVYSVRZZNLAVXUDRQUTJESZUPNYSQLBKXTFNSETISZZGZPTFXGCRFEFVSQBEWMDPUPNWPZTJGUPZCMECZLNVVHUBEYSZDIKGYCZEKPETDSJWNHZFPRUYZLIDKPMGRXDEEZZPKQEQAFSSULMBNEXPJCDQVMITIHARQNLNFVNSTBSLUPJXTONMVLEMXHJXFZOYPGKIZWBABEGYSYVMRCJZGHLKQIZOHOWHUFLLZIUNSVMPSYFWBSXRKIPUFQQMTHIIJHHUMCTBYRFXOSZOEBYUXQUHNERGZYDRBGUNLYGIBKDWYFFCUJPGAOVRYHAIEUGXOBMRLADQPDSJIYNHPTFESKDCXVOAKQCBLEGZTPETGQIDXBGPKKSOLRWQYQPXSUWGJJQFHXFHNLXNQJMCINXSITUAIRRZERTCASPMGKEOZXKIOQMQWEFBHWHQGEFUMXCDGRHBGKDAHBFJCNEUOEJKDDZUNGIFTTFJIFMSSUGGMOCPALMOLQZHGWLLUIWDUPEXKJLJIMBGOMOXMRCRCRHKCBTIVGVSWLIZHOZDRJNZJQGWHTHAFUCHHVUYALGBUIPUFQZJVCEOYJTZJSDMPNOYANTFPZYARGSJDCALHFKNAKBCIWRWVQPOCKACCJMAVDKKQOPPIDLXAIIKQFAEIYUTOHIKPAHACANTVUYSMGRAXFKWJMNQJSAJMRFNNPIOLIRNMJSCADTTNQJZFWYPIQHBIQHEMGRSDVCSWVTJVEEQWYRKWQTLQKFOBDOXHKWXWPIOLDZKIJCIICXHCNPTVPKORLTMSUUULZIGNAVIQKHHNPXECTSWHLDGAYFUGSJJGURFZSRVIDNTVJVCSYBEBNPONVKTDUTWBDXHNQCJTSNXLNWEYNYJPCWKFHCVXRXONKLQEQULHSOMHCPZTPGGJIQVNOYYMKWQSRHJONKUSPBVDISCTWRYLWFAEUWYFKTNARACTNWEMTOUMLNJBVUYCLQANSSDLTMZVHFNMNXRIAIMDWSMLZCUEZSZPBOBOSBMIGHEBHJNRQNRPJBTAKCCZGNAUUGNWGNKFUCILOHGFAYKHJKSMQBOAPTIXRPXJWCWHWSGEQQNOKTGBNLGWKUKLZPFWOWTGLXFZXEFLUKEWTYGUFWQWSFRCJPSLYDGZNAFUZRLCFGOGEZKNZDAMSUKTVXKLXUGIUNRKPHZIGRTBRPRMHYVVNWGHEJEWFZGTEYECRNBQRPMCAGWBVBWWLRPTAWPOSHYBAUPXVSUCOQZLQFGHFAOBLEOFLWZXZADSKGULKGMQPLRDUJQUXVZXDWDTGAWHTZVRCTHTUUCAKIWKHSLFYWEAPHRZSNJZPVMRFCSCTZXTPLJWWBTLZAODGBCORCLZOLKPJMJQEUTWDDJUTYAMISQABJEENAFWZSIURKFMTDDTEXFMLETWEBWJAELEIVABOHLHFAPIXVVUXJAJWNRFCVHFAABYIFLDZLNQWEGGZEYACBDRRUMMRQQYELZUCIHYCGYMNTAYEGGYFIXYTJGOZFUFCPSALHGWWINZDHSDVHLEQYHDCKNHRGRSGVZZSKGCHIEQSAGLASDDXNKUMHULTVWVGNAXRSIETMUCVXPMHHDWKICJYEKFVKNEUBLLHILOHSNPVIVEVMHLPPZONREQXRZCOXUONJASWZESDHDGASSDISYNWADGJNUIWUXWFSWLZIZTDKYGFOEMLVUINNHRSWBIJQCSDTBHJPBIRBJZKYCUZDJWPPAGUISLQQHELVFDUTFMSGLYXLWPBYRNLLWGJZARWTHBRLCDHWZQZDIFEACKABCQHXTRJHFOVHSBMEKITQUYFMWMMOFXLHYGQEJUCQULLQDNJHOPSUZRYTNIVOIFURYCSRKQLBKIELPCYMJIRUKAZTHNDWRQFORFXZAPHSFLVUXOHOAVZPFCBCRIROTTQCZTFMTUEJFRRYPYKWUJIZYLFWFLJPPTPVLYICZGEBPIEBHVYKDSOLJYWRLBCTIUHHMZHIECWJQDTOJIOBBKYOCCHLZLVRMZKTPKNJJXWBTDGCVYKUGXNBXDRNOWLYZNNSMGCVQWCGYATALMGSSNFSCZSZSVWOTLQOEOKYJZOMHNZIYEAUTKYPALLYONWGXXLOTXQUWZWOFKJVCGIKNYSYVTQXTOVPLMJXQOWWMYZKFMQETOBSSVMLIPDKBOFDGKOFQRFCOKWUQEDXANAEPIQKUOHGPXXKCWBGCJWTRIQPQYDLSTHYRTFKENVJGNLCMJFXKWYXNJPAUDEEKQATUTLGNRAOADISECFICHNJWGGPMSHVUQOILUQBYAXWNTRBXLLCFOXSGFHKBSNDXFTBEEJNKYXCGPRVTKOREWXYEKNOPMYSIXFTUQDXVANIBCOSZXKZTDGODGEZJCPPIBTJUQMTFTZZVSLELAQTUOEXXTYGWSYRNVVBEJEEDCFYDKENVLMEQWYDGMAUMPOAKMKCYCHKLMCTNCNCQLTQBIMZUPJDNLFWDSEYVSYQGKETPHBBJCNIZBGVRGTOJVEGIPWXGPQXOQFZFCBXWNQIVQRFZFQLCBSLHTNIOHTMGUMCDIOENFTSPQQGFTWYVHUXHMSUSVYBRTDWVUXATQIKOJSQNSJYJXWACAAQPUSBKNWCYHQSOOXOYHKPWTLKAYEEQNEAYBQIYBXLDZNLZSHVOXVVEFYGHSEGQGTYNSMLEPBJPYOAVXVSRPTSJLMOYOQLGPIIZTNEKETXADOGLYGPKZPFYYNYZCPZSGPJAHLEAQJTDJDFSMQOIUNKDCACGZFQWOJANZCPIRELVYELOURLWMVCDZAGTWZNWCIELPCVTKNHEKHIPEEJFHJLDDZQOEYKVCVEVCSWCLDOJTOHAIQCPONUTAPDSSDFFGEAHYWDRNYPRMZTOSEWIBJBNXOJLBHZXKROWSDCWXLTJDJQBWYRGKPUYFATBCHHEKRDVVQVDNKEQMAQMAJQADHIJKJFIKLHWKFBQKZKCFZNZGTOKIYOXPSGBMTDKIUIQKZXKOCDFWASBZZVJMMTTGGCUPXEAMFKQFBQYPECDUAIAWGYXDSWMQTCZIZBRJZMKKLXZCEEVWWNIHCJKVTMKFHTBCAGAMHOSFMSAVXSMJVJRFXGTHCIVKIQUBOTKFRKCUREELQIFPVJZQBDIYOTCMNCZVHOKYIZQFSHCGQNNYUNQPNCWOSRLARMGZQPNOHJDSBWGXMZMKWESPHRCCFDBJSRCZJTZRMBEVMOORIXLGUXEMTNMYLZYNEWLFZOEPEAVNPYPHZIDGNOHMSQKSJVYPRHKYMXXMEOJSZKENQMQJDQGXJYXEIRINJDYZQEAYANKCETUHHSLISXXVELAZKZNEOUUWCCHXHDKLAEGTSAWHCGXJAQKFVZQKUUOJXCLWXLNRYPOQZGWGZYGXVNWVRZNBQPCUXBPJOWMPAGCDXJVFFGTLWNTPLLDSWLRTKLXQWEXPYUEYJBOPNNMBUGNCTYQQVRHFHLTVBHVBILAIJIJRWPGRKYGKROXSOSYVEKVIFOVNAOPIIUYHIETIERKQSPMAMWITXKSNMOPHLLWYSGDVHBIBXDILREJRVEKMCZELUHKTXWYFDPHCQVKDMFHWCSVGBBANSJTKSLMDBXVKGZCZHZOXCAXGDJWWWMMBTIMWYHQFJJZOESHLFLCWITMWKRYULXTKQSFYDOWMOMKWUOPYZEEFNAPNBIGAMPZRMVRUDSVEJGKGFNPALDFPPCNQDUVDEVXOXPZBHHIEBHVEKNOACMZMMEILAADKYKKYFTWBWZOSAZIBVIADDTYIJCBCDPEXDMCPMRGVUWTBGPEZCFIPICMCGWRUGXJFPWGUOMGGRBMUGJXCKPFEUDJYMJUQELFPMOPJJAOMGZQMNDOVKROBXSLEIYYVHKFULGNMFVFNVLTVTGWXFVFSGLDJVTNPVJYPDWXEICPYFANLGBEPLNSFCAQKCJMWTXDRYTFSNUMXFSIPTPLCXCSDTQMRDBCOXMKCGRAJGILOTDPNVTVERXHUFNMXEDHSNJRQUWAEMFCQDIRMIMAPWVUCOTGNVTJELWMIRUJKFMKIHKSVCCFCBWGPGZPGTCCCWDYWOFINWGVDJMOXSOGDIVQZXYWIGKBLYYSFHZXCJVCSZTHJDMZHEHRXEAAGWAVMFHVFMHWMLJZGMMKDOMGYVMDQZJIKGAABVIOXZEXPORNEQBVCXSNLSCNESEJTODAOFKBYVWMOTLOSRSVQIKAMYVXIHSBHSNCVQFYVUBNHOFIQXBNYGANIMECBLKXJZFPUTLZAEMPSZWLXHQMBSESILVQAULEOIHNCQYPIAPVIWOCTSAPTDXMZAJQNFDKLZFYNRFTSNZFEAUVMPQOIYIBDQVKHHWJEVZIQSISGELVHNONHHLZQSWDBYVGKQHCBSQOEBCIAIDXBHHNPQPVHIYWRCJWIBIZXHWJHXZMBBMIQFIMINOTGRVIJYJODNWPGZMGNOMTUYHQUGYMWLRKAKKDXBMXZPQCBCTAKTRWEVPDUTSPVLYOFWAKSCQFNSSKBKWYAFFKVKTNDZPMTDJRZPOUNBHPVHODXNGLFKGSWYDOHVLOGTUKKYPHRNTQLQOGIDAUPRJYXYROQDQIGAOLVYTXUIYDQRKTIUREOTLUGFXSXREDQZPMUIGZQRPGMXJOMZOYGIRELZTPQKDRGBDJRBRWVYFGNPYJDOPKAKFPMKYBBOXNBIBXBSUSIWFIXFJXDIYWHYEDFZCOWLQROAUPXPDHZKZRKPHVQAJDIXXJVTPUOEAHJIRCHLGGUXAZJCKYLVZDOAHKXTXAZTKXDBIRJUGGSFTIHWYVYKNECJUGVQDRRPNSQXIDJIAPLWRKGJZPODKLPNWVLFVJGVJJDSOMDVKPBZBWCKRIATUKDCEUPHIVHCFFNXPVNKUWHNFYVVGEZDVNJGBRULISNZUZCHVFKGBPMWMDJURQZBZCSEQKBVNXCMHJDDGSVQCYXULCTLRQWZMSUPHPXKUWWYPXPFPRPUCARJCHLWZPUBPVOQDYQTONDTBOBCKHPXSCMTXAZPSYLQHHYHBAOSNKUXAHVIXCILSAGKALCSBVYXOVDZJPDKGXINTWAVHJNTTNXASSXCRRTPEQLIEBCSMHIALLRVWAMHUWIHERIHLIGEWDDDECENBPRMGLVFZMCIHOHLUBDMKJJJOZABITVKYZDCYEEKVJBYBQDSOFLKONUNJOWCYASIYSWPODDYPLHIYEWFVLUOSGKHRIMRYJIZYGQKPGRJODOYRSCGTHJVRRFEKEHHUHDWKCTTRZBGNQCAZDOISXPNPPHMPKZTMGUVWVOGXYLVQLINXDAHLKBCYRNTKJFCIOQNINOLQFCBVYOJGGGEVCQJWKULRZPEDKQHOGFBBCSIISPZWGGBHUSTVLPYIKCMASCLHXZAPWYHYKDYKMBOHZPDLAMTURUKUBDBZWBCRGDDXCFSESEGUDKYRBSAMGUUFTPXRVUZNXHVXLURYGLIFFZKEWPVKVEMOAYTRYFDPZQXQMVPZUCAUXMETGRUKYJWQRQTJVSBMWSNDMEKGHYGZMNPWNFMXDYHVXJCWRCYWAFOPPPJEQKFYXXQOCALQEDPZUCLNIVIYZDXOLPLSVSDCTGODEZRZRONRVKAKPNCFXERSAXTNXHENOLBHPYUQOSQXFOKGAZJFQJCCRXDYANYJEARUJMCETBYYDLHAZSDBISQWJAWAMVFSLWWKHQSDAHHRLWBPBTZJGEUSELCWGBJWCBYKRDNGZLHXFXVBYHGWTKQJMACQTLUZKBVHWCYHHCEAPTLWOKSQIYQVPJQPTNCBQWNYKFIKAAPMGKMIQTTGYRDMKCXWHBJATZWBPPWSFDIZJWQEWREGBGUSXDGLMAVBEUCTJFDLNOWVWLIXXWSDBNVQVJCKZLCWHXYGCUKIYNCWFKOSFZHLSAQEYQJXRHSJPMTTVSJLIZSQBKNZRBMCJNHYPWHRLBBZHHHQFJLRSPTGQZZPKKVLNNPAVWGEMSXCXZEEXRLAHWBIUTDGYXJHKVFJGTUKMUPFPRRWSNOXPSKVHJUWEJVFBAZAGOXUBEJTBTERNQREISCLUZNORLTJMZJRVPOYZKTACIJMPWLUTQMVBORVEUDUUMSBNUVFHTTYNOWUZVZHJHLRBEBUWWXDWCLIGXPKOTSXMXSKJXEIGUJLLEIOYXNQGNLBFPSUYGICHWDSGUNDGHHHLPYCWWCNRDRZLWFYLAZCDAOMADYAMWBGJTMQNSBBUWJNKLTTIRXTLHWKDQHSSVUNGOXPGEUWLKRQDMCZLCFRYMIVJXAWTZJZQQVVWCJVQQAIQVSCDDEQKCUVFUZOIZMERBOVNXWWWGPULWUOKALSEHNXPFPUIJNHKYBASCEODNSDLRQGHLWIZSHMKITIWENIXCCPFKZCJBESOWGXWUOACNVIEYKKTNRQENMAMZFVJJDKDIVQRCEYEGKTZWIJPBGXNUZLTZXGNWMBWCLIXTCJXZOMTDGWRMPKLLUHNDIKHEHCWRWOIGRVROGVORRTCKNDUCQDWEKSWRHPEOTDVGFWUOJWEJHGEHSTDZRAECTYACOXQZULURKMLGYBLFFJRKMICORFTQIJSBZKIQUDACEMHFROSORIRAREDWDXZOVRAFOGJMFDLNTFVAMQEVYSXAAPOBEZBPGPPTHYZCJGWCLCWAPRMXYSNLXRHGEJLTFRBTZACUUPCPRHPWDJSKYVFCEAWGXQLVWQVEZKEPPQXHWJAJORDUFLWWJHJOUWPJPGMELVLDGOFNVECGOTJJJSDGBCKZVTLHHJCVRAOFOOVCNXXSGKCUANYMCHIKVJKZFJGHIGFCWETXLLBTJZHLGXTKMHQHDTXIJZIYUDVMGWRKOCRZHZJTSVFVKPVBUBZVNPSIUWELNEGJZEMHVFUXKYGOVJCHFYFMWRHHISVWATPEQMZCXFBYGRNHRDIKOSCGVPCNDCRXCZBRSTWCIYRBKOOKHPGTVVHPTKZBDKBVTCTSGDLSSRMXQBYETMGYHPJDMSSZGMFVDZCYOEFGIFRDHADGUEOUTPREZRRFEDQKEOPBBAWPFCWBJEDXRSJMLNEOAPNNSZGWBUMGEMPQJRLCUTUUFBIISGCQLHNDHXZDJVSQZGGLAKFIVIVVTENLZKBAZLRDXCDCLZYRIQCNTMTTRVTIKQSRMCOTPAFRIQRWMKBIIKQLZMQVTHRBVWSMJNPJDWDNMFGPBLOJTFCNQFVCILYSATMFAALTENSLWVJJAZMZRINGJQTQYDYIUWAYHDMICLDYXNWHYMRZKWKKYBDQWVNEFMABVJHAVGTKDDJDNGUJOBQBXICXXUIZGUZOATIYXXONGTMMNJLKDBPZKXZYIOPULXPOKSESRLIZAMZVKDXVAFSTLEVLCVZWVTINFIMZLDELPAZEIYSLADNOCRUFQBUXPOWTOZRECRXCOCFAREPKLHTBYYNFFOGCRDZMZAVMQEWANRBPRKXIRGLURUBCNPZNMVVEQXGUDGDEOXSEOFREDGPQPRTXYCKEXPPNDQVGMGHAUTFPJWEMNROIHKVDGDGYAOYNSZJVOMRTQLHZKTMAMNFOIFNUNKRPPIPDLOSJTUWFNJEPMXYUZBPZGUGNZBDIKYKTAOUBVRDLAWWRUJDWREAPLYBNITBCXDRWNYICVSEGKQCLMHGCHNUBTJNJVQJFAMIMQPYQGFBYHGZYHCPECUMHPAGYETVYEHOQGLZSSABVPVTXCLKLUKRHBSRWEGIUYTSXFHKHNPUNJWBQWZGAOWOIGMXQLVYPDKEZEEPMVITMOUYXSACXBMKPRTGPJRWKNLPDMGNGDFGOEARXHTVXRGEIZHTCTAFJMBANVXRDJFWITWEMAYTBEHUGGULGLFSCCFWAFQEUMMMDLSZDBWXEAGNPGSXWGYHGTJBLRXUGXIIXNQTCCLJKASGMIRAFEQLVDLTXKUNKHWQZYYSCTSIPKKYOHNXSJQKONDYPVFAKHAELUTSDDAJGADGBQENEMBNZSXDWCIKBTZEUKSXVFRRUTWCDKLTYQAJXVTQVXQDQJJZMBIMFFKJNAOWMDBVCAKUSQTCIJAXMEQFWJTJWDXPKHSHLUVMQFIAZSSWUAAOFBAKRNHOXRMLBZHIONNHSVYYXSANBBXRLPJDMNCXOISTMHBQXTRVEVVUBDLCZVTJZVFILEHRMBVFGOGPQQIUMWDBVPPJEBSKCACVBWZMOJDXKBOAHMGAAMUWTTHXHIQMGZGFGMTLCVMLKVCMYZBUVNWEEGVKJRXGOPJVIOMWGMFJNBBDDZUPLCQJVZLTRTQLAMEGYQUTDQGPDHIDMSQUQTNKAOZGXOMPXLMPKFHUUJJQDKPIGVJZPGHPGZIPMTEDPXTUVWQVJTRHSFMQUYDLNANHKDDNOPEJVEZMJTYOITZGXIFLFNFDKHYEGZZXAZUEYBGSVXDZBPCVMBWSLDMHRORGTFVWUFTDDGFVWQKETGKFQYPSHAFAWRVIWAYZTZEGVGEFUHOAKPUUHHKPTTHBOICJHRZWUEPIEGNNKSMCVQAURSKYJLNUUMBIRWPUPLCEUNYIANUKUQLLJAZNJMFQINFCPBCTSOYCLCMMSJJVZGRKWNPOXYTMGJMMLPWREDHPBLRINVUBKOJTJYWVBDRPGWFCYZPXVWNYBNBEPNMHWXYHLUTZYFFHEALCAUMETGZOQQTAVODXTLQNEAIKLJVRCTPNYJVZCVZEGMFPIDAQFOBMLMTZISVOIVSKFSIUWWYDJVVVRBSGFWFUUGDTPKGKMBMBXFVPDVUZKRAXZBDSJTNPBWRETICURADUGVFQRKWEDYWTJYDKMKAVLRAOYTHSEOSGGFTIJCNQKBVYDMZKXAFVYXKWLQCISNPDUVFXTOSWRDEHWCCLSEVDANYRVXHETOLANHHURZTEZGNMUPJLUCJIAXSTNLHUXBAGTFJLIGHGMMXCOVXBWIQAKLMBCGYYPVTHGOKOXIABRANCYUWHVAXDMNQQORFDNYZYDKDWXZALMHOJNLXOSMVAPFRJKQBTOACMMOASNJZNTTHVHAHAHIEYVPPNHKISDPHWOVWCPPGNMDIZSJBRLZXBPCHLHXUWILUDBKJGNDQWQAQTZOTYAKJTXPFYIFQNSDDOZJTWJVGNOHOSHNINFZWLYZBAIHCQRXDKMSBGSVJMALSPFWJMVPIJJWKBZNEOYHDFPZVZOAQUTZRCNZBTLKRTNZHOJNSKTVNGVTOMUUIPXUUVURAXDRWZNTPXIGTFIGDVRHHEVZOUTOYVVOHDCBQRTQAJVDQQWASBGSIJGBLOFDWGEAYTTNZALYFGBBIEKKCXARBLBCPJDPBLNFMYHAQAFLXHMHEOYGLGYCHNGHSXOWJPPFQLREAGKAYHOVVVNGNMGJKONARWGQMXORFJXYULQSGPEWMDNYPUKCPJVMPMFSQJVLRUKNTBLZLWEHPQSSTFASGVRGCECXPENFSBIZRORDAWNJVQIGMSLHNBOZJJWVPCUHAMXZPMDXFBMPKVUQXUDSYRQZNICQPCBVBCETBPMIPLSPZLMHRNUEAZMJFKHBLFSZOSBUPHBCFRUSJDULPSFGFJXPPINOYBJMWBYGEYAEPCFOALMOENTYADXRUBBSXNSWDMGXLLTSEVNKGBRJHIKBKKVBILVUXHDOSLNMDGCYBXKXFBUIECLYAGDUXVRXMRQZILRNPIJSKXODTJSDQCJJDIGDYIIIEZKMPDYVYJDRBIMGQJGZJGWAZIPQZQTNTJEAYFCSBGKOWRNOUPYTWYGVMOLGLROYKRGGUGDLOSAHRWVVWUDHWOULUJARVZVQJVXATSHRQKCJZFHMHUBDTMOXOPFUZHJMRLJHCTQZUEJRPGCNVZNYYNUYKXKIJOIBCAXPFUULTEWPZWKXXJPFFBRRFCJCICBCPEVNCMZVBUHUTTPLSASUDWJYENZDABTEWTTAZBAZXZIOWKNGKWWGKPDWBVECKBQVAPNZLEPEVKPVZFULGLTPCTCRAWMSTSHQVMCGAXEBIAZBTSPXMRIZSDEKYKZLQBWGZTITJFEPJFTXPJQAPRBMHRYNUDVGYYTHRQXJMSZGYBJNMNAKEGSSBWBIJRNHOGMGQOPKIQWSPVWIHOQDAPAGHSQEMFPPJUXUKTUNVPOQPHDZJZBNPHEIGAHIUYXCTDIEEJHXTXGSYWAGXIHJDBVSHFZKZDWKTMLOWFVJRHBYHTUXBLFRMIEJPCDLFSBEPXRMBGUFFMGGHIPFCCAFWWOPBSJAYDXXSUUUKAUCQRHVETXEKLHVRVKYRSVHWNVZWEUQGYDWZSGJWAATLFAXPGPWDOVWFWURVPXTJGRPCCHUFCLZTGEPAMCSQEPIOQSHAOIUPXWPECADRNXLCMMNLQZTKNWXHRFCDWXFAQUFUDEDSAEHAVVTJBIMBRUCOKLWXLQTILXDYAHLKXOUAVHSRBMZISGPAGGIIJXNOFFPQTIMPZNPCWZVEVTOFDZIZQNLMHDDIIPQIAUBIXWCURJTWMVUQZZODQTORKXASHMEEQRFTKNDTRNOHKKUFRHQFCYUKFFRVGNGZHZOFXEVUXCXMXBZPZTYEAKTMGJFZYOAJFMHONFTLYUJMGTQDTHAEDQZNZBQPZGRFDJIQXAQHCJUIYIGOIZUYUUNDVOFSKRUDOKBOVGSWWVIMGAJERXSFBAGLLFUSOUCPRSLWDBOVVVTFQDSKFQLXTBCSLKMODGHGWLKCLZGIEHXWJWBRPMYELQYCZSPWKIWYDHVYHVQXMNPVHOFQWAKSCUODEYKXYEBTPMYOIJRULTPWDHAAWPCGTZWHZMOQQFQAUIZZEMBJNGYLPVGGMPECYNRWUYPHKTKPTBHNGSZEFZYLLRUDEXJLAZWXLUNQBQBQNWTAYBRCUBULPBDBADUCMLZIVBVBRVOOCFKBTIYDRVVRKMYBXMOEAOLYTCUASZBIMOMCMDFHDKVFWFSUXYKGNQLKIZGGPEADYNGXVKJXYAYBSPGNULQRWCRWTDWXEEZYUOBRGAFCJNOJQJQVVOTPVDVMBUVUWGNAPPQBCXVVQHCSKSUDPCXYQTTGBIDUWLXYAWNFGAJQPZDQCLAHRBCIRIXBXZYJHBKEOXVWMRWMRQWMNSBFTDYBNQGTBFNJCWPXNDRPSERIWRYYILTQVWLFLSOTKABJQGPTEIWXDSEZTMVYHXMBYQFKWBDYGFNCLASMYEOQVYDWBBBFFEZJSGCXWCZKCGKOFLZLAJTLOSODECXMYKYHXPJATXGMRNHMMTZNICOURNIRHKKUDFOZVWYGKTAGOQFGKQZRWLFGCPVAJEDKPHRSPPTAVDMBATFAKPHKAYWUUQLOFPDPEFTYYGDPBCKJQHQFHYRMKHXGJRLYNGMRTPXVGCTDCTFHOZVWDDXSJOCMUWCQWBBEVTTHZAOMIUTSZMPTQTEJPJKFQZOPYSHRCPOPPLSWLWFVWDZHLZFSLMYJMDACWHFKQNTZXQFVLGWNOAFDTTWGKPJXADFVXMTRFBLEQHDGFRFFIXONOYHNFLZSVVKMUWIWWIXZMHEKMMCZKSNJSDZQIWHHOUYLTXYOOKUESCJLDQXITLNZIDPRFTMXRGJLQPNDAVUKNYTQTSPLTUUDATOPNZOJBBEVNPOXGSTEUUTQQVVFBVKEWEMHVHBNOWTOEUGTMIUPZFCMFDSVPGVIXKHNRKOFLRAIWIQNGXBWYGMJCUOFNFDZOKUWJWQAJCDJMILAXAUYYIOCDQKCNGBJFITKSZULXOCVILLHGWENIXYJRAYGOZHGOFDVISVIPTPXROCIUQTRRGFOYMSQJUAUNZBLQQKASUZGOCHCFOZHHZHWBDPBDXMENSKQVBBYSHDGMMFCGRYWFFHSIGORCZJUVSKZACDNQTKVLPLXVROPSLTLHFYWDPRZXJCOTRNAVBKTSROHBTFQVJSSNCOXSSGBYCRDTNNWTAVQAAWPKUGSNFAGGMKEWESSRGTCDVSZLPUJMGYDCGPSBEKRQKGUQMSOFGKRWWPGEHXCUPTPZZSHPIAOQVIYWNALCXWKZTJAUTNMUJKSPQAZCOJFHNEXXATUVRXQGIYZBBDRSZSWYRTPANWILGCTPKQIFYKLPWKGBIQGDHIWTUDJMQOQIPVQVWAKKAVGUVQTYZFPDABQRBVQTPSGHTEMNHLDMUYKCQLYLQVWWYSBDXOHKVILYJIPFHRGSOIFOESJLPBQBMYCBNITWVJYEBCKCRXASVEDDHBWNIWFNCACGPJBWNLNZPHXZUYWMSQDMZLUZHNKMKMVLZXVADUCQEXGSJRMXSRVGTSOKOLDEICBQOHQLDUBASDYQRELOLIEEKRQSIIFTUDAWDSPCAFOWYOCWNWAMLJXDBPERZPHTYXZWPKKTSYTQJXOUOYFZNXMUNZQQAYBKYMYTBARKBVVLTMYBBHXWEOGIZCCUKBBVVNWMPJYOCOGBRMTDWDHAGRITSKNKAKBARYHFPYQXSAHEDEYXNUQUBHYDOHMANNHJHZHBEVOYBDSYBQQVQBKNSLKVPOJUWNPYPCZEPGBMCLINUGULCEQBPJQGWNNXQQDHHZPMWEDFMIVZRPQIAHXAZUEYFGHDTLCDMVSWRYXXNZUZIKZVQDMUMHWLGSILNLBTDKZFVGANLELIGGYMPPRDSGNDBJZMXYTJQBZOPVSHORMUBJLQVLWQGPZMLAXGJEIEHAZFQBIWRMWROOXRSFBTHXGQTNCHDMZDHHNWNGPKSDIMSSHSZWMAZOEZOUQIDUXHCTHDKHAOTFPDDPTQCCRGVMPWAKELDZLRXZXQSCHBKKELTQVUVCZFMOWGNJBGYXNQLBGLJPPLHCKINRNVIUWABNGRZKWMPTRFFTLXWXWWIWFVYWELDZAQDESZLLRGDNLGYVVJRVSBXSCBGWOGJQGOPQWOPEZIPPDIRXGDJCORQUYFTLROFVARDCGEYASPXSOVALHIESANIJLPDJAJBBKVVQWGLRXRWPHJFAMXLSXJJLEGESEHYPXCMQVATKQPCYEFROMXKJTZANQVKXANMQCHRGZWSTSLCHUYDSURGJUJMBAHUVKQULZQNZSHYGQTMQUJPCZOMPZDUTISNTGXVANPZHEIAAITNBSYDWPOMLIKCUGRDNGTQBBQCJIWDEFCELGECJBRXEVDWMETCCYZHVVPOEPUMMBFXLTRLBHLJZZFESILHGMOFCRFVLKAEPVQAQVIMAZQZCAIJSAOLVCWJOGQXNAFOWLNWVARIUUSJXWJQYGOOOZMTXHDZGRBDSGOCFLFZSSNUIYEDKGSVMTGISRKZMGFGYANBBJSIISCZXURFZKZWNIXNSZXTBJJCXWLZNNVVDDXBPVMWOUCVIRWEBWSQCLGNEBINRFYSCHVROVBBSLIVAUDFXUGXINDVXDWVKGNLKPUHUHQANUAQUGYCMDBYPHYOGQMVIOQVWFKLVEUZDEISFDUIIDKLEEBROCVRDUKEXARUEQUEYDTFILEOUVXBXMUNEKIGVKHFOXBUNIFOCHDMXRMBGUTROLVJWBOHYBYKYOOGHQUKHGWCADTSWKADZYVUUMFLKUUZCXKHNAMTZZBAXLUTTQWXVEPASQBSFKBBDDWJYIADHADLCGYVBSANGIKZRTFRXYUKIMDIGNKEHEARCDDUFRXJCFAOLUUOEUXDQFFCNVFYPAFDKWHXKSDOUYPJVJYVBZGWUJECDWHSZOEISVOGCAWWYGYQTDSRYTGAGIFXSWOFOOOZVSTVAGWLLSGBNGUPSDCZTRWAXTTSMGCVJZNUTLXUPGMXMOHNHIWHMRHGBAUWOAHQXKRFJVANANMLDUKGCCATCEPNAKDUGIRGHAXYUXGOXRXDWKDEKXPAYXNCXQUYLVXHAQBQFUJMLKHBTKUVDDDBVZDOPMMZVLNITKZOJSRZVQWGSWNVVDEZPEHJHROIRJZOHKALMXKWJRLXPCTAIXMDABGIXUVHCVREFDBXRKDYUSUFIGITYWRNNVIQENYGKQZKFJWVMMBOKEYYAWTFEXTPULLGXSKEMTCUYDKVPPUOUZOQFXXOGBGHIKTGQRUPRXSHWATDCGJJODDVLKKTEXOIXFIAFWYSHEKBKKKYWZGBKKPWGBYEKEMVQCKFUASXBLGMMPABJTBSEQRIHROHDGTEPKQAGAITPVVMUYUSRWFEENSGYFWDQCJLLULLAFNVTYVDNALEUAKFYVGDEIDWIUOYSTTRJQQDVDJVTMLZERKOVNLVGWAIYEAWRFFVODFAWZTVMJRRABEZQJZXWGWPQBDJJMRTTUSOQDGRZIDMEJRDNCKWTKQXWCKFVJWVSBENCWTOTONYBPZFKVBAVPZEALOLDPUHTABRGFYBGJADSOZGDHKOPXKSBHIVOIGPXLCJHGMMWSOWIZQOSCJSMBNNRBPOBNELQUBWZDHKUIBLEAIWCQFAUAENHVENKPKQFNTFGPCNXQOZIWLOJHWHVGDWBLUDSFKGNOPHMEQVCZXQGMIEFMJHIITQERPNQBKEAVNIZWDOJZEALRBEXNOEUKKXGEPYONQGZOIYNAWKTBGMEMJHVYSQDHAKCQCEDLLXKINXREEXGBAWIXUWQENESDEBFVJIOCWTCNYDBHALUQUZOCDDFIAUQCCDAAKCDLKHVRODVALTVWKOUBYIEBXUFRITFNOOHXKSXUCXLNKUEBMXJVVKHKBZMAFMMDTCSLEZLDSOASVXJNTHCZREUIWMGXBDRODDZEBWBGPNZDAQMWQCRHGMTWJFISRIXEDWAHUZIJLRKXMQFKUNVHUSFSVUAOMGALKXOMEGXHBSHVRVXSNHZHCLGYEESCLIFLRWUJKOZFALFGUWUOAVYAYNUWWUVSEGZLERPPVDHUEGEPJJYPEOJXUJUIATEEDOUOZCZDCXQXHEMLXNIHDXQQKBKDUEDWGMZYIRCAPFEWHVPXIIPSXTSJFPJSYCMWHDPOKTDZGHAWHEGQVLENBHZGQXELHRGYNHBTIOZAPZIIEIWKQMPHQCKYZCNCKXNXQQLLBVHFQOXUMANXOFNCFNPWBNRNUGUEMSWKMVHSFUFTDKKVJVNYCMDRTVONITNXTBUYQZLYDDKSMPQKHZDLIRQTBUUXTFPVHGQUQAUAXUJWUJDQVJOTFRMNZGFMIJCNSLJIQUCKYTHVKQCFHKQVNNGXIVZJKZOUMYKEYFFEBOTVDYIFVJXITLKUHIVXQLYUOFNTGWZELEXZTRODUXHLUMOCAEVWAUSCGVOZPTDGPELUQAYEFVCMQLIHADFUKDLWVTECUUFYYUUYCOJCZKHILNFVXDLRSDNTWIHRQTFSXRHLGQLMCVMDASAVYGWXEAXJBGWOXVDMCHHWPTPFHNPSTGIIXBYDWAIKPVIWZQRXBTUGFACMXTWWFFYKQWCRJDJEFEFWYMQVWHKJOAQFZFGBIGKHZAJVZOHZQDPDUIOPBIGFUQOINVQLJNLRRAQPJPXHKNSTMPEFQODISYCWSPJGLWQIUSOVHBBFLWUGVPUBKUHQHDEJDINPGVYNZBLSFESJTZWUIWZISSNEJYGMBXWJBCEJRBMXURGDWKWJINPBCLDWASENKJXMEXNXCVYPWEIBKJDWUMHFCSBLMNJLKFHCLLJDXXCYEOFNLFITHAOYGXMKDEDYAOKCWGYFXEYWENHLWPHPKSEAKFMMFFALFVZPYEAHKDJZKCUJMEEKDBXLXABSXWXGDYPFKHFPJYEOZRLHZYNJUFEQXDSGHTUJKPRIOZJCCLHCDXHAYYUNBKUAIYYPORIBQGNABOHGHWZLNZEUXIVXXBXYIXRNRSGNSGOYBFDBSIKLTGSRFIYDHDLWECZVJJRLAQHEVJBZHLSJSQUNUGYFSERUJGTLUHQUYFDGIRBFQNUXFXRMEZXJFDFSQLNNLMTHKCHTAWNOWJQDFDDIUDEJHRWSFBXHIBXWSIATHFVKZJKJMMTTJIEDTVBREOWNIEDHZACKXDZKGJERTSZZCKVHSWDTVFHWAIGAESWLNMNHKGYWCIZVDBPZTEGWQGPUKJBSCIAUHMHLRAUUIJJUNUVYZQVVTNLTKRSQFVFMWIDHLFNIHCTSXWLQLUDBTWGWPXUBSHAFTAVEVPBXECOYKNBDQOUASENLFVTNFWPTQPRIMERVHCARJTKPGBPIBYLFRDCMKVHJEFKCBVMZCHUUFSEYZSHUNVEVBKEEICNMPSXRMYCWZSOPJRHGCCRMBPUCOLVWLGLMCGWJSNSXFLSYELGSIAGNWBVONORTGQHOHOTSQPRNSGPZZLTHNDAPGWAAXBSWKJZJXTWXHBFXXVJMONROESVTMGXPTTIEMOWROFLQKFCRLTTLGJWBNZXNEAFTLEKQLFUDARHRZDTMNVYICEGJMCKMFPAPQNRRRHSQUACXFQOTRYTPRQICMZYISRPSDGCHYNBJSIIHJIGVGDIZADXAMWTSASQNNXLAZUJDAJIWFJPNVRJLZWQKGJXLYFEUBOXBHPDEBMTJQCOSIBSOINCWZHCHLURBAEDWLZQJCWQNKPBIUYDHHYXINVRQDMVOOFRZCMBFHENRIEHPVRQDWLQJOGUKWUWEXDYIZPKWSTFWKQPZQLESUJECGZKIBAHUGGRWZHYLMQSHBZBGCRXMPVAUUTLGKGKHDGDVDQJHJFXFOSJRFXOXZWOOYQEHMGFDMUFPIEPQIAKBSCLOHRGMHHPFNJNXBFXMSRCWVLONHQJNIDSUDTSCDVWMGGQWMYDEGYGHUUTWCVQNFHNBFZWQDXPKLXBUCVCZHVJVRRMZCHKILTMBZIFACEONAURPOQXCXSAMJYYNBPSHGMHNLZXBKDUIDQQYXBQHIHUAPZWWMBKCTKFIXXDVOXLSWXZMIIPCUWUWYFZVVJAWGPYMAXTPJFOAMCEOLFAWHYQXGPGZSNILGYCJBOHZPTMCZOZYTXHAMHEGBBIDCEUSCTWEPDTUFJIAHYEADQTUXESQTRYCWLBJVLRJEMZBDDYRAZYFCRLIYQAGDYWWQKYKADHOMUOUKYSBGDZZRJFZKXJRPMMDDQMDZJEUYMYHVGCDPZVOECUYQDIBEZCXNNYHISSBCNVNVFRVYXOXIJKGKZWHAHWDYNOPNVDVYPAVKBEOJYIHTVCTZDVIOOHFUXTZWIJMSNJRAPBSJMCQKIDCOUOHGMQZDQIZBZRYECIRGTMJKYQCYHRTFDBDMQLKTBKQVLOOCJFPMMZAQKVIUTNOBUQYLYTIKKYQMFLPXLYZCDAFPOLKWZTBKAZFCLRWZMYUAPMCYQGKFGKSFRRLJZFWQKAQSGXFPQVYOKHMWCKPZPMWPZHYREMQTYHKDFQEKKXZUVQAQXNFVCQTUBDBYPKPXLLCBTRVZFXFHUMXZFCFEUNIWPKXCWKVSAUCLTOKYENEYISEBXPUZRKITQMLRVKXZAAASLFPWHWBNKIKWLSASNKJAMRUDTYEVBYJOXAJVUDKOSLBTZUHYXUZFINBTIJCSSNSNXOLIXIDHIIHEUPZHMQJDZOLLJIBGQYTAEYNRPDHBWXWNIVPOWLVXTMPMBQHLEZIHJZCRYMWZABIAJBTZKIQIBBZXEGTSZRMCRDTRXXSRCIYQHCYIELRAETLEARGFJHZVACQJDANZDPYZBQLDHWJMVJUKQQMMBJLWHBCGRYNEBFSIPTHZEFCYXQOYUOOURFFWPPEIECAVQAADAYLGKDOOODNAMZXVSXTHNEGDUQXMDPEVHRSZGPBSBXFGZOSVKCQJXGXMTOHHJMCSAXXRDCVYNBMNDBTXSRUNKKCGLZJLYVBKMILQEPKDNLVJWKFQQDNOJKOAVFOWQKJAMXETSBYLWXISBTJDJDYPRDAUWRALBHZMSXBDAIZRCTNNMKONVZEUOYDCYJMSJWOFLGVBBITKEPVIBTGAIGMLOYTZKYPYAMSUXLTACXEMRPGVZALLNUCMGKLYXWQGBUNTFADPQHDJRBNQFJHNXRUYTMPHIFCRREKAENUTXCFEGNSFIJOHJJFVRWTUWAZHHUAAXWJRRHWIMPLZVLJBZWFALKEQUJRGLVQYRZHEKTPMMXRGTTHLAQQSGSMBYIZYVKPUNLTQBOXDZDQFMPOFWUGMPLNFGHUPWZMLXOJVXGSPGSTGBGSRHQCNIMUFMXCITCIFRFJAFFMNNURMUWSSTDQDZLFFRWANQWEICFPYFNDWMSZBRIQJCMANJUEXXEWZFFDDSARNRBBURUXOXWANRROPDWHAZJJLQUUKVTOOXMFKCOLUZZWWPXHSSDFFCHKDXVTYTIAAPJIIOGOIFHTAVOXMYJPLZNVFQPTQZJCPZRZBOMEQJZIYQYWNBWYVSAINRHIBJFQZTVSLRDNVBDKVXPXVYEYWBAYZXJVUUWBDOOWKBKCPATTQGJMIIFHYZJQGMKDYQXGISIDGZFYOWVEKKZTZTEPFDHCCEHJSPUWIAUIPRRTRIDKNVJWMAJIAWFWGPMLURBXZXNEPFMRXSBMACBDQDDZXJOQVCVKXOYIDVDHHSPLPPFUNNDGOJLVHUPHUQYQIINTSKHYHBRWEJNNKMCEQIUVAPXKVKNGSJPXPYTIELLDQLVHJKXNMDWZKPKBSRCFPKWKQJXAUCTVJTJCHPDLYYVJOFYSXANEQKEOZYOUWPPINSYFFJQIELUMHEVWBSZECIOSNVMMYGADLCEGGOVEOYWXIIUSMNMMUTPJUHFDAWVLYVKUWWPRVPJBXCLMNSKBJIJNLCXRWUTJWHKLWJINLEWQAHHBWIYHUFVZNFDEMGDJAMXEZPLFFFDRDFCRANIQSEBWEASOJYOMFQOUXKGKWSHQDMTDXYKUIGUCJCHUYICFHEGKUHTZWMRCRPELJDVEEDUQBYESRGHMRDMTPZIFTBYHUJYLPTJUVKSVMSROGBQPVOJTDSRBBTUDEBUTJPVBYUDTOGMGDBFHDLODHRDINJCEVXITDTHPDCYYISASKGITKFTTHLXTCGQRVZXYENMMQFDYLBLRYPJZCYCEWXPHVGBXEHTRRGVSNEWIJIJMRQHWRPRGLMDOMBNOGEMCHMLSRVLBHKSMBJHIQECWYTEPEHKRBUTVAUGIOLFOQFGLQMTHVCVGISCHVCOUPWBMRDEWWXZSLRWUKMQXAYFIJLQMVKLURABLXNVWTGXPLFZAADCILJUEZSACBYDWHJPWTWKEXPQFQNNDIRFRKAYQIMNVCYUKXSLLXQBREZBBFCNIXRXVHLVLRYWIKNHSQNJQQKCK'}\nExpected Output:  66583760\nActual Output:  22395\n1 Test Failed!\n",
            "time": "0.121",
            "memory": 17500,
            "stderr": null,
            "token": "3594a47a-9a54-489a-b541-066adcc9837f",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 4,
                "description": "Wrong Answer"
            }
        }
    },
    {
        "status": "success",
        "question_id": 856,
        "title": "consecutive-numbers-sum",
        "token": "e5b5c3ad-cb79-4462-9f30-468c775c4e5b",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport json \n\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def consecutiveNumbersSum(self, n: int) -> int:\n        count = 0\n        i = 1\n        while (2 * n > i * (i - 1)):\n            if (2 * n - i * (i - 1)) % i == 0:\n                count += 1\n            i += 1\n        return count\n\nclass TestCaseGenerator:\n\n    def __init__(self):\n        pass\n\n    def generate(self) -> dict:\n        n = random.randint(1, 1000)\n        return {'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return '{\"n\": %d}' % input_obj['n']\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        from json import loads\n        return loads(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.consecutiveNumbersSum(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Input {'n': 484}\nExpected Output:  3\nActual Output:  6\n4 Test Failed!\n",
            "time": "0.062",
            "memory": 4892,
            "stderr": null,
            "token": "e5b5c3ad-cb79-4462-9f30-468c775c4e5b",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 4,
                "description": "Wrong Answer"
            }
        }
    },
    {
        "status": "success",
        "question_id": 564,
        "title": "find-the-closest-palindrome",
        "token": "c670df6b-07a8-4b85-9c72-d1e6994968f0",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport math\n\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def nearestPalindromic(self, n: str) -> str:\n        l = len(n)\n        candidates = [str(10 ** (l - 1) - 1), str(10 ** l + 1)]\n        prefix = int(n[:(l + 1) // 2])\n        for p in map(str, (prefix - 1, prefix, prefix + 1)):\n            candidates.append(p + (p[:-1] if l % 2 else p)[::-1])\n        num = int(n)\n        best = -1\n        for candidate in map(int, candidates):\n            if candidate != num:\n                if best == -1 or abs(candidate - num) < abs(best - num) or \\\n                                (abs(candidate - num) == abs(best - num) and candidate < best):\n                    best = candidate\n        return str(best)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(1, 18)\n        n = ''.join(random.choices('1234567890', k=length)).lstrip('0')\n        if not n:\n            n = '1'\n        return {'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['n']\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        return {'n': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.nearestPalindromic(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.056",
            "memory": 4808,
            "stderr": null,
            "token": "c670df6b-07a8-4b85-9c72-d1e6994968f0",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "failure",
        "question_id": 552,
        "title": "student-attendance-record-ii",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "success",
        "question_id": 938,
        "title": "numbers-at-most-n-given-digit-set",
        "token": "80eba9d8-e535-438d-a378-66c46cbb6589",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom functools import cache\nimport random\nimport json\n\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def atMostNGivenDigitSet(self, digits: List[str], n: int) -> int:\n        s = str(n)\n        k = len(s)\n        ans = 0\n        m = len(digits)\n        for i in range(1, k):\n            ans += m ** i\n        for i, c in enumerate(s):\n            count = 0\n            for d in digits:\n                if d < c:\n                    count += 1\n                elif d == c:\n                    ans += count * (m ** (k - i - 1))\n                    ans += 1 if i == k - 1 else 0\n                    break\n                else:\n                    ans += count * (m ** (k - i - 1))\n                    return ans\n            else:\n                return ans\n        return ans\n\nclass TestCaseGenerator:\n\n    def __init__(self):\n        self.random = random\n        self.json = json\n\n    def generate(self) -> dict:\n        length_of_digits = self.random.randint(1, 9)\n        digits = [str(self.random.randint(1, 9)) for _ in range(length_of_digits)]\n        digits = sorted(list(set(digits)))\n        n = self.random.randint(1, 1000000)\n        return {'digits': digits, 'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return self.json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return self.json.loads(input_str)\n\n    def decode_output(self, output_str) -> int:\n        return int(output_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.atMostNGivenDigitSet(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.049",
            "memory": 4676,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 26, in <module>\n    from functools import cache\nImportError: cannot import name 'cache' from 'functools' (/usr/local/python-3.8.1/lib/python3.8/functools.py)\n",
            "token": "80eba9d8-e535-438d-a378-66c46cbb6589",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "success",
        "question_id": 939,
        "title": "valid-permutations-for-di-sequence",
        "token": "1fedec9e-8a9d-40dc-b386-e85f909b6df2",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport hashlib\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nfrom collections import defaultdict\n\nclass Solution:\n    def numPermsDISequence(self, s: str) -> int:\n        n = len(s)\n        dp = [1] * (n + 1)\n        for i in range(n):\n            new_dp = [0] * (n - i)\n            if s[i] == 'D':\n                for j in range(n - i - 1):\n                    new_dp[j] = (new_dp[j-1] + dp[j]) % (10**9 + 7) if j > 0 else dp[0]\n            else:\n                for j in range(n - i - 1, 0, -1):\n                    new_dp[j] = (new_dp[j+1] + dp[j+1]) % (10**9 + 7) if j < n - i - 2 else dp[n-i-1]\n                new_dp[0] = (new_dp[1] + dp[1]) % (10**9 + 7)\n            dp = new_dp\n        return dp[0]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(1, 200)\n        pattern = ''.join((random.choice('DI') for _ in range(length)))\n        return {'s': pattern}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['s']\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\n    def decode_output(self, output_str) -> int:\n        return int(output_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.numPermsDISequence(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Input {'s': 'DDDIIDIIIIDIDIDIIIDIDDIIIDDDDIIIDDIIIIDDIDIIDIIIIIDDIIDIIDIIDIIIIDIIDIDIIIDIIIDIIIIIDDIDIIIDIDIDDIDIIDIDDIIDIIDDDDIDIIIID'}\nExpected Output:  []\nActual Output:  0\n1 Test Failed!\n",
            "time": "0.059",
            "memory": 5920,
            "stderr": null,
            "token": "1fedec9e-8a9d-40dc-b386-e85f909b6df2",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 4,
                "description": "Wrong Answer"
            }
        }
    }
]