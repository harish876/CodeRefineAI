[
  {
    "status": "success",
    "question_id": 131,
    "title": "palindrome-partitioning",
    "token": "05c96aa2-7636-4697-bc11-95b3b55aa9dc",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\nimport string\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        res = []\n        self.backtrack(s, [], res)\n        return res\n\n    def backtrack(self, s, curr, res):\n        if len(curr) == len(s):\n            res.append(curr[:])\n            return\n        \n        for i in range(len(s)):\n            if s[i] == curr[-1]:\n                self.backtrack(s, curr + [s[i]], res)\n            else:\n                self.backtrack(s, curr, res)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(1, 16)\n        s = ''.join((random.choice(string.ascii_lowercase) for _ in range(length)))\n        return {'s': s}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['s']\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.partition(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": null,
      "time": "0.052",
      "memory": 4824,
      "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 112, in <module>\n    runner.run()\n  File \"script.py\", line 96, in run\n    output = self.solution.partition(**input)\n  File \"script.py\", line 52, in partition\n    self.backtrack(s, [], res)\n  File \"script.py\", line 61, in backtrack\n    if s[i] == curr[-1]:\nIndexError: list index out of range\n",
      "token": "05c96aa2-7636-4697-bc11-95b3b55aa9dc",
      "compile_output": null,
      "message": "Exited with error status 1",
      "status": {
        "id": 11,
        "description": "Runtime Error (NZEC)"
      }
    }
  },
  {
    "status": "success",
    "question_id": 132,
    "title": "palindrome-partitioning-ii",
    "token": "14b4b2ee-b9f8-4ce4-828a-b785859ea4cf",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport json\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def minCut(self, s: str) -> int:\n        def is_palindrome(s):\n            return s == s[::-1]\n\n        @lru_cache(None)\n        def f(s):\n            if not s or len(s) == 1 or is_palindrome(s):\n                return 0\n\n            min_ = float('inf')\n            for i in range(len(s)):\n                if is_palindrome(s[:i+1]):\n                    min_ = min(min_, 1 + f(s[i+1:]))\n            return min_\n\n        return f(s)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        \"\"\"\n        Generates a test case input containing a random string `s` of length between 1 and 10.\n        This ensures we have a reasonable range for testing without excessive computation time.\n        \"\"\"\n        min_length = 1\n        max_length = 10\n        length = random.randint(min_length, max_length)\n        s = ''.join(random.choices('abcdefghijklmnopqrstuvwxyz', k=length))\n        return {'s': s}\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\"\n        Encodes the test case input into a JSON string.\n        \"\"\"\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\"\n        Encodes the test case output, which is an integer, to a string.\n        \"\"\"\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\"\n        Decodes a JSON string into a dictionary representing the test case input.\n        \"\"\"\n        return json.loads(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.minCut(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "0.05",
      "memory": 4880,
      "stderr": null,
      "token": "14b4b2ee-b9f8-4ce4-828a-b785859ea4cf",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "success",
    "question_id": 135,
    "title": "candy",
    "token": "69f78fb1-c3ee-4eb6-8799-2daecddda4cd",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def candy(self, ratings: List[int]) -> int:\n        ratings.sort()\n        candies = 0\n        for i in range(1, len(ratings)):\n            if ratings[i] > ratings[i - 1]:\n                candies += 1\n        return candies\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        test_case_1 = {'ratings': [1, 0, 2]}\n        test_case_2 = {'ratings': [1, 2, 2]}\n        test_case_3 = {'ratings': [3, 2, 1]}\n        test_case_4 = {'ratings': [1, 3, 4, 5, 2]}\n        test_case_5 = {'ratings': [1, 2, 87, 87, 87, 2, 1]}\n        return random.choice([test_case_1, test_case_2, test_case_3, test_case_4, test_case_5])\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.candy(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Input {'ratings': [1, 2, 2]}\nExpected Output:  4\nActual Output:  1\n1 Test Failed!\n",
      "time": "0.061",
      "memory": 4780,
      "stderr": null,
      "token": "69f78fb1-c3ee-4eb6-8799-2daecddda4cd",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 4,
        "description": "Wrong Answer"
      }
    }
  },
  {
    "status": "success",
    "question_id": 137,
    "title": "single-number-ii",
    "token": "84256487-3d3a-4857-8ec7-8979795e1d72",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        ln=len(nums)\n        if ln<999999:\n            while(1):\n                val = nums[-1]\n                nums.pop()\n                if val in nums:\n                    nums.insert(0,val)\n                else:\n                    return val\n        else:\n            dicto={}\n            for i in nums:\n                if i in dicto.keys():\n                    dicto[i]+=1\n                else:\n                    dicto[i]=1\n            mini=min(dicto.values())\n            for i in dicto.items():\n                if i[1]==mini:\n                    return i[0]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        \"\"\"\n        Generate a sample test case input where elements \n        appear three times except one. This will return \n        a dictionary with one element `nums` containing \n        a list.\n        \"\"\"\n        nums = [2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\"\n        Convert a test case input into a string.\n        This typically involves converting the list into a string format.\n        \"\"\"\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\"\n        Since the expected output is an integer, simply convert it to string.\n        This will help in returning a stringified version of the integer result.\n        \"\"\"\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\"\n        Given the input string, convert it back to a dictionary with key `nums`.\n        Warning: eval() is used here for simplicity; in production, safer alternatives\n        should be used to parse the input format to avoid code injection vulnerabilities.\n        \"\"\"\n        nums = eval(input_str)\n        return {'nums': nums}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.singleNumber(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Input {'nums': [2, 2, 2, 3, 4, 4, 4, 5, 5, 5]}\nExpected Output:  3\nActual Output:  6\n1 Test Failed!\n",
      "time": "0.049",
      "memory": 4744,
      "stderr": null,
      "token": "84256487-3d3a-4857-8ec7-8979795e1d72",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 4,
        "description": "Wrong Answer"
      }
    }
  },
  {
    "status": "success",
    "question_id": 138,
    "title": "copy-list-with-random-pointer",
    "token": "21f29792-cc9e-4922-8dee-a0a5d4e742b0",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import Optional\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\n\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        if not head:\n            return None\n        \n        old_to_new = {None:None}\n        \n        old = head\n        while old:\n            new = Node(old.val)\n            old_to_new[old] = new\n            old = old.next\n        \n        old = head\n        while old:\n            new = old_to_new[old]\n            new.next = old_to_new[old.next]\n            new.random = old_to_new[old.random]\n            old = old.next\n        \n        return old_to_new[head]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        nodes = [{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]\n        head = self.build_linked_list(nodes)\n        return {'head': head}\n\n    def build_linked_list(self, node_info):\n        if not node_info:\n            return None\n        nodes = [Node(info['val']) for info in node_info]\n        for i in range(len(nodes) - 1):\n            nodes[i].next = nodes[i + 1]\n        for i, info in enumerate(node_info):\n            if info['random_index'] is not None:\n                nodes[i].random = nodes[info['random_index']]\n        return nodes[0]\n\n    def encode_input(self, input_obj) -> str:\n        return str(self.linked_list_to_array(input_obj['head']))\n\n    def encode_output(self, output_obj) -> str:\n        if not output_obj:\n            return str([])\n        return str(self.linked_list_to_array(output_obj))\n\n    def decode_input(self, input_str) -> dict:\n        data = eval(input_str)\n        return {'head': self.build_linked_list(data)}\n\n    def linked_list_to_array(self, head: 'Node') -> list:\n        if not head:\n            return []\n        nodes = []\n        current = head\n        while current:\n            random_index = None\n            if current.random is not None:\n                random_index = self.find_index(head, current.random)\n            nodes.append({'val': current.val, 'random_index': random_index})\n            current = current.next\n        return nodes\n\n    def find_index(self, head: 'Node', node: 'Node') -> int:\n        current, index = (head, 0)\n        while current:\n            if current == node:\n                return index\n            current = current.next\n            index += 1\n        return -1\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.copyRandomList(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "0.046",
      "memory": 4924,
      "stderr": null,
      "token": "21f29792-cc9e-4922-8dee-a0a5d4e742b0",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "success",
    "question_id": 140,
    "title": "word-break-ii",
    "token": "394b78ae-9b87-4e62-b627-8d40e345133a",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\n        # Time complexity: O(n\u22c52^n)\n        # Space complexity: O(2^n)\n\n        wordDict = set(wordDict)\n\n        # curr_i is where to continue iteration, stop_i is if > i then eating into next word, don't take\n        output = []\n\n        @lru_cache(None)\n        def dfs(curr_i, stop_i, word_str):\n            if stop_i == 0:\n                output.append(word_str[:-1])\n            elif curr_i < 0 or curr_i < 0:\n                return\n\n            for i in range(curr_i, -1, -1):\n                if s[i: stop_i] in wordDict:\n                    # Use a set instead of a dictionary, we can do look up of the word instead of looping through the word dic each time\n                    dfs(i - 1, i, s[i: stop_i] + \" \" + word_str)\n\n        dfs(len(s)-1, len(s), \"\")\n        return output\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        test_cases = [{'s': 'catsanddog', 'wordDict': ['cat', 'cats', 'and', 'sand', 'dog']}, {'s': 'pineapplepenapple', 'wordDict': ['apple', 'pen', 'applepen', 'pine', 'pineapple']}, {'s': 'catsandog', 'wordDict': ['cats', 'dog', 'sand', 'and', 'cat']}]\n        return random.choice(test_cases)\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['s']}|{'|'.join(input_obj['wordDict'])}\"\n\n    def encode_output(self, output_obj) -> str:\n        return '|'.join(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        s, *wordDict = input_str.split('|')\n        return {'s': s, 'wordDict': wordDict}\n\n    def decode_output(self, output_str) -> list:\n        return output_str.split('|')\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.wordBreak(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Input {'s': 'catsanddog', 'wordDict': ['cat', 'cats', 'and', 'sand', 'dog']}\nExpected Output:  cat sand dog|cats and dog\nActual Output:  cats and dog|cat sand dog\n1 Test Failed!\n",
      "time": "0.062",
      "memory": 4872,
      "stderr": null,
      "token": "394b78ae-9b87-4e62-b627-8d40e345133a",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 4,
        "description": "Wrong Answer"
      }
    }
  },
  {
    "status": "success",
    "question_id": 134,
    "title": "gas-station",
    "token": "8ddf959d-9559-4e16-8f8b-d060d9112f8f",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\n        n = len(gas)\n        total_gas = 0\n        curr_gas = 0\n        start_index = 0\n\n        for i in range(n):\n            total_gas += gas[i] - cost[i]\n            curr_gas += gas[i] - cost[i]\n            if curr_gas < 0:\n                curr_gas = 0\n                start_index = i + 1\n        return start_index if total_gas >= 0 else -1\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 10)\n        gas = [random.randint(0, 10) for _ in range(n)]\n        cost = [random.randint(0, 10) for _ in range(n)]\n        return {'gas': gas, 'cost': cost}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['gas']}|{input_obj['cost']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        gas_str, cost_str = input_str.split('|')\n        gas = list(map(int, gas_str.strip('[]').split(', ')))\n        cost = list(map(int, cost_str.strip('[]').split(', ')))\n        return {'gas': gas, 'cost': cost}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.canCompleteCircuit(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "0.045",
      "memory": 4844,
      "stderr": null,
      "token": "8ddf959d-9559-4e16-8f8b-d060d9112f8f",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "success",
    "question_id": 228,
    "title": "summary-ranges",
    "token": "75128eac-b1f0-48c3-a2fd-3b91e8573f3d",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def summaryRanges(self, nums: List[int]) -> List[str]:\n        if not nums:\n            return []\n        result = []\n        start = nums[0]\n        for i in range(1, len(nums)):\n            if nums[i]!= start + 1:\n                if start!= -1:\n                    result.append(str(start) + \"->\" + str(nums[i]))\n                start = nums[i]\n            else:\n                if start == -1:\n                    result.append(str(start))\n                start = nums[i]\n        if start == -1:\n            result.append(str(start))\n        return result\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(0, 20)\n        nums = sorted(random.sample(range(-100, 100), length))\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'nums': eval(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.summaryRanges(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Input {'nums': [-98, -94, -91, -66, -49, -41, -20, -15, -4, 10, 17, 21, 33, 34, 51, 56, 71, 80, 82, 99]}\nExpected Output:  ['-98', '-94', '-91', '-66', '-49', '-41', '-20', '-15', '-4', '10', '17', '21', '33->34', '51', '56', '71', '80', '82', '99']\nActual Output:  ['-98->-94', '-94->-91', '-91->-66', '-66->-49', '-49->-41', '-41->-20', '-20->-15', '-15->-4', '-4->10', '10->17', '17->21', '21->33', '34->51', '51->56', '56->71', '71->80', '80->82', '82->99']\n1 Test Failed!\n",
      "time": "0.063",
      "memory": 4920,
      "stderr": null,
      "token": "75128eac-b1f0-48c3-a2fd-3b91e8573f3d",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 4,
        "description": "Wrong Answer"
      }
    }
  },
  {
    "status": "success",
    "question_id": 229,
    "title": "majority-element-ii",
    "token": "c1f16450-5d18-4d76-9b2a-2bae3df580ca",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nfrom collections import defaultdict\nimport random\nimport json\n\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def majorityElement(self, nums: List[int]) -> List[int]:\n        n1, n2 = nums[0], nums[0]\n        for i in range(1, len(nums)):\n            if nums[i] == n1:\n                n1 = nums[i]\n                n2 = nums[i]\n                c1 += 1\n                c2 += 1\n            elif nums[i] == n2:\n                n2 = nums[i]\n                c2 += 1\n            else:\n                c1 -= 1\n                c2 -= 1\n        return [n1, n2]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(1, 100)\n        nums = [random.randint(-10, 10) for _ in range(length)]\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return json.dumps(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return json.loads(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.majorityElement(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": null,
      "time": "0.052",
      "memory": 4916,
      "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 114, in <module>\n    runner.run()\n  File \"script.py\", line 98, in run\n    output = self.solution.majorityElement(**input)\n  File \"script.py\", line 64, in majorityElement\n    c1 -= 1\nUnboundLocalError: local variable 'c1' referenced before assignment\n",
      "token": "c1f16450-5d18-4d76-9b2a-2bae3df580ca",
      "compile_output": null,
      "message": "Exited with error status 1",
      "status": {
        "id": 11,
        "description": "Runtime Error (NZEC)"
      }
    }
  },
  {
    "status": "success",
    "question_id": 230,
    "title": "kth-smallest-element-in-a-bst",
    "token": "56f3f13b-a322-44c7-a9c2-99bfa3defba6",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import Optional\nimport json\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:\n        if not root:\n            return -1\n        stack = [(root, 0)]\n        while stack:\n            node, level = stack.pop()\n            if node.left:\n                stack.append((node.left, level+1))\n            if node.right:\n                stack.append((node.right, level+1))\n            if level == k:\n                return node.val\n        return -1\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        root = TreeNode(3)\n        root.left = TreeNode(1)\n        root.right = TreeNode(4)\n        root.left.right = TreeNode(2)\n        k = 1\n        return {'root': root, 'k': k}\n\n    def encode_input(self, input_obj) -> str:\n\n        def tree_to_list(node):\n            if not node:\n                return None\n            return [node.val, tree_to_list(node.left), tree_to_list(node.right)]\n        as_list = tree_to_list(input_obj['root'])\n        return json.dumps({'root': as_list, 'k': input_obj['k']})\n\n    def encode_output(self, output_obj) -> str:\n        return json.dumps({'output': output_obj})\n\n    def decode_input(self, input_str) -> dict:\n\n        def list_to_tree(lst):\n            if not lst:\n                return None\n            node = TreeNode(lst[0])\n            node.left = list_to_tree(lst[1])\n            node.right = list_to_tree(lst[2])\n            return node\n        data = json.loads(input_str)\n        return {'root': list_to_tree(data['root']), 'k': data['k']}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.kthSmallest(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Input {'root': <__main__.TreeNode object at 0x7faf2ba57ac0>, 'k': 1}\nExpected Output:  {\"output\": 1}\nActual Output:  {\"output\": 4}\n1 Test Failed!\n",
      "time": "0.047",
      "memory": 4736,
      "stderr": null,
      "token": "56f3f13b-a322-44c7-a9c2-99bfa3defba6",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 4,
        "description": "Wrong Answer"
      }
    }
  },
  {
    "status": "success",
    "question_id": 231,
    "title": "power-of-two",
    "token": "c63f7c87-b2a4-46aa-9227-acca5aa3a871",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def isPowerOfTwo(self, n: int) -> bool:\n        return n > 0 and 2 ** n == n\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        \"\"\" Generate random test cases for `isPowerOfTwo` method. \"\"\"\n        n = random.choice([1, 2, 4, 8, 16, 32, 64, 3, 5, 7, 9, 0, -1])\n        return {'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\" Convert the generate method's output into a test input string. \"\"\"\n        return str(input_obj['n'])\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\" Convert the output of the entry_point method into a test output string. \"\"\"\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\" Convert a test input string back into a Python dict for use in the entry_point method. \"\"\"\n        return {'n': int(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.isPowerOfTwo(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Input {'n': 8}\nExpected Output:  8\nActual Output:  False\n1 Test Failed!\n",
      "time": "0.047",
      "memory": 4796,
      "stderr": null,
      "token": "c63f7c87-b2a4-46aa-9227-acca5aa3a871",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 4,
        "description": "Wrong Answer"
      }
    }
  },
  {
    "status": "success",
    "question_id": 233,
    "title": "number-of-digit-one",
    "token": "e3cb4b98-f0ca-4687-9c0b-a3c897c4a4d5",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def countDigitOne(self, n: int) -> int:\n        ans = 0\n        while n > 0:\n            ans += n * (10 ** i) + 10 ** (i - 1)\n            n //= 10\n            i += 1\n        return ans\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        n = random.randint(0, 1000000)\n        return {'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['n'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'n': int(input_str)}\n\n    def decode_output(self, output_str) -> int:\n        return int(output_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.countDigitOne(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": null,
      "time": "0.053",
      "memory": 4824,
      "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 105, in <module>\n    runner.run()\n  File \"script.py\", line 89, in run\n    output = self.solution.countDigitOne(**input)\n  File \"script.py\", line 51, in countDigitOne\n    ans += n * (10 ** i) + 10 ** (i - 1)\nUnboundLocalError: local variable 'i' referenced before assignment\n",
      "token": "e3cb4b98-f0ca-4687-9c0b-a3c897c4a4d5",
      "compile_output": null,
      "message": "Exited with error status 1",
      "status": {
        "id": 11,
        "description": "Runtime Error (NZEC)"
      }
    }
  },
  {
    "status": "success",
    "question_id": 123,
    "title": "best-time-to-buy-and-sell-stock-iii",
    "token": "f9bdad17-142e-495a-8f93-d04e6cb891e6",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        # Tabulation\n\n        n = len(prices)\n        dp = [[[0 for _ in range(3)] for _ in range(2)] for _ in range(n + 1)]\n\n        # Base cases are already covered as the dp is initialized to 0\n      \n        for i in range(n - 1, -1, -1):\n            for j in range(2):\n                for k in range(1, 3):\n                    if j == 0:\n                        dp[i][j][k] = max(-prices[i] + dp[i + 1][1][k], 0 + dp[i + 1][0][k])\n                    else:\n                        dp[i][j][k] = max(+prices[i] + dp[i + 1][0][k - 1], 0 + dp[i + 1][1][k])\n\n        return dp[0][0][2]\n\nclass TestCaseGenerator:\n    import random\n\n    def generate(self) -> dict:\n        length = self.random.randint(1, 100)\n        prices = [self.random.randint(0, 100) for _ in range(length)]\n        return {'prices': prices}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.maxProfit(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "0.053",
      "memory": 5028,
      "stderr": null,
      "token": "f9bdad17-142e-495a-8f93-d04e6cb891e6",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "success",
    "question_id": 125,
    "title": "valid-palindrome",
    "token": "a8732db5-4d84-4e2e-bfbc-30a2c2b1028d",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport json\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def isPalindrome(self, s: str) -> bool:\n        return s == s[::-1]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        \"\"\"Generate random test case input for isPalindrome function.\"\"\"\n        test_cases = ['A man, a plan, a canal: Panama', 'race a car', '', ' ', 'Able was I ere I saw Elba', '!!!abcba!!!', '12321', 'No lemon, no melon', 'Step on no pets']\n        return {'s': random.choice(test_cases)}\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\"Convert a test case input into a JSON string.\"\"\"\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\"Convert a test case output into a JSON string.\"\"\"\n        return 'true' if output_obj else 'false'\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\"Convert a test case input string into a Python dict.\"\"\"\n        return json.loads(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.isPalindrome(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Input {'s': 'Step on no pets'}\nExpected Output:  true\nActual Output:  false\n1 Test Failed!\n",
      "time": "0.049",
      "memory": 4784,
      "stderr": null,
      "token": "a8732db5-4d84-4e2e-bfbc-30a2c2b1028d",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 4,
        "description": "Wrong Answer"
      }
    }
  },
  {
    "status": "success",
    "question_id": 128,
    "title": "longest-consecutive-sequence",
    "token": "bfc80645-6065-421a-996b-d955f4d59618",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\nimport json\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def longestConsecutive(self, nums: List[int]) -> int:\n        numset = set(nums)\n        res = 0\n        for n in nums:\n            if (n-1) not in numset:\n                op = 0\n                while (n+op) in numset:\n                    op+=1\n                res = max(res,op)\n        return res\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(0, 100)\n        nums = random.sample(range(-10 ** 9, 10 ** 9), length)\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return json.loads(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.longestConsecutive(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "0.056",
      "memory": 4992,
      "stderr": null,
      "token": "bfc80645-6065-421a-996b-d955f4d59618",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "success",
    "question_id": 130,
    "title": "surrounded-regions",
    "token": "5aae0f1d-34d5-4cba-95ce-0ccddcc46f91",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport collections\nimport random\nfrom typing import List\nfrom ast import literal_eval\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def solve(self, board: List[List[str]]) -> None:\n        \"\"\"\n        Do not return anything, modify board in-place instead.\n        \"\"\"\n        M, N = len(board), len(board[0])\n        total_visited = set()\n        def dfs(i,j):\n            nonlocal M,N,board,total_visited\n            curr_visited = set()\n            q = [(i,j)]\n            edged = False\n            while q:\n                curr = q.pop()\n                curr_visited.add(curr)\n                for di in [(-1,0), (1,0), (0,1), (0,-1)]:\n                    new_i, new_j = curr[0]+di[0], curr[1]+di[1]\n                    if new_i >= 0 and new_i < M and new_j >= 0 and new_j < N:\n                        if board[new_i][new_j] == 'O' and (new_i, new_j) not in curr_visited:\n                            q.append((new_i, new_j))\n                    else:\n                        edged = True\n            total_visited.update(curr_visited)\n            if edged:\n                return\n            for i,j in curr_visited:\n                board[i][j] = 'X'\n                \n\n        for i in range(M):\n            for j in range(N):\n                if board[i][j] == 'O' and (i,j) not in total_visited:\n                    dfs(i,j)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        ...\n\n    def encode_input(self, input_obj) -> str:\n        ...\n\n    def encode_output(self, output_obj) -> str:\n        ...\n\n    def decode_input(self, input_str) -> dict:\n        ...\n\n    def decode_output(self, output_str) -> str:\n        ...\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.solve(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": null,
      "time": "0.051",
      "memory": 5160,
      "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 131, in <module>\n    runner.run()\n  File \"script.py\", line 115, in run\n    output = self.solution.solve(**input)\nTypeError: solve() argument after ** must be a mapping, not NoneType\n",
      "token": "5aae0f1d-34d5-4cba-95ce-0ccddcc46f91",
      "compile_output": null,
      "message": "Exited with error status 1",
      "status": {
        "id": 11,
        "description": "Runtime Error (NZEC)"
      }
    }
  },
  {
    "status": "success",
    "question_id": 82,
    "title": "remove-duplicates-from-sorted-list-ii",
    "token": "b43d9090-e18d-4207-bccb-304191ec81c9",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import Optional\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        dummy = ListNode(-1)\n        dummy.next = head\n        curr, prev = dummy, head\n        while curr and curr.next:\n            if curr.next.val == curr.val:\n                prev.next = curr.next\n                curr = curr.next\n            else:\n                prev = curr\n                curr = curr.next\n        return dummy.next\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        list_values = self._create_random_sorted_list()\n        head = self._convert_list_to_linkedlist(list_values)\n        return {'head': head}\n\n    def encode_input(self, input_obj) -> str:\n        encoded_input = []\n        current = input_obj['head']\n        while current:\n            encoded_input.append(current.val)\n            current = current.next\n        return str(encoded_input)\n\n    def encode_output(self, output_obj) -> str:\n        encoded_output = []\n        current = output_obj\n        while current:\n            encoded_output.append(current.val)\n            current = current.next\n        return str(encoded_output)\n\n    def decode_input(self, input_str) -> dict:\n        node_values = eval(input_str)\n        head = self._convert_list_to_linkedlist(node_values)\n        return {'head': head}\n\n    def _create_random_sorted_list(self) -> list:\n        list_size = random.randint(0, 30)\n        values = []\n        while len(values) < list_size:\n            rand_value = random.randint(-100, 100)\n            if random.choice([True, False]):\n                values += [rand_value] * random.randint(1, 3)\n            else:\n                values.append(rand_value)\n        values = sorted(values[:300])\n        return values\n\n    def _convert_list_to_linkedlist(self, values: list) -> Optional[ListNode]:\n        if not values:\n            return None\n        head = ListNode(values[0])\n        current = head\n        for value in values[1:]:\n            current.next = ListNode(value)\n            current = current.next\n        return head\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.deleteDuplicates(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Input {'head': <__main__.ListNode object at 0x7fea7d545d30>}\nExpected Output:  [-16, 34, 35, 63, 73, 75, 87, 97]\nActual Output:  [-93, -34, -16, 34, 35, 42, 60, 63, 73, 75, 85, 87, 97]\n1 Test Failed!\n",
      "time": "0.059",
      "memory": 4808,
      "stderr": null,
      "token": "b43d9090-e18d-4207-bccb-304191ec81c9",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 4,
        "description": "Wrong Answer"
      }
    }
  },
  {
    "status": "success",
    "question_id": 84,
    "title": "largest-rectangle-in-histogram",
    "token": "21ef6b3b-f842-4d24-bf33-0ddd1062fb52",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def largestRectangleArea(self, heights: List[int]) -> int:\n        # OK\n        stack = []\n        max_area = 0\n        heights = [-1] + heights + [-1]\n        for i, h in enumerate(heights):\n            while stack and heights[stack[-1]] > h:\n                rr = i\n                k = stack.pop()\n                ll = stack[-1]\n                h = heights[k]\n                length = i - ll - 1\n                area = max(area, h * length)\n            stack.append(i)\n\n        return max_area\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        num_bars = random.randint(1, 10)\n        heights = [random.randint(0, 10) for _ in range(num_bars)]\n        return {'heights': heights}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['heights'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        heights = eval(input_str)\n        return {'heights': heights}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.largestRectangleArea(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": null,
      "time": "0.055",
      "memory": 4760,
      "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 113, in <module>\n    runner.run()\n  File \"script.py\", line 97, in run\n    output = self.solution.largestRectangleArea(**input)\n  File \"script.py\", line 61, in largestRectangleArea\n    area = max(area, h * length)\nUnboundLocalError: local variable 'area' referenced before assignment\n",
      "token": "21ef6b3b-f842-4d24-bf33-0ddd1062fb52",
      "compile_output": null,
      "message": "Exited with error status 1",
      "status": {
        "id": 11,
        "description": "Runtime Error (NZEC)"
      }
    }
  },
  {
    "status": "success",
    "question_id": 85,
    "title": "maximal-rectangle",
    "token": "2e2db31f-799e-41f8-9487-5d541a6c15e8",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\n        m, n = len(matrix), len(matrix[0])\n        dp = [[0 for _ in range(n+1)] for _ in range(m+1)]\n        for i in range(1, m+1):\n            for j in range(1, n+1):\n                if matrix[i-1][j-1] == '1':\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1] + 1) * (j+1)\n        return max(max(dp[i][j] for i in range(1, m+1) for j in range(1, n+1)) for i in range(1, m+1))\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        rows = random.randint(1, 20)\n        cols = random.randint(1, 20)\n        matrix = [[random.choice(['0', '1']) for _ in range(cols)] for _ in range(rows)]\n        return {'matrix': matrix}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['matrix'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        input_list = eval(input_str)\n        return {'matrix': input_list}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.maximalRectangle(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Input {'matrix': [['0', '1', '1', '1', '0', '1', '0'], ['0', '0', '0', '1', '0', '1', '1'], ['0', '1', '0', '0', '0', '1', '0'], ['0', '1', '1', '0', '1', '0', '0'], ['1', '1', '1', '0', '1', '1', '0'], ['0', '1', '1', '1', '0', '0', '0']]}\nExpected Output:  6\nActual Output:  3205\n1 Test Failed!\n",
      "time": "0.051",
      "memory": 4836,
      "stderr": null,
      "token": "2e2db31f-799e-41f8-9487-5d541a6c15e8",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 4,
        "description": "Wrong Answer"
      }
    }
  },
  {
    "status": "success",
    "question_id": 87,
    "title": "scramble-string",
    "token": "74b87e33-2c6d-4d70-a064-6ca23c84f90b",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport numpy as np\nimport random\nimport string\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def isScramble(self, s1: str, s2: str) -> bool:\n        def isScramble1(s1, s2):\n            return True if s1==s2 else False\n\n        def isScramble2(s1, s2):\n            if len(s1)!=len(s2):\n                return False\n            for i in range(len(s1)):\n                if isScramble1(s1[:i], s2[:i])!= isScramble1(s1[i:], s2[i:]):\n                    return False\n            return True\n\n        return isScramble2(s1, s2)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(1, 30)\n        s1 = ''.join(random.choices(string.ascii_lowercase, k=length))\n        s2 = self.scramble(s1)\n        return {'s1': s1, 's2': s2}\n\n    def scramble(self, s: str) -> str:\n        if len(s) == 1:\n            return s\n        i = random.randint(1, len(s) - 1)\n        x, y = (s[:i], s[i:])\n        if random.random() > 0.5:\n            return self.scramble(x) + self.scramble(y)\n        else:\n            return self.scramble(y) + self.scramble(x)\n\n    def encode_input(self, input_obj: dict) -> str:\n        return f\"{input_obj['s1']},{input_obj['s2']}\"\n\n    def encode_output(self, output_obj: bool) -> str:\n        return 'true' if output_obj else 'false'\n\n    def decode_input(self, input_str: str) -> dict:\n        s1, s2 = input_str.split(',')\n        return {'s1': s1, 's2': s2}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.isScramble(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": null,
      "time": "0.056",
      "memory": 4592,
      "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 26, in <module>\n    import numpy as np\nModuleNotFoundError: No module named 'numpy'\n",
      "token": "74b87e33-2c6d-4d70-a064-6ca23c84f90b",
      "compile_output": null,
      "message": "Exited with error status 1",
      "status": {
        "id": 11,
        "description": "Runtime Error (NZEC)"
      }
    }
  },
  {
    "status": "success",
    "question_id": 88,
    "title": "merge-sorted-array",
    "token": "a125b513-5561-4612-ab17-aadf5a6b1025",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\nimport ast\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\n        \"\"\"\n        Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        p1 = m-1\n        p2 = n-1\n        p = m+n-1\n        while p2 >= 0:\n            if p1 >= 0 and nums1[p1] > nums2[p2]:\n                nums1[p] = nums1[p1]\n                p1 -= 1\n            else:\n                nums1[p] = nums2[p2]\n                p2 -= 1\n            p -= 1\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        test_cases = [{'nums1': [1, 2, 3, 0, 0, 0], 'm': 3, 'nums2': [2, 5, 6], 'n': 3}, {'nums1': [4, 5, 6, 0, 0, 0], 'm': 3, 'nums2': [1, 2, 3], 'n': 3}, {'nums1': [1], 'm': 1, 'nums2': [], 'n': 0}, {'nums1': [0], 'm': 0, 'nums2': [1], 'n': 1}, {'nums1': [1, 2, 4, 5, 6, 0, 0, 0], 'm': 5, 'nums2': [3, 7, 8], 'n': 3}]\n        return random.choice(test_cases)\n\n    def encode_input(self, input_obj) -> str:\n        return f'{input_obj}'\n\n    def encode_output(self, output_obj) -> str:\n        return f'{output_obj}'\n\n    def decode_input(self, input_str) -> dict:\n        return ast.literal_eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.merge(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "0.067",
      "memory": 5336,
      "stderr": null,
      "token": "a125b513-5561-4612-ab17-aadf5a6b1025",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "success",
    "question_id": 89,
    "title": "gray-code",
    "token": "c4a9c086-3172-476b-bf7b-e286d7727089",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def grayCode(self, n: int) -> List[int]:\n        return [0, 1] + list(self.grayCode(n-1))\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 16)\n        return {'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"n = {input_obj['n']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return f'{output_obj}'\n\n    def decode_input(self, input_str) -> dict:\n        lines = input_str.split(' = ')\n        return {'n': int(lines[1])}\n\n    def decode_output(self, output_str) -> dict:\n        output_obj = eval(output_str)\n        return output_obj\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.grayCode(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": null,
      "time": "0.078",
      "memory": 16232,
      "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 102, in <module>\n    runner.run()\n  File \"script.py\", line 86, in run\n    output = self.solution.grayCode(**input)\n  File \"script.py\", line 50, in grayCode\n    return [0, 1] + list(self.grayCode(n-1))\n  File \"script.py\", line 50, in grayCode\n    return [0, 1] + list(self.grayCode(n-1))\n  File \"script.py\", line 50, in grayCode\n    return [0, 1] + list(self.grayCode(n-1))\n  [Previous line repeated 995 more times]\nRecursionError: maximum recursion depth exceeded\n",
      "token": "c4a9c086-3172-476b-bf7b-e286d7727089",
      "compile_output": null,
      "message": "Exited with error status 1",
      "status": {
        "id": 11,
        "description": "Runtime Error (NZEC)"
      }
    }
  },
  {
    "status": "success",
    "question_id": 90,
    "title": "subsets-ii",
    "token": "4c3bc6f5-b9fe-4c46-b9c6-d3391d84d193",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\n        ans=[]\n        ds=[]\n        nums.sort()\n        def findSubsets(ind:int):\n            ans.append(ds[:])\n            for i in range(ind,len(nums)):\n                if i!= ind and nums[i] == nums[i-1]:\n                    continue\n                ds.append(nums[i])\n                findSubsets(i+1)\n                ds.pop()\n        findSubsets(0)\n        return ans\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(1, 10)\n        nums = [random.randint(-10, 10) for _ in range(length)]\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.subsetsWithDup(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Input {'nums': [-7, 2, 4]}\nExpected Output:  [[], [-7], [2], [-7, 2], [4], [-7, 4], [2, 4], [-7, 2, 4]]\nActual Output:  [[], [-7], [-7, 2], [-7, 2, 4], [-7, 4], [2], [2, 4], [4]]\n1 Test Failed!\n",
      "time": "0.062",
      "memory": 6500,
      "stderr": null,
      "token": "4c3bc6f5-b9fe-4c46-b9c6-d3391d84d193",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 4,
        "description": "Wrong Answer"
      }
    }
  },
  {
    "status": "success",
    "question_id": 144,
    "title": "binary-tree-preorder-traversal",
    "token": "03ebf75b-cc8d-4c52-97ec-d2608bf13e78",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List, Optional, Union\nimport random\n\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\ndef solve(root, ans):\n    if root is None:\n        return\n    ans.append(root.val)\n    solve(root.left,ans)\n    solve(root.right,ans)\n\nclass Solution:\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        ans = []\n        solve(root,ans)\n        return ans\n\n#### Input Code:\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        ans = []\n        return ans\n\nclass TestCaseGenerator:\n\n    class TreeNode:\n\n        def __init__(self, val=0, left=None, right=None):\n            self.val = val\n            self.left = left\n            self.right = right\n\n    def generate(self) -> dict:\n\n        def generate_random_tree(size=100):\n            if size == 0:\n                return None\n            nodes = [self.TreeNode(val=random.randint(-100, 100)) for _ in range(size)]\n            for i in range(size):\n                if 2 * i + 1 < size:\n                    nodes[i].left = nodes[2 * i + 1]\n                if 2 * i + 2 < size:\n                    nodes[i].right = nodes[2 * i + 2]\n            return nodes[0] if size > 0 else None\n        tree_size = random.randint(0, 10)\n        root = generate_random_tree(tree_size)\n        return {'root': root}\n\n    def encode_input(self, input_obj: dict) -> str:\n\n        def tree_to_list(root):\n            if not root:\n                return []\n            queue = [(root, 0)]\n            result = []\n            while queue:\n                node, index = queue.pop(0)\n                if node:\n                    if index >= len(result):\n                        result.extend([None] * (index - len(result) + 1))\n                    result[index] = node.val\n                    queue.append((node.left, 2 * index + 1))\n                    queue.append((node.right, 2 * index + 2))\n            while result and result[-1] is None:\n                result.pop()\n            return result\n        root = input_obj['root']\n        return str(tree_to_list(root))\n\n    def encode_output(self, output_obj: List[int]) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str: str) -> dict:\n\n        def list_to_tree(nodes: List[Union[int, None]]):\n            if not nodes:\n                return None\n            tree_nodes = [self.TreeNode(val=v) if v is not None else None for v in nodes]\n            for i in range(len(nodes)):\n                if tree_nodes[i] is not None:\n                    left_index = 2 * i + 1\n                    right_index = 2 * i + 2\n                    if left_index < len(tree_nodes):\n                        tree_nodes[i].left = tree_nodes[left_index]\n                    if right_index < len(tree_nodes):\n                        tree_nodes[i].right = tree_nodes[right_index]\n            return tree_nodes[0] if tree_nodes else None\n        nodes_list = eval(input_str)\n        root = list_to_tree(nodes_list)\n        return {'root': root}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.preorderTraversal(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Input {'root': <__main__.TestCaseGenerator.TreeNode object at 0x7fd630e54250>}\nExpected Output:  [72, -51, -17, 64, 46, 71, 0, 71, 75]\nActual Output:  []\n1 Test Failed!\n",
      "time": "0.048",
      "memory": 4836,
      "stderr": null,
      "token": "03ebf75b-cc8d-4c52-97ec-d2608bf13e78",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 4,
        "description": "Wrong Answer"
      }
    }
  },
  {
    "status": "success",
    "question_id": 148,
    "title": "sort-list",
    "token": "bc9e649c-5828-46c2-b462-3717a2f06eaf",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import Optional\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        def merge(head1, head2):\n            resultHead = ListNode(0)\n            cur = resultHead\n            while head1!= None or head2!= None:\n                if head1 == None:\n                    cur.next = head2\n                    head2 = None\n                elif head2 == None:\n                    cur.next = head1\n                    head1 = None\n                else:\n                    if head1.val < head2.val:\n                        cur.next = head1\n                        cur = head1\n                        head1 = head1.next \n                    else:\n                        cur.next = head2\n                        cur = head2\n                        head2 = head2.next\n            \n            return resultHead.next\n\n\n        def findOneBeforeMiddle(head):\n            fast = head\n            slow = head\n            prev = None\n            while fast and fast.next:\n                prev = slow\n\n                fast = fast.next.next\n                slow = slow.next\n                \n            return prev\n        \n        if not head or not head.next:\n            return head\n\n        prev = findOneBeforeMiddle(head)\n        if prev!= None:\n            middle = prev.next\n            prev.next = None\n\n        return merge(self.sortList(head), self.sortList(middle))\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        ...\n\n    def encode_input(self, input_obj) -> str:\n        ...\n\n    def encode_output(self, output_obj) -> str:\n        ...\n\n    def decode_input(self, input_str) -> dict:\n        ...\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.sortList(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": null,
      "time": "0.049",
      "memory": 4792,
      "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 144, in <module>\n    runner.run()\n  File \"script.py\", line 128, in run\n    output = self.solution.sortList(**input)\nTypeError: sortList() argument after ** must be a mapping, not NoneType\n",
      "token": "bc9e649c-5828-46c2-b462-3717a2f06eaf",
      "compile_output": null,
      "message": "Exited with error status 1",
      "status": {
        "id": 11,
        "description": "Runtime Error (NZEC)"
      }
    }
  },
  {
    "status": "success",
    "question_id": 149,
    "title": "max-points-on-a-line",
    "token": "354f152c-d9d6-47aa-9367-91f949e5e509",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nfrom collections import defaultdict\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n\n    def num(self, points, p1, p2):\n        v = [p2[0]-p1[0], p2[1]-p1[1]]\n        n = [v[1], -v[0]]\n        C = p2[0]*p1[1]-p1[0]*p2[1]\n        count = 0\n        for p in points:\n            sum_v = n[0]*p[0] + n[1]*p[1] + C\n\n            if sum_v == 0:\n                count += 1\n        return count\n\n    def maxPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        if n == 1:\n            return 1\n        max_num = 0\n        d = {}\n        for i in range(n):\n            for j in range(i+1,n):\n                if (i,j) in d or (j,i) in d:\n                    continue\n                max_num = max(max_num, self.num(points, points[i], points[j]))\n                d[(i,j)] = max_num\n        return max_num\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        simple_line = [[1, 1], [2, 2], [3, 3]]\n        mixed_points = [[1, 1], [3, 2], [5, 3], [4, 1], [2, 3], [1, 4]]\n        single_point = [[0, 0]]\n        return {'points': simple_line}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['points'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'points': eval(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.maxPoints(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "0.06",
      "memory": 4752,
      "stderr": null,
      "token": "354f152c-d9d6-47aa-9367-91f949e5e509",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "success",
    "question_id": 150,
    "title": "evaluate-reverse-polish-notation",
    "token": "e8aa0065-386c-43bd-9b30-483d5fc9bb1c",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport operator as op\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def evalRPN(self, tokens):\n        operators = ['+', '-', '*', '/']\n        stack = []\n        for i in tokens:\n            if i not in operators:\n                stack.append(i)\n            else:\n                operation = stack.pop(-2) + i + stack.pop()\n                stack.append(str(int(eval(operation))))\n        return int(stack[0])\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        operators = ['+', '-', '*', '/']\n        expressions = [('2', '1', '+', '3', '*'), ('4', '13', '5', '/', '+'), ('10', '6', '9', '3', '+', '-11', '*', '/', '*', '17', '+', '5', '+')]\n        selected_expr = random.choice(expressions)\n        return {'tokens': list(selected_expr)}\n\n    def encode_input(self, input_obj) -> str:\n        return ','.join(input_obj['tokens'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        tokens = input_str.split(',')\n        return {'tokens': tokens}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.evalRPN(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "0.055",
      "memory": 4872,
      "stderr": null,
      "token": "e8aa0065-386c-43bd-9b30-483d5fc9bb1c",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "success",
    "question_id": 153,
    "title": "find-minimum-in-rotated-sorted-array",
    "token": "16327696-b363-48ce-82d7-f7f7d0f499fb",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom random import randint, shuffle\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def findMin(self, arr: List[int]) -> int:\n        n = len(arr)\n        l = 0\n        h = n - 1\n        ans = float('inf')\n\n        while l <= h:\n            m = (l + h) // 2\n\n            if arr[l] <= arr[h]:\n                ans = min(arr[l], ans)\n                break\n\n            if arr[l] <= arr[m]:\n                ans = min (ans, arr[l])\n                l = m + 1\n            else:\n                ans = min(ans, arr[m])\n                h = m - 1\n        return ans\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = randint(2, 100)\n        sorted_array = sorted((randint(-5000, 5000) for _ in range(n)))\n        k = randint(1, n)\n        rotated_array = sorted_array[-k:] + sorted_array[:-k]\n        return {'nums': rotated_array}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'nums': eval(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.findMin(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": null,
      "time": "0.047",
      "memory": 5004,
      "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 118, in <module>\n    runner.run()\n  File \"script.py\", line 102, in run\n    output = self.solution.findMin(**input)\nTypeError: findMin() got an unexpected keyword argument 'nums'\n",
      "token": "16327696-b363-48ce-82d7-f7f7d0f499fb",
      "compile_output": null,
      "message": "Exited with error status 1",
      "status": {
        "id": 11,
        "description": "Runtime Error (NZEC)"
      }
    }
  },
  {
    "status": "success",
    "question_id": 160,
    "title": "intersection-of-two-linked-lists",
    "token": "0f94e76c-fa10-42a9-96e1-df3f8f10658d",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import Optional\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        if not headA or not headB:\n            return None\n        pA=headA\n        pB=headB\n        while pA!=pB:\n            pA=pA.next if pA else headB\n            pB=pB.next if pB else headA\n        return pA\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        \"\"\"\n        Generates a test case with an intersection in the linked list.\n        Returns a dictionary containing two linked list heads: headA and headB.\n        \"\"\"\n        common = ListNode(8)\n        common.next = ListNode(4)\n        common.next.next = ListNode(5)\n        listA = ListNode(4)\n        listA.next = ListNode(1)\n        listA.next.next = common\n        listB = ListNode(5)\n        listB.next = ListNode(6)\n        listB.next.next = ListNode(1)\n        listB.next.next.next = common\n        headA = listA\n        headB = listB\n        return {'headA': headA, 'headB': headB}\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\"\n        Encodes the length of both linked lists into a string.\n        \"\"\"\n        lengthA, lengthB = (0, 0)\n        currentA, currentB = (input_obj['headA'], input_obj['headB'])\n        while currentA:\n            lengthA += 1\n            currentA = currentA.next\n        while currentB:\n            lengthB += 1\n            currentB = currentB.next\n        return f'LENGTHS: A={lengthA}, B={lengthB}'\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\"\n        Returns the value of the intersecting node, or \"No Intersection\" if there isn\u2019t one.\n        \"\"\"\n        if output_obj:\n            return str(output_obj.val)\n        return 'No Intersection'\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\"\n        Decodes input (statically in our case) to provide test case linked lists.\n        \"\"\"\n        example_listA = [4, 1, 8, 4, 5]\n        example_listB = [5, 6, 1, 8, 4, 5]\n        headA, headB = (self._create_linked_list(example_listA), self._create_linked_list(example_listB))\n        return {'headA': headA, 'headB': headB}\n\n    def _create_linked_list(self, values):\n        \"\"\"\n        Helper method to create a linked list from a list of values.\n        \"\"\"\n        if not values:\n            return None\n        head = ListNode(values[0])\n        current = head\n        for val in values[1:]:\n            current.next = ListNode(val)\n            current = current.next\n        return head\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.getIntersectionNode(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "0.053",
      "memory": 4752,
      "stderr": null,
      "token": "0f94e76c-fa10-42a9-96e1-df3f8f10658d",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "success",
    "question_id": 238,
    "title": "product-of-array-except-self",
    "token": "a096c740-032b-461e-94a8-0a4c3e993577",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nfrom random import randint\nimport ast\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        res = [1] * len(nums)\n        prefix = 1\n        postfix = 1\n        for i in range(len(nums)):\n            res[i] = prefix\n            prefix *= nums[i]\n            postfix *= nums[i]\n        return res\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = randint(2, 10)\n        nums = [randint(-30, 30) for _ in range(length)]\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return ast.literal_eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.productExceptSelf(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Input {'nums': [12, -19, 13, 13, 27]}\nExpected Output:  [-86697, 54756, -80028, -80028, -38532]\nActual Output:  [1, 12, -228, -2964, -38532]\n1 Test Failed!\n",
      "time": "0.055",
      "memory": 5096,
      "stderr": null,
      "token": "a096c740-032b-461e-94a8-0a4c3e993577",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 4,
        "description": "Wrong Answer"
      }
    }
  },
  {
    "status": "success",
    "question_id": 239,
    "title": "sliding-window-maximum",
    "token": "fe13c65a-dde6-4758-85f3-de7d3479945f",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport heapq\nimport random\nimport json\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nfrom collections import deque\nimport heapq\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        q = deque()\n        heapq.heapify(q)\n        ans = []\n        for j, i in enumerate(nums):\n            if len(q) < k:\n                q.append(i)\n                if i > -1:\n                    heapq.heappop(q)\n                else:\n                    heapq.heappush(q, (-i, j))\n            else:\n                ans.append(-1)\n                pop = q.popleft()\n                if pop == -1:\n                    pop, index = heapq.heappop(q)\n                    -1\n                    while q:\n                        if q[0][1] < index:\n                            heapq.heappop(q)\n                        else:\n                            break\n                q.append(i)\n                if i > -1:\n                    heapq.heappush(q, (-1*i, j))\n        ans.append(-1)\n        return ans\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 100)\n        nums = [random.randint(-10000, 10000) for _ in range(n)]\n        k = random.randint(1, n)\n        return {'nums': nums, 'k': k}\n\n    def encode_input(self, input_obj: dict) -> str:\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj: list) -> str:\n        return json.dumps(output_obj)\n\n    def decode_input(self, input_str: str) -> dict:\n        return json.loads(input_str)\n\n    def decode_output(self, output_str: str) -> list:\n        return json.loads(output_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.maxSlidingWindow(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": null,
      "time": "0.071",
      "memory": 4948,
      "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 131, in <module>\n    runner.run()\n  File \"script.py\", line 115, in run\n    output = self.solution.maxSlidingWindow(**input)\n  File \"script.py\", line 55, in maxSlidingWindow\n    heapq.heapify(q)\nTypeError: heap argument must be a list\n",
      "token": "fe13c65a-dde6-4758-85f3-de7d3479945f",
      "compile_output": null,
      "message": "Exited with error status 1",
      "status": {
        "id": 11,
        "description": "Runtime Error (NZEC)"
      }
    }
  },
  {
    "status": "success",
    "question_id": 241,
    "title": "different-ways-to-add-parentheses",
    "token": "78c2e2b1-e393-423c-859c-210b330fcbc5",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport functools\nimport random\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def diffWaysToCompute(self, expression: str) -> List[int]:\n        if not expression:\n            return []\n        elif expression.isdigit():\n            return [int(expression)]\n        else:\n            res = []\n            for i, s in enumerate(expression):\n                if s in \"+-*\":\n                    l = self.diffWaysToCompute(expression[:i])\n                    r = self.diffWaysToCompute(expression[i+1:])\n                    for ls in l:\n                        for rs in r:\n                            res.append(eval(str(ls) + s + str(rs)))\n            return res\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        operators = ['+', '-', '*']\n        num_parts = random.randint(2, 5)\n        expression = str(random.randint(0, 99))\n        for _ in range(num_parts - 1):\n            operator = random.choice(operators)\n            number = random.randint(0, 99)\n            expression += operator + str(number)\n        return {'expression': expression}\n\n    def encode_input(self, input_obj: dict) -> str:\n        return input_obj['expression']\n\n    def encode_output(self, output_obj: List[int]) -> str:\n        return ','.join(map(str, output_obj))\n\n    def decode_input(self, input_str: str) -> dict:\n        return {'expression': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.diffWaysToCompute(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "0.058",
      "memory": 4872,
      "stderr": null,
      "token": "78c2e2b1-e393-423c-859c-210b330fcbc5",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "success",
    "question_id": 242,
    "title": "valid-anagram",
    "token": "474b66ec-7f4b-4e26-8e37-3eeaeac4a957",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def isAnagram(self, s: str, t: str) -> bool:\n        return self.countOfChar(s) == self.countOfChar(t)\n    \n    def countOfChar(self, str):\n        counter = {}\n        for char in str:\n            if char not in counter:\n                counter[char] = 1\n            else:\n                counter[char] += 1\n        return counter\n\n#### Explanation:\n# We create a dictionary of counters that stores the frequency of each character in string's' and another dictionary of counters that stores the frequency of each character in string 't'.\n# Then we compare the two counters and return True if they are equal.\n# We use a counter that maps characters to their frequency in's' and a counter that maps characters to their frequency in 't' to compare the two counters. \n# If the counters are equal, then the two strings are anagrams of each other.\n\nclass TestCaseGenerator:\n\n    def __init__(self):\n        self.examples = [{'s': 'anagram', 't': 'nagaram'}, {'s': 'rat', 't': 'car'}, {'s': 'listen', 't': 'silent'}, {'s': 'hello', 't': 'bello'}, {'s': 'debitcard', 't': 'badcredit'}]\n\n    def generate(self) -> dict:\n        return random.choice(self.examples)\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['s']},{input_obj['t']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj).lower()\n\n    def decode_input(self, input_str) -> dict:\n        s, t = input_str.split(',')\n        return {'s': s, 't': t}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.isAnagram(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "0.058",
      "memory": 4792,
      "stderr": null,
      "token": "474b66ec-7f4b-4e26-8e37-3eeaeac4a957",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "success",
    "question_id": 31,
    "title": "next-permutation",
    "token": "8d0bc4f4-ff50-4989-9afb-41704f8882af",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def reverse(self, nums, i, j):\n        while i < j:\n            self.swap(nums, i, j)\n            i += 1\n            j -= 1\n\n    def nextPermutation(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        i = len(nums) - 2\n        while i >= 0 and nums[i] >= nums[i + 1]:\n            i -= 1\n        if i >= 0:\n            j = len(nums) - 1\n            while nums[j] <= nums[i]:\n                j -= 1\n            self.swap(nums, i, j)\n        self.reverse(nums, i+1, len(nums) - 1)\n\n        return nums\n\nclass TestCaseGenerator:\n\n    def __init__(self):\n        self.sample = random.sample\n        self.randint = random.randint\n\n    def generate(self) -> dict:\n        length = self.randint(1, 10)\n        nums = self.sample(range(0, 101), length)\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'nums': list(map(int, input_str.strip('[]').split(',')))}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.nextPermutation(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": null,
      "time": "0.055",
      "memory": 4776,
      "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 120, in <module>\n    runner.run()\n  File \"script.py\", line 104, in run\n    output = self.solution.nextPermutation(**input)\n  File \"script.py\", line 65, in nextPermutation\n    self.swap(nums, i, j)\nAttributeError: 'Solution' object has no attribute 'swap'\n",
      "token": "8d0bc4f4-ff50-4989-9afb-41704f8882af",
      "compile_output": null,
      "message": "Exited with error status 1",
      "status": {
        "id": 11,
        "description": "Runtime Error (NZEC)"
      }
    }
  },
  {
    "status": "success",
    "question_id": 32,
    "title": "longest-valid-parentheses",
    "token": "de3f8dd0-d77d-40ff-9efa-34fd910aa118",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def longestValidParentheses(self, s: str) -> int:\n        memo = {}\n        def dfs(i):\n            if i >= len(s):\n                return 0\n            if i in memo:\n                return memo[i]\n            memo[i] = 0\n            if s[i] == '(':\n                if i + 1 < len(s) and s[i + 1] == ')':\n                    memo[i] = dfs(i + 2) + 2\n                elif i + dfs(i + 1) + 1 < len(s) and s[i + dfs(i + 1) + 1] == ')':\n                    memo[i] = dfs(i + 1) + 2 + dfs(i + dfs(i + 1) + 2)\n            return memo[i]\n\n        for i in range(len(s)):\n            dfs(i)\n        return max(memo.values()) if memo else 0\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        length = random.randint(0, 20)\n        parentheses = [random.choice(['(', ')']) for _ in range(length)]\n        return {'s': ''.join(parentheses)}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['s']\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.longestValidParentheses(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "0.058",
      "memory": 4768,
      "stderr": null,
      "token": "de3f8dd0-d77d-40ff-9efa-34fd910aa118",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "success",
    "question_id": 33,
    "title": "search-in-rotated-sorted-array",
    "token": "d804aeb6-e559-4bdb-9626-7806331502c0",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        l = 0\n        r = len(nums) - 1\n        while l <= r:\n            mid = (l + r) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                if nums[mid] <= nums[l] and nums[mid] <= nums[r]:\n                    l = mid + 1\n                else:\n                    r = mid - 1\n            elif nums[mid] > target:\n                if nums[mid] >= nums[l] and nums[mid] >= nums[r]:\n                    r = mid - 1\n                else:\n                    l = mid + 1\n        return -1\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 20)\n        array = sorted(random.sample(range(-50, 50), n))\n        k = random.randint(0, n - 1)\n        rotated_array = array[k:] + array[:k]\n        target = random.choice(rotated_array + [101])\n        return {'nums': rotated_array, 'target': target}\n\n    def encode_input(self, input_obj) -> str:\n        nums_str = ','.join(map(str, input_obj['nums']))\n        target_str = str(input_obj['target'])\n        return f'nums=[{nums_str}], target={target_str}'\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        input_str = input_str.strip()\n        nums_part = input_str.split('target=')[0].strip()\n        target_part = input_str.split('target=')[1].strip()\n        nums = list(map(int, nums_part[nums_part.index('[') + 1:nums_part.rindex(']')].split(',')))\n        target = int(target_part)\n        return {'nums': nums, 'target': target}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.search(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Input {'nums': [42, -46, -41, -39, -36, -34, -30, -25, -15, 6, 21], 'target': -41}\nExpected Output:  2\nActual Output:  -1\n3 Test Failed!\n",
      "time": "0.05",
      "memory": 4796,
      "stderr": null,
      "token": "d804aeb6-e559-4bdb-9626-7806331502c0",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 4,
        "description": "Wrong Answer"
      }
    }
  },
  {
    "status": "success",
    "question_id": 34,
    "title": "find-first-and-last-position-of-element-in-sorted-array",
    "token": "510c29d4-3b89-4d97-a379-698b3fff9e01",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\n        return self.searchRange(nums, 0, len(nums) - 1, target)\n    \n    def searchRange(self, nums, l, r, target):\n        if l > r:\n            return [-1, -1]\n        m = bisect_left(nums, target)\n        if m == len(nums) or nums[m]!= target:\n            return [-1, -1]\n        m += 1\n        if m < len(nums) and nums[m] == target:\n            return [m, m]\n        return [m - 1, m]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        test_cases = [{'nums': [5, 7, 7, 8, 8, 10], 'target': 8}, {'nums': [5, 7, 7, 8, 8, 10], 'target': 6}, {'nums': [], 'target': 0}, {'nums': [2, 2, 2, 2, 2], 'target': 2}, {'nums': [1, 3, 5, 6, 8, 10], 'target': 7}]\n        return random.choice(test_cases)\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['nums']}|{input_obj['target']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        nums_str, target_str = input_str.split('|')\n        nums = list(map(int, nums_str.strip('[]').split(','))) if nums_str.strip('[]') else []\n        target = int(target_str)\n        return {'nums': nums, 'target': target}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.searchRange(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": null,
      "time": "0.051",
      "memory": 4780,
      "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 111, in <module>\n    runner.run()\n  File \"script.py\", line 95, in run\n    output = self.solution.searchRange(**input)\nTypeError: searchRange() missing 2 required positional arguments: 'l' and 'r'\n",
      "token": "510c29d4-3b89-4d97-a379-698b3fff9e01",
      "compile_output": null,
      "message": "Exited with error status 1",
      "status": {
        "id": 11,
        "description": "Runtime Error (NZEC)"
      }
    }
  },
  {
    "status": "success",
    "question_id": 191,
    "title": "number-of-1-bits",
    "token": "e1d9a02f-b7ba-4822-a86b-acac74956fd5",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport json\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def hammingWeight(self, n: int) -> int:\n        return bin(n)[2:].count('1')\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 2 ** 20)\n        return {'n': n}\n\n    def encode_input(self, input_obj: dict) -> str:\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj: int) -> str:\n        return json.dumps({'result': output_obj})\n\n    def decode_input(self, input_str: str) -> dict:\n        return json.loads(input_str)\n\n    def decode_output(self, output_str: str) -> int:\n        return json.loads(output_str)['result']\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.hammingWeight(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "0.056",
      "memory": 4824,
      "stderr": null,
      "token": "e1d9a02f-b7ba-4822-a86b-acac74956fd5",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "success",
    "question_id": 198,
    "title": "house-robber",
    "token": "75c38c28-b758-47e5-a9ee-38a1d41182fd",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def rob(self, nums: List[int]) -> int:\n        \n        if (len(nums) == 0):\n            return 0\n        elif (len(nums) == 1):\n            return nums[0]\n        elif (len(nums) == 2):\n            return max(nums)\n        \n        dp = [0]* len(nums)\n        dp[0] = nums[0]\n        dp[1] = max(nums[0:2])\n        \n        \n        for i in range(2, len(nums)):\n            dp[i] = max(dp[i-1], dp[i-2]+nums[i])\n        \n        return dp[-1]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(2, 20)\n        nums = [random.randint(0, 400) for _ in range(length)]\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        nums = eval(input_str)\n        return {'nums': nums}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.rob(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "0.049",
      "memory": 4836,
      "stderr": null,
      "token": "75c38c28-b758-47e5-a9ee-38a1d41182fd",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "failure",
    "question_id": 199,
    "title": "binary-tree-right-side-view",
    "token": null,
    "error": "No test case decoder found",
    "code": null
  },
  {
    "status": "success",
    "question_id": 201,
    "title": "bitwise-and-of-numbers-range",
    "token": "3a02379b-ab41-4c6b-9654-c83857fc3027",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def rangeBitwiseAnd(self, left: int, right: int) -> int:\n        return bin(left)[2:].zfill(right.bit_length()) & bin(right)[2:].zfill(left.bit_length())\n\nclass TestCaseGenerator:\n\n    @staticmethod\n    def generate() -> dict:\n        left = random.randint(0, 10000)\n        right = random.randint(left, left + random.randint(0, 10000))\n        return {'left': left, 'right': right}\n\n    @staticmethod\n    def encode_input(input_obj) -> str:\n        return f\"{input_obj['left']},{input_obj['right']}\"\n\n    @staticmethod\n    def encode_output(output_obj) -> str:\n        return str(output_obj)\n\n    @staticmethod\n    def decode_input(input_str) -> dict:\n        left, right = map(int, input_str.split(','))\n        return {'left': left, 'right': right}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.rangeBitwiseAnd(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": null,
      "time": "0.055",
      "memory": 4800,
      "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 102, in <module>\n    runner.run()\n  File \"script.py\", line 86, in run\n    output = self.solution.rangeBitwiseAnd(**input)\n  File \"script.py\", line 49, in rangeBitwiseAnd\n    return bin(left)[2:].zfill(right.bit_length()) & bin(right)[2:].zfill(left.bit_length())\nTypeError: unsupported operand type(s) for &: 'str' and 'str'\n",
      "token": "3a02379b-ab41-4c6b-9654-c83857fc3027",
      "compile_output": null,
      "message": "Exited with error status 1",
      "status": {
        "id": 11,
        "description": "Runtime Error (NZEC)"
      }
    }
  },
  {
    "status": "success",
    "question_id": 202,
    "title": "happy-number",
    "token": "b5727795-39bc-4d9d-8b84-f60e9f93b796",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def isHappy(self, n: int) -> bool:\n        def get_next(number: int) -> int:\n            total_sum = 0\n            while number > 0:\n                digit = number % 10\n                total_sum += digit * digit\n                number //= 10\n            return total_sum\n        \n        seen = set()\n        while n!= 1 and n not in seen:\n            seen.add(n)\n            n = get_next(n)\n        \n        return n == 1\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        return {'n': random.randint(1, 100)}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['n'])\n\n    def encode_output(self, output_obj) -> str:\n        return 'true' if output_obj else 'false'\n\n    def decode_input(self, input_str) -> dict:\n        return {'n': int(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.isHappy(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "0.057",
      "memory": 4788,
      "stderr": null,
      "token": "b5727795-39bc-4d9d-8b84-f60e9f93b796",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "success",
    "question_id": 204,
    "title": "count-primes",
    "token": "3ccb377b-2312-48de-90eb-7a27b7116560",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def countPrimes(self, n: int) -> int:\n        if n==0 or n==1:\n            return 0\n        return sum(1 for i in range(2, n) if all(i%j!=0 for j in range(2, int(i**0.5)+1)))\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(0, 100)\n        return {'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['n'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'n': int(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.countPrimes(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "0.05",
      "memory": 4856,
      "stderr": null,
      "token": "3ccb377b-2312-48de-90eb-7a27b7116560",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "success",
    "question_id": 205,
    "title": "isomorphic-strings",
    "token": "88f2d445-f1cd-4073-875f-02e347b0f468",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport string\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def isIsomorphic(self, s: str, t: str) -> bool:\n        return sorted(set(s)) == set(t)\n\nclass TestCaseGenerator:\n\n    def __init__(self):\n        self.libraries = ['random', 'string']\n\n    def generate(self) -> dict:\n        length = random.randint(1, 100)\n        s = ''.join((random.choice(string.ascii_letters) for _ in range(length)))\n        t = ''.join((random.choice(string.ascii_letters) for _ in range(length)))\n        return {'s': s, 't': t}\n\n    def encode_input(self, input_obj) -> str:\n        return f'''s = \"{input_obj['s']}\", t = \"{input_obj['t']}\"'''\n\n    def encode_output(self, output_obj) -> str:\n        return 'true' if output_obj else 'false'\n\n    def decode_input(self, input_str) -> dict:\n        input_parts = input_str.split(', ')\n        s_value = input_parts[0].split('= ')[1].strip('\"')\n        t_value = input_parts[1].split('= ')[1].strip('\"')\n        return {'s': s_value, 't': t_value}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.isIsomorphic(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "0.049",
      "memory": 4804,
      "stderr": null,
      "token": "88f2d445-f1cd-4073-875f-02e347b0f468",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "success",
    "question_id": 210,
    "title": "course-schedule-ii",
    "token": "fb4044e3-4177-4682-832b-f7137bb4550b",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom collections import deque\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\n        world = [Node(n) for n in range(numCourses)]\n        for (a, b) in prerequisites:\n            world[a].prereqs.add(world[b])\n        res = []\n        taken = set()\n        for n in world:\n            if n.n in taken:\n                continue\n            ne = n.how_to_take_this(taken, visited=set())\n            if ne is False:\n                return []\n            taken |= set(ne)\n            res.append(ne)\n        return [ele for node in res for ele in node]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        numCourses = random.randint(1, 10)\n        prereq_num = random.randint(0, min(10, numCourses * (numCourses - 1)))\n        prerequisites = []\n        seen = set()\n        for _ in range(prereq_num):\n            a, b = random.sample(range(numCourses), 2)\n            if (a, b) not in seen:\n                seen.add((a, b))\n                prerequisites.append([a, b])\n        return {'numCourses': numCourses, 'prerequisites': prerequisites}\n\n    def encode_input(self, input_obj: dict) -> str:\n        return f\"{input_obj['numCourses']}, {input_obj['prerequisites']}\"\n\n    def encode_output(self, output_obj: list) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str: str) -> dict:\n        num_courses_str, prerequisites_str = input_str.split(',', 1)\n        num_courses = int(num_courses_str)\n        prerequisites = eval(prerequisites_str.strip())\n        return {'numCourses': num_courses, 'prerequisites': prerequisites}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.findOrder(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": null,
      "time": "0.049",
      "memory": 4852,
      "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 122, in <module>\n    runner.run()\n  File \"script.py\", line 106, in run\n    output = self.solution.findOrder(**input)\n  File \"script.py\", line 53, in findOrder\n    world[a].prereqs.add(world[b])\nAttributeError: 'Node' object has no attribute 'prereqs'\n",
      "token": "fb4044e3-4177-4682-832b-f7137bb4550b",
      "compile_output": null,
      "message": "Exited with error status 1",
      "status": {
        "id": 11,
        "description": "Runtime Error (NZEC)"
      }
    }
  },
  {
    "status": "success",
    "question_id": 214,
    "title": "shortest-palindrome",
    "token": "a175d598-1ac8-4fc0-a2c4-4b660b030e65",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport string\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def shortestPalindrome(self, s: str) -> str:\n        n = len(s)\n        res = 0\n        for i in range(1, n+1):\n            if s[:i] == s[i-1::-1]:\n                res = i\n        return s[:res-1:-1] +s\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(1, 100)\n        random_str = ''.join((random.choice(string.ascii_lowercase) for _ in range(length)))\n        return {'s': random_str}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['s']\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.shortestPalindrome(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "0.052",
      "memory": 4908,
      "stderr": null,
      "token": "a175d598-1ac8-4fc0-a2c4-4b660b030e65",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "success",
    "question_id": 216,
    "title": "combination-sum-iii",
    "token": "076b1d42-0c3d-4b1d-8d4d-1c5fc04020f2",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\n        if 45-(9-k)*(10-k)/2 < n or k*(k+1)/2 > n:\n            return []\n\n        def backtrack(comb, s, n):\n            if n == 0 and len(comb) == k:\n                output.append(comb)\n                return\n            for i in range(s, min(n+1, 10)):\n                if n-i <0:\n                    break\n                backtrack(comb + [i], i+1, n-i)\n        \n        output = []\n        backtrack([], 1, n)\n        return output\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        k = random.randint(2, 9)\n        n = random.randint(1, 60)\n        return {'k': k, 'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['k']} {input_obj['n']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        k, n = map(int, input_str.split())\n        return {'k': k, 'n': n}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.combinationSum3(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "0.053",
      "memory": 4788,
      "stderr": null,
      "token": "076b1d42-0c3d-4b1d-8d4d-1c5fc04020f2",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "success",
    "question_id": 91,
    "title": "decode-ways",
    "token": "9c8f6b47-8e08-438a-97b7-e4f17ecc5ad5",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def numDecodings(self, s: str) -> int:\n        if s == \"\":\n            return 0\n        \n        @lru_cache(None)\n        def helper(idx):\n            if idx == len(s):\n                return 1\n            \n            if s[idx] == '0':\n                return 0\n            \n            single_digit = helper(idx + 1)\n            two_digit = 0\n            if (idx + 1 < len(s) and (s[idx] == '1' or (s[idx] == '2' and s[idx + 1] <= '6'))):\n                two_digit = helper(idx + 2)\n                \n            return single_digit + two_digit\n        return helper(0)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        length = random.randint(1, 100)\n        digits = ''.join((random.choice('0123456789') for _ in range(length)))\n        return {'s': digits}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['s']\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.numDecodings(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "0.053",
      "memory": 4776,
      "stderr": null,
      "token": "9c8f6b47-8e08-438a-97b7-e4f17ecc5ad5",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "success",
    "question_id": 93,
    "title": "restore-ip-addresses",
    "token": "159c5de6-f0fe-4a9a-aa57-81f1e4a5f1d9",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\r\n    def restoreIpAddresses(self, s: str) -> List[str]:\r\n        result = []\r\n        def backtracking(start_idx, point_count):\r\n            if point_count == 4 and start_idx >= len(s):\r\n                result.append(\".\".join(path))\r\n                return \r\n\r\n            for i in range(start_idx, len(s)):\r\n                temp = s[start_idx:i + 1]\r\n                if temp.count('.') == 1 and int(temp) <= 255:\r\n                    path.append(temp)\r\n                    backtracking(i + 1, point_count + 1)\r\n                    path.pop()\r\n        \r\n        backtracking(0, 0)\r\n        return result\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        \"\"\"Generates a random test case for the restoreIpAddresses function.\"\"\"\n        s = ''.join((random.choice('0123456789') for _ in range(random.randint(4, 12))))\n        return {'s': s}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['s']\n\n    def encode_output(self, output_obj) -> str:\n        return ','.join(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.restoreIpAddresses(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Input {'s': '0159'}\nExpected Output:  0.1.5.9\nActual Output:  \n2 Test Failed!\n",
      "time": "0.052",
      "memory": 4728,
      "stderr": null,
      "token": "159c5de6-f0fe-4a9a-aa57-81f1e4a5f1d9",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 4,
        "description": "Wrong Answer"
      }
    }
  },
  {
    "status": "failure",
    "question_id": 127,
    "title": "word-ladder",
    "token": null,
    "error": "No test case decoder found",
    "code": null
  },
  {
    "status": "success",
    "question_id": 81,
    "title": "search-in-rotated-sorted-array-ii",
    "token": "9ad3ab36-20c9-4678-9c20-7c70fa0f26f8",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def search(self, nums: List[int], target: int) -> bool:\n        left = 0\n        right = len(nums) - 1\n        while left <= right:\n            middle = (left + right) // 2\n            if nums[middle] == target:\n                return True\n            if (nums[left] == nums[middle] and nums[middle] == nums[right]):\n                left += 1\n                right -= 1\n            elif nums[left] <= nums[middle]:\n                if nums[left] <= target and target < nums[middle]:\n                    right = middle - 1\n                else:\n                    left = middle + 1 \n            else:\n                if target > nums[middle] and target <= nums[right]:\n                    left = middle + 1\n                else:\n                    right = middle - 1\n        return False\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        n = random.randint(1, 100)\n        nums = sorted([random.randint(-10000, 10000) for _ in range(n)])\n        pivot = random.randint(0, n - 1)\n        nums = nums[pivot:] + nums[:pivot]\n        target = random.choice(nums + [random.randint(-10000, 10000)])\n        return {'nums': nums, 'target': target}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.search(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "0.056",
      "memory": 4936,
      "stderr": null,
      "token": "9ad3ab36-20c9-4678-9c20-7c70fa0f26f8",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "success",
    "question_id": 151,
    "title": "reverse-words-in-a-string",
    "token": "d538cbab-01ae-46b1-b1d3-83e346ba70a7",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def reverseWords(self, s: str) -> str:\n        return \" \".join(reversed(s.split()))\n        \n\n#### Explanation:\nclass Solution:\n    def reverseWords(self, s: str) -> str:\n        return \" \".join(reversed(s.split()))\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        test_cases = [{'s': 'the sky is blue'}, {'s': '  hello world  '}, {'s': 'a good   example'}, {'s': 'singleword'}, {'s': '  multiple words   with   extra spaces '}, {'s': '    boundary   '}]\n        return test_cases[0]\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['s']\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.reverseWords(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "0.05",
      "memory": 4788,
      "stderr": null,
      "token": "d538cbab-01ae-46b1-b1d3-83e346ba70a7",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "success",
    "question_id": 152,
    "title": "maximum-product-subarray",
    "token": "420dc9cd-d00a-46a2-94d8-75998c7b0231",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def maxProduct(self, nums: List[int]) -> int:\n        n = len(nums)\n        prefix, suffix = 1, 1\n        for i in range(n):\n            prefix *= nums[i]\n            suffix *= nums[n - i - 1]\n            if prefix >= suffix: continue\n            prefix = suffix = prefix // nums[i]\n        return max(prefix, suffix)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        nums_length = random.randint(1, 20)\n        nums = [random.randint(-10, 10) for _ in range(nums_length)]\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.maxProduct(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Input {'nums': [-4, 9, 1, 2, 2, 0, 5, 1, -4, 4, 1, 0, -3]}\nExpected Output:  36\nActual Output:  0\n1 Test Failed!\n",
      "time": "0.051",
      "memory": 4796,
      "stderr": null,
      "token": "420dc9cd-d00a-46a2-94d8-75998c7b0231",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 4,
        "description": "Wrong Answer"
      }
    }
  },
  {
    "status": "failure",
    "question_id": 95,
    "title": "unique-binary-search-trees-ii",
    "token": null,
    "error": "No test case decoder found",
    "code": null
  },
  {
    "status": "success",
    "question_id": 96,
    "title": "unique-binary-search-trees",
    "token": "281a4836-411e-4c34-9297-ee51c692e727",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport json\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def numTrees(self, n: int) -> int:\n        return self.dp(n)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 19)\n        return {'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return json.dumps(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return json.loads(input_str)\n\n    def decode_output(self, output_str) -> int:\n        return json.loads(output_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.numTrees(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": null,
      "time": "0.053",
      "memory": 4772,
      "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 100, in <module>\n    runner.run()\n  File \"script.py\", line 84, in run\n    output = self.solution.numTrees(**input)\n  File \"script.py\", line 50, in numTrees\n    return self.dp(n)\nAttributeError: 'Solution' object has no attribute 'dp'\n",
      "token": "281a4836-411e-4c34-9297-ee51c692e727",
      "compile_output": null,
      "message": "Exited with error status 1",
      "status": {
        "id": 11,
        "description": "Runtime Error (NZEC)"
      }
    }
  },
  {
    "status": "success",
    "question_id": 97,
    "title": "interleaving-string",
    "token": "8703241f-01b5-42c2-bc6b-c3000804a6bd",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import Dict\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n\n        # dp[i][j] represents whether the first i characters in s1\n        # and the first j characters in s2\n        # can form the first i + j characters of s3\n\n        if len(s1) + len(s2)!= len(s3):\n            return False\n\n        dp = [[False] * (len(s2) + 1) for _ in range((len(s1) + 1))]\n\n        # true for empty string\n        dp[0][0] = True\n\n        for i in range(len(s1) + 1):\n            for j in range(len(s2) + 1):\n                if i == 0 and j == 0:\n                    continue\n                # initialise base cases i and j\n                elif i == 0:\n                    dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\n                elif j == 0:\n                    dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\n                # interleave using either s1 OR s2\n                else:\n                    dp[i][j] = (dp[i][j - 1] and s2[j - 1] == s3[j + i - 1]) or \\\n                               (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1])\n\n        return dp[len(s1)][len(s2)]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        return {'s1': 'aabcc', 's2': 'dbbca', 's3': 'aadbbcbcac'}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{{'s1': '{input_obj['s1']}', 's2': '{input_obj['s2']}', 's3': '{input_obj['s3']}'}}\"\n\n    def encode_output(self, output_obj) -> str:\n        return 'true' if output_obj else 'false'\n\n    def decode_input(self, input_str) -> dict:\n        input_obj = eval(input_str)\n        return {'s1': input_obj['s1'], 's2': input_obj['s2'], 's3': input_obj['s3']}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.isInterleave(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "0.05",
      "memory": 4768,
      "stderr": null,
      "token": "8703241f-01b5-42c2-bc6b-c3000804a6bd",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "success",
    "question_id": 1,
    "title": "two-sum",
    "token": "2609c1a2-4651-455f-ae52-49c05a57cf22",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        nums.sort()\n        for i in range(len(nums) - 1):\n            complement = target - nums[i]\n            if complement in nums[i + 1:]:\n                return [i, nums[i + 1:].index(complement) + i]\n        return None\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        length = random.randint(2, 10)\n        nums = random.sample(range(-100, 100), length)\n        idx1, idx2 = random.sample(range(length), 2)\n        target = nums[idx1] + nums[idx2]\n        return {'nums': nums, 'target': target}\n\n    def encode_input(self, input_obj) -> str:\n        nums_str = ','.join(map(str, input_obj['nums']))\n        return f\"nums=[{nums_str}],target={input_obj['target']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return f'{output_obj[0]},{output_obj[1]}'\n\n    def decode_input(self, input_str) -> dict:\n        input_vars = input_str.split('],')\n        nums_str = input_vars[0].replace('nums=[', '')\n        nums = list(map(int, nums_str.split(',')))\n        target = int(input_vars[1].replace('target=', ''))\n        return {'nums': nums, 'target': target}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.twoSum(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Input {'nums': [-96, -92, -73, -43, -5, 36, 77, 88], 'target': 45}\nExpected Output:  1,6\nActual Output:  3,6\n1 Test Failed!\n",
      "time": "0.05",
      "memory": 4776,
      "stderr": null,
      "token": "2609c1a2-4651-455f-ae52-49c05a57cf22",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 4,
        "description": "Wrong Answer"
      }
    }
  },
  {
    "status": "success",
    "question_id": 5,
    "title": "longest-palindromic-substring",
    "token": "e8dd2830-3c90-4247-91a1-6c080fcaf15e",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport string\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        longest = s[0]\n        palin = set()\n        for i in range(len(s)):\n            for j in range(i + 1, len(s)):\n                if j - i < len(longest):\n                    continue\n                _s = s[i : j + 1]\n                if _s in palin:\n                    continue\n                elif self.check(_s, palin):\n                    palin.add(_s)\n                    if len(_s) > len(longest):\n                        longest = _s\n        return longest\n\n    def check(self, s, palin):\n        n = len(s)\n        i = 0\n        j = n - 1\n        while i < j:\n            if s in palin:\n                return True\n            if s[i]!= s[j]:\n                return False\n            else:\n                i += 1\n                j -= 1\n        return True\n\n\n#### Output Code:\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        longest = s[0]\n        palin = set()\n        for i in range(len(s)):\n            for j in range(i + 1, len(s)):\n                if j - i < len(longest):\n                    continue\n                _s = s[i : j + 1]\n                if _s in palin:\n                    continue\n                elif self.check(_s, palin):\n                    palin.add(_s)\n                    if len(_s) > len(longest):\n                        longest = _s\n        return longest\n\n    def check(self, s, palin):\n        n = len(s)\n        i = 0\n        j = n - 1\n        while i < j:\n            if s in palin:\n                return True\n            if s[i]!= s[j]:\n                return False\n            else:\n                i += 1\n                j -= 1\n        return True\n\n\n#### Input Code:\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        longest = s[0]\n        palin = set()\n        for i in range(len(s)):\n            for j in range(i + 1, len(s)):\n                if j - i < len(longest):\n                    continue\n                _s = s[i : j + 1]\n                if _s in palin:\n                    continue\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(1, 100)\n        s = ''.join(random.choices(string.ascii_letters + string.digits, k=length))\n        return {'s': s}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['s']\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.longestPalindrome(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Input {'s': 'xuAfI3uE5Bcs57wnM8ySwb2SBYF5963NankQ4qo3rwkmfiwN8FCUxbVDUVTsfGBf9NITT0hfQ5Evpsb'}\nExpected Output:  TT\nActual Output:  None\n1 Test Failed!\n",
      "time": "0.052",
      "memory": 4804,
      "stderr": null,
      "token": "e8dd2830-3c90-4247-91a1-6c080fcaf15e",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 4,
        "description": "Wrong Answer"
      }
    }
  },
  {
    "status": "success",
    "question_id": 6,
    "title": "zigzag-conversion",
    "token": "a8ee4364-8b5d-4b70-b1a1-3ce8fd49d5ed",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom math import ceil\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def convert(self, s: str, numRows: int) -> str:\n        strings = []\n        currString = \"\"\n        if(numRows <= 1):\n            return s\n        idx = 0\n        while (idx < len(s)):\n            for i in range(0, numRows):\n                if(idx + i >= len(s)):\n                    currString += \"_\"\n                else:\n                    currString += s[idx + i]\n            idx += i\n            strings.append(currString)\n            currString = \"\"\n            for i in range (numRows - 2, 0, -1):\n                idx += 1\n                if(idx >= len(s)):\n                    break\n                for j in range(0, i):\n                    currString += \"_\"\n                currString += s[idx]\n                for j in range(i+1, numRows):\n                    currString += \"_\"\n                strings.append(currString)\n                currString = \"\"\n            idx += 1\n        outputString = \"\"\n        for idx in range(0, numRows):\n            for line in strings:\n                if(line[idx]!= \"_\"):\n                    outputString+= line[idx]\n        return outputString\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz,.'\n        string_length = random.randint(1, 20)\n        random_string = ''.join((random.choice(letters) for _ in range(string_length)))\n        num_rows = random.randint(1, min(string_length, 10))\n        return {'s': random_string, 'numRows': num_rows}\n\n    def encode_input(self, input_obj) -> str:\n        s = input_obj['s']\n        numRows = input_obj['numRows']\n        return f\"{{'s': '{s}', 'numRows': {numRows}}}\"\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        return eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.convert(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "0.05",
      "memory": 4812,
      "stderr": null,
      "token": "a8ee4364-8b5d-4b70-b1a1-3ce8fd49d5ed",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "success",
    "question_id": 8,
    "title": "string-to-integer-atoi",
    "token": "f3f50868-34cf-4e25-b5be-5720be7a1dd6",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def myAtoi(self, s: str) -> int:\n        negative = False\n        start_digit = False\n        string_number = \"\"\n        INT_MAX = 2**31 - 1\n        INT_MIN = -2**31\n        \n        for char in s:\n            if char == \" \" and not start_digit:\n                continue\n            \n            if char == \"-\" and not start_digit:\n                negative = True\n                start_digit = True\n                continue\n            elif char == \"+\" and not start_digit:\n                start_digit = True\n                continue\n            \n            if char.isdigit():\n                string_number += char\n                start_digit = True\n                continue\n            \n            # If a non-digit character is encountered after starting to read digits\n            if start_digit:\n                break\n            \n            # If the character is invalid at the start (non-digit and not a sign)\n            if not char.isdigit() and not start_digit:\n                return 0\n        \n        if not string_number:\n            return 0\n        \n        result = int(string_number)\n        \n        # Clamp the result to the 32-bit integer range\n        if result < INT_MIN:\n            return INT_MIN\n        if result > INT_MAX:\n            return INT_MAX\n        return result\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        cases = ['42', '    -42', '+123', '1337abc', ' ', '9223372036854775808', '-2147483649', '3.14159', '00100', 'words 456']\n        return {'s': random.choice(cases)}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['s']\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.myAtoi(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "0.049",
      "memory": 4752,
      "stderr": null,
      "token": "f3f50868-34cf-4e25-b5be-5720be7a1dd6",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "success",
    "question_id": 309,
    "title": "best-time-to-buy-and-sell-stock-with-cooldown",
    "token": "2a452837-8fad-47bd-b903-5a1939ae381e",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List\nimport ast\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        L = len(prices)\n        # padding the array with additional zero to simply the logic\n        MP = [0] * (L + 2)\n\n        for i in range(L-1, -1, -1):\n            C1 = 0\n            # Case 1). buy and sell the stock\n            for sell in range(i + 1, L):\n                profit = (prices[sell] - prices[i]) + MP[sell + 2]\n                C1 = max(profit, C1)\n\n            # Case 2). do no transaction with the stock p[i]\n            C2 = MP[i + 1]\n\n            # sum up two cases\n            MP[i] = max(C1, C2)\n\n        return MP[0]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(1, 100)\n        prices = [random.randint(0, 1000) for _ in range(length)]\n        return {'prices': prices}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['prices'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        prices = ast.literal_eval(input_str)\n        return {'prices': prices}\n\n    def decode_output(self, output_str) -> int:\n        return int(output_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.maxProfit(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "0.067",
      "memory": 5288,
      "stderr": null,
      "token": "2a452837-8fad-47bd-b903-5a1939ae381e",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "success",
    "question_id": 312,
    "title": "burst-balloons",
    "token": "751a99b9-88d0-4f1b-8ec5-6e0bf95cc6e1",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def maxCoins(self, nums: List[int]) -> int:\n        nums = [1]+nums+[1]\n        memo = {}\n        def dfs(leftbound, rightbound):\n            if (leftbound, rightbound) in memo:\n                return memo[(leftbound, rightbound)]\n            if rightbound - leftbound <= 1:\n                return 0\n            res = 0\n            for i in range(leftbound, rightbound + 1):\n                gain = nums[leftbound] * nums[i] * nums[rightbound]\n                total_gain = dfs(leftbound, i) + gain + dfs(i, rightbound)\n                res = max(res, total_gain)\n            memo[(leftbound, rightbound)] = res\n            return res\n        return dfs(0, len(nums) - 1)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        n = random.randint(1, 10)\n        nums = [random.randint(0, 100) for _ in range(n)]\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        nums = eval(input_str)\n        return {'nums': nums}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.maxCoins(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": null,
      "time": "0.047",
      "memory": 5908,
      "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 114, in <module>\n    runner.run()\n  File \"script.py\", line 98, in run\n    output = self.solution.maxCoins(**input)\n  File \"script.py\", line 64, in maxCoins\n    return dfs(0, len(nums) - 1)\n  File \"script.py\", line 60, in dfs\n    total_gain = dfs(leftbound, i) + gain + dfs(i, rightbound)\n  File \"script.py\", line 60, in dfs\n    total_gain = dfs(leftbound, i) + gain + dfs(i, rightbound)\n  File \"script.py\", line 60, in dfs\n    total_gain = dfs(leftbound, i) + gain + dfs(i, rightbound)\n  [Previous line repeated 992 more times]\n  File \"script.py\", line 58, in dfs\n    for i in range(leftbound, rightbound + 1):\nRecursionError: maximum recursion depth exceeded in comparison\n",
      "token": "751a99b9-88d0-4f1b-8ec5-6e0bf95cc6e1",
      "compile_output": null,
      "message": "Exited with error status 1",
      "status": {
        "id": 11,
        "description": "Runtime Error (NZEC)"
      }
    }
  },
  {
    "status": "success",
    "question_id": 299,
    "title": "bulls-and-cows",
    "token": "72ef0877-0dcd-4ed2-805c-9ef3d5076262",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom collections import Counter\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def getHint(self, secret: str, guess: str) -> str:\n        bulls = 0\n        cows = 0\n        guessDict = {}\n        secretDict = {}\n        for i in range(len(secret)):\n            if secret[i] == guess[i]:\n                bulls += 1\n            else:\n                if secret[i] in guessDict and guessDict[secret[i]] > 0:\n                    cows += 1\n                    guessDict[secret[i]] -= 1\n                else:\n                    secretDict[secret[i]] = secretDict.get(secret[i], 0) + 1\n                if guess[i] in secretDict and secretDict[guess[i]] > 0:\n                    cows += 1\n                    secretDict[guess[i]] -= 1\n                else:\n                    guessDict[guess[i]] = guessDict.get(guess[i], 0) + 1\n        return f'{bulls}A{cows}B'\n\nclass TestCaseGenerator:\n\n    def __init__(self):\n        self.random = random\n\n    def generate(self) -> dict:\n        length = self.random.randint(1, 10)\n        secret = ''.join(self.random.choices('0123456789', k=length))\n        guess = ''.join(self.random.choices('0123456789', k=length))\n        return {'secret': secret, 'guess': guess}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"secret={input_obj['secret']}&guess={input_obj['guess']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        parts = input_str.split('&')\n        secret = parts[0].split('=')[1]\n        guess = parts[1].split('=')[1]\n        return {'secret': secret, 'guess': guess}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.getHint(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "0.043",
      "memory": 4736,
      "stderr": null,
      "token": "72ef0877-0dcd-4ed2-805c-9ef3d5076262",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "success",
    "question_id": 300,
    "title": "longest-increasing-subsequence",
    "token": "21c05b4b-e82c-4e99-adf8-5cd5ab31ba4e",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def lengthOfLIS(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n == 0:\n            return 0\n        dp = [0] * n\n        dp[0] = nums[0]\n        for i in range(1, n):\n            if nums[i] > dp[i - 1]:\n                dp[i] = nums[i]\n            else:\n                dp[i] = max(dp[i - 1], dp[i])\n        return max(dp)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 100)\n        nums = [random.randint(-1000, 1000) for _ in range(n)]\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['nums']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        nums = list(map(int, input_str.strip('[]').split(',')))\n        return {'nums': nums}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.lengthOfLIS(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Input {'nums': [532]}\nExpected Output:  1\nActual Output:  532\n1 Test Failed!\n",
      "time": "0.051",
      "memory": 4880,
      "stderr": null,
      "token": "21c05b4b-e82c-4e99-adf8-5cd5ab31ba4e",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 4,
        "description": "Wrong Answer"
      }
    }
  },
  {
    "status": "success",
    "question_id": 301,
    "title": "remove-invalid-parentheses",
    "token": "5af8deee-26af-4850-a052-aae73fc41150",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def removeInvalidParentheses(self, s: str) -> List[str]:\n        def dfs(i, c, o):\n            if o < 0:\n                return set()\n            if i == len(s):\n                if o == 0:\n                    return {c}\n                else:\n                    return set()\n\n            combos = set()\n            if s[i] == \"(\":\n                combos |= dfs(i + 1, c + \"(\", o + 1)\n                combos |= dfs(i + 1, c, o)\n            elif s[i] == \")\":\n                combos |= dfs(i + 1, c + \")\", o - 1)\n                combos |= dfs(i + 1, c, o)\n            else:\n                combos |= dfs(i + 1, c + s[i], o)\n\n            maxlen = 0\n            for c in combos:\n                maxlen = max(maxlen, len(c))\n            for c in list(combos):\n                if len(c) < maxlen:\n                    combos.remove(c)\n\n            return combos\n\n        return list(dfs(0, \"\", 0))\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        input_length = random.randint(1, 25)\n        charset = 'abcdefghijklmnopqrstuvwxyz()'\n        s = ''.join((random.choice(charset) for _ in range(input_length)))\n        return {'s': s}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj.get('s', '')\n\n    def encode_output(self, output_obj) -> str:\n        return ','.join(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.removeInvalidParentheses(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Input {'s': ')erslahfmk'}\nExpected Output:  bgcnljowklo\nActual Output:  erslahfmk\n2 Test Failed!\n",
      "time": "0.053",
      "memory": 4888,
      "stderr": null,
      "token": "5af8deee-26af-4850-a052-aae73fc41150",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 4,
        "description": "Wrong Answer"
      }
    }
  },
  {
    "status": "success",
    "question_id": 162,
    "title": "find-peak-element",
    "token": "3ecc1c3f-96a0-4d3f-a5e3-98e25deae6e0",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\nimport ast\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def findPeakElement(self, nums: List[int]) -> int:\n        left = 0\n        right = len(nums) - 1\n\n        while left < right:\n            mid = left + (right - left) // 2\n            if nums[mid] > nums[mid + 1]:\n                right = mid\n            else:\n                left = mid + 1\n\n        return left\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        \"\"\" Generate a random test case within problem constraints. \"\"\"\n        length = random.randint(1, 1000)\n        nums = [random.randint(-1000, 1000) for _ in range(length)]\n        for i in range(1, len(nums)):\n            while nums[i] == nums[i - 1]:\n                nums[i] = random.randint(-1000, 1000)\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\" Convert test case input to string. \"\"\"\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\" Convert test case output to string. \"\"\"\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\" Convert input string back to dictionary format. \"\"\"\n        return {'nums': ast.literal_eval(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.findPeakElement(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "0.074",
      "memory": 6596,
      "stderr": null,
      "token": "3ecc1c3f-96a0-4d3f-a5e3-98e25deae6e0",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "success",
    "question_id": 164,
    "title": "maximum-gap",
    "token": "6712fe59-11f9-4c29-bed2-8b30e55fa69e",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom random import randint, shuffle\nfrom typing import List, Dict\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def maximumGap(self, nums: List[int]) -> int:\n        if len(nums) < 2:\n            return 0\n        if len(nums) == 2:\n            return abs(nums[0] - nums[1])\n        nmax, nmin = max(nums), min(nums)\n        if nmax == nmin:\n            return 0\n        num_buckets = len(nums) - 1\n        bucket_size = (nmax - nmin) / num_buckets\n        buckets = [[float('inf'), -1] for _ in range(num_buckets)]\n        for num in nums:\n            bucket_num = min(int((num - nmin) // bucket_size), num_buckets - 1)\n            buckets[bucket_num][0] = min(buckets[bucket_num][0], num)\n            buckets[bucket_num][1] = max(buckets[bucket_num][1], num)\n        prev_bucket = buckets[0]\n        ret = -1\n        for i in range(1, len(buckets)):\n            cur_bucket = buckets[i]\n            if cur_bucket[1]!= -1:\n                ret = max(ret, cur_bucket[0] - prev_bucket[1])\n                prev_bucket = cur_bucket\n        return ret\n\n#### Code Explanation:\n# To get the maximum gap between 2 elements, we will use the following formula:\n# max_gap = max(max(abs(x1 - x2), abs(x3 - x4),..., abs(x1 - xn)))\n# where x1, x2, x3,..., xn are the elements in the array.\n# We will use the max() function to find the maximum value from the array and then find the difference between the max value and the current element, and compare the result with the current element. We will repeat this process until we reach the end of the array. We will use a list to store the values, and the list will be filled with the results of the comparison.\n# We will use the -1 to represent the maximum value in the list, and the -1 to represent the minimum value in the list.\n# The -1 to represent the minimum value in the list is useful because it allows us to skip the minimum value in the list and move on to the next one. This will save time and make the code more efficient.\n# We will use a nested for loop to iterate through the elements of the array and compare\n\nclass TestCaseGenerator:\n\n    def generate(self) -> Dict[str, List[int]]:\n        case_type = randint(1, 3)\n        if case_type == 1:\n            nums = [3, 6, 9, 1]\n        elif case_type == 2:\n            size = randint(2, 100)\n            nums = [randint(0, 1000) for _ in range(size)]\n        else:\n            nums = [10]\n        shuffle(nums)\n        return {'nums': nums}\n\n    def encode_input(self, input_obj: Dict[str, List[int]]) -> str:\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj: int) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str: str) -> Dict[str, List[int]]:\n        nums = [int(x) for x in input_str.strip('[]').split(',') if x.strip()]\n        return {'nums': nums}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.maximumGap(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "0.059",
      "memory": 4800,
      "stderr": null,
      "token": "6712fe59-11f9-4c29-bed2-8b30e55fa69e",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "success",
    "question_id": 166,
    "title": "fraction-to-recurring-decimal",
    "token": "fe94ba66-104b-4431-aed6-1cd93344f52a",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\n        if numerator == 0 or denominator == 0:\n            return \"0\"\n        if numerator * denominator < 0:\n            numerator, denominator = abs(numerator), abs(denominator)\n            string = \"\"\n            quo = numerator // denominator\n            string += str(quo)\n            rem = numerator % denominator\n            if rem == 0:\n                return string\n            else:\n                seen = {}\n                while rem:\n                    if rem in seen:\n                        ind = seen[rem]\n                        return ''.join(string[:ind]) + \"(\" + ''.join(string[ind:]) + \")\"\n                    seen[rem] = len(string)\n                    rem *= 10\n                    quo = rem // denominator\n                    rem = rem % denominator\n                    string += str(quo)\n                return ''.join(string)\n        return ''.join(string)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        numerators = [1, 2, 4, random.randint(-1000, 1000)]\n        denominators = [2, 1, 333, random.randint(-1000, 1000)]\n        numerator = random.choice(numerators)\n        denominator = random.choice([d for d in denominators if d != 0])\n        return {'numerator': numerator, 'denominator': denominator}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['numerator']},{input_obj['denominator']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        numerator, denominator = map(int, input_str.split(','))\n        return {'numerator': numerator, 'denominator': denominator}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.fractionToDecimal(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Input {'numerator': -233, 'denominator': 1}\nExpected Output:  -233\nActual Output:  233\n1 Test Failed!\n",
      "time": "0.057",
      "memory": 4776,
      "stderr": null,
      "token": "fe94ba66-104b-4431-aed6-1cd93344f52a",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 4,
        "description": "Wrong Answer"
      }
    }
  },
  {
    "status": "success",
    "question_id": 43,
    "title": "multiply-strings",
    "token": "ae117a58-f48f-49e3-baba-cdf9763d2e22",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def multiply(self, num1: str, num2: str) -> str:\n        zero = ord('0')\n        n, m = len(num1), len(num2)\n        ret = 0\n        for j in range(m-1, -1, -1):\n            jmult = 10**(m-j-1)\n            carry = 0\n            for i in range(n-1, -1, -1):\n                tmp = (ord(num1[i]) - zero) * (ord(num2[j]) - zero) + carry\n                imult = 10**(n-i-1)\n                ret += (tmp % 10) * jmult * imult\n                carry = tmp // 10\n            ret = ret + (carry * jmult * 10**n)\n        return str(ret)\n\nclass TestCaseGenerator:\n\n    def __init__(self):\n        self.max_len = 200\n\n    def generate(self) -> dict:\n        import random\n        len1 = random.randint(1, self.max_len)\n        len2 = random.randint(1, self.max_len)\n        num1 = ''.join([random.choice('123456789') if i == 0 else random.choice('0123456789') for i in range(len1)])\n        num2 = ''.join([random.choice('123456789') if i == 0 else random.choice('0123456789') for i in range(len2)])\n        return {'num1': num1, 'num2': num2}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['num1']},{input_obj['num2']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        num1, num2 = input_str.split(',')\n        return {'num1': num1, 'num2': num2}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.multiply(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "0.251",
      "memory": 4996,
      "stderr": null,
      "token": "ae117a58-f48f-49e3-baba-cdf9763d2e22",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "success",
    "question_id": 50,
    "title": "powx-n",
    "token": "10105b6c-001c-4dc4-93c6-d619284d51b9",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom random import uniform, randint\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def solve(self, a, b):\n        if b == 0:\n            return 1\n        ans = self.solve(a, b // 2)\n        ans *= ans\n        if b & 1:\n            return ans * a\n        else:\n            return ans\n\n    def myPow(self, x: float, n: int) -> float:\n        res = self.solve(x, abs(n))\n        if n < 0:\n            return 1 / res\n        return res\n\n#### Output:\nInput: a = 2, b = 5\nOutput: 16\n\nInput: a = 2, b = 3\nOutput: 8\n\nInput: a = 2, b = 0\nOutput: 1\n\nInput: a = 2, b = 1\nOutput: 4\n\nInput: a = 2, b = -2\nOutput: 0.25\n\nInput: a = 2, b = 2\nOutput: 4\n\nInput: a = 2, b = -1\nOutput: 0.25\n\nInput: a = 2, b = 0\nOutput: 1\n\nInput: a = 2, b = -1\nOutput: 0.25\n\nInput: a = 2, b = 0\nOutput: 1\n\nInput: a = 2, b = -1\nOutput: 0.25\n\nInput: a = 2, b = 0\nOutput: 1\n\nInput: a = 2, b = -1\nOutput: 0.25\n\nInput: a = 2, b = 0\nOutput: 1\n\nInput: a = 2, b = -1\nOutput: 0.25\n\nInput: a = 2, b = 0\nOutput: 1\n\nInput: a = 2, b = -1\nOutput: 0.25\n\nInput: a = 2, b = 0\nOutput: 1\n\nInput: a = 2, b = -1\nOutput: 0.25\n\nInput: a = 2, b = 0\nOutput: 1\n\nInput: a = 2, b = -1\nOutput: 0.25\n\nInput: a = 2, b = 0\nOutput: 1\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        return {'x': round(uniform(-99.9, 99.9), 5), 'n': randint(-20, 20)}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['x']},{input_obj['n']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return f'{output_obj:.5f}'\n\n    def decode_input(self, input_str) -> dict:\n        x, n = input_str.split(',')\n        return {'x': float(x), 'n': int(n)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.myPow(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": null,
      "time": "0.023",
      "memory": 3244,
      "stderr": "  File \"script.py\", line 65\n    Input: a = 2, b = 5\n                    ^\nSyntaxError: invalid syntax\n",
      "token": "10105b6c-001c-4dc4-93c6-d619284d51b9",
      "compile_output": null,
      "message": "Exited with error status 1",
      "status": {
        "id": 11,
        "description": "Runtime Error (NZEC)"
      }
    }
  },
  {
    "status": "success",
    "question_id": 219,
    "title": "contains-duplicate-ii",
    "token": "4b4ff634-42d5-4161-a6df-ab95d116526c",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom random import randint\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\n        if k > len(nums):\n            return False\n        seen = {}\n        for i in range(len(nums)):\n            if nums[i] in seen and abs(i - seen[nums[i]]) <= k:\n                return True\n            seen[nums[i]] = i\n        return False\n\nclass TestCaseGenerator:\n\n    def __init__(self, nums_max_length=1000, num_range=(-10 ** 9, 10 ** 9), k_max=1000):\n        self.nums_max_length = nums_max_length\n        self.num_range = num_range\n        self.k_max = k_max\n\n    def generate(self) -> dict:\n        from random import randint\n        nums_length = randint(1, self.nums_max_length)\n        nums = [randint(self.num_range[0], self.num_range[1]) for _ in range(nums_length)]\n        k = randint(0, min(nums_length, self.k_max))\n        return {'nums': nums, 'k': k}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"nums: {input_obj['nums']}, k: {input_obj['k']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        parts = input_str.split(', k: ')\n        nums_part = parts[0].replace('nums: ', '')\n        nums = eval(nums_part)\n        k = int(parts[1])\n        return {'nums': nums, 'k': k}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.containsNearbyDuplicate(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "0.074",
      "memory": 6460,
      "stderr": null,
      "token": "4b4ff634-42d5-4161-a6df-ab95d116526c",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "success",
    "question_id": 221,
    "title": "maximal-square",
    "token": "709212c6-ee0a-421e-8edc-4b7997f9e437",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\n        R, C = len(matrix), len(matrix[0])\n\n        sums = [[0 for c in range(C + 1)] for r in range(R + 1)]\n        for r in range(1, R + 1):\n            for c in range(1, C + 1):\n                sums[r][c] = sums[r][c - 1] + sums[r - 1][c] - sums[r - 1][c - 1] + int(matrix[r - 1][c - 1])\n\n        result = 0\n\n        for r in range(1, R + 1):\n            for c in range(1, C + 1):\n                if matrix[r - 1][c - 1] == \"0\":\n                    continue\n\n                st, en = 1, min(R - r + 1, C - c + 1)\n                while en - st > 1:\n                    md = (st + en) // 2\n                    if sums[r + md - 1][c + md - 1] - sums[r + md - 1][c - 1] - sums[r - 1][c + md - 1] + sums[r - 1][c - 1] == md * md:\n                        st = md\n                    else:\n                        en = md\n                if sums[r + en - 1][c + en - 1] - sums[r + en - 1][c - 1] - sums[r - 1][c + en - 1] + sums[r - 1][c - 1] == en * en:\n                    st = en\n\n                result = max(result, st)\n\n        return result * result\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        m = random.randint(1, 100)\n        n = random.randint(1, 100)\n        matrix = [[random.choice(['0', '1']) for _ in range(n)] for _ in range(m)]\n        return {'matrix': matrix}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['matrix'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        matrix = eval(input_str)\n        return {'matrix': matrix}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.maximalSquare(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "0.168",
      "memory": 10876,
      "stderr": null,
      "token": "709212c6-ee0a-421e-8edc-4b7997f9e437",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "success",
    "question_id": 223,
    "title": "rectangle-area",
    "token": "3b5bf79b-785a-483d-a56b-bd744ca7a561",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\n\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -> int:\n        int_x = set(range(ax1, ax2)).intersection(range(bx1, bx2))\n        int_y = set(range(ay1, ay2)).intersection(range(by1, by2))\n        return (ax2-ax1)*(ay2-ay1) + (bx2-bx1)*(by2-by1) - len(int_x)*len(int_y)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        \"\"\"\n        Generate a test case input for the problem where two rectangles are defined by their bottom-left \n        and top-right corners.\n        \"\"\"\n        test_cases = [{'ax1': -3, 'ay1': 0, 'ax2': 3, 'ay2': 4, 'bx1': 5, 'by1': 4, 'bx2': 10, 'by2': 8}, {'ax1': 0, 'ay1': 0, 'ax2': 4, 'ay2': 3, 'bx1': 2, 'by1': 2, 'bx2': 6, 'by2': 5}, {'ax1': -2, 'ay1': -2, 'ax2': 2, 'ay2': 2, 'bx1': -2, 'by1': -2, 'bx2': 2, 'by2': 2}, {'ax1': 0, 'ay1': 0, 'ax2': 2, 'ay2': 2, 'bx1': 2, 'by1': 0, 'bx2': 4, 'by2': 2}, {'ax1': 1, 'ay1': 1, 'ax2': 4, 'ay2': 5, 'bx1': 1, 'by1': 1, 'bx2': 4, 'by2': 5}]\n        return test_cases[0]\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\"\n        Encode a test case input dictionary into a string.\n        \"\"\"\n        return ','.join((f'{value}' for value in input_obj.values()))\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\"\n        Encode a test case output integer into a string.\n        \"\"\"\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\"\n        Decode an input string back into a test case input dictionary.\n        \"\"\"\n        values = list(map(int, input_str.split(',')))\n        return {'ax1': values[0], 'ay1': values[1], 'ax2': values[2], 'ay2': values[3], 'bx1': values[4], 'by1': values[5], 'bx2': values[6], 'by2': values[7]}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.computeArea(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "0.053",
      "memory": 4744,
      "stderr": null,
      "token": "3b5bf79b-785a-483d-a56b-bd744ca7a561",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "failure",
    "question_id": 107,
    "title": "binary-tree-level-order-traversal-ii",
    "token": null,
    "error": "No test case decoder found",
    "code": null
  },
  {
    "status": "success",
    "question_id": 109,
    "title": "convert-sorted-list-to-binary-search-tree",
    "token": "d8ece79d-52df-4e76-a41c-1620d741be13",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom collections import deque\nfrom typing import Optional\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        if not head:\n            return None\n        if not head.next:\n            return TreeNode(head.val)\n        slow, fast = head, head.next\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        root = TreeNode(slow.val)\n        root.left = self.sortedListToBST(slow.next)\n        root.right = self.sortedListToBST(slow.next.next)\n        return root\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(0, 20)\n        if n == 0:\n            return {'head': None}\n        sorted_values = sorted(random.sample(range(-100, 100), n))\n        head = ListNode(sorted_values[0])\n        current = head\n        for value in sorted_values[1:]:\n            current.next = ListNode(value)\n            current = current.next\n        return {'head': head}\n\n    def encode_input(self, input_obj) -> str:\n        if input_obj['head'] is None:\n            return '[]'\n        res = []\n        current = input_obj['head']\n        while current is not None:\n            res.append(current.val)\n            current = current.next\n        return str(res)\n\n    def encode_output(self, output_obj) -> str:\n        if not output_obj:\n            return '[]'\n        queue = deque([output_obj])\n        result = []\n        while queue:\n            node = queue.popleft()\n            if node:\n                result.append(node.val)\n                queue.append(node.left)\n                queue.append(node.right)\n            else:\n                result.append(None)\n        while result and result[-1] is None:\n            result.pop()\n        return str(result)\n\n    def decode_input(self, input_str) -> dict:\n        vals = eval(input_str)\n        if not vals:\n            return {'head': None}\n        head = ListNode(vals[0])\n        current = head\n        for value in vals[1:]:\n            current.next = ListNode(value)\n            current = current.next\n        return {'head': head}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.sortedListToBST(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Input {'head': <__main__.ListNode object at 0x7f22842add00>}\nExpected Output:  [-13, -52, 80, -88, -41, 29, 86, None, -68, -49, -20, 11, 33, 82, 98]\nActual Output:  [-13, 80, 80, 86, 86, 86, 86, 98, None, 98, None, 98, None, 98]\n1 Test Failed!\n",
      "time": "0.061",
      "memory": 4908,
      "stderr": null,
      "token": "d8ece79d-52df-4e76-a41c-1620d741be13",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 4,
        "description": "Wrong Answer"
      }
    }
  },
  {
    "status": "failure",
    "question_id": 268,
    "title": "missing-number",
    "token": null,
    "error": "No test case decoder found",
    "code": null
  },
  {
    "status": "success",
    "question_id": 172,
    "title": "factorial-trailing-zeroes",
    "token": "ef15698f-ef30-49b2-8eb7-74869dbd0088",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def trailingZeroes(self, n: int) -> int:\n        return n // math.factorial(n//5) * 5\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(0, 100)\n        return {'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['n'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'n': int(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.trailingZeroes(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Input {'n': 53}\nExpected Output:  12\nActual Output:  0\n1 Test Failed!\n",
      "time": "0.064",
      "memory": 4764,
      "stderr": null,
      "token": "ef15698f-ef30-49b2-8eb7-74869dbd0088",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 4,
        "description": "Wrong Answer"
      }
    }
  },
  {
    "status": "success",
    "question_id": 179,
    "title": "largest-number",
    "token": "1ef6e4df-f1d8-41a1-a41f-9a5e36b1c8fc",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport heapq\nimport random\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\ndef insert (n, l) :\n    l.append (n)\n    i = len (l) - 1\n    while i and str(n) + str(l[i-1]) > str(l[i-1]) + str(n): \n        l[i] = l[i-1]\n        i -= 1\n    l[i] = n\n\nclass Solution:\n    def largestNumber(self, nums: List[int]) -> str:\n        nums.sort(key = lambda x : (str (x), -1 if str (x) + str (nums[0]) > str (nums[0]) + str (x) else 1))\n        return str (nums[0])\n\nclass TestCaseGenerator:\n    \"\"\"\n    A helper class to generate test cases, encode/decode inputs and outputs\n    \"\"\"\n\n    def generate(self) -> dict:\n        \"\"\"\n        Generates a random test case input, ensuring scenarios of different input sizes.\n        \"\"\"\n        import random\n        length = random.randint(1, 20)\n        nums = [random.randint(0, 10000) for _ in range(length)]\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\"\n        Converts the test case input into a human-readable string.\n        \"\"\"\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\"\n        Converts the test case output (a string) into a human-readable string format.\n        \"\"\"\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\"\n        Transforms an input string back into a Python dictionary structure.\n        \"\"\"\n        nums = eval(input_str)\n        return {'nums': nums}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.largestNumber(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": null,
      "time": "0.053",
      "memory": 4904,
      "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 125, in <module>\n    runner.run()\n  File \"script.py\", line 109, in run\n    output = self.solution.largestNumber(**input)\n  File \"script.py\", line 59, in largestNumber\n    nums.sort(key = lambda x : (str (x), -1 if str (x) + str (nums[0]) > str (nums[0]) + str (x) else 1))\n  File \"script.py\", line 59, in <lambda>\n    nums.sort(key = lambda x : (str (x), -1 if str (x) + str (nums[0]) > str (nums[0]) + str (x) else 1))\nIndexError: list index out of range\n",
      "token": "1ef6e4df-f1d8-41a1-a41f-9a5e36b1c8fc",
      "compile_output": null,
      "message": "Exited with error status 1",
      "status": {
        "id": 11,
        "description": "Runtime Error (NZEC)"
      }
    }
  },
  {
    "status": "success",
    "question_id": 187,
    "title": "repeated-dna-sequences",
    "token": "3edf00c2-0a89-48ed-a540-3b6a68e824d2",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def findRepeatedDnaSequences(self, s: str) -> List[str]:\n        if len(s) < 10:\n            return []\n\n        mp = {}\n        currList = collections.deque()\n        for i in range(10):\n            currList.append(s[i])\n\n        mp[tuple(currList)] = 0\n        r = 10\n        ans = []\n        while r < len(s):\n            currList.append(s[r])\n            currList.popleft()\n            dna = tuple(currList)\n            if dna in mp and mp[dna]!= 1:\n                ans.append(\"\".join(currList))\n                mp[dna] = 1\n            elif dna not in mp:\n                mp[dna] = 0\n            r += 1\n        return ans\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        nucleotides = ['A', 'C', 'G', 'T']\n        length = random.randint(20, 200)\n        s = ''.join(random.choices(nucleotides, k=length))\n        return {'s': s}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['s']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return '[' + ', '.join((f'\"{seq}\"' for seq in output_obj)) + ']'\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.findRepeatedDnaSequences(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "0.059",
      "memory": 4860,
      "stderr": null,
      "token": "3edf00c2-0a89-48ed-a540-3b6a68e824d2",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "success",
    "question_id": 12,
    "title": "integer-to-roman",
    "token": "cb672cf8-d2a0-4f29-addb-189e1e3cca9e",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\n\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def intToRoman(self, num: int) -> str:\n        dictionary = {1000:'M', 900:'CM', 500:'D', 400:'CD', 100:'C', 90:'XC', 50:'L', 40:'XL', 10:'X', 9:'IX', 5:'V', 4:'IV', 1:'I'}\n        ans=''\n        for key, val in dictionary.items():\n            while num>=key:\n                ans+=val\n                num-=key\n        return ans\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        return {'num': 3}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['num'])\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        return {'num': int(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.intToRoman(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "0.056",
      "memory": 4732,
      "stderr": null,
      "token": "cb672cf8-d2a0-4f29-addb-189e1e3cca9e",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "success",
    "question_id": 13,
    "title": "roman-to-integer",
    "token": "49e1a19c-13de-47cc-a56a-d389ab638fce",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def romanToInt(self, s: str) -> int:\n        m = {\n            'I': 1,\n            'V': 5,\n            'X': 10,\n            'L': 50,\n            'C': 100,\n            'D': 500,\n            'M': 1000\n        }\n        \n        ans = 0\n        \n        for i in range(len(s)):\n            if i < len(s) - 1 and m[s[i]] < m[s[i+1]]:\n                ans -= m[s[i]]\n            else:\n                ans += m[s[i]]\n        \n        return ans\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        \"\"\"\n        Generate a random test case input.\n        Limited range of test cases for simplicity.\n        \"\"\"\n        test_cases = [{'s': 'III'}, {'s': 'IV'}, {'s': 'IX'}, {'s': 'LVIII'}, {'s': 'XLIX'}, {'s': 'XC'}, {'s': 'CCCXC'}, {'s': 'CMXCIX'}, {'s': 'MCMXCIV'}, {'s': 'MMXXII'}]\n        return random.choice(test_cases)\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\"\n        Convert a test case input into a string.\n        \"\"\"\n        return input_obj['s']\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\"\n        Convert a test case output into a string.\n        \"\"\"\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\"\n        Convert a test case input string into a Python dict.\n        \"\"\"\n        return {'s': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.romanToInt(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "0.063",
      "memory": 4768,
      "stderr": null,
      "token": "49e1a19c-13de-47cc-a56a-d389ab638fce",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "success",
    "question_id": 18,
    "title": "4sum",
    "token": "e072c7e7-0d76-44f8-8d2d-bb43503d533f",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport json\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\n        nums.sort()\n        res = set()\n        for i in range(len(nums)-3):\n            for j in range(i+1,len(nums)-2):\n                m = j+1\n                n = len(nums) - 1\n                while m < n:\n                    if nums[m] + nums[n] == target - (nums[i] + nums[j]):\n                       res.add((nums[i],nums[j],nums[m],nums[n]))\n                       m+=1\n                       n-=1\n                    elif  target - (nums[i] + nums[j]) > (nums[m] + nums[n]):\n                        m+=1\n                    else:\n                        n-=1\n        return [list(t) for t in res]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        from random import randint, sample\n        n = randint(4, 10)\n        nums = sample(range(-10, 10), n)\n        target = randint(-20, 20)\n        return {'nums': nums, 'target': target}\n\n    def encode_input(self, input_obj) -> str:\n        import json\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        import json\n        return json.dumps(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        import json\n        return json.loads(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.fourSum(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Input {'nums': [-7, -5, -4, 1, 3, 4, 6, 7, 8, 9], 'target': 8}\nExpected Output:  [[-7, 1, 6, 8], [-7, 3, 4, 8], [-5, -4, 8, 9], [-5, 1, 3, 9], [-5, 1, 4, 8], [-5, 3, 4, 6], [-4, 1, 3, 8], [-4, 1, 4, 7]]\nActual Output:  [[-7, 3, 4, 8], [-4, 1, 3, 8], [-4, 1, 4, 7], [-5, -4, 8, 9], [-5, 1, 4, 8], [-7, 1, 6, 8], [-5, 3, 4, 6], [-5, 1, 3, 9]]\n1 Test Failed!\n",
      "time": "0.059",
      "memory": 4808,
      "stderr": null,
      "token": "e072c7e7-0d76-44f8-8d2d-bb43503d533f",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 4,
        "description": "Wrong Answer"
      }
    }
  },
  {
    "status": "success",
    "question_id": 20,
    "title": "valid-parentheses",
    "token": "8a42636a-a43e-4d64-b879-159ea4448252",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport json\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution(object):\n    def isValid(self, s):\n        stack = [] \n        pairs = {\n            '(': ')',\n            '{': '}',\n            '[': ']'\n        }\n        \n        for bracket in s:\n            if bracket in pairs:\n                stack.append(bracket)\n            elif len(stack) == 0 or bracket!= pairs[stack.pop()]:\n                return False\n\n        return len(stack) == 0\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(1, 20)\n        elements = ['(', ')', '{', '}', '[', ']']\n        s = ''.join(random.choices(elements, k=length))\n        return {'s': s}\n\n    def encode_input(self, input_obj) -> str:\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return json.loads(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.isValid(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "0.061",
      "memory": 4744,
      "stderr": null,
      "token": "8a42636a-a43e-4d64-b879-159ea4448252",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "failure",
    "question_id": 113,
    "title": "path-sum-ii",
    "token": null,
    "error": "No test case decoder found",
    "code": null
  },
  {
    "status": "success",
    "question_id": 115,
    "title": "distinct-subsequences",
    "token": "61986201-848c-4b2a-b951-02ff11a7e9e9",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport string\nimport json\n\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def numDistinct(self, s: str, t: str) -> int:\n        #s = \"rabbbit\", t = \"rabbit\"\n\n        #ultimatly its all about moving pointers, when to move them (need to try all the possiblities of moving the pointers)\n\n        #if i == j\n            #move both and just move i (since duh not j)\n        #else:\n            #move i to find other\n\n        #store (cache) when we get to i,j we've already seen ()\n\n        dp = {}\n\n        def dfs(i,j):\n            if j == len(t):\n                return 1\n            if i == len(s):\n                return 0\n            if (i,j) in dp:\n                return dp[(i,j)]\n            \n            if s[i] == t[j]:\n                dp[(i,j)] = dfs(i + 1, j + 1) + dfs(i + 1, j)\n            else:\n                dp[(i,j)] = dfs(i + 1,j)\n\n            return dp[(i,j)]\n\n        return dfs(0,0)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        s_length = random.randint(1, 10)\n        t_length = random.randint(1, s_length)\n        s = ''.join(random.choices(string.ascii_lowercase, k=s_length))\n        t = ''.join(random.choices(s, k=t_length))\n        return {'s': s, 't': t}\n\n    def encode_input(self, input_obj) -> str:\n        return json.dumps({'s': input_obj['s'], 't': input_obj['t']})\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return json.loads(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.numDistinct(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "0.054",
      "memory": 4848,
      "stderr": null,
      "token": "61986201-848c-4b2a-b951-02ff11a7e9e9",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "failure",
    "question_id": 117,
    "title": "populating-next-right-pointers-in-each-node-ii",
    "token": null,
    "error": "No test case decoder found",
    "code": null
  },
  {
    "status": "success",
    "question_id": 118,
    "title": "pascals-triangle",
    "token": "e3b8f8ef-5d24-418b-ab72-da97527c56dc",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def generate(self, numRows: int) -> List[List[int]]:\n        \n        if numRows == 1: return [[1]]\n        if numRows == 2: return [[1], [1, 1]]\n\n        prev_result = self.generate(numRows-1)\n        last_row = prev_result[-1]\n        new_result = [1]\n        for i in range(1, numRows-1):\n            new_result.append(last_row[i] + last_row[i-1])\n        new_result.append(1)\n        prev_result.append(new_result)\n        return prev_result\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        numRows = random.randint(1, 10)\n        return {'numRows': numRows}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['numRows'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'numRows': int(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.generate(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "0.06",
      "memory": 4756,
      "stderr": null,
      "token": "e3b8f8ef-5d24-418b-ab72-da97527c56dc",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "success",
    "question_id": 119,
    "title": "pascals-triangle-ii",
    "token": "39111b20-a111-4304-8800-5f40a8702501",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def getRow(self, rowIndex: int) -> List[int]:\n        # \u5982\u679c\u53ea\u8981\u7b2c0\u5217\n        if rowIndex == 0:\n            return [1]\n\n        # \u5132\u5b58\u73fe\u5728\u9019\u5217\n        rowNums = [1,1]\n\n        for _ in range(1, rowIndex):\n            # \u65b0\u5217\n            newRow = [1]\n            for i in range(1, len(rowNums)):\n                newRow.append(rowNums[i]+rowNums[i-1])\n            rowNums = newRow + [1]\n        return rowNums\n\nif __name__ == \"__main__\":\n    Solution().getRow(1)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        row_index = random.randint(0, 10)\n        return {'rowIndex': row_index}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['rowIndex']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'rowIndex': int(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.getRow(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "0.056",
      "memory": 4752,
      "stderr": null,
      "token": "39111b20-a111-4304-8800-5f40a8702501",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "success",
    "question_id": 260,
    "title": "single-number-iii",
    "token": "c5fcce4b-19b0-4791-931b-9f859f167dc5",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport ast\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def singleNumber(self, nums: List[int]) -> List[int]:\n\n        nums.sort()\n        L = []\n\n        for num in nums:\n            if nums.count(num) == 1:\n                L.append(num)\n\n        return L\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        return {'nums': [4, 2, 2, 1, 4, 5, 1, 6]}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'nums': ast.literal_eval(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.singleNumber(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Input {'nums': [1, 1, 2, 2, 4, 4, 5, 6]}\nExpected Output:  [6, 5]\nActual Output:  [5, 6]\n1 Test Failed!\n",
      "time": "0.048",
      "memory": 4912,
      "stderr": null,
      "token": "c5fcce4b-19b0-4791-931b-9f859f167dc5",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 4,
        "description": "Wrong Answer"
      }
    }
  },
  {
    "status": "success",
    "question_id": 264,
    "title": "ugly-number-ii",
    "token": "50915eb9-df5a-4f57-b2c1-0ce753a256ee",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nfrom heapq import heappush, heappop\nclass Solution:\n    def nthUglyNumber(self, n: int) -> int:\n        nums = [1]\n        ugly = [1]\n        count = 0\n        while len(nums) < n:\n            if nums[-1] * 2 not in ugly:\n                nums.append(nums[-1] * 2)\n                heappush(ugly, nums[-1] * 2)\n            if nums[-1] * 3 not in ugly:\n                nums.append(nums[-1] * 3)\n                heappush(ugly, nums[-1] * 3)\n            if nums[-1] * 5 not in ugly:\n                nums.append(nums[-1] * 5)\n                heappush(ugly, nums[-1] * 5)\n            count += 1\n        return ugly[0]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 100)\n        return {'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.nthUglyNumber(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Input {'n': 69}\nExpected Output:  540\nActual Output:  1\n1 Test Failed!\n",
      "time": "0.051",
      "memory": 4772,
      "stderr": null,
      "token": "50915eb9-df5a-4f57-b2c1-0ce753a256ee",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 4,
        "description": "Wrong Answer"
      }
    }
  },
  {
    "status": "success",
    "question_id": 71,
    "title": "simplify-path",
    "token": "ac38b5cf-eabb-4832-8f97-b9d4ffbdae11",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def simplifyPath(self, path: str) -> str:\n        components = path.split('/')\n        stack = []\n        for component in components:\n            if component == '.':\n                continue\n            elif component == '..':\n                if stack:\n                    stack.pop()\n            else:\n                stack.append(component)\n        return '/' + '/'.join(stack)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        paths = ['/home/', '/home//foo/', '/home/user/Documents/../Pictures', '/../', '/.../a/../b/c/../d/./', '/a/b/c/../../', '/a/b//c/.././d', '/a/./b/./c/./d', '/a/b/c/././../..', '/a///b////c/']\n        random_path = random.choice(paths)\n        return {'path': random_path}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['path']\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        return {'path': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.simplifyPath(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Input {'path': '/a/./b/./c/./d'}\nExpected Output:  /a/b/c/d\nActual Output:  //a/b/c/d\n1 Test Failed!\n",
      "time": "0.05",
      "memory": 4744,
      "stderr": null,
      "token": "ac38b5cf-eabb-4832-8f97-b9d4ffbdae11",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 4,
        "description": "Wrong Answer"
      }
    }
  },
  {
    "status": "failure",
    "question_id": 75,
    "title": "sort-colors",
    "token": null,
    "error": "No test case decoder found",
    "code": null
  },
  {
    "status": "success",
    "question_id": 77,
    "title": "combinations",
    "token": "14cf9294-477b-4b2c-b777-267052496143",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def combine(self, n: int, k: int) -> List[List[int]]:\n        self.res = []\n        self.dfs(n, k, [])\n        return self.res\n\n    def dfs(self, n, k, tmp):\n        if len(tmp) == k:\n            self.res.append(tmp)\n        else:\n            for i in range(n + 1):\n                tmp.append(i)\n                self.dfs(n, k, tmp)\n                tmp.pop()\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        n = random.randint(1, 10)\n        k = random.randint(1, n)\n        return {'n': n, 'k': k}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['n']} {input_obj['k']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return ','.join(('[' + ','.join(map(str, combo)) + ']' for combo in output_obj))\n\n    def decode_input(self, input_str) -> dict:\n        n, k = map(int, input_str.split())\n        return {'n': n, 'k': k}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.combine(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Input {'n': 2, 'k': 1}\nExpected Output:  [1],[2]\nActual Output:  [],[],[]\n1 Test Failed!\n",
      "time": "0.064",
      "memory": 4776,
      "stderr": null,
      "token": "14cf9294-477b-4b2c-b777-267052496143",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 4,
        "description": "Wrong Answer"
      }
    }
  },
  {
    "status": "success",
    "question_id": 80,
    "title": "remove-duplicates-from-sorted-array-ii",
    "token": "c09065d1-4a67-4ded-b1d3-db7349626776",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List, Dict\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        count=0\n        for i in range(1,len(nums)):\n            if(nums[i-1]==nums[i]):\n                count+=1\n            else:\n                nums[count]=nums[i]\n                count+=1\n        return count\n\nclass TestCaseGenerator:\n\n    def generate(self) -> Dict[str, List[int]]:\n        \"\"\"\n        Generate a random test case input within a reasonable range\n        (based on the problem constraints) for invoking the entry_point function.\n        \"\"\"\n        length = random.randint(1, 100)\n        nums = []\n        for _ in range(length):\n            if nums and random.random() > 0.5:\n                nums.append(nums[-1])\n            else:\n                nums.append(nums[-1] + random.randint(1, 3) if nums else random.randint(-10, 10))\n        nums = self._limit_duplicates(nums)\n        return {'nums': nums}\n\n    def _limit_duplicates(self, nums: List[int]) -> List[int]:\n        \"\"\"\n        Make sure no number appears more than two times sequentially. Ensures input validity.\n        \"\"\"\n        result = []\n        count, current = (0, None)\n        for num in nums:\n            if num == current:\n                if count < 2:\n                    result.append(num)\n                    count += 1\n            else:\n                result.append(num)\n                current = num\n                count = 1\n        return result\n\n    def encode_input(self, input_obj: Dict[str, List[int]]) -> str:\n        \"\"\"\n        Convert a test case input into a JSON string representation.\n        \"\"\"\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj: int) -> str:\n        \"\"\"\n        Convert a test case output into a string.\n        \"\"\"\n        return str(output_obj)\n\n    def decode_input(self, input_str: str) -> Dict[str, List[int]]:\n        \"\"\"\n        Convert a test case input string into a Python dict with a numerical list.\n        \"\"\"\n        return {'nums': eval(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.removeDuplicates(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Input {'nums': [1, 4, 4, 7, 7]}\nExpected Output:  5\nActual Output:  4\n1 Test Failed!\n",
      "time": "0.052",
      "memory": 4900,
      "stderr": null,
      "token": "c09065d1-4a67-4ded-b1d3-db7349626776",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 4,
        "description": "Wrong Answer"
      }
    }
  },
  {
    "status": "success",
    "question_id": 21,
    "title": "merge-two-sorted-lists",
    "token": "effa52bf-deca-4ef5-9260-ab1c79e4c9c5",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import Optional\nfrom random import randint, choice\nfrom ast import literal_eval\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\n        dummy = ListNode()\n        head = dummy\n        while list1 and list2:\n            if list1.val < list2.val:\n                head.next = list1\n                list1 = list1.next\n            else:\n                head.next = list2\n                list2 = list2.next\n            head = head.next\n        if list1:\n            head.next = list1\n        else:\n            head.next = list2\n        return dummy.next\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        from random import randint, choice\n        length1 = randint(0, 10)\n        length2 = randint(0, 10)\n        list1 = sorted((randint(-100, 100) for _ in range(length1)))\n        list2 = sorted((randint(-100, 100) for _ in range(length2)))\n        return {'list1': self.build_linked_list(list1), 'list2': self.build_linked_list(list2)}\n\n    def build_linked_list(self, values):\n        head = ListNode(values[0]) if values else None\n        current = head\n        for val in values[1:]:\n            current.next = ListNode(val)\n            current = current.next\n        return head\n\n    def encode_input(self, input_obj) -> str:\n        return str((self.list_to_array(input_obj['list1']), self.list_to_array(input_obj['list2'])))\n\n    def list_to_array(self, node):\n        array = []\n        while node:\n            array.append(node.val)\n            node = node.next\n        return array\n\n    def encode_output(self, output_obj) -> str:\n        return str(self.list_to_array(output_obj))\n\n    def decode_input(self, input_str) -> dict:\n        from ast import literal_eval\n        list1, list2 = literal_eval(input_str)\n        return {'list1': self.build_linked_list(list1), 'list2': self.build_linked_list(list2)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.mergeTwoLists(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": null,
      "time": "0.048",
      "memory": 5200,
      "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 138, in <module>\n    runner.run()\n  File \"script.py\", line 122, in run\n    output = self.solution.mergeTwoLists(**input)\n  File \"script.py\", line 56, in mergeTwoLists\n    dummy = ListNode()\nTypeError: __init__() missing 1 required positional argument: 'x'\n",
      "token": "effa52bf-deca-4ef5-9260-ab1c79e4c9c5",
      "compile_output": null,
      "message": "Exited with error status 1",
      "status": {
        "id": 11,
        "description": "Runtime Error (NZEC)"
      }
    }
  },
  {
    "status": "success",
    "question_id": 27,
    "title": "remove-element",
    "token": "4ca67625-0857-4f57-8b22-2a4ada9a9d98",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        i = 0\n        j = len(nums) - 1\n        while i < j:\n            if nums[j] == val:\n                nums[i], nums[j] = nums[j], nums[i]\n                j -= 1\n            elif nums[i] == val:\n                i += 1\n            else:\n                j -= 1\n        return i + (0 if nums[i] == val else 1)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        \"\"\"\n        Generate a random test case input to be used for invoking the\n        removeElement function.\n        \"\"\"\n        nums_length = random.randint(1, 100)\n        nums = [random.randint(0, 50) for _ in range(nums_length)]\n        val = random.randint(0, 50)\n        return {'nums': nums, 'val': val}\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\"\n        Convert a test case input dictionary into a string.\n        \"\"\"\n        nums_str = ','.join(map(str, input_obj['nums']))\n        val_str = str(input_obj['val'])\n        return f'nums=[{nums_str}],val={val_str}'\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\"\n        Convert a test case output into a string.\n        \"\"\"\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\"\n        Convert a test case input string into a Python dictionary.\n        \"\"\"\n        nums_part, val_part = input_str.split('],val=')\n        nums_str = nums_part.split('=')[1].strip('[]')\n        nums = list(map(int, nums_str.split(','))) if nums_str else []\n        val = int(val_part)\n        return {'nums': nums, 'val': val}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.removeElement(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Input {'nums': [16, 29, 21, 47, 17, 33, 46, 12, 15, 3], 'val': 16}\nExpected Output:  9\nActual Output:  2\n1 Test Failed!\n",
      "time": "0.065",
      "memory": 4848,
      "stderr": null,
      "token": "4ca67625-0857-4f57-8b22-2a4ada9a9d98",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 4,
        "description": "Wrong Answer"
      }
    }
  },
  {
    "status": "success",
    "question_id": 28,
    "title": "find-the-index-of-the-first-occurrence-in-a-string",
    "token": "6d333606-7f04-493c-8f95-4952e0aa3039",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        for i in range(len(haystack)):\n            if haystack[i:i+len(needle)]==needle:\n                return i\n        return -1\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        cases = [{'haystack': 'sadbutsad', 'needle': 'sad'}, {'haystack': 'leetcode', 'needle': 'leeto'}, {'haystack': 'a' * 1000 + 'b', 'needle': 'a' * 500}, {'haystack': 'hello', 'needle': 'll'}, {'haystack': 'aaaaaa', 'needle': 'b'}]\n        return random.choice(cases)\n\n    def encode_input(self, input_obj) -> str:\n        return f\"haystack={input_obj['haystack']}, needle={input_obj['needle']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        parts = input_str.split(', ')\n        haystack = parts[0].split('=')[1]\n        needle = parts[1].split('=')[1]\n        return {'haystack': haystack, 'needle': needle}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.strStr(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "0.063",
      "memory": 4932,
      "stderr": null,
      "token": "6d333606-7f04-493c-8f95-4952e0aa3039",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "success",
    "question_id": 29,
    "title": "divide-two-integers",
    "token": "ad78f157-d8b9-4b8e-94dc-f8e836c2cdb1",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def divide(self, dividend: int, divisor: int) -> int:\n        # Constants for 32-bit signed integer limits\n        INT_MAX, INT_MIN = 2**31 - 1, -2**31\n        \n        # Edge case for overflow\n        if dividend == INT_MIN and divisor == -1:\n            return INT_MAX\n        \n        # Determine the sign of the result\n        sign = (dividend < 0)!= (divisor < 0)\n        \n        # Work with absolute values\n        dividend, divisor = abs(dividend), abs(divisor)\n        \n        # Initialize the result\n        quotient = 0\n        \n        # The power of two divisor\n        power = 31\n        # The value of divisor shifted left\n        divisor_power = divisor << power\n        \n        # Subtract divisor multiples from dividend\n        while dividend >= divisor:\n            while divisor_power > dividend:\n                divisor_power >>= 1\n                power -= 1\n            dividend -= divisor_power\n            quotient += 1 << power\n        \n        # Apply the sign\n        if sign:\n            quotient = -quotient\n        \n        # Clamp the result within the 32-bit signed integer range\n        return min(max(quotient, INT_MIN), INT_MAX)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        dividend = random.randint(-1000, 1000)\n        divisor = random.randint(-1000, 1000)\n        while divisor == 0:\n            divisor = random.randint(-1000, 1000)\n        return {'dividend': dividend, 'divisor': divisor}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['dividend']}, {input_obj['divisor']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        dividend, divisor = map(int, input_str.split(','))\n        return {'dividend': dividend, 'divisor': divisor}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.divide(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "0.051",
      "memory": 4772,
      "stderr": null,
      "token": "ad78f157-d8b9-4b8e-94dc-f8e836c2cdb1",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "success",
    "question_id": 30,
    "title": "substring-with-concatenation-of-all-words",
    "token": "7b5cdd78-6de6-4ad3-bd66-586f31a2e903",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        n = len(words)\n        k = len(words[0])\n        words_counts = Counter(words)\n        l = n * k\n\n        indices = []\n        for i in range(len(s) - l + 1):\n            if Counter(s[i + j * k: i + (j + 1) * k] for j in range(n)) == words_counts:\n                indices.append(i)\n\n        return indices\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 50)\n        num_words = random.randint(1, 5)\n        word_length = random.randint(1, 5)\n        s = ''.join((random.choice('abcdefghijklmnopqrstuvwxyz') for _ in range(n)))\n        words = [''.join((random.choice('abcdefghijklmnopqrstuvwxyz') for _ in range(word_length))) for _ in range(num_words)]\n        return {'s': s, 'words': words}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"s={input_obj['s']};words={input_obj['words']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return ','.join(map(str, output_obj))\n\n    def decode_input(self, input_str) -> dict:\n        parts = input_str.split(';')\n        s = parts[0].split('=')[1]\n        words = parts[1].split('=')[1].strip('[]').replace('\"', '').split(',')\n        return {'s': s, 'words': words}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.findSubstring(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "0.049",
      "memory": 4888,
      "stderr": null,
      "token": "7b5cdd78-6de6-4ad3-bd66-586f31a2e903",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "success",
    "question_id": 62,
    "title": "unique-paths",
    "token": "b40a9834-3d89-461d-ad23-55feb11d1528",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport math\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        return self._uniquePaths(m, n)\n\n    def _uniquePaths(self, m, n):\n        if m == 0 or n == 0:\n            return 1\n\n        dp = [[0] * n for _ in range(m)]\n\n        dp[0][0] = 1\n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j == 0:\n                    dp[i][j] = 1\n                elif i == 0:\n                    dp[i][j] = dp[i][j-1]\n                elif j == 0:\n                    dp[i][j] = dp[i-1][j]\n                else:\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1]\n\n        return dp[-1][-1]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        m = random.randint(1, 100)\n        n = random.randint(1, 100)\n        return {'m': m, 'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['m']} {input_obj['n']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        m, n = map(int, input_str.split())\n        return {'m': m, 'n': n}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.uniquePaths(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "0.057",
      "memory": 5160,
      "stderr": null,
      "token": "b40a9834-3d89-461d-ad23-55feb11d1528",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "success",
    "question_id": 64,
    "title": "minimum-path-sum",
    "token": "3fc2b003-894b-432b-9475-22318d06a30b",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\nimport json\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        if not grid or not grid[0]:\n            return 0\n        \n        m, n = len(grid), len(grid[0])\n        \n        # Initialize the dp table\n        dp = [[0] * n for _ in range(m)]\n        \n        # Base case: starting point\n        dp[0][0] = grid[0][0]\n        \n        # Fill the first row\n        for j in range(1, n):\n            dp[0][j] = dp[0][j-1] + grid[0][j]\n        \n        # Fill the first column\n        for i in range(1, m):\n            dp[i][0] = dp[i-1][0] + grid[i][0]\n        \n        # Fill the rest of the dp table\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])\n        \n        # The bottom-right corner has the result\n        return dp[m-1][n-1]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        m = random.randint(1, 10)\n        n = random.randint(1, 10)\n        grid = [[random.randint(0, 200) for _ in range(n)] for _ in range(m)]\n        return {'grid': grid}\n\n    def encode_input(self, input_obj) -> str:\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return json.loads(input_str)\n\n    def decode_output(self, output_str) -> int:\n        return int(output_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.minPathSum(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "0.053",
      "memory": 4784,
      "stderr": null,
      "token": "3fc2b003-894b-432b-9475-22318d06a30b",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "success",
    "question_id": 65,
    "title": "valid-number",
    "token": "bc7b6074-a0ef-4daa-80a6-44e0e25217df",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport string\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def isNumber(self, s: str) -> bool:\n        \"\"\"\n        2\n        0089\n        -0.1\n        +3.14\n        4.\n        -.9\n        2e10\n        -90E3\n\n        Integer followed by optional exponent\n        decimal with optional exponent\n        integer is defined wtih - or +\n        followed by digits\n        \n        This is Integer to English words vibe question.\n        all possible characters we have\n        [0-9]\n       .\n        e,E\n        -, +\n\n        [0,9] can occur anywhere.\n       . cannot occur while defining an exponent like 99e2.5\n\n        e/E cannot occur \n            - if there is no num before it \n            - after it there is no {-,+}[0-9]\n        \n        - and + cannot occur if there is a - or + before it or after.\n        anything else is invalid \n\n        but how many cases can we have\n\n        what about 2e2e2? CONFIRMED INVALID\n        - given 2e2.5 is invalid this may also be invalid\n        - it's possible its not tho\n\n        1. splitting at E should give 2 non-empty elements.\n            - it may not matter if its 3 elements\n            - but if its less than 2 its invalid\n            because it's either e3 or 3e. both invalid\n            for each string:\n                check the - and + \n                check the. \n                    this can only happen in the first element.\n                    remember 2.5e is invalid. but 2.5e3 is not\n        \n        and assumption is are we allowed to modify the input?\n        because if we can I can convert it to all lowercase then split at \"e\"\n        otherwise we have to split at either (might be possible)\n\n        \"\"\"\n        s = s.replace(\"E\",\"e\")\n        elems = s.split(\"e\")\n        # FOR THIS CASE \"92e1740e91\"\n        if len(elems) > 2:\n            return False \n    \n        for i in range(len(elems)):\n            cur_num = elems[i]\n            # eitehr e3 or 3e case\n            if cur_num == \"\":\n                return False\n            # check this number\n            found_dot = False\n\n            for j in range(len(cur_num)):\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        import string\n        case_type = random.choice(['valid', 'invalid'])\n        valid_chars = string.digits + '+-' + 'eE' + '.'\n        invalid_chars = string.ascii_letters + ''.join(set(valid_chars) - set(string.digits))\n        if case_type == 'valid':\n            return {'s': random.choice(['', '+', '-']) + str(random.randint(0, 999)) + random.choice(['', '.', '.']) + ''.join(random.choices(string.digits, k=random.randint(0, 3))) + random.choice(['', 'e', 'E']) + random.choice(['', '+', '-']) + ''.join(random.choices(string.digits, k=random.randint(0, 3)))}\n        else:\n            return {'s': ''.join(random.choices(valid_chars + invalid_chars, k=random.randint(1, 20)))}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['s']\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\n    def decode_output(self, output_str) -> bool:\n        return output_str == 'True'\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.isNumber(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": null,
      "time": "0.025",
      "memory": 3184,
      "stderr": "  File \"script.py\", line 119\n    class TestCaseGenerator:\n    ^\nIndentationError: expected an indented block\n",
      "token": "bc7b6074-a0ef-4daa-80a6-44e0e25217df",
      "compile_output": null,
      "message": "Exited with error status 1",
      "status": {
        "id": 11,
        "description": "Runtime Error (NZEC)"
      }
    }
  },
  {
    "status": "success",
    "question_id": 66,
    "title": "plus-one",
    "token": "6a57a15a-c6a6-4dfc-9b31-ff8d117de27f",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom ast import literal_eval\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def plusOne(self, digits: List[int]) -> List[int]:\n        n=len(digits)\n        for i in range(n-1,-1,-1):\n            if digits[i]<9:\n                digits[i]+=1\n                return digits\n            else:\n                digits[i]=0\n        return [1]+digits\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 10)\n        digits = [random.randint(1, 9)] + [random.randint(0, 9) for _ in range(n - 1)]\n        return {'digits': digits}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['digits'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'digits': literal_eval(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.plusOne(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "0.06",
      "memory": 5064,
      "stderr": null,
      "token": "6a57a15a-c6a6-4dfc-9b31-ff8d117de27f",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "success",
    "question_id": 67,
    "title": "add-binary",
    "token": "40b4ea8d-8dc9-4250-9dac-6b37b3b19fa2",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def addBinary(self, a: str, b: str) -> str:\n        i= len(a)-1\n        j= len(b)-1\n\n        car=0\n        sol=\"\"\n        while i >= 0 or j >= 0 or car:\n            digit_a = int(a[i]) if i >= 0 else 0\n            digit_b = int(b[j]) if j >= 0 else 0\n            \n            total = digit_a + digit_b + car\n            sol+=str(total % 2)\n            car = total // 2  \n\n            i-=1\n            j-=1\n        return sol[::-1]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length_a = random.randint(1, 15)\n        length_b = random.randint(1, 15)\n        a = ''.join((random.choice('01') for _ in range(length_a)))\n        b = ''.join((random.choice('01') for _ in range(length_b)))\n        return {'a': a, 'b': b}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['a']},{input_obj['b']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        a, b = input_str.split(',')\n        return {'a': a, 'b': b}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.addBinary(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Input {'a': '010011110', 'b': '0010111100'}\nExpected Output:  101011010\nActual Output:  0101011010\n4 Test Failed!\n",
      "time": "0.059",
      "memory": 4792,
      "stderr": null,
      "token": "40b4ea8d-8dc9-4250-9dac-6b37b3b19fa2",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 4,
        "description": "Wrong Answer"
      }
    }
  },
  {
    "status": "success",
    "question_id": 69,
    "title": "sqrtx",
    "token": "f10a838b-6efb-4860-9241-b985439c9056",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport json\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def mySqrt(self, x: int) -> int:\n        if x == 0 or x == 1:\n            return x\n        return int(-1/2 * (math.log(x) / math.log(2)) + 0.5)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        x = random.randint(0, 1000000)\n        return {'x': x}\n\n    def encode_input(self, input_obj) -> str:\n        import json\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        import json\n        return json.dumps({'result': output_obj})\n\n    def decode_input(self, input_str) -> dict:\n        import json\n        return json.loads(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.mySqrt(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Input {'x': 101934}\nExpected Output:  {\"result\": 319}\nActual Output:  {\"result\": -7}\n1 Test Failed!\n",
      "time": "0.061",
      "memory": 4772,
      "stderr": null,
      "token": "f10a838b-6efb-4860-9241-b985439c9056",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 4,
        "description": "Wrong Answer"
      }
    }
  },
  {
    "status": "success",
    "question_id": 70,
    "title": "climbing-stairs",
    "token": "6b7ff1ed-5778-4534-a745-a0869b25c56f",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom functools import cache\nimport random\n\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def climbStairs(self, n: int) -> int:\n        return self._dfs(n, {})\n\n    def _dfs(self, n: int, memo: dict[int, int]):\n        if n == 0 or n == 1:\n            return 1\n        if n not in memo:\n            memo[n] = self._dfs(n - 1, memo) + self._dfs(n - 2, memo)\n        return memo[n]\n\n#### Test Code:\nimport unittest\nfrom Solution import Solution as s\n\nclass Test(unittest.TestCase):\n    def test_climbStairs(self):\n        self.assertEqual(1, s.climbStairs(1))\n        self.assertEqual(2, s.climbStairs(2))\n        self.assertEqual(3, s.climbStairs(3))\n        self.assertEqual(5, s.climbStairs(5))\n        self.assertEqual(15, s.climbStairs(15))\n\nif __name__ == '__main__':\n    unittest.main()\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        return {'n': random.randint(1, 10)}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['n'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'n': int(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.climbStairs(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": null,
      "time": "0.046",
      "memory": 4584,
      "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 26, in <module>\n    from functools import cache\nImportError: cannot import name 'cache' from 'functools' (/usr/local/python-3.8.1/lib/python3.8/functools.py)\n",
      "token": "6b7ff1ed-5778-4534-a745-a0869b25c56f",
      "compile_output": null,
      "message": "Exited with error status 1",
      "status": {
        "id": 11,
        "description": "Runtime Error (NZEC)"
      }
    }
  },
  {
    "status": "failure",
    "question_id": 51,
    "title": "n-queens",
    "token": null,
    "error": "No test case decoder found",
    "code": null
  },
  {
    "status": "success",
    "question_id": 52,
    "title": "n-queens-ii",
    "token": "8078b262-9fca-44df-af00-4822802da09b",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def totalNQueens(self, n: int) -> int:\n        def helper(row):\n            if row == n:\n                return 1\n            count = 0\n            for c in range(len(board[row])):\n                if board[row][c] == 0:\n                    continue\n                count += helper(row+1)\n            return count\n\n        board = [[0] * n for _ in range(n)]\n        count = 0\n        for r in range(n):\n            for c in range(n):\n                if board[r][c] == 0:\n                    continue\n                count += helper(r)\n\n        return count\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 9)\n        return {'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['n'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'n': int(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.totalNQueens(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Input {'n': 9}\nExpected Output:  352\nActual Output:  0\n1 Test Failed!\n",
      "time": "0.058",
      "memory": 4812,
      "stderr": null,
      "token": "8078b262-9fca-44df-af00-4822802da09b",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 4,
        "description": "Wrong Answer"
      }
    }
  },
  {
    "status": "success",
    "question_id": 53,
    "title": "maximum-subarray",
    "token": "c368447b-2fd5-43a3-8009-3e3458b001a6",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\ndef maxSubArray(nums):\n    # maxSum = float('-inf') # initialize maxSum is -infinity which is the lowest of any number \n    # currentSum = 0\n    \n    # for num in nums:\n    #     currentSum += num\n    #     if currentSum > maxSum:\n    #         maxSum = currentSum\n    #     if currentSum < 0:\n    #         currentSum = 0\n    \n    # return maxSum\n    \n    if not nums:\n        return 0\n    \n    currentSum = nums[0]\n    maxSum = currentSum\n    \n    for num in nums[1:]:\n        currentSum = max(currentSum + num, num)\n        maxSum = max(maxSum, currentSum)\n    \n    return maxSum\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        \"\"\"\n        Generate a random test case input for the maxSubArray function.\n        :return: A dictionary with 'nums' as key and list of integers as value.\n        \"\"\"\n        length = random.randint(1, 100)\n        nums = [random.randint(-10000, 10000) for _ in range(length)]\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\"\n        Convert a test case input into a string (JSON-like format).\n        :param input_obj: A dictionary with 'nums' as key.\n        :return: A string representation of 'nums'\n        \"\"\"\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\"\n        Convert a test case output into a string.\n        :param output_obj: The output value to be encoded.\n        :return: A string representation of the output.\n        \"\"\"\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\"\n        Convert a test case input string into a Python dict.\n        :param input_str: The input string to decode.\n        :return: A dictionary with 'nums' as key.\n        \"\"\"\n        nums = eval(input_str)\n        return {'nums': nums}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.maxSubArray(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": null,
      "time": "0.048",
      "memory": 4788,
      "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 109, in <module>\n    class Runner:\n  File \"script.py\", line 110, in Runner\n    def __init__(self, solution: Solution):\nNameError: name 'Solution' is not defined\n",
      "token": "c368447b-2fd5-43a3-8009-3e3458b001a6",
      "compile_output": null,
      "message": "Exited with error status 1",
      "status": {
        "id": 11,
        "description": "Runtime Error (NZEC)"
      }
    }
  },
  {
    "status": "success",
    "question_id": 55,
    "title": "jump-game",
    "token": "560e3523-ea40-4655-aa92-74f35674d4a1",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List, Dict\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def canJump(self, nums: List[int]) -> bool:\n        n = len(nums)\n        dp = [0] * n\n        dp[0] = 1\n\n        for i in range(1, n):\n            if dp[i - 1] == 1:\n                continue\n            for j in range(nums[i]):\n                if i + j + 1 < n:\n                    dp[i + j + 1] = 1\n                    i = i + j + 1\n\n        return dp[n - 1] == 1\n\nclass TestCaseGenerator:\n\n    def generate(self) -> Dict[str, List[int]]:\n        nums_length = random.randint(1, 20)\n        nums = [random.randint(0, 5) for _ in range(nums_length)]\n        return {'nums': nums}\n\n    def encode_input(self, input_obj: Dict[str, List[int]]) -> str:\n        return ','.join(map(str, input_obj['nums']))\n\n    def encode_output(self, output_obj: bool) -> str:\n        return 'true' if output_obj else 'false'\n\n    def decode_input(self, input_str: str) -> Dict[str, List[int]]:\n        nums = list(map(int, input_str.split(',')))\n        return {'nums': nums}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.canJump(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Input {'nums': [3, 4, 4]}\nExpected Output:  true\nActual Output:  false\n2 Test Failed!\n",
      "time": "0.043",
      "memory": 4868,
      "stderr": null,
      "token": "560e3523-ea40-4655-aa92-74f35674d4a1",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 4,
        "description": "Wrong Answer"
      }
    }
  },
  {
    "status": "success",
    "question_id": 58,
    "title": "length-of-last-word",
    "token": "c398042c-dce2-492e-a34a-b3c14c59dfad",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def lengthOfLastWord(self, s: str) -> int:\n        return len(s.split(' ')[-1])\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        words = ['abcdefghijklmnopqrstuvwxyz', 'hello', 'world', 'moon', 'joyboy']\n        sentence = ' '.join(random.choices(words, k=random.randint(1, 5)))\n        sentence = sentence.rjust(len(sentence) + random.randint(0, 5))\n        sentence = sentence.ljust(len(sentence) + random.randint(0, 5))\n        return {'s': sentence.strip()}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['s']\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\n    def decode_output(self, output_str) -> int:\n        return int(output_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.lengthOfLastWord(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "0.058",
      "memory": 4736,
      "stderr": null,
      "token": "c398042c-dce2-492e-a34a-b3c14c59dfad",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "success",
    "question_id": 60,
    "title": "permutation-sequence",
    "token": "92ddcf36-0263-41c9-82f9-000934bbb0f7",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport math\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def getPermutation(self, n: int, k: int) -> str:\n        def nextPermutation(lst):\n            if len(lst)==1:\n                return lst\n            else:\n                e=len(lst)-1\n                b=[]\n                while (lst[e]<=lst[e-1]):\n                    b.append(lst[e])\n                    e=e-1\n                    if e==0:\n                        return []\n                b.append(lst[e])\n                b.append(lst[e-1])\n                pivot=lst[e-1]\n                min_next=max(lst)+1\n                for element in b:\n                    if element > pivot and element<min_next:\n                        min_next=element\n                m=lst[0:e-1]\n                m.append(min_next)\n                b.remove(min_next)\n                b.sort()\n                for e in b:\n                    m.append(e)\n                return m\n        if n==1:\n            return str(n)\n        else:\n            nums=[]\n            for i in range(1,n+1):\n                nums.append(i)\n            count=1\n            while(count<k):\n                nums=nextPermutation(nums)\n                count+=1\n            s=''\n            for elem in nums:\n                s+=str(elem) \n        return s\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 9)\n        k = random.randint(1, math.factorial(n))\n        return {'n': n, 'k': k}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['n']},{input_obj['k']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        n, k = map(int, input_str.split(','))\n        return {'n': n, 'k': k}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.getPermutation(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "0.084",
      "memory": 4864,
      "stderr": null,
      "token": "92ddcf36-0263-41c9-82f9-000934bbb0f7",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "success",
    "question_id": 282,
    "title": "expression-add-operators",
    "token": "c72c23b6-4d6b-407f-9851-189c34cda097",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def addOperators(self, num: str, target: int) -> List[str]:\n        def add(expr: str, val: int, val2: int):\n            if val2 == 0: return expr + str(val)\n            return str(val) + expr\n        \n        def validate(expr: str):\n            prev = ''\n            check = False\n            cnt = 0\n            for v in expr:\n                if not prev.isdigit():\n                    if v == '0': check = True\n                    else: \n                        check = False\n                        cnt = 0\n                if v.isdigit() and check: cnt += 1\n                else:\n                    check = False\n                    cnt = 0\n                if cnt == 2: return False\n                prev = v\n            return True\n        \n        def find_expressions(available):\n            if not available: return ''\n            if len(available) == 1: return available[0]\n            exps = []\n            c = available.pop()\n            for expr in find_expressions(available):\n                exps.append(expr + c)\n                exps.append(expr + '+' + c)\n                exps.append(expr + '-' + c)\n                exps.append(expr + '*' + c)\n            return exps\n\n        ret = []\n        available = list(num)\n        for expr in find_expressions(available):\n            if eval_expr(expr) == target and validate(expr): ret.append(expr)\n\n        return ret\n\nclass TestCaseGenerator:\n    import random\n\n    def generate(self) -> dict:\n        nums = ['123', '232', '3456237490', '105', '00', '9999']\n        targets = [6, 8, 9191, 5, 0, 27]\n        test_index = self.random.randint(0, len(nums) - 1)\n        return {'num': nums[test_index], 'target': targets[test_index]}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"num = '{input_obj['num']}', target = {input_obj['target']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return ', '.join(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        parts = input_str.split(', ')\n        num = parts[0].split('=')[1].strip().strip(\"'\")\n        target = int(parts[1].split('=')[1].strip())\n        return {'num': num, 'target': target}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.addOperators(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": null,
      "time": "0.058",
      "memory": 4828,
      "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 141, in <module>\n    runner.run()\n  File \"script.py\", line 125, in run\n    output = self.solution.addOperators(**input)\n  File \"script.py\", line 86, in addOperators\n    if eval_expr(expr) == target and validate(expr): ret.append(expr)\nNameError: name 'eval_expr' is not defined\n",
      "token": "c72c23b6-4d6b-407f-9851-189c34cda097",
      "compile_output": null,
      "message": "Exited with error status 1",
      "status": {
        "id": 11,
        "description": "Runtime Error (NZEC)"
      }
    }
  },
  {
    "status": "success",
    "question_id": 283,
    "title": "move-zeroes",
    "token": "3ffb5579-c8fb-4d4a-ab1e-0163cf1ff240",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def moveZeroes(self, nums: List[int]) -> None:\n        n = len(nums)\n        for i in range(n):\n            if nums[i]==0:\n                for j in range(i,n):\n                    if nums[j]!=0:\n                        nums[i],nums[j]=nums[j],nums[i]\n                        break\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        test_case = {'nums': [random.choice(range(-10, 10)) for _ in range(random.randint(1, 20))]}\n        return test_case\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        nums = eval(input_str)\n        return {'nums': nums}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.moveZeroes(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "0.05",
      "memory": 4824,
      "stderr": null,
      "token": "3ffb5579-c8fb-4d4a-ab1e-0163cf1ff240",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "failure",
    "question_id": 335,
    "title": "self-crossing",
    "token": null,
    "error": "No test case decoder found",
    "code": null
  },
  {
    "status": "failure",
    "question_id": 336,
    "title": "palindrome-pairs",
    "token": null,
    "error": "No test case decoder found",
    "code": null
  },
  {
    "status": "success",
    "question_id": 338,
    "title": "counting-bits",
    "token": "10140f3b-6bb7-4a3e-8f55-4fd53fb39ad3",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def countBits(self, n: int) -> List[int]:\n        return [bin(i).count('1') for i in range(n+1)]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(0, 1000)\n        return {'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['n'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        n = int(input_str)\n        return {'n': n}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.countBits(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "0.061",
      "memory": 5112,
      "stderr": null,
      "token": "10140f3b-6bb7-4a3e-8f55-4fd53fb39ad3",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "success",
    "question_id": 342,
    "title": "power-of-four",
    "token": "dc906a65-18de-4a0b-9493-a4ee843920cd",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def isPowerOfFour(self, n: int) -> bool:\n        return n>0 and (n&(-n)==n)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        test_values = [1, 4, 16, 64, 256, 1024, 5, 12, 20, 50, 100, -4, 0, random.randint(-500, 500)]\n        n = random.choice(test_values)\n        return {'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['n'])\n\n    def encode_output(self, output_obj) -> str:\n        return 'true' if output_obj else 'false'\n\n    def decode_input(self, input_str) -> dict:\n        return {'n': int(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.isPowerOfFour(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "0.046",
      "memory": 4784,
      "stderr": null,
      "token": "dc906a65-18de-4a0b-9493-a4ee843920cd",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "success",
    "question_id": 345,
    "title": "reverse-vowels-of-a-string",
    "token": "3aa6e228-0716-43cc-94ef-b14e71c72eaa",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\n\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def reverseVowels(self, s: str) -> str:\n        buf = list(s)\n        vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n        vowels.reverse()\n        vowels = vowels + vowels[::-1]\n        vowels = [vowels[i] for i in range(len(vowels))]\n        indexs = [i for i, v in enumerate(vowels) if v in buf]\n        indexs = [i for i, v in enumerate(vowels) if v not in buf]\n        for i in range(len(indexs)):\n            buf[indexs[i]] = vowels[i]\n        answer = ''.join(buf)\n        return answer\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        return {'s': 'ExampleTestString'}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['s']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.reverseVowels(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": null,
      "time": "0.045",
      "memory": 4736,
      "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 105, in <module>\n    runner.run()\n  File \"script.py\", line 89, in run\n    output = self.solution.reverseVowels(**input)\n  File \"script.py\", line 57, in reverseVowels\n    buf[indexs[i]] = vowels[i]\nIndexError: list assignment index out of range\n",
      "token": "3aa6e228-0716-43cc-94ef-b14e71c72eaa",
      "compile_output": null,
      "message": "Exited with error status 1",
      "status": {
        "id": 11,
        "description": "Runtime Error (NZEC)"
      }
    }
  },
  {
    "status": "success",
    "question_id": 521,
    "title": "longest-uncommon-subsequence-i",
    "token": "bb476a14-591d-450c-8ca4-237855ce71d9",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport string\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def findLUSlength(self, a: str, b: str) -> int:\n        return max(len(a), len(b))\n\nclass TestCaseGenerator:\n\n    def __init__(self):\n        self.random = random\n\n    def generate(self) -> dict:\n        length_a = self.random.randint(1, 100)\n        length_b = self.random.randint(1, 100)\n        a = ''.join(self.random.choices(string.ascii_lowercase, k=length_a))\n        b = ''.join(self.random.choices(string.ascii_lowercase, k=length_b))\n        return {'a': a, 'b': b}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"a={input_obj['a']}&b={input_obj['b']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        params = input_str.split('&')\n        a = params[0].split('=')[1]\n        b = params[1].split('=')[1]\n        return {'a': a, 'b': b}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.findLUSlength(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "0.044",
      "memory": 4852,
      "stderr": null,
      "token": "bb476a14-591d-450c-8ca4-237855ce71d9",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "success",
    "question_id": 383,
    "title": "ransom-note",
    "token": "9856c8e1-52e6-4979-b35e-9bcd239cda6e",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport string\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def canConstruct(self, ransomNote: str, magazine: str) -> bool:\n        d={}\n        for c in magazine:\n            if c not in d:\n                d[c]=1\n            else:\n                d[c]+=1\n        for i in ransomNote:\n            if i in d and d[i]>0:\n                d[i]-=1\n            else:\n                return False\n        return True\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        ransom_length = random.randint(1, 100)\n        magazine_length = random.randint(ransom_length, 105)\n        ransomNote = ''.join(random.choices(string.ascii_lowercase, k=ransom_length))\n        magazine = ''.join(random.choices(string.ascii_lowercase, k=magazine_length))\n        return {'ransomNote': ransomNote, 'magazine': magazine}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"ransomNote={input_obj['ransomNote']}&magazine={input_obj['magazine']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return 'true' if output_obj else 'false'\n\n    def decode_input(self, input_str) -> dict:\n        components = input_str.split('&')\n        return {'ransomNote': components[0].split('=')[1], 'magazine': components[1].split('=')[1]}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.canConstruct(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "0.059",
      "memory": 4864,
      "stderr": null,
      "token": "9856c8e1-52e6-4979-b35e-9bcd239cda6e",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "success",
    "question_id": 389,
    "title": "find-the-difference",
    "token": "c3533ad7-e98a-453a-bc67-eb928ed6bc40",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def findTheDifference(self, s: str, t: str) -> str:\n        s = list(s)\n        t = list(t)\n        for i in range(len(s)):\n            s[i] -= ord(s[i])\n            t[i] -= ord(t[i])\n        return chr(s[0] + t[0])\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        alphabets = 'abcdefghijklmnopqrstuvwxyz'\n        length = random.randint(0, 1000)\n        s = ''.join(random.choices(alphabets, k=length))\n        added_char = random.choice(alphabets)\n        t_list = list(s)\n        random.shuffle(t_list)\n        insert_position = random.randint(0, length)\n        t_list.insert(insert_position, added_char)\n        t = ''.join(t_list)\n        return {'s': s, 't': t}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['s']} {input_obj['t']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        s, t = input_str.split()\n        return {'s': s, 't': t}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.findTheDifference(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": null,
      "time": "0.051",
      "memory": 5044,
      "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 110, in <module>\n    runner.run()\n  File \"script.py\", line 94, in run\n    output = self.solution.findTheDifference(**input)\n  File \"script.py\", line 52, in findTheDifference\n    s[i] -= ord(s[i])\nTypeError: unsupported operand type(s) for -=: 'str' and 'int'\n",
      "token": "c3533ad7-e98a-453a-bc67-eb928ed6bc40",
      "compile_output": null,
      "message": "Exited with error status 1",
      "status": {
        "id": 11,
        "description": "Runtime Error (NZEC)"
      }
    }
  },
  {
    "status": "success",
    "question_id": 391,
    "title": "perfect-rectangle",
    "token": "a1412aa7-303a-4f1e-b15a-e9f32484a6c3",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport numpy as np\nfrom typing import List\nimport ast\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\n        x1, x2 = max([x[0] for x in rectangles]), min([x[2] for x in rectangles])\n        y1, y2 = max([y[1] for y in rectangles]), min([y[3] for y in rectangles])\n        if x1 >= x2 or y1 >= y2: return False\n        area = 0\n        for x, y, a, b in rectangles:\n            area += (a - x) * (b - y)\n        return area == x2 - x1 * y2 / y1\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        test_cases = [{'rectangles': [[1, 1, 3, 3], [3, 1, 4, 2], [3, 2, 4, 4], [1, 3, 2, 4], [2, 3, 3, 4]]}, {'rectangles': [[1, 1, 2, 3], [1, 3, 2, 4], [3, 1, 4, 2], [3, 2, 4, 4]]}, {'rectangles': [[1, 1, 3, 3], [3, 1, 4, 2], [1, 3, 2, 4], [2, 2, 4, 4]]}]\n        return test_cases[0]\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        import ast\n        return ast.literal_eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.isRectangleCover(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": null,
      "time": "0.043",
      "memory": 4588,
      "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 26, in <module>\n    import numpy as np\nModuleNotFoundError: No module named 'numpy'\n",
      "token": "a1412aa7-303a-4f1e-b15a-e9f32484a6c3",
      "compile_output": null,
      "message": "Exited with error status 1",
      "status": {
        "id": 11,
        "description": "Runtime Error (NZEC)"
      }
    }
  },
  {
    "status": "success",
    "question_id": 392,
    "title": "is-subsequence",
    "token": "5ef5c2a0-8d6f-4e80-b2e9-63e7e152f1b5",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport string\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def isSubsequence(self, s: str, t: str) -> bool:\n        if len(s) == 0:\n            return True\n        return self.isSubsequenceHelper(s, t, 0, len(t))\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        \"\"\"\n        Generates a test case with randomly generated strings s and t.\n        \"\"\"\n        import random\n        import string\n        t = ''.join((random.choice(string.ascii_lowercase) for _ in range(random.randint(1, 1000))))\n        if random.choice([True, False]):\n            s = ''.join(random.sample(t, random.randint(0, len(t))))\n        else:\n            s = ''.join((random.choice(string.ascii_lowercase) for _ in range(random.randint(0, min(100, len(t))))))\n        return {'s': s, 't': t}\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\"\n        Encodes the input dictionary into a string format.\n        \"\"\"\n        return f\"{input_obj['s']}::{input_obj['t']}\"\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\"\n        Encodes the output object into a string format (true/false as a string).\n        \"\"\"\n        return str(output_obj).lower()\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\"\n        Decodes the input string back into a dictionary with keys 's' and 't'.\n        \"\"\"\n        s, t = input_str.split('::')\n        return {'s': s, 't': t}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.isSubsequence(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": null,
      "time": "0.044",
      "memory": 5000,
      "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 118, in <module>\n    runner.run()\n  File \"script.py\", line 102, in run\n    output = self.solution.isSubsequence(**input)\n  File \"script.py\", line 52, in isSubsequence\n    return self.isSubsequenceHelper(s, t, 0, len(t))\nAttributeError: 'Solution' object has no attribute 'isSubsequenceHelper'\n",
      "token": "5ef5c2a0-8d6f-4e80-b2e9-63e7e152f1b5",
      "compile_output": null,
      "message": "Exited with error status 1",
      "status": {
        "id": 11,
        "description": "Runtime Error (NZEC)"
      }
    }
  },
  {
    "status": "success",
    "question_id": 354,
    "title": "russian-doll-envelopes",
    "token": "1cd09463-79cd-4934-ae6b-893cd3b3c64e",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List\nimport ast\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def maxEnvelopes(self, envelopes: List[List[int]]) -> int:\n        n = len(envelopes)\n        envelopes.sort(key=lambda x: (x[0], -x[1])) # when there is a tie in width, desc height prevent wrong LIS\n\n        sub = [envelopes[0][1]]\n        for e in envelopes:\n            idx = bisect_left(sub, e[1])\n            if idx == len(sub):\n                sub.append(e[1])\n            else:\n                sub[idx] = e[1]\n        return len(sub)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        num_envelopes = random.randint(1, 100)\n        envelopes = [[random.randint(1, 100), random.randint(1, 100)] for _ in range(num_envelopes)]\n        return {'envelopes': envelopes}\n\n    def encode_input(self, input_obj) -> str:\n        envelopes = input_obj['envelopes']\n        return str(envelopes)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        envelopes = ast.literal_eval(input_str)\n        return {'envelopes': envelopes}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.maxEnvelopes(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "0.054",
      "memory": 5480,
      "stderr": null,
      "token": "1cd09463-79cd-4934-ae6b-893cd3b3c64e",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "success",
    "question_id": 479,
    "title": "largest-palindrome-product",
    "token": "1cd03014-764d-4b83-ae49-e308d1d5e5d8",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport math\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def largestPalindrome(self, n: int) -> int:\n        if n == 1: return 9\n        upper = int('9'*n)\n        lower = int('9'*(n-1))\n        \n        firstHalf = upper\n\n        while True:\n            pal = int(str(firstHalf) + str(firstHalf)[::-1])\n            for div in range(upper, lower, -1):\n                if div * div < pal or pal / div > upper:\n                    break\n                if pal % div == 0:\n                    return pal % 1337\n            firstHalf -= 1\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        n = random.randint(1, 8)\n        return {'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['n'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'n': int(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.largestPalindrome(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "1.636",
      "memory": 4832,
      "stderr": null,
      "token": "1cd03014-764d-4b83-ae49-e308d1d5e5d8",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "success",
    "question_id": 483,
    "title": "smallest-good-base",
    "token": "57a37073-bff0-4bdd-ba5b-57b3a7277ff2",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport math\nimport time\nfrom fractions import Fraction\nfrom random import randint\n\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def smallestGoodBase(self, n: str) -> str:\n        import math\n        import time\n        from fractions import Fraction\n\n        n = int(n)\n\n        def f(u, n, x):\n            a = 0\n            for i in range(n + 1):\n                a += u**i\n            a -= x\n            return a\n\n        def candidates(x):\n            Z = set()\n            L = 6\n            for m in range(1, L + 1):\n                a = 0\n                b = x\n                z = 0\n                while (True):\n                    z = Fraction(a + b, 2)\n                    if (f(z, m, x) < -0.1):\n                        a = z\n                    elif (f(z, m, x) > 0.1):\n                        b = z\n                    else:\n                        z = int(round(z))\n                        if (f(z, m, x) == 0):\n                            Z.add(z)\n                        break\n            if (min(Z) == 1):\n                Z.pop()\n            return min(Z)\n\n        for b in range(2, 1201):\n            y = n\n            g = 1\n            while (y!= 0):\n                if (y % b!= 1):\n                    g = 0\n                    break\n                else:\n                    y //= b\n            if (g == 1):\n                return str(b)\n\n        return str(candidates(n))\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        \"\"\"Generate a random test case.\"\"\"\n        n = randint(3, 100000)\n        return {'n': str(n)}\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\"\n        Convert a test case input into a string.\n        :param input_obj: Dictionary with the input object.\n        :return: String representation of the input object.\n        \"\"\"\n        return input_obj['n']\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\"\n        Convert a test case output into a string.\n        :param output_obj: The output which is a good base.\n        :return: String representation of the output object.\n        \"\"\"\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\"\n        Convert a test case input string into a dictionary.\n        :param input_str: String representation of the input.\n        :return: Dictionary with the input object.\n        \"\"\"\n        return {'n': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.smallestGoodBase(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "0.21",
      "memory": 5520,
      "stderr": null,
      "token": "57a37073-bff0-4bdd-ba5b-57b3a7277ff2",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "failure",
    "question_id": 485,
    "title": "max-consecutive-ones",
    "token": null,
    "error": "No test case decoder found",
    "code": null
  },
  {
    "status": "success",
    "question_id": 409,
    "title": "longest-palindrome",
    "token": "8baadfb3-876c-41a8-bd4e-e22d517c4233",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom collections import Counter\nimport random\nimport string\nimport json\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def longestPalindrome(self, s: str) -> int:\n        char_count = Counter(s)\n        length = 0\n        odd_found = False\n        for count in char_count.values():\n            if count % 2 == 0:\n                length += count\n            else:\n                length += count - 1\n                odd_found = True\n        if odd_found:\n            return length + 1\n        return length\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(1, 20)\n        random_string = ''.join(random.choices(string.ascii_letters, k=length))\n        return {'s': random_string}\n\n    def encode_input(self, input_obj) -> str:\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return json.loads(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.longestPalindrome(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "0.051",
      "memory": 4804,
      "stderr": null,
      "token": "8baadfb3-876c-41a8-bd4e-e22d517c4233",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "failure",
    "question_id": 410,
    "title": "split-array-largest-sum",
    "token": null,
    "error": "No test case decoder found",
    "code": null
  },
  {
    "status": "failure",
    "question_id": 412,
    "title": "fizz-buzz",
    "token": null,
    "error": "No test case decoder found",
    "code": null
  },
  {
    "status": "success",
    "question_id": 414,
    "title": "third-maximum-number",
    "token": "2e0088b4-558a-4150-9b8c-96ead1e5103b",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport json\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\ndef thirdMax(nums):\n    if len(nums) < 3:\n        return max(nums)\n    return max(nums) if nums.count(max(nums)) == 1 else max(nums) if nums.count(max(nums)) == 2 else max(nums)[0]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        nums_length = random.randint(1, 100)\n        nums = [random.randint(-2 ** 31, 2 ** 31 - 1) for _ in range(nums_length)]\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return json.loads(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.thirdMax(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": null,
      "time": "0.043",
      "memory": 4676,
      "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 70, in <module>\n    class Runner:\n  File \"script.py\", line 71, in Runner\n    def __init__(self, solution: Solution):\nNameError: name 'Solution' is not defined\n",
      "token": "2e0088b4-558a-4150-9b8c-96ead1e5103b",
      "compile_output": null,
      "message": "Exited with error status 1",
      "status": {
        "id": 11,
        "description": "Runtime Error (NZEC)"
      }
    }
  },
  {
    "status": "success",
    "question_id": 472,
    "title": "concatenated-words",
    "token": "186b5cb1-24f2-4928-b539-b26481f67ad3",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nfrom functools import cache\nimport json\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\n        def dfs(word, i):\n            if i >= len(word):\n                return True\n            if word[i] not in word_dict:\n                return False\n            curr = word_dict[word[i]]\n            if \"$\" in curr:\n                return dfs(word, i + 1)\n            return dfs(word, i + 1)\n        word_dict = {}\n        for word in words:\n            word_dict[word] = {}\n            for i in range(len(word)):\n                word_dict[word][word[i]] = {}\n                word_dict[word][word[i]][\"$\"] = None\n        return [w for w in words if dfs(w, 0)]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        test_cases = [{'words': ['cat', 'cats', 'catsdogcats', 'dog', 'dogcatsdog', 'hippopotamuses', 'rat', 'ratcatdogcat']}, {'words': ['cat', 'dog', 'catdog']}, {'words': ['apple', 'banana', 'applebanana', 'bananaapple']}, {'words': ['a', 'b', 'c', 'abc', 'bc', 'cab', 'ac', 'abcab']}]\n        return test_cases[0]\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\" Convert a test case input into a JSON string \"\"\"\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\" Convert a test case output into a JSON string \"\"\"\n        return json.dumps(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\" Convert a test case input string back into a Python dict \"\"\"\n        return json.loads(input_str)\n\n    def decode_output(self, output_str) -> list:\n        \"\"\" Convert a test case output string back into a Python list \"\"\"\n        return json.loads(output_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.findAllConcatenatedWordsInADict(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": null,
      "time": "0.049",
      "memory": 4636,
      "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 27, in <module>\n    from functools import cache\nImportError: cannot import name 'cache' from 'functools' (/usr/local/python-3.8.1/lib/python3.8/functools.py)\n",
      "token": "186b5cb1-24f2-4928-b539-b26481f67ad3",
      "compile_output": null,
      "message": "Exited with error status 1",
      "status": {
        "id": 11,
        "description": "Runtime Error (NZEC)"
      }
    }
  },
  {
    "status": "success",
    "question_id": 476,
    "title": "number-complement",
    "token": "bb2b8f0a-4568-44d3-b4f4-d47cd201d04e",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution(object):\n    def findComplement(self, num):\n        return ~num\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        num = random.randint(1, 10 ** 5)\n        return {'num': num}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['num'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'num': int(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.findComplement(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Input {'num': 20256}\nExpected Output:  12511\nActual Output:  -20257\n1 Test Failed!\n",
      "time": "0.047",
      "memory": 4776,
      "stderr": null,
      "token": "bb2b8f0a-4568-44d3-b4f4-d47cd201d04e",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 4,
        "description": "Wrong Answer"
      }
    }
  },
  {
    "status": "success",
    "question_id": 440,
    "title": "k-th-smallest-in-lexicographical-order",
    "token": "ac351833-cac1-49d6-8e33-05c84dbec61d",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution(object):\n    def findKthNumber(self, n, k):\n        def countSteps(n, prefix1, prefix2):\n            steps = 0\n            while prefix1 <= n:\n                steps += min(n + 1, prefix2) - prefix1\n                prefix1 *= 10\n                prefix2 *= 10\n            return steps\n\n        def countPrefixes(n, prefix1):\n            return countSteps(n, prefix1, prefix1 + 1)\n\n        def countPrefixes2(n\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 1000)\n        k = random.randint(1, n)\n        return {'n': n, 'k': k}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['n']} {input_obj['k']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        n, k = map(int, input_str.split())\n        return {'n': n, 'k': k}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.findKthNumber(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": null,
      "time": "0.022",
      "memory": 3172,
      "stderr": "  File \"script.py\", line 62\n    class TestCaseGenerator:\n    ^\nSyntaxError: invalid syntax\n",
      "token": "ac351833-cac1-49d6-8e33-05c84dbec61d",
      "compile_output": null,
      "message": "Exited with error status 1",
      "status": {
        "id": 11,
        "description": "Runtime Error (NZEC)"
      }
    }
  },
  {
    "status": "success",
    "question_id": 441,
    "title": "arranging-coins",
    "token": "3ef07a33-5ba7-4785-ab52-874e2b9ff43c",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def arrangeCoins(self, n: int) -> int:\n        res = 0\n        step = 1\n        \n        while n >= step:\n            res += 1\n            n -= step\n            step += 1\n        \n        return res\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 100)\n        return {'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['n'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        n = int(input_str)\n        return {'n': n}\n\n    def decode_output(self, output_str) -> int:\n        return int(output_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.arrangeCoins(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "0.059",
      "memory": 4752,
      "stderr": null,
      "token": "3ef07a33-5ba7-4785-ab52-874e2b9ff43c",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "failure",
    "question_id": 401,
    "title": "binary-watch",
    "token": null,
    "error": "No test case decoder found",
    "code": null
  },
  {
    "status": "success",
    "question_id": 404,
    "title": "sum-of-left-leaves",
    "token": "f0c5a2f9-3b54-4f46-9402-43e5578cd637",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom collections import deque\nfrom typing import Optional\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sumOfLeftLeaves(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        res = 0\n        if root.left:\n            if root.left.left:\n                res += self.sumOfLeftLeaves(root.left.left)\n            else:\n                res += self.sumOfLeftLeaves(root.left.right)\n        if root.right:\n            if root.right.left:\n                res += self.sumOfLeftLeaves(root.right.left)\n            else:\n                res += self.sumOfLeftLeaves(root.right.right)\n        return res\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        single_node_tree = {'root': TreeNode(1)}\n        left_leaf_tree = {'root': TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7)))}\n        no_left_leaf_tree = {'root': TreeNode(1, None, TreeNode(2, None, TreeNode(3)))}\n        return no_left_leaf_tree\n\n    def encode_input(self, input_obj) -> str:\n\n        def serialize_tree(node):\n            if not node:\n                return 'null'\n            return f'{node.val}, {serialize_tree(node.left)}, {serialize_tree(node.right)}'\n        root = input_obj['root']\n        return f'[{serialize_tree(root)}]'\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n\n        def deserialize_tree(data_list):\n            if not data_list:\n                return None\n            val = data_list.pop(0)\n            if val == 'null':\n                return None\n            node = TreeNode(val=int(val))\n            node.left = deserialize_tree(data_list)\n            node.right = deserialize_tree(data_list)\n            return node\n        elements = input_str.strip('[]').split(', ')\n        root = deserialize_tree(elements)\n        return {'root': root}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.sumOfLeftLeaves(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": null,
      "time": "0.047",
      "memory": 4748,
      "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 137, in <module>\n    runner.run()\n  File \"script.py\", line 118, in run\n    input = self.test.decode_input(test_case['input'])\n  File \"script.py\", line 104, in decode_input\n    root = deserialize_tree(elements)\n  File \"script.py\", line 99, in deserialize_tree\n    node = TreeNode(val=int(val))\nTypeError: __init__() got an unexpected keyword argument 'val'\n",
      "token": "f0c5a2f9-3b54-4f46-9402-43e5578cd637",
      "compile_output": null,
      "message": "Exited with error status 1",
      "status": {
        "id": 11,
        "description": "Runtime Error (NZEC)"
      }
    }
  },
  {
    "status": "success",
    "question_id": 405,
    "title": "convert-a-number-to-hexadecimal",
    "token": "1fc57256-3333-42c5-b5b9-4c20e29f8ea2",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def toHex(self, num: int) -> str:\n        return ''.join([hexas[i] for i in bin(num)[2:]])\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        num = random.randint(-2 ** 31, 2 ** 31 - 1)\n        return {'num': num}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['num'])\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        num = int(input_str)\n        return {'num': num}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.toHex(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": null,
      "time": "0.056",
      "memory": 4780,
      "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 97, in <module>\n    runner.run()\n  File \"script.py\", line 81, in run\n    output = self.solution.toHex(**input)\n  File \"script.py\", line 49, in toHex\n    return ''.join([hexas[i] for i in bin(num)[2:]])\n  File \"script.py\", line 49, in <listcomp>\n    return ''.join([hexas[i] for i in bin(num)[2:]])\nNameError: name 'hexas' is not defined\n",
      "token": "1fc57256-3333-42c5-b5b9-4c20e29f8ea2",
      "compile_output": null,
      "message": "Exited with error status 1",
      "status": {
        "id": 11,
        "description": "Runtime Error (NZEC)"
      }
    }
  },
  {
    "status": "success",
    "question_id": 363,
    "title": "max-sum-of-rectangle-no-larger-than-k",
    "token": "a79f8b4c-0ba5-4045-9c9b-e9093359d6fc",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport math\nfrom sortedcontainers import SortedList\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nimport numpy as np\nfrom sortedcontainers import SortedList\nfrom typing import List\n\nclass Solution:\n    def helper(self, a_list: List[int], k: int) -> int:\n        prefix_sums = SortedList([0])\n        cur_sum = 0\n        max_sum = float('-inf')\n        \n        for num in a_list:\n            cur_sum += num\n            # \u67e5\u627e\u5c0f\u4e8e\u7b49\u4e8e cur_sum - k \u7684\u524d\u7f00\u548c\n            target = cur_sum - k\n            pos = prefix_sums.bisect_left(target)\n            if pos < len(prefix_sums):\n                max_sum = max(max_sum, cur_sum - prefix_sums[pos])\n            prefix_sums.add(cur_sum)\n            \n            if max_sum == k:\n                return k\n        \n        return max_sum\n\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\n        mtx = matrix = np.array(matrix)\n        M, N = len(matrix), len(matrix[0])\n        max_sum = float('-inf')\n        sums = []\n\n        cursums = np.array([0] * N)\n        for i in range(M): \n            cur = mtx[i]\n            cursums += cur\n            sums.append(cursums.copy())\n        sums = np.array(sums)\n\n        for i in range(M): \n            for j in range(i, M): \n                nowsums = sums[j] - sums[i] + mtx[i]\n                max_sum = max(self.helper(nowsums, k), max_sum)\n        \n        return max_sum\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        m = random.randint(1, 10)\n        n = random.randint(1, 10)\n        k = random.randint(-1000, 1000)\n        matrix = [[random.randint(-100, 100) for _ in range(n)] for _ in range(m)]\n        return {'matrix': matrix, 'k': k}\n\n    def encode_input(self, input_obj: dict) -> str:\n        matrix_str = str(input_obj['matrix'])\n        k_str = str(input_obj['k'])\n        return f\"{{'matrix': {matrix_str}, 'k': {k_str}}}\"\n\n    def encode_output(self, output_obj: int) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str: str) -> dict:\n        return eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.maxSumSubmatrix(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": null,
      "time": "0.044",
      "memory": 4632,
      "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 27, in <module>\n    from sortedcontainers import SortedList\nModuleNotFoundError: No module named 'sortedcontainers'\n",
      "token": "a79f8b4c-0ba5-4045-9c9b-e9093359d6fc",
      "compile_output": null,
      "message": "Exited with error status 1",
      "status": {
        "id": 11,
        "description": "Runtime Error (NZEC)"
      }
    }
  },
  {
    "status": "success",
    "question_id": 459,
    "title": "repeated-substring-pattern",
    "token": "a3cbd78b-b1a6-409c-ae14-7ed0a769cc45",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nimport numpy as np\nclass Solution:\n    def repeatedSubstringPattern(self, s: str) -> bool:\n        return bool(s[:1] * len(s)/len(s[1:]))\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(2, 20)\n        s = ''.join(random.choices('abcdefghijklmnopqrstuvwxyz', k=length))\n        return {'s': s}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['s']\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj).lower()\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.repeatedSubstringPattern(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": null,
      "time": "0.048",
      "memory": 4756,
      "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 47, in <module>\n    import numpy as np\nModuleNotFoundError: No module named 'numpy'\n",
      "token": "a3cbd78b-b1a6-409c-ae14-7ed0a769cc45",
      "compile_output": null,
      "message": "Exited with error status 1",
      "status": {
        "id": 11,
        "description": "Runtime Error (NZEC)"
      }
    }
  },
  {
    "status": "success",
    "question_id": 461,
    "title": "hamming-distance",
    "token": "82975379-6701-4dfe-8f77-91f4c58f0cbb",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def hammingDistance(self, x: int, y: int) -> int:\n        return sum(x!= y and bin(x)[i]!= bin(y)[i] for i in range(32))\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        x = random.randint(0, 2 ** 31 - 1)\n        y = random.randint(0, 2 ** 31 - 1)\n        return {'x': x, 'y': y}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{{'x': {input_obj['x']}, 'y': {input_obj['y']}}}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        input_parts = input_str.strip('{}').split(', ')\n        x = int(input_parts[0].split(': ')[1])\n        y = int(input_parts[1].split(': ')[1])\n        return {'x': x, 'y': y}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.hammingDistance(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": null,
      "time": "0.043",
      "memory": 4836,
      "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 100, in <module>\n    runner.run()\n  File \"script.py\", line 84, in run\n    output = self.solution.hammingDistance(**input)\n  File \"script.py\", line 49, in hammingDistance\n    return sum(x!= y and bin(x)[i]!= bin(y)[i] for i in range(32))\n  File \"script.py\", line 49, in <genexpr>\n    return sum(x!= y and bin(x)[i]!= bin(y)[i] for i in range(32))\nIndexError: string index out of range\n",
      "token": "82975379-6701-4dfe-8f77-91f4c58f0cbb",
      "compile_output": null,
      "message": "Exited with error status 1",
      "status": {
        "id": 11,
        "description": "Runtime Error (NZEC)"
      }
    }
  },
  {
    "status": "success",
    "question_id": 463,
    "title": "island-perimeter",
    "token": "7ee30d89-ea1e-4bdf-b63c-bf055b5238d5",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List\nimport ast\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def count_perimeter_at(self, neiboughr_matrix, grid, i, j):\n        counter = 0\n        for step in neiboughr_matrix:\n            new_step = [step[0] + i, step[1] + j]\n            if not (0 <= new_step[0] < len(grid)):\n                counter += 1\n                continue\n            elif not (0 <= new_step[1] < len(grid[0])):\n                counter += 1\n                continue\n            elif grid[new_step[0]][new_step[1]] == 0:\n                counter += 1\n        return counter\n\n    def islandPerimeter(self, grid: List[List[int]]) -> int:\n        neiboughr_matrix = [[1, 0], [0, 1], [-1, 0], [0, -1]]\n        counter = 0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 1:\n                    counter += self.count_perimeter_at(neiboughr_matrix, grid, i, j)\n        return counter\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        height = random.randint(1, 10)\n        width = random.randint(1, 10)\n        grid = [[0 for _ in range(width)] for _ in range(height)]\n        start_x = random.randint(0, height - 1)\n        start_y = random.randint(0, width - 1)\n        grid[start_x][start_y] = 1\n        for _ in range(int(height * width / 4)):\n            direction = random.choice(['up', 'down', 'left', 'right'])\n            if direction == 'up' and start_x - 1 >= 0:\n                start_x -= 1\n            elif direction == 'down' and start_x + 1 < height:\n                start_x += 1\n            elif direction == 'left' and start_y - 1 >= 0:\n                start_y -= 1\n            elif direction == 'right' and start_y + 1 < width:\n                start_y += 1\n            grid[start_x][start_y] = 1\n        return {'grid': grid}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['grid'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        grid = ast.literal_eval(input_str)\n        return {'grid': grid}\n\n    def decode_output(self, output_str) -> int:\n        return int(output_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.islandPerimeter(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "0.06",
      "memory": 5240,
      "stderr": null,
      "token": "7ee30d89-ea1e-4bdf-b63c-bf055b5238d5",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "success",
    "question_id": 466,
    "title": "count-the-repetitions",
    "token": "bb9dc220-2916-49d3-bf77-ad7766281929",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom collections import defaultdict\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n        dp = [[0,0]]\n\n        for i in range(len(s2)):\n            start, count = i, 0 \n            for j in range(len(s1)):\n                if s1[j] == s2[start]:\n                    start += 1 \n                    if start == len(s2):\n                        start = 0 \n                        count += 1 \n            dp.append([start,count])\n\n        total, idx = 0, 0\n\n        for _ in range(n1):\n            total += dp[idx][1]\n            idx = dp[idx][0]\n\n        return total//n2\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        letters = 'abcdefghijklmnopqrstuvwxyz'\n        s1_length = random.randint(1, 10)\n        s2_length = random.randint(1, 10)\n        s1 = ''.join((random.choice(letters) for _ in range(s1_length)))\n        s2 = ''.join((random.choice(letters) for _ in range(s2_length)))\n        n1 = random.randint(1, 100)\n        n2 = random.randint(1, 100)\n        return {'s1': s1, 'n1': n1, 's2': s2, 'n2': n2}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['s1']},{input_obj['n1']},{input_obj['s2']},{input_obj['n2']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        s1, n1, s2, n2 = input_str.split(',')\n        return {'s1': s1, 'n1': int(n1), 's2': s2, 'n2': int(n2)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.getMaxRepetitions(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "0.048",
      "memory": 4860,
      "stderr": null,
      "token": "bb9dc220-2916-49d3-bf77-ad7766281929",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "success",
    "question_id": 685,
    "title": "redundant-connection-ii",
    "token": "0d599317-201e-4344-bdc3-32dc2f838c65",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nfrom collections import defaultdict\n\nclass Solution:\n    def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:\n        graph = defaultdict(set)\n        num_incoming_edges = defaultdict(int)\n        for edge in edges:\n            a, b = edge[0], edge[1]\n            graph[a].add(b)\n            num_incoming_edges[b] += 1\n\n        def findCycleDfs(root, curr, history, visited):\n            if curr == root:\n                return history\n            if curr in visited:\n                return\n            visited.add(curr)\n            for node in graph[curr]:\n                history.add((curr, node))\n                result = findCycleDfs(root, node, history, visited)\n                if result is not None:\n                    return result\n                history.remove((curr, node))\n\n        result = None\n        for edge in edges:\n            a, b = edge[0], edge[1]\n            if num_incoming_edges[b] > 1:\n                result = edge\n            if result is not None and (a, b) in result:\n                return edge\n\n        return result\n\nclass TestCaseGenerator:\n\n    def __init__(self, nodes_range=(3, 6)):\n        self.nodes_range = nodes_range\n\n    def generate(self) -> dict:\n        n = random.randint(*self.nodes_range)\n        edges = []\n        for i in range(1, n):\n            edges.append([i, i + 1])\n        a = random.randint(1, n - 1)\n        b = random.randint(a + 1, n)\n        edges.append([b, a])\n        random.shuffle(edges)\n        return {'edges': edges}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['edges'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'edges': eval(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.findRedundantDirectedConnection(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Input {'edges': [[3, 2], [3, 4], [2, 3], [1, 2]]}\nExpected Output:  [3, 2]\nActual Output:  [1, 2]\n1 Test Failed!\n",
      "time": "0.045",
      "memory": 4876,
      "stderr": null,
      "token": "0d599317-201e-4344-bdc3-32dc2f838c65",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 4,
        "description": "Wrong Answer"
      }
    }
  },
  {
    "status": "success",
    "question_id": 736,
    "title": "parse-lisp-expression",
    "token": "4e67d716-689e-4820-a10f-0c89c8501fd1",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List, Dict\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def evaluate(self, expression: str) -> int:\n        \"\"\"\n        expr := (let [string expr]*)\n        expr := (add  expr expr)\n        expr := (mult expr expr)\n        expr := var \n        \"\"\"\n\n        def tokenize(s):\n            Q = deque()\n            cur = 0\n            n = len(s)\n            while cur < n:\n                c = s[cur]\n                if c in ('(', ')'):\n                    Q.append(c)\n                    cur += 1\n                    continue\n                if c.isdigit() or c == '-':\n                    res = 0\n                    sign = 1\n                    if c == '-':\n                        sign = -1\n                        cur += 1\n                    while cur < n and s[cur].isdigit():\n                        res = res*10 + int(s[cur])\n                        cur += 1\n                    Q.append(sign * res)\n                    continue\n                if c.isalpha():\n                    res = []\n                    while cur < n and (s[cur].isalpha() or s[cur].isdigit()):\n                        res.append(s[cur])\n                        cur += 1\n                    Q.append(''.join(res))\n                    continue\n                cur += 1\n            return Q\n\n        tokens = tokenize(expression)  #TODO\n\n        def string():\n            return tokens.popleft()\n\n        def var(mp):\n            s = tokens.popleft()\n            if mp.get(s)!= None:\n                return mp[s]\n            return s\n\n        def expr(_mp):\n            mp = copy.copy(_mp)\n            if tokens[0] == '(':\n                assert tokens.popleft() == '('\n                op = tokens.popleft()\n                if op == 'let':\n                    while tokens[0]!= '(' and tokens[1]!= ')':\n                        variable_name = string()\n                        expression = expr(mp)\n                        mp[variable_name] = expression\n                    expression = expr(mp)\n                elif op =='mult':\n                    expr1 = expr(mp)\n                    expr2 = expr(mp)\n                    expression = expr1 * expr2\n                elif op == 'add':\n                    expr1 = expr(mp)\n                    expr2 = expr(mp)\n                    expression = expr1 + expr2\n                assert tokens.popleft() == ')'\n                return expression\n            else:\n                return var(mp)\n\n        return expr({})\n\nclass TestCaseGenerator:\n\n    def generate(self) -> Dict:\n        test_cases = [{'expression': '(let x 2 (mult x (let x 3 y 4 (add x y))))'}, {'expression': '(let x 3 x 2 x )'}, {'expression': '(let x 1 y 2 x (add x y) (add x y))'}, {'expression': '(add 1 2)'}, {'expression': '(mult (add 1 2) 3)'}]\n        return random.choice(test_cases)\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['expression']\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> Dict:\n        return {'expression': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.evaluate(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "0.051",
      "memory": 4908,
      "stderr": null,
      "token": "4e67d716-689e-4820-a10f-0c89c8501fd1",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "success",
    "question_id": 973,
    "title": "stamping-the-sequence",
    "token": "b4a52124-2842-42cf-824c-bd23c11203c0",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        def can_stamp(i):\n            changed = False\n            for j in range(len(stamp)):\n                if target[i + j] == '?':\n                    continue\n                if target[i + j]!= stamp[j]:\n                    return False\n                changed = True\n            return changed\n\n        def do_stamp(i):\n            for j in range(len(stamp)):\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        stamp = 'abc'\n        target = 'ababc'\n        return {'stamp': stamp, 'target': target}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{{'stamp': '{input_obj['stamp']}', 'target': '{input_obj['target']}'}}\"\n\n    def encode_output(self, output_obj) -> str:\n        return f'{output_obj}'\n\n    def decode_input(self, input_str) -> dict:\n        import ast\n        return ast.literal_eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.movesToStamp(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": null,
      "time": "0.02",
      "memory": 3248,
      "stderr": "  File \"script.py\", line 62\n    class TestCaseGenerator:\n    ^\nIndentationError: expected an indented block\n",
      "token": "b4a52124-2842-42cf-824c-bd23c11203c0",
      "compile_output": null,
      "message": "Exited with error status 1",
      "status": {
        "id": 11,
        "description": "Runtime Error (NZEC)"
      }
    }
  },
  {
    "status": "failure",
    "question_id": 975,
    "title": "range-sum-of-bst",
    "token": null,
    "error": "No test case decoder found",
    "code": null
  },
  {
    "status": "failure",
    "question_id": 977,
    "title": "distinct-subsequences-ii",
    "token": null,
    "error": "No test case decoder found",
    "code": null
  },
  {
    "status": "success",
    "question_id": 1013,
    "title": "fibonacci-number",
    "token": "a184a7d5-b89e-4471-9b1e-9db269b17879",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def fib(self, n: int) -> int:\n        if n < 2: \n            return n\n        \n        return self.fib(n-2) + self.fib(n-1)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        from random import randint\n        return {'n': randint(0, 30)}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['n'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'n': int(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.fib(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "0.744",
      "memory": 4856,
      "stderr": null,
      "token": "a184a7d5-b89e-4471-9b1e-9db269b17879",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "success",
    "question_id": 514,
    "title": "freedom-trail",
    "token": "297ce501-dd8c-4f10-8024-4704caf44e00",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nfrom collections import defaultdict\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def findRotateSteps(self, ring: str, key: str) -> int:\n        dp = [0] * len(ring)\n        dp[0] = 0\n        for k in reversed(range(len(key))):\n            nextDP = [inf] * len(ring)\n            for r in range(len(ring)):\n                for i, c in enumerate(ring):\n                    if c == key[k]:\n                        minDist = min(abs(r-i), len(ring)-abs(r-i))\n                        nextDP[r] = min(nextDP[r], 1+minDist+dp[i])\n                dp = nextDP\n        return dp[0]\n\nclass TestCaseGenerator:\n    \"\"\"\n    Generates test case inputs for the \"Road to Freedom\" problem where a ring needs to be rotated to match a given key string.\n    \"\"\"\n\n    def generate(self) -> dict:\n        random.seed(0)\n        ring_length = random.randint(1, 100)\n        key_length = random.randint(1, 100)\n        alphabet = 'abcdefghijklmnopqrstuvwxyz'\n        ring = ''.join(random.choices(alphabet, k=ring_length))\n        key = ''.join(random.choices(alphabet, k=key_length))\n        return {'ring': ring, 'key': key}\n\n    def encode_input(self, input_obj: dict) -> str:\n        return f\"ring={input_obj['ring']},key={input_obj['key']}\"\n\n    def encode_output(self, output_obj: int) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str: str) -> dict:\n        parts = input_str.split(',')\n        ring = parts[0].split('=')[1]\n        key = parts[1].split('=')[1]\n        return {'ring': ring, 'key': key}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.findRotateSteps(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "0.385",
      "memory": 4908,
      "stderr": null,
      "token": "297ce501-dd8c-4f10-8024-4704caf44e00",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "success",
    "question_id": 920,
    "title": "uncommon-words-from-two-sentences",
    "token": "5caf2ab7-1a72-4529-95b7-01a90b86dcaa",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nfrom collections import Counter\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def uncommonFromSentences(self, s1: str, s2: str) -> List[str]:\n        d=Counter(s1.split())+Counter(s2.split())\n        return [x for x in d if d[x]==1]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        test_cases = [('this apple is sweet', 'this apple is sour'), ('apple apple', 'banana'), ('orange', 'apple orange'), ('dog cat', 'cat dog'), ('unique words', 'unique unique words'), ('a quick brown fox', 'jumps over the lazy dog')]\n        s1, s2 = random.choice(test_cases)\n        return {'s1': s1, 's2': s2}\n\n    def encode_input(self, input_obj: dict) -> str:\n        return f\"{input_obj['s1']}|{input_obj['s2']}\"\n\n    def encode_output(self, output_obj: List[str]) -> str:\n        return ','.join(output_obj)\n\n    def decode_input(self, input_str: str) -> dict:\n        s1, s2 = input_str.split('|')\n        return {'s1': s1, 's2': s2}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.uncommonFromSentences(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "0.045",
      "memory": 4876,
      "stderr": null,
      "token": "5caf2ab7-1a72-4529-95b7-01a90b86dcaa",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "failure",
    "question_id": 35,
    "title": "search-insert-position",
    "token": null,
    "error": "No test case decoder found",
    "code": null
  },
  {
    "status": "success",
    "question_id": 9,
    "title": "palindrome-number",
    "token": "4039077f-4630-4b7b-8938-4fdafeed571a",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def isPalindrome(self, x: int) -> bool:\n        if x < 0:\n            return False\n        if x == 0:\n            return True\n        return x % 10 == x // 10\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        test_values = [121, -121, 10, 0, 12321, -12321, 1, -1, 123321, 1234321, 12345, 1000021]\n        x = random.choice(test_values)\n        return {'x': x}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['x'])\n\n    def encode_output(self, output_obj) -> str:\n        return 'true' if output_obj else 'false'\n\n    def decode_input(self, input_str) -> dict:\n        return {'x': int(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.isPalindrome(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Input {'x': 12321}\nExpected Output:  true\nActual Output:  false\n4 Test Failed!\n",
      "time": "0.046",
      "memory": 4848,
      "stderr": null,
      "token": "4039077f-4630-4b7b-8938-4fdafeed571a",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 4,
        "description": "Wrong Answer"
      }
    }
  },
  {
    "status": "failure",
    "question_id": 10,
    "title": "regular-expression-matching",
    "token": null,
    "error": "No test case decoder found",
    "code": null
  },
  {
    "status": "success",
    "question_id": 218,
    "title": "the-skyline-problem",
    "token": "9c4fb11d-3f24-4ac5-b321-d9429fa1862d",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport heapq\nimport random\nimport ast\n\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def getSkyline(self, buildings: List[List[int]]) -> List[List[int]]:\n        # Sort the unique positions of all the edges.\n        positions = sorted(list(set([x for building in buildings for x in building[:2]])))\n        \n        # Hast table 'edge_index_map' to record every {position : index} pairs in edges.\n        edge_index_map = {x : i for i, x in enumerate(positions)}\n\n        # Initialize 'heights' to record maximum height at each index.\n        heights = [0] * len(positions)\n        \n        # Iterate over all the buildings.\n        for left, right, height in buildings:\n            # For each building, find the indexes of its left\n            # and right edges.\n            left_idx = edge_index_map[left]\n            right_idx = edge_index_map[right]\n\n            # Update the maximum height within the range [left_idx, right_idx)\n            for i in range(left_idx, right_idx):\n                heights[i] = max(heights[i], height)\n\n        answer = []\n\n        # Iterate over 'heights'.\n        for i in range(len(heights)):\n            curr_height = heights[i]\n            curr_x = positions[i]\n\n            # Add all the positions where the height changes to 'answer'.\n            if not answer or answer[-1][1]!= curr_height:\n                answer.append([curr_x, curr_height])\n        return answer\n\nclass TestCaseGenerator:\n\n    def __init__(self):\n        self.min_height = 1\n        self.max_height = 20\n        self.max_x_coord = 100\n\n    def generate(self) -> dict:\n        num_buildings = random.randint(1, 100)\n        buildings = []\n        current_x = 0\n        for _ in range(num_buildings):\n            left = current_x\n            right = left + random.randint(1, 10)\n            height = random.randint(self.min_height, self.max_height)\n            buildings.append([left, right, height])\n            current_x = right + random.randint(0, 5)\n        return {'buildings': buildings}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return ast.literal_eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.getSkyline(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "0.061",
      "memory": 5788,
      "stderr": null,
      "token": "9c4fb11d-3f24-4ac5-b321-d9429fa1862d",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "failure",
    "question_id": 226,
    "title": "invert-binary-tree",
    "token": null,
    "error": "No test case decoder found",
    "code": null
  },
  {
    "status": "success",
    "question_id": 273,
    "title": "integer-to-english-words",
    "token": "aa69b934-7d7e-47d3-9222-452b54cf7caa",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def numberToWords(self, num: int) -> str:\n        if num == 0:\n            return \"Zero\"\n        \n        converter = {1:\"One\",2:'Two',3:'Three',4:'Four',5:'Five',6:'Six',7:'Seven', 8:\"Eight\", 9:'Nine',10:'Ten',11:\"Eleven\",12:'Twelve',13:'Thirteen',14:'Fourteen',15:'Fifteen',16:\"Sixteen\",17:'Seventeen',18:\"Eighteen\",19:\"Nineteen\",20:\"Twenty\",30:\"Thirty\",40:\"Forty\",50:\"Fifty\",60:\"Sixty\",70:\"Seventy\", 80:\"Eighty\",90:\"Ninety\"}\n        \n        def hundreds(number):\n            ans = []\n            if number >= 100:\n                hundreds_digit,number = divmod(number,100)\n                ans.append(converter[hundreds_digit])\n                ans.append(\"Hundred\")\n            if number > 20:\n                tens_digit,number = divmod(number,10)\n                ans.append(converter[tens_digit*10])\n            if number > 0:\n                ans.append(converter[number])\n            return \" \".join(ans)\n        sol = []\n        digit,num = divmod(num,10**9)\n        \n        if digit:\n            sol.append(hundreds(digit))\n            sol.append(\"Billion\")\n        \n        digit,num = divmod(num,10**6)\n        \n        if digit:\n            sol.append(hundreds(digit))\n            sol.append(\"Million\")\n        \n        digit,num = divmod(num,10**3)\n        \n        if digit:\n            sol.append(hundreds(digit))\n            sol.append(\"Thousand\")\n        if num:\n            sol.append(hundreds(num))\n        return \" \".join(sol)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        \"\"\"\n        Generates a random test case input within the range of the problem's constraints.\n        \"\"\"\n        num = random.randint(0, 2 ** 31 - 1)\n        return {'num': num}\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\"\n        Convert a test case input into a string suitable for passing to the function.\n        \"\"\"\n        return str(input_obj['num'])\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\"\n        Convert a test case output into a string representation.\n        \"\"\"\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\"\n        Convert a test case input string into a Python dict.\n        \"\"\"\n        return {'num': int(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.numberToWords(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "0.049",
      "memory": 4856,
      "stderr": null,
      "token": "aa69b934-7d7e-47d3-9222-452b54cf7caa",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "success",
    "question_id": 14,
    "title": "longest-common-prefix",
    "token": "ed99ffa9-cb01-4503-94a7-874e1fe4a41f",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def longestCommonPrefix(self, strs: List[str]) -> str:\n        if not strs: return ''\n        strs.sort(key=len)\n        pf = ''\n        for i,l in enumerate(strs[0]):\n            for word in strs:\n                if word[i]!= l:\n                    return pf\n            pf += l\n        return pf\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        num_strings = random.randint(1, 10)\n        strs = []\n        for _ in range(num_strings):\n            str_length = random.randint(0, 10)\n            random_str = ''.join(random.choices('abcdefghijklmnopqrstuvwxyz', k=str_length))\n            strs.append(random_str)\n        return {'strs': strs}\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\"Convert a test case input into a string for transport.\"\"\"\n        return str(input_obj['strs'])\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\"Convert a test case output into a string for transport.\"\"\"\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\"Convert a test case input string back into a dictionary.\"\"\"\n        strs = eval(input_str[1:-1])\n        return {'strs': strs}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.longestCommonPrefix(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": null,
      "time": "0.049",
      "memory": 4796,
      "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 115, in <module>\n    runner.run()\n  File \"script.py\", line 99, in run\n    output = self.solution.longestCommonPrefix(**input)\n  File \"script.py\", line 52, in longestCommonPrefix\n    strs.sort(key=len)\nAttributeError: 'str' object has no attribute 'sort'\n",
      "token": "ed99ffa9-cb01-4503-94a7-874e1fe4a41f",
      "compile_output": null,
      "message": "Exited with error status 1",
      "status": {
        "id": 11,
        "description": "Runtime Error (NZEC)"
      }
    }
  },
  {
    "status": "success",
    "question_id": 258,
    "title": "add-digits",
    "token": "f35bdf9f-4c69-49f6-a9ef-bfe163c49cf1",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def addDigits(self, num: int) -> int:\n        if num == 0: \n            return 0\n        mod = num % 9 \n        if mod == 0:\n            return 9 \n        else: return mod\n\n#### Explanation:\n1. The code is optimized by removing the unnecessary variable'mod' and return statement.\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        num = random.randint(0, 1000)\n        return {'num': num}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['num'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        try:\n            num = int(input_str)\n            return {'num': num}\n        except ValueError:\n            raise ValueError('Invalid input string for conversion to integer')\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.addDigits(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": null,
      "time": "0.023",
      "memory": 3172,
      "stderr": "  File \"script.py\", line 57\n    1. The code is optimized by removing the unnecessary variable'mod' and return statement.\n       ^\nSyntaxError: invalid syntax\n",
      "token": "f35bdf9f-4c69-49f6-a9ef-bfe163c49cf1",
      "compile_output": null,
      "message": "Exited with error status 1",
      "status": {
        "id": 11,
        "description": "Runtime Error (NZEC)"
      }
    }
  },
  {
    "status": "success",
    "question_id": 76,
    "title": "minimum-window-substring",
    "token": "0d51fcaa-849c-418a-ad44-fad207c68e78",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        n = len(s)\n        t_counter = Counter(t)\n        curr_counter = t_counter.copy()\n        for key in curr_counter:\n            curr_counter[key] = 0\n        left, right = 0, 0\n        minimum_window = ''\n        length = n + 1\n        while right < n:\n            curr_counter[s[right]] += 1\n            t_counter[s[right]] += 0\n            valid = True\n            for key in t_counter:\n                if curr_counter[key] < t_counter[key]:\n                    valid = False\n            if valid:\n                while True:\n                    if curr_counter[s[left]] - 1 >= t_counter[s[left]]:\n                        curr_counter[s[left]] -= 1\n                        left += 1\n                    else:\n                        break\n                if right - left + 1 < length:\n                    minimum_window = s[left:right+1]\n                    length = len(minimum_window)\n            right += 1\n        return minimum_window\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        possible_cases = [{'s': 'ADOBECODEBANC', 't': 'ABC'}, {'s': 'a', 't': 'a'}, {'s': 'a', 't': 'aa'}, {'s': 'MANGROVESANDMONOGRAMS', 't': 'GMSA'}]\n        return random.choice(possible_cases)\n\n    def encode_input(self, input_obj) -> str:\n        return f\"s={input_obj['s']},t={input_obj['t']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        values = input_str.split(',')\n        return {'s': values[0].split('=')[1], 't': values[1].split('=')[1]}\n\n    def decode_output(self, output_str) -> str:\n        return output_str\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.minWindow(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "0.057",
      "memory": 4764,
      "stderr": null,
      "token": "0d51fcaa-849c-418a-ad44-fad207c68e78",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "success",
    "question_id": 68,
    "title": "text-justification",
    "token": "d90f52ae-2925-40d5-9fc1-63d42e138758",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport json\nfrom math import ceil\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\n        \n        res=[]\n        n=len(words)\n        cur_width = 0\n        for word in words:\n            cur_width += len(word) + 1\n            if cur_width > maxWidth:\n                res += [' '.join(line) for line in [word] * (maxWidth // len(word))]\n                cur_width = 0\n            else:\n                res.append([word] * (maxWidth // len(word)))\n        return res\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        test_cases = [{'words': ['This', 'is', 'an', 'example', 'of', 'text', 'justification.'], 'maxWidth': 16}, {'words': ['What', 'must', 'be', 'acknowledgment', 'shall', 'be'], 'maxWidth': 16}, {'words': ['Science', 'is', 'what', 'we', 'understand', 'well', 'enough', 'to', 'explain', 'to', 'a', 'computer.', 'Art', 'is', 'everything', 'else', 'we', 'do'], 'maxWidth': 20}, {'words': ['Lorem', 'ipsum', 'dolor', 'sit', 'amet'], 'maxWidth': 14}, {'words': ['A', 'test', 'case', 'with'], 'maxWidth': 12}]\n        return random.choice(test_cases)\n\n    def encode_input(self, input_obj) -> str:\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return json.dumps(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return json.loads(input_str)\n\n    def decode_output(self, output_str) -> list:\n        return json.loads(output_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.fullJustify(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Input {'words': ['What', 'must', 'be', 'acknowledgment', 'shall', 'be'], 'maxWidth': 16}\nExpected Output:  [\"What   must   be\", \"acknowledgment  \", \"shall be        \"]\nActual Output:  [[\"What\", \"What\", \"What\", \"What\"], [\"must\", \"must\", \"must\", \"must\"], [\"be\", \"be\", \"be\", \"be\", \"be\", \"be\", \"be\", \"be\"], \"a c k n o w l e d g m e n t\", [\"shall\", \"shall\", \"shall\"], [\"be\", \"be\", \"be\", \"be\", \"be\", \"be\", \"be\", \"be\"]]\n1 Test Failed!\n",
      "time": "0.051",
      "memory": 4912,
      "stderr": null,
      "token": "d90f52ae-2925-40d5-9fc1-63d42e138758",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 4,
        "description": "Wrong Answer"
      }
    }
  },
  {
    "status": "success",
    "question_id": 332,
    "title": "reconstruct-itinerary",
    "token": "f22c0199-95df-4376-ad3b-4159f375c4d7",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport collections\nimport random\nimport ast\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\n        self.graph = {}\n        for src, dst in tickets:\n            self.graph[src] = self.graph.get(src, []) + [dst]\n        \n        self.res = []\n        self.dfs(\"JFK\")\n        return self.res[::-1]\n    \n    def dfs(self, src):\n        #\u00a0destinations = self.graph.get(src, [])\n        while self.graph.get(src, []):\n            dst = self.graph[src].pop(-1)\n            self.dfs(dst)\n        self.res.append(src)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        airports = ['JFK', 'SFO', 'ATL', 'LHR', 'MUC', 'SJC', 'LGB']\n        tickets = [['JFK', random.choice(airports[1:])]]\n        for _ in range(random.randint(1, 10)):\n            from_airport = random.choice(airports)\n            to_airport = random.choice([airport for airport in airports if airport != from_airport])\n            tickets.append([from_airport, to_airport])\n        return {'tickets': tickets}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['tickets'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        input_list = ast.literal_eval(input_str)\n        return {'tickets': input_list}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.findItinerary(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "0.054",
      "memory": 5124,
      "stderr": null,
      "token": "f22c0199-95df-4376-ad3b-4159f375c4d7",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "success",
    "question_id": 446,
    "title": "arithmetic-slices-ii-subsequence",
    "token": "41cbaa0d-60d8-407f-abbf-47c623207a98",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom collections import defaultdict\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\n        N = len(nums)\n        if N<=2:\n            return 0\n        dp = defaultdict(int)\n        ans = 0\n        for n in range(2,N):\n            v2 = nums[n]\n            for j in range(0,n):\n                v1 = nums[j]\n                dis = v2-v1\n                ans1 = dp[(j,dis)]\n                ans += ans1\n                dp[(n,dis)]+= (ans1+1)\n        return ans\n\nclass TestCaseGenerator:\n\n    def generate(self) -> Dict[str, List[int]]:\n        length = random.randint(3, 10)\n        nums = [random.randint(-100, 100) for _ in range(length)]\n        return {'nums': nums}\n\n    def encode_input(self, input_obj: Dict[str, List[int]]) -> str:\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj: int) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str: str) -> Dict[str, List[int]]:\n        nums = eval(input_str)\n        return {'nums': nums}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.numberOfArithmeticSlices(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": null,
      "time": "0.05",
      "memory": 4684,
      "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 65, in <module>\n    class TestCaseGenerator:\n  File \"script.py\", line 67, in TestCaseGenerator\n    def generate(self) -> Dict[str, List[int]]:\nNameError: name 'Dict' is not defined\n",
      "token": "41cbaa0d-60d8-407f-abbf-47c623207a98",
      "compile_output": null,
      "message": "Exited with error status 1",
      "status": {
        "id": 11,
        "description": "Runtime Error (NZEC)"
      }
    }
  },
  {
    "status": "success",
    "question_id": 689,
    "title": "maximum-sum-of-3-non-overlapping-subarrays",
    "token": "14627acd-66d9-4d30-bf75-3494de5de1c3",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\nimport json\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def maxSumOfThreeSubarrays(self, nums: List[int], k: int) -> List[int]:\n        sums = []\n        n = len(nums)\n        for i in range(n-k+1):\n            sums.append(sum(nums[i:i+k]))\n        best = 0\n        left = [0]*(n-k+1)\n        for i in range(n-k+1):\n            if sums[i] > sums[best]:\n                best = i\n            left[i] = best\n        \n        best = n-k\n        right = [0]*(n-k+1)\n        for i in range(n-k, -1, -1):\n            if sums[i] >= sums[best]:\n                best = i\n            right[i] = best\n\n        result = []\n        max_sum = 0\n        for mid in range(k, n-2*k+1):\n            l, r = left[mid-k], right[mid+k]\n            cur_sum = sums[l] + sums[r] + sums[mid]\n            if cur_sum > max_sum:\n                max_sum = cur_sum\n                result = [l, mid, r]\n        return result\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(3, 30)\n        k = random.randint(1, n // 3)\n        nums = [random.randint(1, 100) for _ in range(n)]\n        return {'nums': nums, 'k': k}\n\n    def encode_input(self, input_obj) -> str:\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return json.dumps(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return json.loads(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.maxSumOfThreeSubarrays(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "0.059",
      "memory": 4784,
      "stderr": null,
      "token": "14627acd-66d9-4d30-bf75-3494de5de1c3",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "success",
    "question_id": 953,
    "title": "reverse-only-letters",
    "token": "f1a484fe-86cf-4c36-a205-30821910880e",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport string\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def reverseOnlyLetters(self, s: str) -> str:\n        s_list = list(s)\n        for i in range(len(s_list)):\n            if not s_list[i].isalpha():\n                continue\n            start = i\n            end = i + 1\n            while (start < len(s_list) and not s_list[start].isalpha()):\n                start += 1\n            while (end < len(s_list) and not s_list[end].isalpha()):\n                end += 1\n            s_list[start:end] = s_list[start:end][::-1]\n        return \"\".join(s_list)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random, string\n        letters = ''.join(random.choices(string.ascii_letters, k=random.randint(1, 50)))\n        non_letters = ''.join(random.choices('!@#$%^&*()-_1234567890:=', k=50 - len(letters)))\n        string_list = list(letters + non_letters)\n        random.shuffle(string_list)\n        generated_string = ''.join(string_list)\n        return {'s': generated_string}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['s']\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.reverseOnlyLetters(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Input {'s': 'I1HEZTB-uRyVw28MM)3^4^@PvRczc$$18bvDs911SlT%wSXA(K'}\nExpected Output:  K1AXSwT-lSsDv28bc)3^4^@zcRvPM$$18MwVy911RuB%TZEH(I\nActual Output:  1IHEZT-BuRyV82wM@^4^3)MPvRcz81$$cbvD119sSl%TwSX(AK\n1 Test Failed!\n",
      "time": "0.059",
      "memory": 4764,
      "stderr": null,
      "token": "f1a484fe-86cf-4c36-a205-30821910880e",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 4,
        "description": "Wrong Answer"
      }
    }
  },
  {
    "status": "success",
    "question_id": 956,
    "title": "number-of-music-playlists",
    "token": "15d7fed6-4490-4578-81a0-74d37b599265",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def numMusicPlaylists(self, n: int, goal: int, k: int) -> int:\n        MOD = 1_000_000_007\n        dp = [[0 for _ in range(n + 1)] for _ in range(goal + 1)]\n\n        def number_of_playlists(i, j):\n            # Base cases\n            if i == 0 and j == 0:\n                return 1\n            if i == 0 or j == 0:\n                return 0\n            if dp[i][j]!= -1:\n                return dp[i][j]\n            # DP transition: add a new song or replay an old one\n            dp[i][j] = (number_of_playlists(i - 1, j - 1) * (n - j + 1)) % MOD\n            if j > k:\n                dp[i][j] += (number_of_playlists(i - 1, j) * (j - k)) % MOD\n                dp[i][j] %= MOD\n            return dp[i][j]\n\n        return number_of_playlists(goal, n)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 10)\n        goal = random.randint(n, n + 10)\n        k = random.randint(0, n - 1)\n        return {'n': n, 'goal': goal, 'k': k}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['n']} {input_obj['goal']} {input_obj['k']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        values = list(map(int, input_str.split()))\n        return {'n': values[0], 'goal': values[1], 'k': values[2]}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.numMusicPlaylists(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Input {'n': 1, 'goal': 7, 'k': 0}\nExpected Output:  1\nActual Output:  0\n1 Test Failed!\n",
      "time": "0.062",
      "memory": 4796,
      "stderr": null,
      "token": "15d7fed6-4490-4578-81a0-74d37b599265",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 4,
        "description": "Wrong Answer"
      }
    }
  },
  {
    "status": "failure",
    "question_id": 517,
    "title": "super-washing-machines",
    "token": null,
    "error": "No test case decoder found",
    "code": null
  },
  {
    "status": "success",
    "question_id": 923,
    "title": "super-egg-drop",
    "token": "8fad0b0c-9b23-412f-b0db-e8c236b1c0c0",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom functools import cache\nfrom random import randint\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    @cache\n    def superEggDrop(self, k: int, n: int) -> int:\n        \n        # base condition\n\n        if n==0:\n            return 0\n        if n==1:\n            return 1\n        if k==1:\n            return n\n        ans = float('inf')\n        s, e = 1, n\n        while (s <= e):\n            x = (s+e)//2\n            if self.superEggDrop(k-1, x-1) >= self.superEggDrop(k, n-x):\n                ans = min(ans,self.superEggDrop(k-1, x-1) )\n                e = x-1\n            else:\n                ans = min(ans,self.superEggDrop(k, n-x) )\n                s = x+1\n        # for x in range(1, n+1):\n        #     ans  = min(ans, max(self.superEggDrop(k-1, x-1), self.superEggDrop(k, n-x)))\n        return ans +1\n\nclass Solution:\n    def superEggDrop(self, k: int, n: int) -> int:\n        # base condition\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        if k == 1:\n            return n\n        # cache\n        self.cache = {}\n        # dp table\n        dp = [[0 for i in range(n + 1)] for j in range(k + 1)]\n        # base case\n        dp[0][0] = 0\n        for i in range(1, n + 1):\n            dp[0][i] = dp[0][i - 1] + 1\n        for j in range(1, k + 1):\n            dp[j][0] = dp[j - 1][0] + 1\n        # for x in range(1, n+1):\n        #     ans  = min(ans, max(self.superEggDrop(k-1, x-1), self.superEggDrop(k, n-x)))\n        for i in range(1, n + 1):\n            for j in range(1, k + 1):\n                dp[j][i] = dp[j - 1][i] + dp[j][\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        from random import randint\n        k = randint(1, 10)\n        n = randint(1, 100)\n        return {'k': k, 'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{{'k': {input_obj['k']}, 'n': {input_obj['n']}}}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        input_obj = eval(input_str)\n        return input_obj\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.superEggDrop(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": null,
      "time": "0.025",
      "memory": 3360,
      "stderr": "  File \"script.py\", line 99\n    class TestCaseGenerator:\n    ^\nSyntaxError: invalid syntax\n",
      "token": "8fad0b0c-9b23-412f-b0db-e8c236b1c0c0",
      "compile_output": null,
      "message": "Exited with error status 1",
      "status": {
        "id": 11,
        "description": "Runtime Error (NZEC)"
      }
    }
  },
  {
    "status": "failure",
    "question_id": 924,
    "title": "fair-candy-swap",
    "token": null,
    "error": "No test case decoder found",
    "code": null
  },
  {
    "status": "success",
    "question_id": 632,
    "title": "smallest-range-covering-elements-from-k-lists",
    "token": "23c48f35-36ff-4898-bc25-0ad2e278b1c1",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom collections import defaultdict\nimport heapq\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def smallestRange(self, nums: List[List[int]]) -> List[int]:\n        all_nums = []\n        for i, lst in enumerate(nums):\n            for n in lst:\n                all_nums.append((n, i))\n        all_nums.sort()\n        output = [float(\"-inf\"), float(\"inf\")]\n        included = {}\n        l, r = 0, 0\n        last_used_l = -1\n        while r < len(all_nums):\n            if all_nums[r][1] not in included:\n                included[all_nums[r][1]] = deque()\n            included[all_nums[r][1]].append(all_nums[r][0])\n            while len(included) == len(nums) and len(included[all_nums[l][1]]) > 1:\n                included[all_nums[l][1]].popleft()\n                l += 1\n            if len(included) == len(nums) and l!= last_used_l:\n                min_num = float(\"inf\")\n                max_num = float(\"-inf\")\n                for q in included.values():\n                    min_num = min(q[0], min_num)\n                    max_num = max(q[-1], max_num)\n                if max_num - min_num < output[1] - output[0]:\n                    output = [min_num, max_num]\n                last_used_l = l\n            r += 1\n        return output\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        k = random.randint(1, 10)\n        nums = []\n        for _ in range(k):\n            size_of_list = random.randint(1, 10)\n            start_value = random.randint(-100, 100)\n            num_list = sorted((random.randint(start_value, start_value + 20) for _ in range(size_of_list)))\n            nums.append(num_list)\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'nums': eval(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.smallestRange(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "0.058",
      "memory": 4964,
      "stderr": null,
      "token": "23c48f35-36ff-4898-bc25-0ad2e278b1c1",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "success",
    "question_id": 637,
    "title": "average-of-levels-in-binary-tree",
    "token": "cae81034-9c48-4ea9-8686-660eb404a884",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom collections import deque\nfrom typing import List, Optional\nimport json\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nfrom collections import deque\nclass Solution:\n    def averageOfLevels(self, root: Optional[TreeNode]) -> List[float]:\n        levelsAverageList = []\n        if root!= None:\n            queue = deque()\n            queue.append(root)\n            while queue:\n                size = len(queue)\n                levels = []\n                for start in range(size):\n                    treeNode = queue.popleft()\n                    levels.append(float(treeNode.val))\n                    if treeNode.left!= None:\n                        queue.append(treeNode.left)\n                    if treeNode.right!= None:\n                        queue.append(treeNode.right)\n                levelsAverageList.append(float(sum(levels)/len(levels)))\n        return levelsAverageList\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        \"\"\"Generates a sample tree for testing purposes.\"\"\"\n        root = TreeNode(3)\n        root.left = TreeNode(9)\n        root.right = TreeNode(20, TreeNode(15), TreeNode(7))\n        return {'root': root}\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\"Encodes a tree structure into a JSON-compatible string.\"\"\"\n\n        def serialize(root):\n            values = []\n            queue = [root]\n            while queue:\n                node = queue.pop(0)\n                if node:\n                    values.append(node.val)\n                    queue.append(node.left)\n                    queue.append(node.right)\n                else:\n                    values.append(None)\n            return json.dumps(values)\n        return serialize(input_obj['root'])\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\"Converts the result into a JSON string.\"\"\"\n        return json.dumps(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\"Decodes a JSON string back into a tree structure.\"\"\"\n\n        def deserialize(data):\n            data = json.loads(data)\n            if not data or data[0] is None:\n                return None\n            root = TreeNode(data[0])\n            queue = [root]\n            i = 1\n            while queue and i < len(data):\n                node = queue.pop(0)\n                if data[i] is not None:\n                    node.left = TreeNode(data[i])\n                    queue.append(node.left)\n                i += 1\n                if i < len(data) and data[i] is not None:\n                    node.right = TreeNode(data[i])\n                    queue.append(node.right)\n                i += 1\n            return root\n        return {'root': deserialize(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.averageOfLevels(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "0.056",
      "memory": 4696,
      "stderr": null,
      "token": "cae81034-9c48-4ea9-8686-660eb404a884",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "success",
    "question_id": 979,
    "title": "di-string-match",
    "token": "64f43bfa-44f3-4755-b368-8d43836f0ec8",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\nimport ast\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def diStringMatch(self, s: str) -> List[int]:\n        greater_than = set()\n        less_than = set()\n        for c in s:\n            if c == \"D\":\n                greater_than.add(c)\n            else:\n                less_than.add(c)\n        n = len(s)\n        zero_candidates = [i for i in range(n+1) if i not in less_than]\n        q = list(zero_candidates)\n        assignments = [-1] * (n+1)\n        counter = 0\n        while q:\n            curr = q.pop()\n            assignments[curr] = counter\n            counter += 1\n            if curr not in greater_than:\n                continue\n            for bigger in greater_than:\n                less_than.remove(bigger)\n                if len(less_than) == 0:\n                    q.append(bigger)\n        return assignments\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(1, 20)\n        s = ''.join((random.choice(['I', 'D']) for _ in range(length)))\n        return {'s': s}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{{'s': '{input_obj['s']}'}}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return ast.literal_eval(input_str)\n\n    def decode_output(self, output_str) -> list:\n        return eval(output_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.diStringMatch(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Input {'s': 'DIDDDIIIDDIIDDDDI'}\nExpected Output:  [1, 0, 5, 4, 3, 2, 6, 7, 10, 9, 8, 11, 16, 15, 14, 13, 12, 17]\nActual Output:  [17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]\n1 Test Failed!\n",
      "time": "0.059",
      "memory": 5124,
      "stderr": null,
      "token": "64f43bfa-44f3-4755-b368-8d43836f0ec8",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 4,
        "description": "Wrong Answer"
      }
    }
  },
  {
    "status": "success",
    "question_id": 981,
    "title": "delete-columns-to-make-sorted",
    "token": "1eb9ca6c-fa73-4ecd-b078-865900f547a9",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def minDeletionSize(self, strs: List[str]) -> int:\n        return len([s for s in strs[0] if s < max(s for s in strs[1:])])\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 100)\n        m = random.randint(1, 1000)\n        strs = [''.join(random.choices('abcdefghijklmnopqrstuvwxyz', k=m)) for _ in range(n)]\n        return {'strs': strs}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.minDeletionSize(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Input {'strs': ['fmxgjtuljvtxxvhhjwtarlpalwsbvdqkfdxwyxavckwbxkswsvlkbknrqltyctaidcitdsvftmcbjrmzlfrblshrcglyazrkbzzgcmemuphuiuncxvycliilxbaxqyczkhipvywlzlylmgiqhmhglipsayvehefcxbazygksuoyhcizibfowytfjcaeizrhgkfhkwlgkugtawdxnrmkwquxpoawkysszeytfzjafcbfgjauxphtwxhfwmlkvackxbbcfkwcbecglralzzppxhbhnydcysjzlzaqetfqagndjckhetwuzoihghotqxivgilysxpgsgabfhssbctmfksaqiqnkrjrwjdcofoyaksgiknmxzgtcrghvgxhsuzdkbfatbdrfnjbtwygkytkpawqcjcmxgfzqaaotnetqwghodegguxtfbnojwrcwtjcvskufivjozundmakuftayopipixdxatsmoclcdajpkwdycljxqmvgsnrpztvrouakjytve', 'cnbnwhgsqeuwqagievayypxelxnzoyigfwglvivfghgzjcxqcacfcnyczxsexalbudpqfypbdbiebsyjhglktmubqjrygshdtattncaqpdsvnworwlzbaeeisnaaamnawjbvaslyautfvgyqplyhyrfmsmavvaqqbqwaejgxsibtosoihakephxjrtlphrpsorbgdecrkwwvcstflvdozgsohodcgrmtmrinjvihsflikyjtmhugktamgiqhlfdjaqundexbzufoxcwehmdaacivawxmfagzwpehtpihbtnyyubvzjykfbnskektqhxjhmntxrmuupmmeqlnzjuwawxseshrrcysbmwauwetonucbgzresvkhasdewrjvftnpwqegzqmnsirebvsmfvdvgjnijzbbitdmqtzcmctofxnkquyxzqddskxhtyjeminvkgtoqiycmacctwqgrltqtuqhsfvhzfmvhjchcglwbmuiweuvxukuqgmkaropljwgozri', 'zdgsbruvbtpbullvygsexmiwynhiyevhhzamiigryqggrnvcsaovkweiwvgegqmrqsdrjjqotuccazkrdhcwboaseerellqwiejmswcsuyusibvlagxlamebbqijzfdsdptgzppyofdqzemxnxrefumvxqsdjzcqpwmxsykkqhtpwszrxakeulvxfqmevoedggjskrdhphsghpzkppsobcwfjkmbijdjdqpqelqswyibnjzfcpinrinrsqctumswbuixnbyznqmwrevyxjjpdjzdxofpmtrjzpqjerafvfrmseuzqbwslbagrhveslyhtgengkopofckmedtyfohgnhunupvcwlhizecperublryexmbjgiavjeoobiococgjwtufecmlvobzikywnrwxrzqfzclwmynygbnkyklflbgebrsxvjhfjgwtkjthrejfhcxheegdqkcykkhzlsjmhpwpttoqfssfpetkaudhewseartomctotpxrsqymiufgyeby', 'zggpzipnbwdvmvflrhsskthgjeaiehflrqlrlgewvhfbaguhlhiceocknqllxuvawjdkaaxxcegtmedlunxjqhxbjjiiupgvsmzqzbnnuxnqmpljveblmfzmtrbvtvlflitsswccaxoiturzsdzpowblnjpbbykqzcxfjewvvlvkzxmgfmpfzgqnemncumtguagizipmbafutockolyuotgngkpkooeihbhfhujjaqpyxtflkdwaotrfxcljgdyrforjrowiglnbtgbxkfyofoxrdpmshfldkedeyemdztrltqgrfihtpbfkrdeynswbvjzbrmyufvbjgvlmgndchrtljtcvuqevkqrssgprxwsrmpvnljdwfcjojjhraucrjrbfuxqwpnofvmgeijqodhuoyjcxtnjelxgbdwnpxoazeldzytnzrphxgarjuytdukhctgxmrywvtkydrdwmiesakbmfrobcdwvdexehkolruzqdjkpmiwjeievrsxanqzxzn', 'ardkmfobfuephcwoolxumbbibngmwtipmivwhqkevlhutrnsavxtrbyorlygrijtqsembvprxbijtblwmvrsxwsmztwaqyjlpqqwpkitatofhorbkqgnlgxoblximtwhxuufeunltaqoqxbcybabtrcyruohhyggikxtzdartbuuxeutfitvgaeapjrqqdxkrttedervvzzeyyzjxmwvmatteokdmpkhxebdzjunnlofioggzdrikbawgwuanuiljttvyffvanxaxaztxtpxmngwhnzfnnjtimaqoylupfohyseodsontnwgabuaxkvnryeqvcjkswvvdgksxaomaxfvxvgkajwopddjebpdxkynoptgdmtkhpbnfytyzeadbjipknzzryrbqquzccvxhivvxvlrdbiisdveycsxobxzxeeeycfqckhvfmfxqxdvrmybcwtucgvkgoufvlatrtwdorcdvilbvagqsyfeqooltnpgxwitcglkjtinrriubnavh']}\nExpected Output:  511\nActual Output:  517\n2 Test Failed!\n",
      "time": "0.069",
      "memory": 11840,
      "stderr": null,
      "token": "1eb9ca6c-fa73-4ecd-b078-865900f547a9",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 4,
        "description": "Wrong Answer"
      }
    }
  },
  {
    "status": "success",
    "question_id": 927,
    "title": "sum-of-subsequence-widths",
    "token": "700c5981-4da3-4e2e-97a8-c4f3ef18575a",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def sumSubseqWidths(self, nums: List[int]) -> int:\n        nums = sorted(nums)\n        n = len(nums)\n        mod = 10**9 + 7\n        total = 0\n        forward = 1\n        backward = 1\n        for i in range(n):\n            forward *= 2\n            backward *= 2\n            total += forward * nums[i]\n            total %= mod\n            total += backward * nums[i]\n            total %= mod\n        return total\n\nclass TestCaseGenerator:\n\n    def __init__(self):\n        self.random = random\n\n    def generate(self) -> dict:\n        \"\"\" Generate a random test case within reasonable constraints. \"\"\"\n        length = self.random.randint(1, 10)\n        nums = [self.random.randint(1, 100) for _ in range(length)]\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\" Convert the dict input into a JSON-like string format. \"\"\"\n        return str(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\" The output is an integer so we convert it to a string directly. \"\"\"\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\" Convert the input string back to a dictionary object. \"\"\"\n        return eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.sumSubseqWidths(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Input {'nums': [16, 43, 39, 87, 98, 2, 10]}\nExpected Output:  8682\nActual Output:  40568\n1 Test Failed!\n",
      "time": "0.054",
      "memory": 4768,
      "stderr": null,
      "token": "700c5981-4da3-4e2e-97a8-c4f3ef18575a",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 4,
        "description": "Wrong Answer"
      }
    }
  },
  {
    "status": "success",
    "question_id": 928,
    "title": "surface-area-of-3d-shapes",
    "token": "0db99290-e28e-4276-924b-1276d8d931ee",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport ast\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def surfaceArea(self, grid) -> int :\n        length = len(grid)\n\n        def behind(point) :\n                array = []\n                i, j = point\n                # top :       \n                if length > i > 0 : array.append(min((grid[i-1][j],grid[i][j])))\n                # left :\n                if j < length-1 : array.append(min((grid[i][j+1], grid[i][j])))\n                # bottom :\n                if i < length-1 : array.append(min((grid[i+1][j], grid[i][j])))\n                # right :\n                if length > j > 0 : array.append(min((grid[i][j-1],grid[i][j])))\n\n                return array\n        \n        def tower_surface(height) : return height*6-(height-1)*2 if height > 0 else 0\n\n        surface = 0\n        \n        for i in range(length) :\n                for j in range(length) :\n                        surface += tower_surface(grid[i][j]) - sum(behind((i,j)))\n\n        return surface\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 5)\n        grid = [[random.randint(0, 5) for _ in range(n)] for _ in range(n)]\n        return {'grid': grid}\n\n    def encode_input(self, input_obj) -> str:\n        grid_str = '['\n        for row in input_obj['grid']:\n            grid_str += '[' + ','.join(map(str, row)) + '],'\n        grid_str = grid_str[:-1] + ']'\n        return f'grid = {grid_str}'\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        grid_str = input_str.split('=')[1].strip()\n        grid = ast.literal_eval(grid_str)\n        return {'grid': grid}\n\n    def decode_output(self, output_str) -> int:\n        return int(output_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.surfaceArea(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "0.054",
      "memory": 5188,
      "stderr": null,
      "token": "0db99290-e28e-4276-924b-1276d8d931ee",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "failure",
    "question_id": 933,
    "title": "increasing-order-search-tree",
    "token": null,
    "error": "No test case decoder found",
    "code": null
  },
  {
    "status": "success",
    "question_id": 488,
    "title": "zuma-game",
    "token": "d4b057b4-682e-4351-996f-74bb8eb155e7",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom functools import cache\nfrom itertools import groupby\nimport random\nfrom math import inf\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    @cache\n    def compress(self, s):\n        stack = []\n        for c in s:\n            if stack and stack[-1][0]!= c and stack[-1][1] >= 3:\n                stack.pop()\n            if not stack or stack[-1][0]!= c:\n                stack.append([c, 1])\n            else:\n                stack[-1][1] += 1\n        if stack and stack[-1][1] >= 3:\n            stack.pop()\n        return ''.join(a*b for a, b in stack)\n\n    def findMinStep(self, board: str, hand: str) -> int:\n        n = len(hand)\n        hand = ''.join(sorted(hand))\n        @cache\n        def solve(board, hand):\n            board = self.compress(board)\n            if board == '': return n - len(hand)\n            if hand == '': return 1e9\n\n            ans = 1e9\n            for i in range(len(hand)):\n                if i > 0 and hand[i] == hand[i-1]: continue\n    \n                for j in range(len(board)):\n                    if board[j] == hand[i] or j > 0 and board[j] == board[j-1] and board[j]!= hand[i]:\n                        ans = min(ans, solve(board[0:j] + hand[i] + board[j:], hand[0:i] + hand[i+1:]))\n            return ans\n        \n        res = solve(board, hand)\n        if res == 1e9: return -1\n        else: return res\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        colors = ['R', 'Y', 'B', 'G', 'W']\n        board_length = random.randint(1, 16)\n        hand_length = random.randint(1, 5)\n        board = ''.join((random.choice(colors) for _ in range(board_length)))\n        hand = ''.join((random.choice(colors) for _ in range(hand_length)))\n        return {'board': board, 'hand': hand}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"board={input_obj['board']},hand={input_obj['hand']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        parts = input_str.split(',')\n        board_part = parts[0].split('=')[1]\n        hand_part = parts[1].split('=')[1]\n        return {'board': board_part, 'hand': hand_part}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.findMinStep(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": null,
      "time": "0.058",
      "memory": 4656,
      "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 26, in <module>\n    from functools import cache\nImportError: cannot import name 'cache' from 'functools' (/usr/local/python-3.8.1/lib/python3.8/functools.py)\n",
      "token": "d4b057b4-682e-4351-996f-74bb8eb155e7",
      "compile_output": null,
      "message": "Exited with error status 1",
      "status": {
        "id": 11,
        "description": "Runtime Error (NZEC)"
      }
    }
  },
  {
    "status": "success",
    "question_id": 493,
    "title": "reverse-pairs",
    "token": "a673114d-f6c2-458b-9ccf-f4de1f86b598",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nfrom random import randint\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def reversePairs(self, nums: List[int]) -> int:\n        res = 0\n        bit = BIT(len(nums)+1)\n        for x in nums:\n            indx = binary_search(bit.n, 2*x+1)+1\n            res += bit.search(indx)\n            indx = binary_search(bit.n, x)+1\n            bit.update(indx)\n        return res\n\n#### Explanation:\nclass Solution:\n    def reversePairs(self, nums: List[int]) -> int:\n        res = 0\n        bit = BIT(len(nums)+1)\n        for x in nums:\n            indx = binary_search(bit.n, 2*x+1)+1\n            res += bit.search(indx)\n            indx = binary_search(bit.n, x)+1\n            bit.update(indx)\n        return res\n\ndef binary_search(lt, target):\n    l, r = 0, len(lt)\n    while l<r:\n        m = l + ((r-l)>>1)\n        if target<=lt[m]:\n            r = m\n        else:\n            l = m+1\n    return l\n\ndef binary_search_new(lt, target):\n    l, r = 0, len(lt)\n    while l<r:\n        m = l + ((r-l)>>1)\n        if target<=lt[m]:\n            r = m\n        else:\n            l = m+1\n    return l\n\ndef binary_search_new2(lt, target):\n    l, r = 0, len(lt)\n    while l<r:\n        m = l + ((r-l)>>1)\n        if target<=lt[m]:\n            r = m\n        else:\n            l = m+1\n    return l\n\ndef binary_search_new3(lt, target):\n    l, r = 0, len(lt)\n    while l<r:\n        m = l + ((r-l)>>1)\n        if target<=lt[m]:\n            r = m\n        else:\n            l = m+1\n    return l\n\ndef binary_search_new4(lt, target):\n    l, r = 0, len(lt)\n    while l<r:\n        m = l + ((r-l)>>1)\n        if target<=lt[m]:\n            r = m\n        else:\n            l = m+1\n    return l\n\ndef binary_search_new5(lt, target):\n    l\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = randint(1, 100)\n        nums = [randint(-2 ** 31, 2 ** 31 - 1) for _ in range(n)]\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'nums': eval(input_str)}\n\n    def decode_output(self, output_str) -> int:\n        return int(output_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.reversePairs(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": null,
      "time": "0.056",
      "memory": 5068,
      "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 173, in <module>\n    runner.run()\n  File \"script.py\", line 157, in run\n    output = self.solution.reversePairs(**input)\n  File \"script.py\", line 63, in reversePairs\n    bit = BIT(len(nums)+1)\nNameError: name 'BIT' is not defined\n",
      "token": "a673114d-f6c2-458b-9ccf-f4de1f86b598",
      "compile_output": null,
      "message": "Exited with error status 1",
      "status": {
        "id": 11,
        "description": "Runtime Error (NZEC)"
      }
    }
  },
  {
    "status": "success",
    "question_id": 495,
    "title": "teemo-attacking",
    "token": "5b325055-e150-4ce3-bc7a-30c379e84113",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\nfrom ast import literal_eval\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def findPoisonedDuration(self, timeSeries: List[int], duration: int) -> int:\n        n = len(timeSeries)\n        if n == 0:\n            return 0\n        res = 0\n        if duration > 0:\n            for i in range(n - 1):\n                res += min(duration, timeSeries[i + 1] - timeSeries[i])\n        return res + duration\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(1, 20)\n        time_series = sorted(random.sample(range(1, 100), length))\n        duration = random.randint(1, 10)\n        return {'timeSeries': time_series, 'duration': duration}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return literal_eval(input_str)\n\n    def decode_output(self, output_str) -> int:\n        return int(output_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.findPoisonedDuration(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "0.057",
      "memory": 5172,
      "stderr": null,
      "token": "5b325055-e150-4ce3-bc7a-30c379e84113",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "success",
    "question_id": 496,
    "title": "next-greater-element-i",
    "token": "0bbacfee-f18e-4401-943d-1d26c8a7734c",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        stack = []\n        for i in nums1:\n            while stack and i > stack[-1]:\n                stack.pop()\n            if stack:\n                stack.append(i)\n        return [stack.pop() for i in nums2 if i in stack]\n\nclass TestCaseGenerator:\n\n    def __init__(self):\n        pass\n\n    @staticmethod\n    def generate() -> dict:\n        nums2_length = random.randint(2, 10)\n        nums2 = random.sample(range(0, 1000), nums2_length)\n        nums1_length = random.randint(1, nums2_length)\n        nums1 = random.sample(nums2, nums1_length)\n        return {'nums1': nums1, 'nums2': nums2}\n\n    @staticmethod\n    def encode_input(input_obj) -> str:\n        return f\"{input_obj['nums1']}, {input_obj['nums2']}\"\n\n    @staticmethod\n    def encode_output(output_obj) -> str:\n        return f'{output_obj}'\n\n    @staticmethod\n    def decode_input(input_str) -> dict:\n        nums1_str, nums2_str = input_str.split('],')\n        nums1 = list(map(int, nums1_str.strip('[] ').split(',')))\n        nums2 = list(map(int, nums2_str.strip('[] ').strip().split(',')))\n        return {'nums1': nums1, 'nums2': nums2}\n\n    @staticmethod\n    def decode_output(output_str) -> list:\n        return list(map(int, output_str.strip('[] ').split(',')))\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.nextGreaterElement(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Input {'nums1': [998], 'nums2': [974, 438, 25, 998, 410, 364, 378, 543, 668, 738]}\nExpected Output:  [-1]\nActual Output:  []\n1 Test Failed!\n",
      "time": "0.064",
      "memory": 4800,
      "stderr": null,
      "token": "0bbacfee-f18e-4401-943d-1d26c8a7734c",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 4,
        "description": "Wrong Answer"
      }
    }
  },
  {
    "status": "success",
    "question_id": 830,
    "title": "largest-triangle-area",
    "token": "18afd4ee-5db5-4ac4-994b-ad602f472b3e",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\nimport ast\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\n        res = 0\n        for i in range(len(points) - 2):\n            for j in range(i + 1, len(points) - 1):\n                for k in range(j + 1, len(points)):\n                    u1, v1 = points[i][0] - points[j][0], points[i][1] - points[j][1]\n                    u2, v2 = points[j][0] - points[k][0], points[j][1] - points[k][1]\n                    u3, v3 = points[k][0] - points[i][0], points[k][1] - points[i][1]\n                    area = abs(u1 * v2 - u2 * v1) / 2\n                    res = max(res, area)\n        return res\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        num_points = random.randint(3, 50)\n        points = [[random.randint(-50, 50), random.randint(-50, 50)] for _ in range(num_points)]\n        points = list(map(list, set(map(tuple, points))))\n        return {'points': points}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['points'])\n\n    def encode_output(self, output_obj) -> str:\n        return f'{output_obj:.5f}'\n\n    def decode_input(self, input_str) -> dict:\n        return {'points': ast.literal_eval(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.largestTriangleArea(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "0.161",
      "memory": 5292,
      "stderr": null,
      "token": "18afd4ee-5db5-4ac4-994b-ad602f472b3e",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "success",
    "question_id": 836,
    "title": "race-car",
    "token": "5caadf9b-089a-45e7-96bc-7356e373331f",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom collections import deque\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def racecar(self, target: int) -> int:\n        \"\"\"\n        cache or something\n        \"\"\"\n        cache = {0: 0}\n        q = deque()\n        \n        q.append((0, 1))\n        res = 0\n        while q:\n            for _ in range(len(q)):\n                pos, speed = q.popleft()\n                if (pos, speed) in cache:\n                    continue\n                cache[pos] = res\n                res += 1\n                \n                q.append((pos + speed, speed *2))\n                q.append((pos, -1 if speed > 0 else 1))\n                \n            \n            res += 1\n        \n        return res\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        target = random.randint(1, 10000)\n        return {'target': target}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.racecar(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": null,
      "time": "1.202",
      "memory": 128000,
      "stderr": "run: line 1:     3 Killed                  /usr/local/python-3.8.1/bin/python3 script.py\n",
      "token": "5caadf9b-089a-45e7-96bc-7356e373331f",
      "compile_output": null,
      "message": "Exited with error status 137",
      "status": {
        "id": 11,
        "description": "Runtime Error (NZEC)"
      }
    }
  },
  {
    "status": "success",
    "question_id": 861,
    "title": "flipping-an-image",
    "token": "bd1f0477-fb74-4b20-a7c9-4a87f704b21a",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\n        for i in range(len(image)):\n            image[i] = (image[i][::-1])\n        for j in range(0, len(image)):\n            for k in range(0, len(image[j])):\n                if image[j][k] == 0:\n                    image[j][k] = 1 \n                else:\n                    image[j][k] = 0\n        return image\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 5)\n        image = [[random.choice([0, 1]) for _ in range(n)] for _ in range(n)]\n        return {'image': image}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['image'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'image': eval(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.flipAndInvertImage(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "0.059",
      "memory": 4900,
      "stderr": null,
      "token": "bd1f0477-fb74-4b20-a7c9-4a87f704b21a",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "success",
    "question_id": 741,
    "title": "cherry-pickup",
    "token": "595510a7-3716-4a32-9e67-d5bd2efd9799",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\nimport json\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def cherryPickup(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        dp[0][0] = grid[0][0]\n\n        for k in range(1, n + 1):\n            for x1 in range(max(0, k - (n - 1)), min(n, k + 1)):\n                for x2 in range(max(0, k - (n - 1)), min(n, k + 1)):\n                    y1, y2 = k - x1, k - x2\n                    if grid[x1][y1] == -1 or grid[x2][y2] == -1:\n                        continue\n\n                    best = -float('inf')\n                    for d1 in [0, 1]:\n                        for d2 in [0, 1]:\n                            px1, px2 = x1 - d1, x2 - d2\n                            if px1 >= 0 and px2 >= 0:\n                                best = max(best, dp[k-1][px1][px2])\n\n                    if best == -float('inf'):\n                        continue\n\n                    dp[k][x1][x2] = best + grid[x1][y1]\n                    if x1!= x2:\n                        dp[k][x1][x2] += grid[x2][y2]\n\n        return max(0, dp[n][n-1][n-1])\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 6)\n        grid = [[random.choice([0, 1, -1]) for _ in range(n)] for _ in range(n)]\n        grid[0][0] = random.choice([0, 1])\n        grid[n - 1][n - 1] = random.choice([0, 1])\n        for i in range(n):\n            grid[i][0] = random.choice([0, 1])\n        for j in range(n):\n            grid[n - 1][j] = random.choice([0, 1])\n        return {'grid': grid}\n\n    def encode_input(self, input_obj) -> str:\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return json.loads(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.cherryPickup(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": null,
      "time": "0.044",
      "memory": 4820,
      "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 130, in <module>\n    runner.run()\n  File \"script.py\", line 114, in run\n    output = self.solution.cherryPickup(**input)\n  File \"script.py\", line 67, in cherryPickup\n    best = max(best, dp[k-1][px1][px2])\nTypeError: 'int' object is not subscriptable\n",
      "token": "595510a7-3716-4a32-9e67-d5bd2efd9799",
      "compile_output": null,
      "message": "Exited with error status 1",
      "status": {
        "id": 11,
        "description": "Runtime Error (NZEC)"
      }
    }
  },
  {
    "status": "success",
    "question_id": 750,
    "title": "contain-virus",
    "token": "73c09c43-e1dc-4442-8016-40153f2c84f0",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def containVirus(self, mat: List[List[int]]) -> int:\n        m, n = len(mat), len(mat[0])\n        DIRECTIONS = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        \n        def dfs(i, j, visited):\n            if not (0 <= i < m and 0 <= j < n) or (i, j) in visited:\n                return set(), 0\n            if mat[i][j] == 2:\n                return set(), 0\n            elif mat[i][j] == 0:\n                return {(i, j)}, 1\n            \n            visited.add((i, j))\n            infected, walls = set(), 0\n            for dx, dy in DIRECTIONS:\n                ni, nj = i + dx, j + dy\n                next_infected, next_walls = dfs(ni, nj, visited)\n                infected |= next_infected\n                walls += next_walls\n            return infected, walls\n        \n        def quarantine(i, j):\n            if 0 <= i < m and 0 <= j < n and mat[i][j] == 1:\n                mat[i][j] = 2\n                for dx, dy in DIRECTIONS:\n                    quarantine(i + dx, j + dy)\n        \n        ans = 0\n        while True:\n            visited, regions = set(), []\n            for i in range(m):\n                for j in range(n):\n                    if mat[i][j] == 1 and (i, j) not in visited:\n                        infected, walls = dfs(i, j, visited)\n                        if infected:\n                            regions.append((infected, walls, (i, j)))\n            \n            if not regions:\n                break\n            \n            regions.sort(key=lambda x: (-len(x[0]), x[1]))\n            max_infected, max_walls, start = regions[0]\n            ans += max_walls\n            quarantine(*start)\n            \n            for region in regions[1:]:\n                for i, j in region[0]:\n                    mat[i][j] = 1\n        \n        return ans\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        m = random.randint(1, 50)\n        n = random.randint(1, 50)\n        isInfected = [[random.choice([0, 1]) for _ in range(n)] for _ in range(m)]\n        return {'isInfected': isInfected}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.containVirus(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": null,
      "time": "0.05",
      "memory": 5456,
      "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 147, in <module>\n    runner.run()\n  File \"script.py\", line 131, in run\n    output = self.solution.containVirus(**input)\nTypeError: containVirus() got an unexpected keyword argument 'isInfected'\n",
      "token": "73c09c43-e1dc-4442-8016-40153f2c84f0",
      "compile_output": null,
      "message": "Exited with error status 1",
      "status": {
        "id": 11,
        "description": "Runtime Error (NZEC)"
      }
    }
  },
  {
    "status": "success",
    "question_id": 699,
    "title": "falling-squares",
    "token": "15b881be-3426-45c1-b9e2-e15e4101efc7",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom bisect import bisect_right, bisect_left\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Node:\n    def __init__(self, l, r):\n        self.l = l\n        self.r = r\n        self.v = 0\n        self.add = 0\n        self.left = None\n        self.right = None\n\nclass SegmentTree:\n    def __init__(self):\n        self.root = Node(1, int(1e9))\n\n    def modify(self, l, r, v, node=None):\n        if node is None:\n            node = self.root\n        if l > r:\n            return\n        if node.l >= l and node.r <= r:\n            node.v = v\n            node.add = v\n            return\n        self.pushdown(node)\n        if l <= node.mid:\n            self.modify(l, r, v, node.left)\n        if r > node.mid:\n            self.modify(l, r, v, node.right)\n        self.pushup(node)\n\n    def query(self, l, r, node=None):\n        if node is None:\n            node = self.root\n        if l > r:\n            return 0\n        if node.l >= l and node.r <= r:\n            return node.v\n        self.pushdown(node)\n        v = 0\n        if l <= node.mid:\n            v = max(v, self.query(l, r, node.left))\n        if r > node.mid:\n            v = max(v, self.query(l, r, node.right))\n        return v\n\n    def pushup(self, node):\n        if node.left and node.right:\n            node.v = max(node.left.v, node.right.v)\n\n    def pushdown(self, node):\n        if node.left is None:\n            node.left = Node(node.l, node.mid)\n        if node.right is None:\n            node.right = Node(node.mid + 1, node.r)\n        if node.add!= 0:\n            node.left.add = node.add\n            node.right.add = node.add\n            node.left.v = node.add\n            node.right.v = node.add\n            node.add = 0\n\nclass Solution:\n    def fallingSquares(self, positions):\n        ans = []\n        tree = SegmentTree()\n        mx = 0\n        for pos in positions:\n            l, w = pos\n            r = l + w - 1\n            h = tree.query(l, r) + w\n            mx = max(mx, h)\n            ans.append(mx)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 10)\n        positions = [[random.randint(1, 100), random.randint(1, 10)] for _ in range(n)]\n        return {'positions': positions}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['positions'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'positions': eval(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.fallingSquares(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": null,
      "time": "0.058",
      "memory": 7844,
      "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 166, in <module>\n    runner.run()\n  File \"script.py\", line 150, in run\n    output = self.solution.fallingSquares(**input)\n  File \"script.py\", line 116, in fallingSquares\n    h = tree.query(l, r) + w\n  File \"script.py\", line 84, in query\n    self.pushdown(node)\n  File \"script.py\", line 98, in pushdown\n    node.left = Node(node.l, node.mid)\nAttributeError: 'Node' object has no attribute 'mid'\n",
      "token": "15b881be-3426-45c1-b9e2-e15e4101efc7",
      "compile_output": null,
      "message": "Exited with error status 1",
      "status": {
        "id": 11,
        "description": "Runtime Error (NZEC)"
      }
    }
  },
  {
    "status": "success",
    "question_id": 779,
    "title": "max-chunks-to-make-sorted-ii",
    "token": "4b6eabcd-ceec-4d85-b197-001a6311f692",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\nimport json\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nfrom bisect import insort\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        st=sorted(arr)\n        ans=0\n        for n in arr:\n            insort(st,n)\n            if st==st[:len(st)]:\n                ans += 1\n        return ans\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(1, 10)\n        arr = [random.randint(0, 100) for _ in range(length)]\n        return {'arr': arr}\n\n    def encode_input(self, input_obj) -> str:\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return json.loads(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.maxChunksToSorted(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Input {'arr': [58, 9]}\nExpected Output:  1\nActual Output:  2\n1 Test Failed!\n",
      "time": "0.056",
      "memory": 5808,
      "stderr": null,
      "token": "4b6eabcd-ceec-4d85-b197-001a6311f692",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 4,
        "description": "Wrong Answer"
      }
    }
  },
  {
    "status": "success",
    "question_id": 759,
    "title": "set-intersection-size-at-least-two",
    "token": "fac7ec79-34d2-4011-acde-b88fb9699af3",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List, Dict\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def intersectionSizeTwo(self, intervals: List[List[int]]) -> int:\n        intervals.sort(key=lambda x:x[1])\n        return len([i for i in intervals if i[0] <= intervals[0][1] and i[1] >= intervals[0][0]])\n\nclass TestCaseGenerator:\n\n    def generate(self) -> Dict[str, List[List[int]]]:\n        return {'intervals': [[1, 3], [3, 7], [8, 9]]}\n\n    def encode_input(self, input_obj: Dict[str, List[List[int]]]) -> str:\n        return str(input_obj['intervals'])\n\n    def encode_output(self, output_obj: int) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str: str) -> Dict[str, List[List[int]]]:\n        return {'intervals': eval(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.intersectionSizeTwo(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Input {'intervals': [[1, 3], [3, 7], [8, 9]]}\nExpected Output:  5\nActual Output:  2\n1 Test Failed!\n",
      "time": "0.042",
      "memory": 4752,
      "stderr": null,
      "token": "fac7ec79-34d2-4011-acde-b88fb9699af3",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 4,
        "description": "Wrong Answer"
      }
    }
  },
  {
    "status": "success",
    "question_id": 854,
    "title": "making-a-large-island",
    "token": "4e09d018-c507-4058-8182-b6b2bb75e826",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List, Dict, Any\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def largestIsland(self, grid: List[List[int]]) -> int:\n        def getArea(grid, row, col):\n            if (row, col) not in visited:\n                visited.add((row, col))\n                return 1\n            else:\n                return 0\n        def findAndSetArea(grid, row, col):\n            queue = [(row, col)]\n            visited = set()\n            visited.add((row, col))\n\n            area = 0\n            while queue:\n                row, col = queue.pop(0)\n                area += 1\n                for direction in directions:\n                    nextRow, nextCol = row + direction[0], col + direction[1]\n                    if 0 <= nextRow < len(grid) and 0 <= nextCol < len(grid[0]) and grid[nextRow][nextCol] and (nextRow, nextCol) not in visited:\n                        queue.append((nextRow, nextCol))\n                        grid[nextRow][nextCol] = -1\n                        visited.add((nextRow, nextCol))\n            for r, c in visited:\n                positionToArea[(r, c)] = [uniqueKey, area]\n            return area\n\n        maxArea = 0\n        uniqueKey = 0\n        positionToArea = {}\n        directions = {(-1, 0), (1, 0), (0, -1), (0, 1)}\n        for row in range(len(grid)):\n            for col in range(len(grid[0])):\n                if grid[row][col] == 1:\n                    area = findAndSetArea(grid, row, col)\n                    uniqueKey += 1\n                    maxArea = max(maxArea, area)\n                elif grid[row][col] == 0:\n                    areaWithThis0 = 1\n                    keys = set()\n                    for direction in directions:\n                        nextRow, nextCol = row + direction[0], col + direction[1]\n                        key, area = positionToArea.get((nextRow, nextCol), [-1, 0])\n                        if key not in keys:\n                            keys.add(key)\n                            areaWithThis0 += area\n                    maxArea = max(maxArea, areaWithThis0)\n        for row, col in positionToArea:\n            areaWithThis0 = 1\n            keys = set()\n            for direction in directions:\n                nextRow, nextCol = row + direction\n\nclass TestCaseGenerator:\n\n    def generate(self) -> Dict[str, Any]:\n        grid_variants = [[[1, 0], [0, 1]], [[1, 1], [1, 0]], [[1, 1], [1, 1]], [[0, 0, 1], [0, 1, 0], [0, 0, 0]], [[1]], [[0]]]\n        grid = random.choice(grid_variants)\n        return {'grid': grid}\n\n    def encode_input(self, input_obj: Dict[str, Any]) -> str:\n        return str(input_obj['grid'])\n\n    def encode_output(self, output_obj: int) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str: str) -> Dict[str, List[List[int]]]:\n        import ast\n        return {'grid': ast.literal_eval(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.largestIsland(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Input {'grid': [[0]]}\nExpected Output:  1\nActual Output:  None\n1 Test Failed!\n",
      "time": "0.052",
      "memory": 5156,
      "stderr": null,
      "token": "4e09d018-c507-4058-8182-b6b2bb75e826",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 4,
        "description": "Wrong Answer"
      }
    }
  },
  {
    "status": "success",
    "question_id": 855,
    "title": "count-unique-characters-of-all-substrings-of-a-given-string",
    "token": "fa7b7745-9cc4-4b6e-bd40-ff6d01457979",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def uniqueLetterString(self, s: str) -> int:\n        last_exists = collections.defaultdict(lambda: [-1, -1])\n        res = 0\n        for i, c in enumerate(s):\n            last_exists[c][0], last_exists[c][1] = i, last_exists[c][0]\n            for _, exists in last_exists.items(): res += exists[0] - exists[1]\n        return res\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(1, 10 ** 5)\n        s = ''.join(random.choices('ABCDEFGHIJKLMNOPQRSTUVWXYZ', k=length))\n        return {'s': s}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['s']\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.uniqueLetterString(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "1.382",
      "memory": 17544,
      "stderr": null,
      "token": "fa7b7745-9cc4-4b6e-bd40-ff6d01457979",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "success",
    "question_id": 856,
    "title": "consecutive-numbers-sum",
    "token": "09de8d52-88ec-4371-b5f0-314c758831eb",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport json \n\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def consecutiveNumbersSum(self, n: int) -> int:\n        w = 0\n        k = 1\n        while k * (k + 1) / 2 <= n:\n            if (n - k * (k - 1) / 2) % k == 0:\n                w += 1\n            k += 1\n\n        return w\n\nclass TestCaseGenerator:\n\n    def __init__(self):\n        pass\n\n    def generate(self) -> dict:\n        n = random.randint(1, 1000)\n        return {'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return '{\"n\": %d}' % input_obj['n']\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        from json import loads\n        return loads(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.consecutiveNumbersSum(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Tests Passed!\n",
      "time": "0.051",
      "memory": 4728,
      "stderr": null,
      "token": "09de8d52-88ec-4371-b5f0-314c758831eb",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 3,
        "description": "Accepted"
      }
    }
  },
  {
    "status": "success",
    "question_id": 564,
    "title": "find-the-closest-palindrome",
    "token": "485455a5-017c-436f-a0d0-10a6af09ec05",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport math\n\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def nearestPalindromic(self, n: str) -> str:\n        return self.half_to_palindrome(n, len(n) % 2 == 0)\n\n    def half_to_palindrome(self, left: int, even: bool) -> int:\n        res = left\n        if not even:\n            left = left // 10\n        while left > 0:\n            res = res * 10 + left % 10\n            left //= 10\n        return res\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(1, 18)\n        n = ''.join(random.choices('1234567890', k=length)).lstrip('0')\n        if not n:\n            n = '1'\n        return {'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['n']\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        return {'n': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.nearestPalindromic(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": null,
      "time": "0.047",
      "memory": 4844,
      "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 110, in <module>\n    runner.run()\n  File \"script.py\", line 94, in run\n    output = self.solution.nearestPalindromic(**input)\n  File \"script.py\", line 51, in nearestPalindromic\n    return self.half_to_palindrome(n, len(n) % 2 == 0)\n  File \"script.py\", line 57, in half_to_palindrome\n    while left > 0:\nTypeError: '>' not supported between instances of 'str' and 'int'\n",
      "token": "485455a5-017c-436f-a0d0-10a6af09ec05",
      "compile_output": null,
      "message": "Exited with error status 1",
      "status": {
        "id": 11,
        "description": "Runtime Error (NZEC)"
      }
    }
  },
  {
    "status": "failure",
    "question_id": 552,
    "title": "student-attendance-record-ii",
    "token": null,
    "error": "No test case decoder found",
    "code": null
  },
  {
    "status": "success",
    "question_id": 938,
    "title": "numbers-at-most-n-given-digit-set",
    "token": "a862a241-613f-415a-a7bd-6f8d0ffcd9c1",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom functools import cache\nimport random\nimport json\n\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n  def atMostNGivenDigitSet(self, digits: List[str], n: int) -> int:\n    ans = 0\n    num = str(n)\n    for i in range(1, len(num)):\n      ans += pow(len(digits), i)\n    for i, c in enumerate(num):\n      dHasSameNum = False\n      for digit in digits:\n        if digit[0] < c:\n          ans += pow(len(digits), len(num) - i - 1)\n        elif digit[0] == c:\n          dHasSameNum = True\n      if not dHasSameNum:\n        return ans\n    return ans + 1\n\nclass TestCaseGenerator:\n\n    def __init__(self):\n        self.random = random\n        self.json = json\n\n    def generate(self) -> dict:\n        length_of_digits = self.random.randint(1, 9)\n        digits = [str(self.random.randint(1, 9)) for _ in range(length_of_digits)]\n        digits = sorted(list(set(digits)))\n        n = self.random.randint(1, 1000000)\n        return {'digits': digits, 'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return self.json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return self.json.loads(input_str)\n\n    def decode_output(self, output_str) -> int:\n        return int(output_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.atMostNGivenDigitSet(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": null,
      "time": "0.041",
      "memory": 4640,
      "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 26, in <module>\n    from functools import cache\nImportError: cannot import name 'cache' from 'functools' (/usr/local/python-3.8.1/lib/python3.8/functools.py)\n",
      "token": "a862a241-613f-415a-a7bd-6f8d0ffcd9c1",
      "compile_output": null,
      "message": "Exited with error status 1",
      "status": {
        "id": 11,
        "description": "Runtime Error (NZEC)"
      }
    }
  },
  {
    "status": "success",
    "question_id": 939,
    "title": "valid-permutations-for-di-sequence",
    "token": "3322b18f-37e3-4ec8-9836-479a2f2cb567",
    "error": null,
    "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport hashlib\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def numPermsDISequence(self, s: str) -> int:\n        mem=defaultdict(int)\n        def dfs(i,val=0):\n            if i==len(s):\n                return 1\n            if (i,val) in mem:\n                return mem[i,val]\n            p=0\n            if s[i]==\"D\":\n                for ind in range(0,val+1):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            else:\n                for ind in range(val+1,i+2):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            mem[i,val]=p\n            return p\n        return dfs(0)\n\n#### Output:\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(1, 200)\n        pattern = ''.join((random.choice('DI') for _ in range(length)))\n        return {'s': pattern}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['s']\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\n    def decode_output(self, output_str) -> int:\n        return int(output_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.numPermsDISequence(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
    "submission_details": {
      "stdout": "Input {'s': 'DDDIIDIIIIDIDIDIIIDIDDIIIDDDDIIIDDIIIIDDIDIIDIIIIIDDIIDIIDIIDIIIIDIIDIDIIIDIIIDIIIIIDDIDIIIDIDIDDIDIIDIDDIIDIIDDDDIDIIIID'}\nExpected Output:  []\nActual Output:  463618668\n1 Test Failed!\n",
      "time": "0.218",
      "memory": 6480,
      "stderr": null,
      "token": "3322b18f-37e3-4ec8-9836-479a2f2cb567",
      "compile_output": null,
      "message": null,
      "status": {
        "id": 4,
        "description": "Wrong Answer"
      }
    }
  }
]
