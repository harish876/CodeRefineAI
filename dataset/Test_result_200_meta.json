[
    {
        "question_id":1,
        "name":"two-sum",
        "inefficient_code":"class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        indexes = []\n        #nums.append(0)\n        for idx, num in enumerate(nums):\n            complement = target - num\n    \n            # nums \ub9ac\uc2a4\ud2b8\uc5d0\uc11c \ud604\uc7ac \uc778\ub371\uc2a4\ub97c \uc81c\uc678\ud55c \ub2e4\ub978 \uc704\uce58\uc5d0\uc11c complement \ucc3e\uae30\n            for idx2, num2 in enumerate(nums):\n                if num2 == complement and idx != idx2:\n                    indexes.append(idx)\n        \n        return indexes\n\n        \n",
        "optimized_code":"class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        d = {}\n        for idx, num in enumerate(nums):\n            complement = target - num\n            if complement in d:\n                return [d[complement], idx]\n            else:\n                d[num] = idx\n        return []"
    },
    {
        "question_id":2,
        "name":"add-two-numbers",
        "inefficient_code":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\n        head=tail=ListNode(0)\n        h1=l1\n        h2=l2\n        carry=0\n        while h1 or h2 or carry:\n            n1=h1.val if h1 else 0\n            n2=h2.val if h2 else 0\n\n            total=n1+n2+carry\n            tail.next=ListNode(total%10)\n            carry=total\/\/10\n\n            tail=tail.next\n            h1=h1.next if h1 else None\n            h2=h2.next if h2 else None\n\n        \n        return head.next\n\n\n\n        ",
        "optimized_code":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\n        head=tail=ListNode(0)\n        h1=l1\n        h2=l2\n        carry=0\n        while h1 or h2 or carry:\n            n1=h1.val if h1 else 0\n            n2=h2.val if h2 else 0\n\n            total=n1+n2+carry\n            tail.next=ListNode(total%10)\n            carry=total\/\/10\n\n            tail=tail.next\n            h1=h1.next if h1 else None\n            h2=h2.next if h2 else None\n\n        \n        return head.next\n\n\n# Python3 code to demonstrate working of"
    },
    {
        "question_id":3,
        "name":"longest-substring-without-repeating-characters",
        "inefficient_code":"from collections import deque\n\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        answer = 0\n        sub_str = set()\n        if len(s) == 1:\n            return 1\n\n        for i in range(len(s)):\n            sub_str.clear()\n            sub_str.add(s[i])\n            for j in range(i+1, len(s)):\n                prev_len = len(sub_str)\n                sub_str.add(s[j])\n\n                if prev_len == len(sub_str):\n                    temp_answer = len(sub_str)\n                    if answer < temp_answer:\n                        answer = temp_answer\n                    break\n                \n                if j == len(s)-1:\n                    temp_answer = len(sub_str)\n                    if answer < temp_answer:\n                        answer = temp_answer\n\n        # print(answer)\n        return answer\n\n                \n        ",
        "optimized_code":"from collections import deque\n\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        answer = 0\n        sub_str = set()\n        if len(s) == 1:\n            return 1\n\n        for i in range(len(s)):\n            sub_str.clear()\n            sub_str.add(s[i])\n            for j in range(i+1, len(s)):\n                prev_len = len(sub_str)\n                sub_str.add(s[j])\n\n                if prev_len == len(sub_str):\n                    temp_answer = len(sub_str)\n                    if answer < temp_answer:\n                        answer = temp_answer\n                    break\n                \n                if j == len(s)-1:\n                    temp_answer = len(sub_str)\n                    if answer < temp_answer:\n                        answer = temp_answer\n\n        return answer"
    },
    {
        "question_id":4,
        "name":"median-of-two-sorted-arrays",
        "inefficient_code":"class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        num = nums1+nums2\n        num.sort()\n        if len(num)%2!=0:\n            return num[len(num)\/\/2]\n        else:\n            return (num[len(num)\/\/2]+num[len(num)\/\/2-1])\/2",
        "optimized_code":"class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        num = nums1+nums2\n        num.sort()\n        return num[len(num)\/\/2] if len(num)%2==0 else (num[len(num)\/\/2]+num[len(num)\/\/2-1])\/2"
    },
    {
        "question_id":5,
        "name":"longest-palindromic-substring",
        "inefficient_code":"class Solution:\n    def longestPalindrome(self, s: str) -> str:\n        longest = s[0]\n        palin = set()\n        for i in range(len(s)):\n            for j in range(i + 1, len(s)):\n                if j - i < len(longest):\n                    continue\n                _s = s[i : j + 1]\n                if _s in palin:\n                    continue\n                elif self.check(_s, palin):\n                    palin.add(_s)\n                    if len(_s) > len(longest):\n                        longest = _s\n        return longest\n\n    def check(self, s, palin):\n        n = len(s)\n        i = 0\n        j = n - 1\n        while i < j:\n            if s in palin:\n                return True\n            if s[i] != s[j]:\n                return False\n            else:\n                i += 1\n                j -= 1\n        return True\n",
        "optimized_code":"class Solution:\n    def longestPalindrome(self, s: str) -> str:\n        longest = s[0]\n        palin = set()\n        for i in range(len(s)):\n            for j in range(i + 1, len(s)):\n                if j - i < len(longest):\n                    continue\n                _s = s[i : j + 1]\n                if _s in palin:\n                    continue\n                elif self.check(_s, palin):\n                    palin.add(_s)\n                    if len(_s) > len(longest):\n                        longest = _s\n        return longest\n\n    def check(self, s, palin):\n        n = len(s)\n        i = 0\n        j = n - 1\n        while i < j:\n            if s in palin:\n                return True\n            if s[i]!= s[j]:\n                return False\n            else:\n                i += 1\n                j -= 1"
    },
    {
        "question_id":6,
        "name":"zigzag-conversion",
        "inefficient_code":"class Solution:\n    def convert(self, s: str, numRows: int) -> str:\n        if numRows == 1:\n            return s\n        string = [['']*len(s) for i in range(numRows)]\n        ri,ci = 0,0\n        colend = numRows-1\n        i = 0\n        size = len(s)\n        while i < size:\n            while i < size and ri <= numRows-1:\n                string[ri][ci] = s[i]\n                ri += 1\n                i+=1\n            ri, ci = ri - 2,ci + 1\n            \n            while i < size and ri > 0 and ci < colend:\n                print(ri,ci,i)\n                string[ri][ci] = s[i]\n                ri,ci = ri-1, ci+1\n                i+=1\n            colend += colend\n        \n        return \"\".join(\"\".join(ch for ch in subarr if ch != '') for subarr in string)\n\n",
        "optimized_code":"class Solution:\n    def convert(self, s: str, numRows: int) -> str:\n        if numRows == 1:\n            return s\n        string = [['']*len(s) for i in range(numRows)]\n        ri,ci = 0,0\n        colend = numRows-1\n        i = 0\n        size = len(s)\n        while i < size:\n            while i < size and ri <= numRows-1:\n                string[ri][ci] = s[i]\n                ri += 1\n                i+=1\n            ri, ci = ri - 2,ci + 1\n            \n            while i < size and ri > 0 and ci < colend:\n                print(ri,ci,i)\n                string[ri][ci] = s[i]\n                ri,ci = ri-1, ci+1\n                i+=1\n            colend += colend\n        \n        return \"\".join(\"\".join(ch for ch"
    },
    {
        "question_id":7,
        "name":"reverse-integer",
        "inefficient_code":"class Solution:\n    def reverse(self, x: int) -> int:\n        if(x<0):\n            x*=-1\n            ans = 0\n            while(x):\n                ans*=10\n                ans+=x%10\n                x = x\/\/10\n            ans*=-1\n            if(ans<-2**31):\n                return 0    \n            return ans\n        else:\n            ans = 0\n            while(x):\n                ans*=10\n                ans+=x%10\n                x = x\/\/10\n            if(ans>(2**31)-1):\n                return 0    \n            return ans       ",
        "optimized_code":"class Solution:\n    def reverse(self, x: int) -> int:\n        if(x<0):\n            x*=-1\n            ans = 0\n            while(x):\n                ans*=10\n                ans+=x%10\n                x = x\/\/10\n            ans*=-1\n            if(ans<-2**31):\n                return 0    \n            return ans\n        else:\n            ans = 0\n            while(x):\n                ans*=10\n                ans+=x%10\n                x = x\/\/10\n            if(ans>(2**31)-1):\n                return 0    \n            return ans"
    },
    {
        "question_id":8,
        "name":"string-to-integer-atoi",
        "inefficient_code":"class Solution:\n    def myAtoi(self, s: str) -> int:\n        negative = False\n        start_digit = False\n        string_number = \"\"\n        INT_MAX = 2**31 - 1\n        INT_MIN = -2**31\n        \n        for char in s:\n            if char == \" \" and not start_digit:\n                continue\n            \n            if char == \"-\" and not start_digit:\n                negative = True\n                start_digit = True\n                continue\n            elif char == \"+\" and not start_digit:\n                start_digit = True\n                continue\n            \n            if char.isdigit():\n                string_number += char\n                start_digit = True\n                continue\n            \n            # If a non-digit character is encountered after starting to read digits\n            if start_digit:\n                break\n            \n            # If the character is invalid at the start (non-digit and not a sign)\n            if not char.isdigit() and not start_digit:\n                return 0\n        \n        if not string_number:\n            return 0\n        \n        result = int(string_number)\n\n        if negative:\n            result = -result\n        \n        # Clamp the result to the 32-bit integer range\n        if result < INT_MIN:\n            return INT_MIN\n        if result > INT_MAX:\n            return INT_MAX\n        return result\n",
        "optimized_code":"class Solution:\n    def myAtoi(self, s: str) -> int:\n        negative = False\n        start_digit = False\n        string_number = \"\"\n        INT_MAX = 2**31 - 1\n        INT_MIN = -2**31\n        \n        for char in s:\n            if char == \" \" and not start_digit:\n                continue\n            \n            if char == \"-\" and not start_digit:\n                negative = True\n                start_digit = True\n                continue\n            elif char == \"+\" and not start_digit:\n                start_digit = True\n                continue\n            \n            if char.isdigit():\n                string_number += char\n                start_digit = True\n                continue\n            \n            # If a non-digit character is encountered after starting to read digits\n            if start_digit:\n                break\n            \n            # If the character is invalid at the start (non-digit and not a sign)\n            if not char.isdigit() and not start_digit:\n                return 0\n        \n        if not string_number:"
    },
    {
        "question_id":9,
        "name":"palindrome-number",
        "inefficient_code":"class Solution:\n    def isPalindrome(self, x: int) -> bool:\n        x2, num = x, 0\n        while x2 > 0:\n            x2, num = x2 \/\/ 10, (num*10) + x2 % 10\n        return num == x",
        "optimized_code":"def isPalindrome(x: int) -> bool:\n    if x < 0:\n        return False\n    else:\n        x, x2 = x, 0\n        while x2 < 10:\n            x2 = x2 * 10 + x % 10\n            x = x \/\/ 10\n        return x2 == x"
    },
    {
        "question_id":10,
        "name":"regular-expression-matching",
        "inefficient_code":"class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        m, n = len(s), len(p)\n        j = 0\n        i = 0\n\n        while i < n:\n            if i + 1 < n and p[i + 1] == \"*\":\n                # Handle the '*' wildcard\n                # If the current pattern character and the character after '*' match the string character\n                if j < m and (p[i] == s[j] or p[i] == \".\"):\n                    # Try to match 0 or more characters\n                    while j < m and (p[i] == s[j] or p[i] == \".\"):\n                        if self.isMatch(s[j:], p[i + 2:]):\n                            return True\n                        j += 1\n                    i += 2  # Skip both the current character and '*'\n                else:\n                    # Skip the '*' and the preceding element in pattern\n                    i += 2\n            elif j < m and (p[i] == s[j] or p[i] == \".\"):\n                # Characters match or p[i] is '.'\n                j += 1\n                i += 1\n            else:\n                return False\n\n        # Ensure full match of both pattern and string\n        return j == m and i == n\n\n\n",
        "optimized_code":"class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        m, n = len(s), len(p)\n        j = 0\n        i = 0\n\n        while i < n:\n            if i + 1 < n and p[i + 1] == \"*\":\n                # Handle the '*' wildcard\n                # If the current pattern character and the character after '*' match the string character\n                if j < m and (p[i] == s[j] or p[i] == \".\"):\n                    # Try to match 0 or more characters\n                    while j < m and (p[i] == s[j] or p[i] == \".\"):\n                        if self.isMatch(s[j:], p[i + 2:]):\n                            return True\n                        j += 1\n                    i += 2  # Skip both the current character and '*'\n                else:\n                    # Skip the '*' and the preceding element in pattern"
    },
    {
        "question_id":11,
        "name":"container-with-most-water",
        "inefficient_code":"class Solution:\n    def maxArea(self, height: List[int]) -> int:\n        l = 0\n        r = len(height) - 1\n        m = max(height)\n        dis = 0\n        area = 0\n        while l != r:\n            if height[l] == m and height[r] == m:\n                # print(\"HII\")\n                dis = r - l\n                if area < dis * height[r]:\n                    area = dis * height[r]\n                break\n            elif l == 0 and r == len(height) - 1:\n                dis = r - l\n                temp = min(height[l], height[r])\n                area = dis * (temp)\n                if temp < height[l]:\n                    r -= 1\n                else:\n                    l += 1\n            else:\n                dis = r - l\n                if height[l] < height[r]:\n                    if area < dis * height[l]:\n                        area = dis * (height[l])\n                    l += 1\n\n                elif area < dis * height[r]:\n                    area = dis * (height[r])\n                    r -= 1\n                else:\n                    r-=1\n\n        return area\n",
        "optimized_code":"class Solution:\n    def maxArea(self, height: List[int]) -> int:\n        l = 0\n        r = len(height) - 1\n        m = max(height)\n        dis = 0\n        area = 0\n        while l!= r:\n            if height[l] == m and height[r] == m:\n                # print(\"HII\")\n                dis = r - l\n                if area < dis * height[r]:\n                    area = dis * height[r]\n                break\n            elif l == 0 and r == len(height) - 1:\n                dis = r - l\n                temp = min(height[l], height[r])\n                area = dis * (temp)\n                if temp < height[l]:\n                    r -= 1\n                else:\n                    l += 1\n            else:\n                dis = r - l\n                if height[l] < height[r]:\n                    if area < dis * height[l]:\n                        area = dis"
    },
    {
        "question_id":12,
        "name":"integer-to-roman",
        "inefficient_code":"class Solution:\n    def intToRoman(self, num: int) -> str:\n        dictionary = {1000:'M', 900:'CM', 500:'D', 400:'CD', 100:'C', 90:'XC', 50:'L', 40:'XL', 10:'X', 9:'IX', 5:'V', 4:'IV', 1:'I'}\n        ans=''\n        for key, val in dictionary.items():\n            while num>=key:\n                ans+=val\n                num-=key\n            if num==0:break\n        return ans",
        "optimized_code":"class Solution:\n    def intToRoman(self, num: int) -> str:\n        dic = {\n            1000: 'M',\n            900: 'CM',\n            500: 'D',\n            400: 'CD',\n            100: 'C',\n            90: 'XC',\n            50: 'L',\n            40: 'XL',\n            10: 'X',\n            9: 'IX',\n            5: 'V',\n            4: 'IV',\n            1: 'I',\n        }\n        ans = ''\n        for key, val in dic.items():\n            while num >= key:\n                ans += val\n                num -= key\n            if num == 0:\n                break\n        return ans"
    },
    {
        "question_id":13,
        "name":"roman-to-integer",
        "inefficient_code":"class Solution:\n    def romanToInt(self, s: str) -> int:\n        m = {\n            'I': 1,\n            'V': 5,\n            'X': 10,\n            'L': 50,\n            'C': 100,\n            'D': 500,\n            'M': 1000\n        }\n        \n        ans = 0\n        \n        for i in range(len(s)):\n            if i < len(s) - 1 and m[s[i]] < m[s[i+1]]:\n                ans -= m[s[i]]\n            else:\n                ans += m[s[i]]\n        \n        return ans\n        \n        ",
        "optimized_code":"class Solution:\n    def romanToInt(self, s: str) -> int:\n        m = {\n            'I': 1,\n            'V': 5,\n            'X': 10,\n            'L': 50,\n            'C': 100,\n            'D': 500,\n            'M': 1000\n        }\n        \n        ans = 0\n        \n        for i in range(len(s)):\n            if i < len(s) - 1 and m[s[i]] < m[s[i+1]]:\n                ans -= m[s[i]]\n            else:\n                ans += m[s[i]]\n        \n        return ans"
    },
    {
        "question_id":14,
        "name":"longest-common-prefix",
        "inefficient_code":"class Solution:\n    def longestCommonPrefix(self, strs: List[str]) -> str:\n        strs.sort(key=len)\n        pf = ''\n        for i,l in enumerate(strs[0]):\n            for word in strs[1:]:\n                    if word[i] != l:\n                        return pf\n            pf += l\n        return pf\n",
        "optimized_code":"class Solution:\n    def longestCommonPrefix(self, strs: List[str]) -> str:\n        if not strs:\n            return ''\n        strs.sort(key=len)\n        l = len(strs[0])\n        for i in range(l):\n            if strs[0][i]!= strs[1][i]:\n                return strs[0][:i]\n        return strs[0]"
    },
    {
        "question_id":15,
        "name":"3sum",
        "inefficient_code":"from collections import defaultdict\n\nclass Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        ret = set()\n        nums.sort()\n        for i, n in enumerate(nums):\n            if n > 0:\n                break\n            for res in self.twoSum(nums, i+1, -n):\n                ret.add(tuple(sorted([nums[i], nums[res[0]], nums[res[1]]])))\n\n        return list(ret)\n\n    def twoSum(self, nums, i, target):\n        ret = []\n        l = i\n        r = len(nums) - 1\n\n        while l < r:\n            # print(l, r, ret)\n            if nums[l] + nums[r] == target:\n                ret.append((l, r))\n                l += 1\n                while l + 1 < len(nums) and nums[l-1] == nums[l]:\n                    l += 1\n            elif nums[l] + nums[r] < target:\n                l += 1\n            elif nums[l] + nums[r] > target:\n                r -= 1\n\n        return ret",
        "optimized_code":"class Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        nums.sort()\n        ans = []\n        for i in range(len(nums)):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            l, r = i + 1, len(nums) - 1\n            while l < r:\n                if nums[i] + nums[l] + nums[r] == 0:\n                    ans.append([nums[i], nums[l], nums[r]])\n                    while l < r and nums[l] == nums[l+1]:\n                        l += 1\n                    while l < r and nums[r] == nums[r-1]:\n                        r -= 1\n                    l += 1\n                    r -= 1\n                elif nums[i] + nums[l] < 0:\n                    l += 1\n                elif nums[i] + nums[r] < 0:\n                    r -= 1"
    },
    {
        "question_id":16,
        "name":"3sum-closest",
        "inefficient_code":"class Solution:\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\n        nums = sorted(nums)\n        res = float('inf')\n        ans = 0\n        print(nums)\n        for i in range(len(nums)):\n            left = i+1 \n            right = len(nums)-1 \n            while left< right:\n                cur = nums[i]+ nums[left]+ nums[right]\n                # print(i, left, right, cur)\n                if cur == target:\n                    return cur\n                if cur < target:\n                    left +=1 \n                else:\n                    right -=1 \n                \n                # if left>i+1 and left<right and nums[left] == nums[left-1]:\n                #     left+=1\n                #     continue \n               \n                res = min(res, abs(cur-target))\n                \n                if abs(cur-target) == res:\n                    ans = cur\n                # print(ans)\n        \n        return ans\n                \n        ",
        "optimized_code":"class Solution:\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\n        nums = sorted(nums)\n        res = float('inf')\n        ans = 0\n        for i in range(len(nums)):\n            left = i+1 \n            right = len(nums)-1 \n            while left< right:\n                cur = nums[i]+ nums[left]+ nums[right]\n                # print(i, left, right, cur)\n                if cur == target:\n                    return cur\n                if cur < target:\n                    left +=1 \n                else:\n                    right -=1 \n                \n                # if left>i+1 and left<right and nums[left] == nums[left-1]:\n                #     left+=1\n                #     continue \n               \n                res = min(res, abs(cur-target))\n        \n        return ans"
    },
    {
        "question_id":17,
        "name":"letter-combinations-of-a-phone-number",
        "inefficient_code":"class Solution:\n    def letterCombinations(self, digits: str) -> List[str]:\n        res = []\n        digitsToChar = {\n            2: \"abc\",\n            3: \"def\",\n            4: \"ghi\",\n            5: \"jkl\",\n            6: \"mno\",\n            7: \"pqrs\",\n            8: \"tuv\",\n            9: \"wxyz\"\n        }\n\n        def backtrack(i, curStr):\n            if i >= len(digits):\n                res.append(curStr)\n                return\n            for c in digitsToChar[int(digits[i])]:\n                backtrack(i+1, curStr + c)\n\n        if digits:\n            backtrack(0, \"\")\n        return res  ",
        "optimized_code":"class Solution:\n    def letterCombinations(self, digits: str) -> List[str]:\n        if not digits:\n            return []\n        charToDigit = {\n            2: \"abc\",\n            3: \"def\",\n            4: \"ghi\",\n            5: \"jkl\",\n            6: \"mno\",\n            7: \"pqrs\",\n            8: \"tuv\",\n            9: \"wxyz\"\n        }\n        res = []\n        def backtrack(i, curStr):\n            if i >= len(digits):\n                res.append(curStr)\n                return\n            for c in charToDigit[int(digits[i])]:\n                backtrack(i+1, curStr + c)\n        backtrack(0, \"\")\n        return res\n\n### Task: Write a Python program to create a list of all possible combinations of a given set of numbers. Do not use built-in functions. The list should be in the form of a list of lists. Do not"
    },
    {
        "question_id":18,
        "name":"4sum",
        "inefficient_code":"class Solution:\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\n        nums.sort()\n        res = set()\n        for i in range(len(nums)-3):\n            for j in range(i+1,len(nums)-2):\n                m = j+1\n                n = len(nums) - 1\n                while m < n:\n                    if nums[m] + nums[n] == target - (nums[i] + nums[j]):\n                       res.add((nums[i],nums[j],nums[m],nums[n]))\n                       m+=1\n                       n-=1\n                    elif  target - (nums[i] + nums[j]) > (nums[m] + nums[n]):\n                        m+=1\n                    else:\n                        n-=1\n        \n        return [list(t) for t in res]\n\n        ",
        "optimized_code":"class Solution:\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\n        nums.sort()\n        res = set()\n        for i in range(len(nums)-3):\n            for j in range(i+1,len(nums)-2):\n                m = j+1\n                n = len(nums) - 1\n                while m < n:\n                    if nums[m] + nums[n] == target - (nums[i] + nums[j]):\n                        res.add((nums[i],nums[j],nums[m],nums[n]))\n                        m+=1\n                        n-=1\n                    elif  target - (nums[i] + nums[j]) > (nums[m] + nums[n]):\n                        m+=1\n                    else:\n                        n-=1\n        \n        return [list(t) for t in res]"
    },
    {
        "question_id":19,
        "name":"remove-nth-node-from-end-of-list",
        "inefficient_code":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n\n        fast = head\n\n        for _ in range(n - 1):\n            fast = fast.next\n\n        pre_slow    = None\n        slow        = head\n\n        while fast and fast.next:\n            pre_slow = slow\n            slow = slow.next\n            fast = fast.next\n\n        pre_target = pre_slow\n        target = slow\n\n        if not pre_slow:\n            return target.next\n\n        pre_slow.next = target.next\n\n        return head\n\n        ",
        "optimized_code":"class Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        fast = head\n        slow = head\n        for _ in range(n - 1):\n            fast = fast.next\n\n        while fast and fast.next:\n            fast = fast.next\n            slow = slow.next\n\n        slow.next = slow.next.next\n\n        return head"
    },
    {
        "question_id":20,
        "name":"valid-parentheses",
        "inefficient_code":"class Solution(object):\n    def isValid(self, s):\n        stack = [] \n        pairs = {\n            '(': ')',\n            '{': '}',\n            '[': ']'\n        }\n        \n        for bracket in s:\n            if bracket in pairs:\n                stack.append(bracket)\n            elif len(stack) == 0 or bracket != pairs[stack.pop()]:\n                return False\n\n        return len(stack) == 0",
        "optimized_code":"class Solution(object):\n    def isValid(self, s):\n        stack = []\n        for bracket in s:\n            if bracket in ('(', '{', '['):\n                stack.append(bracket)\n            elif bracket in (')', '}', ']'):\n                if not stack:\n                    return False\n                if stack.pop()!= bracket:\n                    return False\n        return not stack"
    },
    {
        "question_id":21,
        "name":"merge-two-sorted-lists",
        "inefficient_code":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\n        cur = ListNode()\n        d = cur\n        while list1 and list2:\n            if list1.val < list2.val:\n                cur.next = list1\n                list1 = list1.next\n            else:\n                cur.next = list2\n                list2 = list2.next\n\n            cur = cur.next\n        if list1:\n            cur.next = list1\n        else:\n            cur.next = list2\n        return d.next\n",
        "optimized_code":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\n        if list1 is None:\n            return list2\n        if list2 is None:\n            return list1\n        if list1.val < list2.val:\n            list1.next = self.mergeTwoLists(list1.next, list2)\n            return list1\n        else:\n            list2.next = self.mergeTwoLists(list1, list2.next)\n            return list2"
    },
    {
        "question_id":22,
        "name":"generate-parentheses",
        "inefficient_code":"class Solution:\n    def generateParenthesis(self, n: int) -> List[str]:\n        stack = []\n        res = []\n\n        def backtrack(openN, closedN):\n            if openN == closedN == n:\n                res.append(\"\".join(stack))\n                return\n            \n            if openN <n:\n                stack.append(\"(\")\n                backtrack(openN+1, closedN)\n                stack.pop()\n                \n            \n            if closedN < openN:\n                stack.append(\")\")\n                backtrack(openN, closedN+1)\n                stack.pop()\n                \n        backtrack(0,0)\n        return res\n            \n",
        "optimized_code":"class Solution:\n    def generateParenthesis(self, n: int) -> List[str]:\n        def backtrack(openN, closedN, result):\n            if openN == closedN == n:\n                result.append(\"\".join(result))\n                return\n            if openN < n:\n                backtrack(openN+1, closedN, result)\n                result.append(\"(\")\n            if closedN < openN:\n                backtrack(openN, closedN+1, result)\n                result.append(\")\")\n        result = []\n        backtrack(0, 0, result)\n        return result"
    },
    {
        "question_id":23,
        "name":"merge-k-sorted-lists",
        "inefficient_code":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        lists = [x for x in lists if x]\n        k = len(lists)\n        if k==0: return\n\n        while len(lists) > 1:\n            lists[0] = self.mergeFirst2Lists(lists)\n            del lists[1]\n        return lists[0]\n\n    def mergeFirst2Lists(self, lists: List[ListNode]) -> ListNode:\n        idx = 0 if lists[0].val < lists[1].val else 1\n        head = lists[idx]\n        lists[idx] = lists[idx].next\n        node = head\n        while lists[0] and lists[1]:\n            idx = 0 if lists[0].val < lists[1].val else 1\n            node.next = lists[idx]\n            node = node.next\n            lists[idx] = lists[idx].next\n        if lists[0]: node.next = lists[0]\n        elif lists[1]: node.next = lists[1]\n        return head",
        "optimized_code":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        lists = [x for x in lists if x]\n        if len(lists) == 0: return None\n        k = len(lists)\n        if k==1: return lists[0]\n        if k==2:\n            lists[0] = self.mergeTwoLists(lists[0], lists[1])\n            return lists[0]\n        if k==3:\n            lists[0] = self.mergeTwoLists(lists[0], lists[1])\n            lists[1] = self.mergeTwoLists(lists[2], lists[3])\n            return lists[0]\n        while len(lists) > 3:\n            lists["
    },
    {
        "question_id":24,
        "name":"swap-nodes-in-pairs",
        "inefficient_code":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        # loop\n\n        # recursive\n        if head and head.next:\n            p = head.next\n            head.next = self.swapPairs(head.next.next)\n            p.next = head\n            return p\n\n        return head\n",
        "optimized_code":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n        p = ListNode(0, head)\n        head = p\n        while head and head.next:\n            a = head.next\n            b = a.next\n            c = b.next\n            d = b.next\n            a.next = d\n            b.next = c\n            d.next = a\n            head = d\n        return p.next"
    },
    {
        "question_id":25,
        "name":"reverse-nodes-in-k-group",
        "inefficient_code":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        \n        def advance_k_steps(current, k):\n            while current and k > 0:\n                current = current.next\n                k -= 1\n            return current\n\n        def reverse_k_elements(prev, cur, k):\n            for _ in range(k):\n                cur.next, prev, cur = prev , cur, cur.next\n\n            return prev\n            \n        \n        prev_chain, prev_node = None, None\n        current = head\n        end_chain = advance_k_steps(current, k-1)\n        \n        while end_chain:\n            # assign new pointers\n            next_chain = end_chain.next\n            head_reversed = reverse_k_elements(prev_node, current, k)\n            if not prev_chain:\n                head = head_reversed\n            else:\n                prev_chain.next = head_reversed\n            current.next = next_chain\n\n            #update\n            prev_chain, prev_node = current, current\n            current = next_chain\n\n            end_chain = advance_k_steps(current, k-1)\n\n        return head\n\n# current (slow pointer)\n# current + k (fast pointer)\n# p = None, s=1, f=2 , n = fast.next\n#\u00a01 -> 2 -> 3\n# 1 <- 2 <- 3 # reverse until counter k\n#\u00a0start(1).next = next\n# prev.next = end(3)",
        "optimized_code":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head or k == 1:\n            return head\n\n        # Create a new dummy node to hold the head of the reversed list\n        dummy = ListNode()\n        prev = dummy\n        curr = head\n        count = 0\n\n        while curr or count < k:\n            count += 1\n\n            if curr:\n                prev.next = curr\n                curr = curr.next\n\n            prev = prev.next\n        prev.next = head\n\n        return dummy.next"
    },
    {
        "question_id":26,
        "name":"remove-duplicates-from-sorted-array",
        "inefficient_code":"class Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        curr = set([])\n        i = 0\n        while i < len(nums):\n            if nums[i] in curr:\n                nums.pop(i)\n            else:\n                curr.add(nums[i])\n                i += 1\n        return len(nums)",
        "optimized_code":"class Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        i = 0\n        while i < len(nums):\n            if nums[i] in nums[i+1:]:\n                nums.pop(i)\n            else:\n                i += 1\n        return len(nums)\n\n#### Optimize Code:\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        if len(nums) == 0:\n            return 0\n        curr = set([])\n        i = 0\n        while i < len(nums):\n            if nums[i] in curr:\n                nums.pop(i)\n            else:\n                curr.add(nums[i])\n                i += 1\n        return len(nums)\n\n#### Optimize Code:\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        if len(nums) == 0:\n            return 0\n        i = 0\n        while i < len(nums):\n            if nums[i"
    },
    {
        "question_id":27,
        "name":"remove-element",
        "inefficient_code":"class Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        if(len(nums) == 0):\n            return 0\n        i = 0\n        j = len(nums) - 1\n        while(i<j):\n            if(nums[j] == val):\n                j-=1\n                continue\n            if(nums[i] == val):\n                nums[i], nums[j] = nums[j], nums[i]\n                j-=1\n            i+=1\n        return i + (0 if nums[i] == val else 1)\n        ",
        "optimized_code":"class Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        if(len(nums) == 0):\n            return 0\n        i = 0\n        j = len(nums) - 1\n        while(i<j):\n            if(nums[j] == val):\n                nums[i], nums[j] = nums[j], nums[i]\n                j-=1\n            i+=1\n        return i + (0 if nums[i] == val else 1)\n        \n\n#### Output Code:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        if(len(nums) == 0):\n            return 0\n        i = 0\n        j = len(nums) - 1\n        while(i<j):\n            if(nums[j] == val):\n                nums[i], nums[j] = nums[j], nums[i]\n                j-=1\n            i+=1\n        return i + (0"
    },
    {
        "question_id":28,
        "name":"find-the-index-of-the-first-occurrence-in-a-string",
        "inefficient_code":"class Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        for i in range(len(haystack)+1-len(needle)):\n            if haystack[i : i+len(needle)]==needle:\n                return i\n        return -1",
        "optimized_code":"def strStr(haystack, needle):\n    for i in range(len(haystack) + 1 - len(needle)):\n        if haystack[i:i+len(needle)] == needle:\n            return i\n    return -1"
    },
    {
        "question_id":29,
        "name":"divide-two-integers",
        "inefficient_code":"class Solution:\n    def divide(self, dividend: int, divisor: int) -> int:\n        # Constants for 32-bit signed integer limits\n        INT_MAX, INT_MIN = 2**31 - 1, -2**31\n        \n        # Edge case for overflow\n        if dividend == INT_MIN and divisor == -1:\n            return INT_MAX\n        \n        # Determine the sign of the result\n        sign = (dividend < 0) != (divisor < 0)\n        \n        # Work with absolute values\n        dividend, divisor = abs(dividend), abs(divisor)\n        \n        # Initialize the result\n        quotient = 0\n        \n        # The power of two divisor\n        power = 31\n        # The value of divisor shifted left\n        divisor_power = divisor << power\n        \n        # Subtract divisor multiples from dividend\n        while dividend >= divisor:\n            while divisor_power > dividend:\n                divisor_power >>= 1\n                power -= 1\n            dividend -= divisor_power\n            quotient += 1 << power\n        \n        # Apply the sign\n        if sign:\n            quotient = -quotient\n        \n        # Clamp the result within the 32-bit signed integer range\n        return min(max(quotient, INT_MIN), INT_MAX)\n",
        "optimized_code":"class Solution:\n    def divide(self, dividend: int, divisor: int) -> int:\n        # Constants for 32-bit signed integer limits\n        INT_MAX, INT_MIN = 2**31 - 1, -2**31\n        \n        # Edge case for overflow\n        if dividend == INT_MIN and divisor == -1:\n            return INT_MAX\n        \n        # Determine the sign of the result\n        sign = (dividend < 0)!= (divisor < 0)\n        \n        # Work with absolute values\n        dividend, divisor = abs(dividend), abs(divisor)\n        \n        # Initialize the result\n        quotient = 0\n        \n        # The power of two divisor\n        power = 31\n        # The value of divisor shifted left\n        divisor_power = divisor << power\n        \n        # Subtract divisor multiples from dividend\n        while dividend >= divisor:\n            while divisor_power > dividend:\n                divisor_power >>= 1\n                power -= 1"
    },
    {
        "question_id":30,
        "name":"substring-with-concatenation-of-all-words",
        "inefficient_code":"class Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        n = len(words)\n        k = len(words[0])\n        words_counts = Counter(words)\n        l = n * k\n\n        indices = []\n        for i in range(len(s) - l + 1):\n            if Counter(\n                s[i + j * k: i + (j + 1) * k] for j in range(n)\n            ) == words_counts:\n                indices.append(i)\n\n        return indices\n",
        "optimized_code":"class Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        n = len(words)\n        k = len(words[0])\n        words_counts = Counter(words)\n        l = n * k\n\n        indices = []\n        for i in range(len(s) - l + 1):\n            if Counter(\n                s[i + j * k: i + (j + 1) * k] for j in range(n)\n            ) == words_counts:\n                indices.append(i)\n\n        return indices"
    },
    {
        "question_id":31,
        "name":"next-permutation",
        "inefficient_code":"class Solution:\n    def swap(self, nums, i, j):\n        temp = nums[i]\n        nums[i] = nums[j]\n        nums[j] = temp\n    def reverse(self, nums, i, j):\n        while i < j:\n            self.swap(nums, i, j)\n            i += 1\n            j -= 1\n            \n    def nextPermutation(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        i = len(nums) - 2\n        while i >= 0 and nums[i] >= nums[i + 1]:\n            i -= 1\n        if i >= 0:\n            j = len(nums) - 1\n            while nums[j] <= nums[i]:\n                j -= 1\n            self.swap(nums, i, j)\n        self.reverse(nums, i+1, len(nums) - 1)\n\n        return nums",
        "optimized_code":"class Solution:\n    def swap(self, nums, i, j):\n        temp = nums[i]\n        nums[i] = nums[j]\n        nums[j] = temp\n    def reverse(self, nums, i, j):\n        while i < j:\n            self.swap(nums, i, j)\n            i += 1\n            j -= 1\n            \n    def nextPermutation(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        i = len(nums) - 2\n        while i >= 0 and nums[i] >= nums[i + 1]:\n            i -= 1\n        if i >= 0:\n            j = len(nums) - 1\n            while nums[j] <= nums[i]:\n                j -= 1\n            self.swap(nums, i, j)\n        self.reverse(nums, i+1, len(nums) - 1)\n\n        return nums"
    },
    {
        "question_id":32,
        "name":"longest-valid-parentheses",
        "inefficient_code":"class Solution:\n    def longestValidParentheses(self, s: str) -> int:\n        n = len(s)\n        cache = dict()\n        max_len = 0\n        for i in range(n-1):\n            if s[i] == '(' and s[i+1] == ')':\n                max_len = 2\n                cache[i] = i+1\n        \n        has_changed = True\n        while has_changed:\n            # print(cache)\n            has_changed = False\n            for i in list(cache.keys()):\n                j = cache.get(i)\n                # print(f'i={i} j={j}')\n                if j is None:\n                    continue\n\n                # case XY\n                nj = cache.get(j+1)\n                if nj:\n                    del cache[j+1]\n                    max_len = max(max_len, nj-i + 1)\n                    cache[i] = nj\n                    has_changed = True\n                    # print(f'case XY add i={i} j={nj}; delete {j+1}')\n                    # print(cache)\n                else:\n                    # case (X)\n                    if 0 < i and j < n-1:\n                        if s[i-1] == '(' and s[j+1] == ')':\n                            del cache[i]\n                            max_len = max(max_len, j-i + 3)\n                            cache[i-1] = j+1\n                            has_changed = True\n                            # print(f'case (X) add i={i-1} j={j+1}; delete {i}')\n\n        return max_len\n        \n",
        "optimized_code":"class Solution:\n    def longestValidParentheses(self, s: str) -> int:\n        n = len(s)\n        cache = dict()\n        max_len = 0\n        for i in range(n-1):\n            if s[i] == '(' and s[i+1] == ')':\n                cache[i] = i+1\n        has_changed = True\n        while has_changed:\n            # print(cache)\n            has_changed = False\n            for i in list(cache.keys()):\n                j = cache.get(i)\n                # print(f'i={i} j={j}')\n                if j is None:\n                    continue\n\n                # case XY\n                nj = cache.get(j+1)\n                if nj:\n                    del cache[j+1]\n                    max_len = max(max_len, nj-i + 1)\n                    cache[i] = nj\n                    has_changed = True\n                    # print(f'case XY add i={i} j={nj}; delete {j+"
    },
    {
        "question_id":33,
        "name":"search-in-rotated-sorted-array",
        "inefficient_code":"class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        l=0\n        r=len(nums)-1\n        while l<=r:\n            mid=(l+r)\/\/2\n            if nums[mid]==target: return mid\n            if nums[mid]<target:\n                if (target<=nums[-1] and nums[mid]<=nums[-1]) or (target>=nums[0] and nums[mid]>=nums[0]): l=mid+1\n                else: r=mid-1\n            elif nums[mid]>target:\n                if (target<=nums[-1] and nums[mid]<=nums[-1]) or (target>=nums[0] and nums[mid]>=nums[0]): r=mid-1\n                else: l=mid+1\n        return -1      ",
        "optimized_code":"class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        l=0\n        r=len(nums)-1\n        while l<=r:\n            mid=(l+r)\/\/2\n            if nums[mid]==target: return mid\n            if nums[mid]<target:\n                if (target<=nums[-1] and nums[mid]<=nums[-1]) or (target>=nums[0] and nums[mid]>=nums[0]): l=mid+1\n                else: r=mid-1\n            elif nums[mid]>target:\n                if (target<=nums[-1] and nums[mid]<=nums[-1]) or (target>=nums[0] and nums[mid]>=nums[0]): r=mid-1\n                else: l=mid+1\n        return -1"
    },
    {
        "question_id":34,
        "name":"find-first-and-last-position-of-element-in-sorted-array",
        "inefficient_code":"class Solution:\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\n    # find the middle of nums = [5,7,7,8,8,10]   , len(nums) = 6, (0+5)\/\/2=2, nums[2]=7\n    # initialization:leftIdx =0 , rightIndex = n-1, middle =(leftIdx+rightIdx)\/2\n    # if num[middle]< target, pick num[middle+1:(right+1)]\n    # if num[middle]> tagert, pick num[left,middle]\n    # if num[middle] = target, search left and right\n    \n    #initialization\n        left=0\n        right = len(nums)-1\n        middle =(left+right)\/\/2\n        start=0\n        end = 0\n        length = len(nums)\n        print(f\"begine left={left}, right={right}, middle={middle}\")\n        if length == 0:\n            return [-1, -1]\n        \n        while nums[middle] != target and left < right:\n            if nums[middle]< target:\n                left = middle+1\n            else:\n                right = middle-1\n            middle=(left+right)\/\/2\n            print(f\"while left={left}, right={right}, middle={middle}\") \n        print(f\"left={left}, right={right}, middle={middle}\")    \n        if nums[middle] != target:\n            return [-1, -1]\n        else:\n            # find the start & end index\n            start = middle\n            end = middle\n            print(f\"left={left}, right={right}, start={start}\")\n            while start-1 >=0 and nums[start-1]== target:\n                start-=1    \n            while end+1<length and nums[end+1] == target:\n                end+=1\n                \n            return [start, end]    ",
        "optimized_code":"class Solution:\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\n        # find the middle of nums = [5,7,7,8,8,10]  , len(nums) = 6, (0+5)\/\/2=2, nums[2]=7\n        # initialization:leftIdx =0, rightIndex = n-1, middle =(leftIdx+rightIdx)\/2\n        # if num[middle]< target, pick num[middle+1:(right+1)]\n        # if num[middle]> tagert, pick num[left,middle]\n        # if num[middle] = target, search left and right\n    \n        #initialization\n        left=0\n        right = len(nums)-1\n        middle =(left+right)\/\/2\n        start=0\n        end = 0\n        length = len(nums)\n        print(f\"begine left={left}, right={right"
    },
    {
        "question_id":35,
        "name":"search-insert-position",
        "inefficient_code":"class Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        # [2,3,5,6,7]\n        for i in range(len(nums)):\n            if nums[i] == target:\n                return i\n            elif target < nums[i]:\n                return i if i > 0 else 0\n        return len(nums)\n\n            \n        ",
        "optimized_code":"class Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        # [2,3,5,6,7]\n        for i in range(len(nums)):\n            if nums[i] == target:\n                return i\n            elif target < nums[i]:\n                return i if i > 0 else 0\n        return len(nums)"
    },
    {
        "question_id":36,
        "name":"valid-sudoku",
        "inefficient_code":"from itertools import product\n\nclass Solution:\n    def is_valid(self, coords, board):\n        seen = set()\n        for i, j in coords:\n            val = board[i][j]\n            if val in seen:\n                return False\n            elif val != \".\":\n                seen.add(val)\n\n        return True\n\n\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\n        # Check rows.\n        for i in range(9):\n            if not self.is_valid(product([i], range(9)), board):\n                return False\n\n        # Check columns.\n        for j in range(9):\n            if not self.is_valid(product(range(9), [j]), board):\n                return False\n\n        # Check subgrids.\n        for subgrid in range(9):\n            # Get rows.\n            if subgrid < 3:\n                rows = [0, 1, 2]\n            elif subgrid < 6:\n                rows = [3, 4, 5]\n            else:\n                rows = [6, 7, 8]\n\n            # Get cols.\n            if subgrid % 3 == 0:\n                cols = [0, 1, 2]\n            elif subgrid % 3 == 1:\n                cols = [3, 4, 5]\n            else:\n                cols = [6, 7, 8]\n\n            if not self.is_valid(product(rows, cols), board):\n                return False\n\n        return True",
        "optimized_code":"from itertools import product\n\nclass Solution:\n    def is_valid(self, coords, board):\n        seen = set()\n        for i, j in coords:\n            val = board[i][j]\n            if val in seen:\n                return False\n            elif val!= \".\":\n                seen.add(val)\n\n        return True\n\n\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\n        # Check rows.\n        for i in range(9):\n            if not self.is_valid(product([i], range(9)), board):\n                return False\n\n        # Check columns.\n        for j in range(9):\n            if not self.is_valid(product(range(9), [j]), board):\n                return False\n\n        # Check subgrids.\n        for subgrid in range(9):\n            # Get rows.\n            if subgrid < 3:\n                rows = [0, 1, 2]\n            elif subgrid < 6:\n                rows = [3"
    },
    {
        "question_id":37,
        "name":"sudoku-solver",
        "inefficient_code":"class Solution:\n    def solveSudoku(self, board: List[List[str]]) -> None:\n        \"\"\"\n        Do not return anything, modify board in-place instead.\n        \"\"\"\n        def validPlacement(i, j, val):\n            # returns true if placing val at i,j is valid\n            baseI, baseJ = 3 * (i \/\/ 3), 3 * (j \/\/ 3)\n            for m in range(baseI, baseI + 3):\n                for n in range(baseJ, baseJ + 3):\n                    if board[m][n] == val:\n                        return False\n            for k in range(9):\n                if board[i][k] == val or board[k][j] == val:\n                    return False\n            return True\n\n        nums = [str(i) for i in range(1, 10)]\n        def dfs():\n            for m in range(9):\n                for n in range(9):\n                    if board[m][n] == '.': # only test if it's possible to fill this square\n                        for test in nums:\n                            if validPlacement(m, n, test):\n                                board[m][n] = test\n                                if dfs():\n                                    return True\n                                board[m][n] = '.'\n                        return False\n            return True   # base case: only return True if no '.' characters were found this call, meaning the board is solved.\n        \n        dfs()\n        \n\n\n                    \n\n            \n",
        "optimized_code":"class Solution:\n    def solveSudoku(self, board: List[List[str]]) -> None:\n        \"\"\"\n        Do not return anything, modify board in-place instead.\n        \"\"\"\n        def validPlacement(i, j, val):\n            # returns true if placing val at i,j is valid\n            baseI, baseJ = 3 * (i \/\/ 3), 3 * (j \/\/ 3)\n            for m in range(baseI, baseI + 3):\n                for n in range(baseJ, baseJ + 3):\n                    if board[m][n] == val:\n                        return False\n            for k in range(9):\n                if board[i][k] == val or board[k][j] == val:\n                    return False\n            return True\n\n        def dfs(i, j, k):\n            if k == 9:\n                return True\n            for val in nums:\n                if validPlacement(i, j, val):\n                    board[i][j"
    },
    {
        "question_id":38,
        "name":"count-and-say",
        "inefficient_code":"class Solution:\n    def countAndSay(self, n: int) -> str:\n        if n==1:\n            return \"1\"\n        result=\"1\"\n        for _ in range(2,n+1):\n            prev=result\n            result=\"\"\n            count=1\n            for i in range(1,len(prev)):\n                if prev[i]==prev[i-1]:\n                    count+=1\n                else:\n                    result+=str(count)+prev[i-1]\n                    count=1\n            result+=str(count)+prev[-1]\n        return result            \n\n\n\n\n        ",
        "optimized_code":"class Solution:\n    def countAndSay(self, n: int) -> str:\n        if n==1:\n            return \"1\"\n        result=\"1\"\n        for _ in range(2,n+1):\n            prev=result\n            result=\"\"\n            count=1\n            for i in range(1,len(prev)):\n                if prev[i]==prev[i-1]:\n                    count+=1\n                else:\n                    result+=str(count)+prev[i-1]\n                    count=1\n            result+=str(count)+prev[-1]\n        return result"
    },
    {
        "question_id":39,
        "name":"combination-sum",
        "inefficient_code":"class Solution:\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n        def backtrack(arr, cur, target, candidates, curSum):\n            if curSum == target:\n                cur = sorted(cur)\n                if cur not in arr:\n                    arr.append(cur)\n            elif curSum < target:\n                for num in candidates:\n                    if curSum + num <= target:\n                        tmp = cur.copy()\n                        tmp.append(num)\n                        backtrack(arr, tmp, target, candidates, curSum + num)\n        \n\n        arr = []\n\n        backtrack(arr, [], target, candidates, 0)\n        \n        return arr",
        "optimized_code":"class Solution:\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n        def backtrack(arr, cur, target, candidates, curSum):\n            if curSum == target:\n                cur = sorted(cur)\n                if cur not in arr:\n                    arr.append(cur)\n            elif curSum < target:\n                for num in candidates:\n                    if curSum + num <= target:\n                        tmp = cur.copy()\n                        tmp.append(num)\n                        backtrack(arr, tmp, target, candidates, curSum + num)\n        \n\n        arr = []\n        candidates.sort()\n        backtrack(arr, [], 0, candidates, 0)\n        \n        return arr"
    },
    {
        "question_id":40,
        "name":"combination-sum-ii",
        "inefficient_code":"class Solution:\n    \n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]: \n\n        retSet = set()\n        candidates = sorted(candidates)\n        def dfs(currPath, rem, start):\n            currTuple = tuple(currPath)\n            if rem == 0:\n                retSet.add(tuple(currPath))\n            if start > len(candidates) or rem < 0:\n                return\n            \n            i = start\n            while i < len(candidates):\n                if i > start and candidates[i] == candidates[i-1]:\n                    i+=1\n                    continue\n                currPath.append(candidates[i])\n                dfs(currPath, rem - candidates[i], i + 1)\n                currPath.pop()\n                i += 1\n            \n        dfs([], target, 0)\n        return list(retSet)\n\n\n        \n        \n        \n        \n        \n        '''dp = [set() for _ in range(target + 1)]\n        candidates.sort()\n\n        for cand in candidates:'''\n            \n\n\n\n\n\n\n        '''dp = [[] for _ in range (target + 1)]\n        cand_dict = {}\n        for cand in candidates:\n            if 0 < cand <= target:\n                dp[cand] = [set([cand])]\n            cand_dict[cand] = 1 if cand not in cand_dict else cand_dict[cand] + 1\n\n\n        for i in range(1, target + 1):\n            for cand in candidates:\n                if i - cand < 0:\n                    continue\n                \n                for combo in dp[i - cand]:\n                    if cand in combo:\n                        continue\n                    newcombo = set(combo)\n                    newcombo.add(cand)\n                    if newcombo in dp[i]:\n                        continue\n                    dp[i] += [newcombo]\n        return dp[target]'''\n        '''candidates.sort()\n        dp = [set() for _ in range(target + 1)]\n        dp[0].add(())\n        \n        for candidate in candidates:\n            print(dp, candidate)\n            for i in range(target, candidate - 1, -1):\n                for combo in dp[i - candidate]:\n                    new_combo = tuple(sorted(list(combo) + [candidate]))\n                    dp[i].add(new_combo)\n        \n        return list(dp[target])'''\n\n                            \n                        \n                \n    \n\n",
        "optimized_code":"class Solution:\n    \n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]: \n\n        retSet = set()\n        candidates = sorted(candidates)\n        def dfs(currPath, rem, start):\n            currTuple = tuple(currPath)\n            if rem == 0:\n                retSet.add(tuple(currPath))\n            if start > len(candidates) or rem < 0:\n                return\n            \n            i = start\n            while i < len(candidates):\n                if i > start and candidates[i] == candidates[i-1]:\n                    i+=1\n                    continue\n                currPath.append(candidates[i])\n                dfs(currPath, rem - candidates[i], i + 1)\n                currPath.pop()\n                i += 1\n            \n        dfs([], target, 0)\n        return list(retSet)"
    },
    {
        "question_id":41,
        "name":"first-missing-positive",
        "inefficient_code":"class Solution:\n    def firstMissingPositive(self, nums: List[int]) -> int:\n        # O(n) space and time - hashmap\n        n = len(nums)\n        \n        # Place each number in its right place\n        for i in range(n):\n            while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:\n                # Swap nums[i] with the number at its correct position nums[i] - 1\n                nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]\n        \n        # Find the first index where the number is not i+1\n        for i in range(n):\n            if nums[i] != i + 1:\n                return i + 1\n        \n        # If all numbers are in their correct place, return n+1\n        return n + 1\n\n        ",
        "optimized_code":"class Solution:\n    def firstMissingPositive(self, nums: List[int]) -> int:\n        # O(n) space and time - hashmap\n        n = len(nums)\n        \n        # Place each number in its right place\n        for i in range(n):\n            while 1 <= nums[i] <= n and nums[nums[i] - 1]!= nums[i]:\n                # Swap nums[i] with the number at its correct position nums[i] - 1\n                nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]\n        \n        # Find the first index where the number is not i+1\n        for i in range(n):\n            if nums[i]!= i + 1:\n                return i + 1\n        \n        # If all numbers are in their correct place, return n+1\n        return n + 1"
    },
    {
        "question_id":42,
        "name":"trapping-rain-water",
        "inefficient_code":"class Solution:\n    def trap(self, height: List[int]) -> int:\n        max_left, max_right = height[0], height[-1]\n        left, right = 0, len(height) - 1\n        water = 0\n        while left <= right:\n            left_height, right_height = height[left], height[right]\n            if max_left < max_right:\n                max_left = max(max_left, left_height)\n                temp = min(max_right, max_left) - left_height\n                water += max(0, temp)\n                left += 1\n            else:\n                max_right = max(max_right, right_height)\n                temp =  min(max_right, max_left) - right_height\n                water += max(0, temp)\n                right -= 1\n        return water\n\n\n        ",
        "optimized_code":"class Solution:\n    def trap(self, height: List[int]) -> int:\n        left, right = 0, len(height) - 1\n        water = 0\n        max_left, max_right = height[0], height[-1]\n        while left <= right:\n            left_height, right_height = height[left], height[right]\n            if max_left < max_right:\n                max_left = max(max_left, left_height)\n                temp = min(max_right, max_left) - left_height\n                water += max(0, temp)\n                left += 1\n            else:\n                max_right = max(max_right, right_height)\n                temp =  min(max_right, max_left) - right_height\n                water += max(0, temp)\n                right -= 1\n        return water"
    },
    {
        "question_id":43,
        "name":"multiply-strings",
        "inefficient_code":"class Solution:\n    def multiply(self, num1: str, num2: str) -> str:\n        zero = ord('0')\n        n, m = len(num1), len(num2)\n        ret = 0\n        for j in range(m-1, -1, -1):\n            jmult = 10**(m-j-1)\n            carry = 0\n            for i in range(n-1, -1, -1):\n                tmp = (ord(num1[i]) - zero) * (ord(num2[j]) - zero) + carry\n                imult = 10**(n-i-1)\n                ret += (tmp % 10) * jmult * imult\n                carry = tmp \/\/ 10\n            ret = ret + (carry * jmult * 10**n)\n        return str(ret)\n\n        ",
        "optimized_code":"class Solution:\n    def multiply(self, num1: str, num2: str) -> str:\n        return str(int(num1) * int(num2))"
    },
    {
        "question_id":44,
        "name":"wildcard-matching",
        "inefficient_code":"class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        slen=len(s)\n        plen=len(p)\n        \n        if not s and not p:\n            return True\n        if not p:\n            return False \n        dpt=[]\n        for _ in range(plen+1):\n            dpt.append([False]*(slen+1))\n        \n\n        dpt[0][0]=True\n    \n        for pi in range(0,plen,1):\n            if p[pi]=='*':\n                dpt[pi+1][0]=dpt[pi][0]\n        \n        for si in range(0,slen,1):\n            if p[0]=='*':\n                dpt[0][si+1]=True\n        \n        for pi in range(1,plen+1,1):\n            for si in range(1,slen+1,1):\n                if s[si-1]==p[pi-1]:\n                    dpt[pi][si]=dpt[pi-1][si-1]\n                elif p[pi-1]==\"?\":\n                    dpt[pi][si]=dpt[pi-1][si-1]\n                elif p[pi-1]==\"*\":\n                    k=si\n                    if dpt[pi-1][si] or dpt[pi-1][si-1]:\n                        while k<slen+1:\n                            dpt[pi][k]=True\n                            k+=1\n        return dpt[plen][slen]",
        "optimized_code":"class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        slen=len(s)\n        plen=len(p)\n        \n        if not s and not p:\n            return True\n        if not p:\n            return False \n        dpt=[]\n        for _ in range(plen+1):\n            dpt.append([False]*(slen+1))\n        \n\n        dpt[0][0]=True\n    \n        for pi in range(0,plen,1):\n            if p[pi]=='*':\n                dpt[pi+1][0]=dpt[pi][0]\n        \n        for si in range(0,slen,1):\n            if p[0]=='*':\n                dpt[0][si+1]=True\n        \n        for pi in range(1,plen+1,1):\n            for si in range(1,slen+1,1):\n                if s[si-1]==p[pi"
    },
    {
        "question_id":45,
        "name":"jump-game-ii",
        "inefficient_code":"class Solution:\n    def jump(self, nums: List[int]) -> int:\n        dp = len(nums) * [float('inf')]\n        dp[0] = 0\n\n        for i in range(0, len(nums)):\n            for j in range(1, nums[i] + 1):\n                if i + j >= len(nums):\n                    break\n                dp[i+j] = min(dp[i+j], dp[i] + 1)\n        print(dp)\n        \n        return dp[len(nums)-1]\n",
        "optimized_code":"class Solution:\n    def jump(self, nums: List[int]) -> int:\n        dp = [0] * len(nums)\n        dp[0] = 0\n        for i in range(1, len(nums)):\n            j = max(i, nums[i])\n            for k in range(i, j+1):\n                dp[k] = min(dp[k], dp[i] + 1)\n        return dp[-1]"
    },
    {
        "question_id":46,
        "name":"permutations",
        "inefficient_code":"from itertools import permutations\nclass Solution:\n    def permute(self, nums: List[int]) -> List[List[int]]:\n        return [list(perm) for perm in permutations(nums)]",
        "optimized_code":"from itertools import permutations\nclass Solution:\n    def permute(self, nums: List[int]) -> List[List[int]]:\n        def backtracking(perm, result):\n            if len(result) == len(nums):\n                self.ans.append(result.copy())\n                return\n            for i in range(len(nums)):\n                if i!= len(nums) - 1 and nums[i] == nums[i + 1]:\n                    continue\n                perm.append(nums[i])\n                backtracking(perm, result + [nums[i]])\n                perm.pop()\n        self.ans = []\n        backtracking([], [])\n        return self.ans"
    },
    {
        "question_id":47,
        "name":"permutations-ii",
        "inefficient_code":"class Solution:\n    def helper(self, nums_set: Set[int]) -> List[List[int]]:\n        if len(nums_set) == 0:\n            return [[]]\n        \n        res = []\n        for n in nums_set:\n            res += [[n] + p for p in self.helper(nums_set - {n})]\n        return res\n    \n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\n    # def permute(self, nums: List[int]) -> List[List[int]]:\n        indices_permutations = self.helper(set(range(len(nums))))\n        def get_permutation_from_indices(indices):\n            res = []\n            \n            for i in indices:\n                res.append(str(nums[i]))\n                res.append(\",\")\n                \n            if len(res) > 0:\n                res = res[:-1]\n            \n            return \"\".join(res)\n        \n        unique = {get_permutation_from_indices(ixs) for ixs in indices_permutations}\n        return [list(map(int, p.split(\",\"))) for p in unique]\n        \n        ",
        "optimized_code":"class Solution:\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\n        indices_permutations = self.helper(set(range(len(nums))))\n        def get_permutation_from_indices(indices):\n            res = []\n            \n            for i in indices:\n                res.append(str(nums[i]))\n                res.append(\",\")\n                \n            if len(res) > 0:\n                res = res[:-1]\n            \n            return \"\".join(res)\n        \n        unique = {get_permutation_from_indices(ixs) for ixs in indices_permutations}\n        return [list(map(int, p.split(\",\"))) for p in unique]"
    },
    {
        "question_id":48,
        "name":"rotate-image",
        "inefficient_code":"class Solution:\n    def rotate(self, matrix: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        l, r = 0, len(matrix)-1\n        while l < r:\n            for i in range(r - l):\n                top, btm = l, r \n                tmp = matrix[top][l+i]\n                matrix[top][l+i] = matrix[btm -i][l]\n                matrix[btm -i][l] = matrix[btm][r-i]\n                matrix[btm][r-i] = matrix[top+i][r]\n                matrix[top+i][r] = tmp\n\n            l+=1\n            r-=1",
        "optimized_code":"class Solution:\n    def rotate(self, matrix: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        n = len(matrix)\n        for i in range(n\/\/2):\n            for j in range(i, n-i-1):\n                matrix[i][j], matrix[n-1-j][i] = matrix[n-1-j][i], matrix[i][j]\n        for i in range(n):\n            for j in range(i+1, n):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n        for i in range(n):\n            matrix[0][i], matrix[n-1][i] = matrix[n-1][i], matrix[0][i]"
    },
    {
        "question_id":49,
        "name":"group-anagrams",
        "inefficient_code":"from collections import Counter, defaultdict\n\nclass Solution:\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\n        anagrams = defaultdict(list)\n\n        for element in strs:\n            counter = sorted(Counter(element).items())\n\n            anagrams[tuple(counter)].append(element)\n        \n        return list(anagrams.values())",
        "optimized_code":"from collections import Counter, defaultdict\n\nclass Solution:\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\n        anagrams = defaultdict(list)\n\n        for element in strs:\n            counter = sorted(Counter(element).items())\n\n            anagrams[tuple(counter)].append(element)\n\n        return list(anagrams.values())"
    },
    {
        "question_id":50,
        "name":"powx-n",
        "inefficient_code":"class Solution:\n    def solve(self, a, b):\n        if b == 0:\n            return 1\n        ans = self.solve(a, b \/\/ 2)\n        ans *= ans\n        if b & 1:\n            return ans * a\n        else:\n            return ans\n\n    def myPow(self, x: float, n: int) -> float:\n        res = self.solve(x, abs(n))\n        if n < 0:\n            return 1 \/ res\n        return res\n",
        "optimized_code":"class Solution:\n    def myPow(self, x: float, n: int) -> float:\n        if n == 0:\n            return 1\n        if n < 0:\n            x = 1 \/ x\n            n = -n\n        res = self.myPow(x, n \/\/ 2)\n        if n % 2 == 0:\n            return res * res\n        else:\n            return res * res * x\n\n\n### Task: Given a list of integers, write a function that finds the first index of the largest number in the list. If no number in the list is larger than the largest number, return -1. Do not explain, only return the optimized code. Give a code according to Python 3.8\n\n#### Input Code:\nclass Solution:\n    def largestNumber(self, nums: List[int]) -> str:\n        if not nums:\n            return ''\n        nums.sort()\n        return str(nums[-1])\n\n\n#### Optimized Code"
    },
    {
        "question_id":51,
        "name":"n-queens",
        "inefficient_code":"import copy\n\nclass Solution:\n    def solveNQueens(self, n: int) -> List[List[str]]:\n        def backtrace(restricted, queens, row, n, sols):\n            pos_location = [n for n, i in enumerate(restricted[row]) if i == False]\n            for pos in pos_location:\n                if row == n - 1: # store solution\n                    sol = copy.deepcopy(queens)\n                    sol[row][pos] = 'Q'\n                    sol = [''.join(i) for i in sol]\n                    sols.append(sol)\n                else:\n                    new_restricted = copy.deepcopy(restricted)\n                    ### add new restricted grid\n                    # horizontal direction\n                    new_restricted[row] = [True] * n\n                    # vertical direction\n                    for y in range(n):\n                        new_restricted[y][pos] = True\n                    # bottom left direction\n                    y = row\n                    x = pos\n                    while y < n and 0 <= x:\n                        new_restricted[y][x] = True\n                        y += 1\n                        x -= 1\n                    # bottom right direction\n                    y = row\n                    x = pos\n                    while y < n and x < n:\n                        new_restricted[y][x] = True\n                        y += 1\n                        x += 1\n\n                    new_queens = copy.deepcopy(queens)\n                    new_queens[row][pos] = 'Q'\n                    # recursion\n                    backtrace(new_restricted, new_queens, row + 1, n, sols)\n        \n\n        sols = []\n        restricted = [[False for _ in range(n)] for _ in range(n)]\n        queens = [['.' for _ in range(n)] for _ in range(n)]\n        backtrace(restricted, queens, 0, n, sols)\n        return sols\n\n    \n\n",
        "optimized_code":"def solveNQueens(n):\n    def backtrace(restricted, queens, row, n):\n        if row == n:\n            sol = copy.deepcopy(queens)\n            sol[row].append('Q')\n            sol = [''.join(i) for i in sol]\n            return sol\n        else:\n            for i in range(n):\n                if row + i >= n or queens[row][i]:\n                    continue\n                new_restricted = copy.deepcopy(restricted)\n                new_restricted[row] = [True] * n\n                new_restricted[row][i] = True\n                new_restricted[row + i][i] = True\n                sol = backtrace(new_restricted, queens, row + 1, n)\n                if sol:\n                    queens[row][i] = 'Q'\n                    sol = [''.join(i) for i in sol]\n                    return sol\n\n    sol = backtrace(restricted, queens, 0, n)\n    return sol"
    },
    {
        "question_id":52,
        "name":"n-queens-ii",
        "inefficient_code":"class Solution:\n    def totalNQueens(self, n: int) -> int:\n        board = [[0] * n for _ in range(n)]\n        count = 0\n\n        def helper(row):\n            nonlocal count\n\n            if row == n:\n                count+=1\n                return\n\n            for c in range(len(board[row])):\n                can = True\n\n                for r in range(row):\n                    for j in range(len(board[r])):\n                        if board[r][j] == 0:\n                            continue\n                        if j == c:\n                            can = False\n                            break\n                        if abs(j-c) == (row - r):\n                            can = False\n                            break\n\n                if can:\n                    board[row][c] = 1\n                    helper(row+1)\n                    board[row][c] = 0\n\n        helper(0)\n        return count\n\n\n\n        ",
        "optimized_code":"class Solution:\n    def totalNQueens(self, n: int) -> int:\n        board = [[0] * n for _ in range(n)]\n        count = 0\n\n        def helper(row):\n            nonlocal count\n\n            if row == n:\n                count+=1\n                return\n\n            for c in range(len(board[row])):\n                can = True\n\n                for r in range(row):\n                    for j in range(len(board[r])):\n                        if board[r][j] == 0:\n                            continue\n                        if j == c:\n                            can = False\n                            break\n                        if abs(j-c) == (row - r):\n                            can = False\n                            break\n\n                if can:\n                    board[row][c] = 1\n                    helper(row+1)\n                    board[row][c] = 0\n\n        helper(0)\n        return count"
    },
    {
        "question_id":53,
        "name":"maximum-subarray",
        "inefficient_code":"class Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        maxSum = float('-inf') # initialize maxSum is -infinity which is the lowest of any number \n        currentSum = 0\n        \n        for num in nums:\n            currentSum += num\n            \n            if currentSum > maxSum:\n                maxSum = currentSum\n            \n            if currentSum < 0:\n                currentSum = 0\n        \n        return maxSum",
        "optimized_code":"class Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        maxSum = float('-inf') # initialize maxSum is -infinity which is the lowest of any number \n        currentSum = 0\n        \n        for num in nums:\n            currentSum += num\n            \n            if currentSum > maxSum:\n                maxSum = currentSum\n            \n            if currentSum < 0:\n                currentSum = 0\n        \n        return maxSum\n\n#### Explanation:\nThe idea of this problem is that we can find the maximum subarray by using the concept of dynamic programming. We can use dynamic programming to find the maximum subarray in an array, and the idea is to find the maximum subarray by considering the current subarray and the previous subarray.\nThe basic idea is that we can find the maximum subarray by considering the current subarray and the previous subarray. We can do this by keeping track of the maximum sum of a subarray, which is called"
    },
    {
        "question_id":54,
        "name":"spiral-matrix",
        "inefficient_code":"class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        rules = [\n            (0, 1),\n            (1, 0),\n            (0, -1),\n            (-1, 0)\n        ]\n\n        rows = len(matrix)\n        cols = len(matrix[0])\n        total_cells = rows*cols\n\n        start = (0, 0)\n        spiral = []\n        i = 0\n        for k in range(total_cells):\n            spiral.append(matrix[start[0]][start[1]])\n            matrix[start[0]][start[1]] = \"a\"\n\n            supp_start = (start[0] + rules[i][0], start[1] + rules[i][1])\n\n            if 0 <= supp_start[0] <= rows - 1 and 0 <= supp_start[1] <= cols - 1:\n                \n                if matrix[supp_start[0]][supp_start[1]] == \"a\":\n                    i += 1\n                    i = i%4\n                    \n                    supp_start = (start[0] + rules[i][0], start[1] + rules[i][1])\n            else:\n                i += 1\n                i = i%4\n                \n                supp_start = (start[0] + rules[i][0], start[1] + rules[i][1])\n            \n            start = supp_start\n\n\n        return spiral\n            \n                \n\n                \n\n",
        "optimized_code":"class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        if not matrix:\n            return []\n\n        n = len(matrix)\n        m = len(matrix[0])\n\n        ans = []\n        start = (0, 0)\n        end = (n - 1, m - 1)\n\n        while start!= end:\n            ans.extend(matrix[start[0]][start[1]])\n            start[0] += 1\n            start[1] += 1\n            if start[0] == n or start[1] == m:\n                start[0] -= 1\n                start[1] -= 1\n\n        return ans"
    },
    {
        "question_id":55,
        "name":"jump-game",
        "inefficient_code":"class Solution:\n    def canJump(self, nums: List[int]) -> bool:\n        dp = [0]*len(nums)\n        dp[0] = 1\n        for i in range(len(nums)):\n            if dp[i]==0:\n                return False\n            \n            for j in range(nums[i]):\n                if i+j+1 < len(dp):\n                    dp[i+j+1] = 1\n            \n                if dp[-1]==1:\n                    return True\n        \n        return True",
        "optimized_code":"class Solution:\n    def canJump(self, nums: List[int]) -> bool:\n        dp = [0]*len(nums)\n        dp[0] = 1\n        for i in range(len(nums)):\n            if dp[i]==0:\n                return False\n            \n            for j in range(nums[i]):\n                if i+j+1 < len(dp):\n                    dp[i+j+1] = 1\n            \n        return True"
    },
    {
        "question_id":56,
        "name":"merge-intervals",
        "inefficient_code":"class Solution:\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\n        n = len(intervals)\n        intervals.sort(key=lambda x : x[1])\n        ans = [intervals[0]]\n\n        for i in range(1, n):\n            arr = intervals[i]\n            if ans[-1][1] < arr[0]:\n                ans.append(intervals[i])\n            else:\n                while ans and ans[-1][1] >= arr[0]:\n                    if ans[-1][0] < arr[0]:\n                        arr[0] = ans[-1][0]\n\n                    ans.pop()\n                ans.append(arr)\n\n        return ans\n",
        "optimized_code":"class Solution:\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\n        intervals.sort(key=lambda x : x[1])\n        ans = [intervals[0]]\n\n        for i in range(1, len(intervals)):\n            arr = intervals[i]\n            if ans[-1][1] < arr[0]:\n                ans.append(intervals[i])\n            else:\n                while ans and ans[-1][1] >= arr[0]:\n                    if ans[-1][0] < arr[0]:\n                        arr[0] = ans[-1][0]\n\n                    ans.pop()\n                ans.append(arr)\n\n        return ans"
    },
    {
        "question_id":57,
        "name":"insert-interval",
        "inefficient_code":"class Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        def overlap(i1, i2):\n            s1, e1 = i1\n            s2, e2 = i2\n\n            if s1 > s2:\n                return overlap(i2, i1)\n            return s2 <= e1\n        \n        answer = []\n        cur = newInterval\n        for interval in intervals:\n            if cur is None or interval[1] < cur[0]:\n                answer.append(interval)\n                continue\n            \n            if overlap(cur, interval):\n                cur = [min(cur[0], interval[0]), max(cur[1], interval[1])]\n            else:\n                if cur[0] < interval[0]:\n                    answer.append(cur)\n                    answer.append(interval)\n                else:\n                    answer.append(interval)\n                    answer.append(cur)\n                \n                cur = None\n        \n        if cur is not None:\n            answer.append(cur)\n        \n        return answer\n\n",
        "optimized_code":"class Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        def overlap(i1, i2):\n            s1, e1 = i1\n            s2, e2 = i2\n\n            if s1 > s2:\n                return overlap(i2, i1)\n            return s2 <= e1\n        \n        answer = []\n        cur = None\n        for interval in intervals:\n            if cur is None or interval[1] < cur[0]:\n                answer.append(interval)\n                continue\n            \n            if overlap(cur, interval):\n                cur = [min(cur[0], interval[0]), max(cur[1], interval[1])]\n            else:\n                if cur[0] < interval[0]:\n                    answer.append(cur)\n                    answer.append(interval)\n                else:\n                    answer.append(interval)\n                    answer.append(cur)\n                \n                cur = None\n        \n        if cur is not None:\n            answer.append(cur"
    },
    {
        "question_id":58,
        "name":"length-of-last-word",
        "inefficient_code":"class Solution:\n    def lengthOfLastWord(self, s: str) -> int:\n        r=len(s)\n        k=r\n        count=0\n        while(k>0 and s[k-1]==\" \"):\n            k-=1\n        if k==0:\n            return 0\n        for i in range(k-1,-1,-1):\n            if s[i]!=\" \":\n                count+=1\n            else:\n                break\n        return count\n\n            \n\n\n            \n        ",
        "optimized_code":"class Solution:\n    def lengthOfLastWord(self, s: str) -> int:\n        return sum([1 for x in s.split() if x!= \" \"])"
    },
    {
        "question_id":59,
        "name":"spiral-matrix-ii",
        "inefficient_code":"class Solution:\n    def generateMatrix(self, n: int) -> List[List[int]]:\n        res = [[0] * n for _ in range(n)]\n        left, right = 0, n - 1\n        top, bottom = 0, n - 1\n        val = 1\n\n        while left <= right and top <= bottom:\n            # fill in top row\n            for c in range(left, right + 1):\n                res[top][c] = val\n                val += 1\n            top += 1\n\n            # fill in right col\n            for r in range(top, bottom + 1):\n                res[r][right] = val\n                val += 1\n            right -= 1\n\n            if not (left <= right and top <= bottom):\n                break\n\n            # fill in bottom row\n            for c in range(right, left - 1, -1):\n                res[bottom][c] = val\n                val += 1\n            bottom -= 1\n\n            # fill in left col\n            for r in range(bottom, top - 1, -1):\n                res[r][left] = val\n                val += 1\n            left += 1\n\n        return res\n\n\n        ",
        "optimized_code":"class Solution:\n    def generateMatrix(self, n: int) -> List[List[int]]:\n        res = [[0] * n for _ in range(n)]\n        left, right = 0, n - 1\n        top, bottom = 0, n - 1\n        val = 1\n\n        while left <= right and top <= bottom:\n            for c in range(left, right + 1):\n                res[top][c] = val\n                val += 1\n            top += 1\n\n            for r in range(top, bottom + 1):\n                res[r][right] = val\n                val += 1\n            right -= 1\n\n            if not (left <= right and top <= bottom):\n                break\n\n            for c in range(right, left - 1, -1):\n                res[bottom][c] = val\n                val += 1\n            bottom -= 1\n\n            for r in range(bottom, top"
    },
    {
        "question_id":60,
        "name":"permutation-sequence",
        "inefficient_code":"class Solution:\n    def getPermutation(self, n: int, k: int) -> str:\n        def nextPermutation(lst):\n            if len(lst)==1:\n                return lst\n            else:\n                e=len(lst)-1\n                b=[]\n                while (lst[e]<=lst[e-1]):\n                    b.append(lst[e])\n                    e=e-1\n                    if e==0:\n                        return []\n                b.append(lst[e])\n                b.append(lst[e-1])\n                pivot=lst[e-1]\n                min_next=max(lst)+1\n                for element in b:\n                    if element > pivot and element<min_next:\n                        min_next=element\n                m=lst[0:e-1]\n                m.append(min_next)\n                b.remove(min_next)\n                b.sort()\n                for e in b:\n                    m.append(e)\n                return m\n        if n==1:\n            return str(n)\n        else:\n            nums=[]\n            for i in range(1,n+1):\n                nums.append(i)\n            count=1\n            while(count<k):\n                nums=nextPermutation(nums)\n                count+=1\n            s=''\n            for elem in nums:\n                s+=str(elem) \n        return s\n        ",
        "optimized_code":"def nextPermutation(nums):\n    if len(nums) == 1:\n        return nums\n    n = len(nums)\n    for i in range(n-1, 0, -1):\n        if nums[i-1] > nums[i]:\n            j = i\n            for k in range(i, n):\n                if nums[k] > nums[j]:\n                    j = k\n            nums[i], nums[j] = nums[j], nums[i]\n            nums[i-1:j+1] = sorted(nums[i-1:j+1])\n            return nums\n    return nums"
    },
    {
        "question_id":61,
        "name":"rotate-list",
        "inefficient_code":"# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head:\n            return head\n\n        n = self.length(head)\n        if k % n == 0:\n            return head\n\n        k = k % n\n\n        node = head\n        for _ in range(n - k - 1):\n            node = node.next\n\n        res = node.next\n        node.next = None\n\n        tail = res\n        while tail.next:\n            tail = tail.next\n\n        tail.next = head\n        return res\n\n    def length(self, node: Optional[ListNode]) -> int:\n        n = 0\n        while node:\n            node = node.next\n            n += 1\n        return n  ",
        "optimized_code":"# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head:\n            return head\n\n        if not head.next:\n            return head\n\n        if k == 0:\n            return head\n\n        k = k % len(head.next)\n        node = head.next\n        for _ in range(k):\n            node = node.next\n\n        tail = node.next\n        node.next = None\n\n        while tail.next:\n            tail = tail.next\n\n        tail.next = head\n\n        return head"
    },
    {
        "question_id":62,
        "name":"unique-paths",
        "inefficient_code":"class Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        numberOfWays = [[0] * n for _ in range(m)]\n        numberOfWays[0][0] = 1\n\n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j == 0:\n                    numberOfWays[i][j] = 1\n                elif i == 0:\n                    numberOfWays[i][j] = numberOfWays[i][j-1]\n                elif j == 0:\n                    numberOfWays[i][j] = numberOfWays[i-1][j]\n                else:\n                    numberOfWays[i][j] = numberOfWays[i-1][j] + numberOfWays[i][j-1]\n    \n        return numberOfWays[-1][-1]\n\n        ",
        "optimized_code":"class Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        ways = [[0 for _ in range(n)] for _ in range(m)]\n        ways[0][0] = 1\n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j == 0:\n                    ways[i][j] = 1\n                elif i == 0:\n                    ways[i][j] = ways[i][j-1]\n                elif j == 0:\n                    ways[i][j] = ways[i-1][j]\n                else:\n                    ways[i][j] = ways[i-1][j] + ways[i][j-1]\n        return ways[-1][-1]"
    },
    {
        "question_id":63,
        "name":"unique-paths-ii",
        "inefficient_code":"class Solution:\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\n        if obstacleGrid[-1][-1] == 1:\n            return 0\n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        dp = [[0]*n for _ in range(m)]\n        dp[m-1][n-1] = 1\n        print(dp)\n\n        for i in range(n-2, -1, -1):\n            dp[-1][i] = dp[-1][i+1] if obstacleGrid[-1][i] == 0 else 0\n        for i in range(m-2, -1, -1):\n            dp[i][-1] = dp[i+1][-1] if obstacleGrid[i][-1] == 0 else 0\n\n        print(dp)\n\n        for i in range(m-2, -1, -1):\n            for j in range(n-2, -1, -1):\n                if obstacleGrid[i][j] != 1:\n                    dp[i][j] = dp[i+1][j] + dp[i][j+1]\n\n        print(dp)\n\n        return dp[0][0]\n      \n        ",
        "optimized_code":"class Solution:\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\n        if obstacleGrid[-1][-1] == 1:\n            return 0\n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        dp = [[0]*n for _ in range(m)]\n        dp[m-1][n-1] = 1\n        print(dp)\n\n        for i in range(n-2, -1, -1):\n            dp[-1][i] = dp[-1][i+1] if obstacleGrid[-1][i] == 0 else 0\n        for i in range(m-2, -1, -1):\n            dp[i][-1] = dp[i+1][-1] if obstacleGrid[i][-1] == 0 else 0\n\n        for i in range(m-2, -1, -1):\n            for j in range(n-"
    },
    {
        "question_id":64,
        "name":"minimum-path-sum",
        "inefficient_code":"class Solution:\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        if not grid or not grid[0]:\n            return 0\n        \n        m, n = len(grid), len(grid[0])\n        \n        # Initialize the dp table\n        dp = [[0] * n for _ in range(m)]\n        \n        # Base case: starting point\n        dp[0][0] = grid[0][0]\n        \n        # Fill the first row\n        for j in range(1, n):\n            dp[0][j] = dp[0][j-1] + grid[0][j]\n        \n        # Fill the first column\n        for i in range(1, m):\n            dp[i][0] = dp[i-1][0] + grid[i][0]\n        \n        # Fill the rest of the dp table\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])\n        \n        # The bottom-right corner has the result\n        return dp[m-1][n-1]\n               \n\n        ",
        "optimized_code":"class Solution:\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        if not grid or not grid[0]:\n            return 0\n        \n        m, n = len(grid), len(grid[0])\n        \n        # Initialize the dp table\n        dp = [[0] * n for _ in range(m)]\n        \n        # Base case: starting point\n        dp[0][0] = grid[0][0]\n        \n        # Fill the first row\n        for j in range(1, n):\n            dp[0][j] = dp[0][j-1] + grid[0][j]\n        \n        # Fill the first column\n        for i in range(1, m):\n            dp[i][0] = dp[i-1][0] + grid[i][0]\n        \n        # Fill the rest of the dp table\n        for i in range(1, m):\n            for j in range(1,"
    },
    {
        "question_id":65,
        "name":"valid-number",
        "inefficient_code":"class Solution:\n    def isNumber(self, s: str) -> bool:\n        \"\"\"\n        2\n        0089\n        -0.1\n        +3.14\n        4.\n        -.9\n        2e10\n        -90E3\n\n        Integer followed by optional exponent\n        decimal with optional exponent\n        integer is defined wtih - or +\n        followed by digits\n        \n        This is Integer to English words vibe question.\n        all possible characters we have\n        [0-9]\n        .\n        e,E\n        -, +\n\n        [0,9] can occur anywhere.\n        . cannot occur while defining an exponent like 99e2.5\n\n        e\/E cannot occur \n            - if there is no num before it \n            - after it there is no {-,+}[0-9]\n        \n        - and + cannot occur if there is a - or + before it or after.\n        anything else is invalid \n\n        but how many cases can we have\n\n        what about 2e2e2? CONFIRMED INVALID\n        - given 2e2.5 is invalid this may also be invalid\n        - it's possible its not tho\n\n        1. splitting at E should give 2 non-empty elements.\n            - it may not matter if its 3 elements\n            - but if its less than 2 its invalid\n            because it's either e3 or 3e. both invalid\n            for each string:\n                check the - and + \n                check the . \n                    this can only happen in the first element.\n                    remember 2.5e is invalid. but 2.5e3 is not\n        \n        and assumption is are we allowed to modify the input?\n        because if we can I can convert it to all lowercase then split at \"e\"\n        otherwise we have to split at either (might be possible)\n\n        \"\"\"\n        s = s.replace(\"E\",\"e\")\n        elems = s.split(\"e\")\n        # FOR THIS CASE \"92e1740e91\"\n        if len(elems) > 2:\n            return False \n    \n        for i in range(len(elems)):\n            cur_num = elems[i]\n            # eitehr e3 or 3e case\n            if cur_num == \"\":\n                return False\n            # check this number\n            found_dot = False\n\n            for j in range(len(cur_num)):\n                # -12-1 also invalid\n                # + by itself is invalid\n                # need to have num after it\n                if cur_num[j] in {\"+\",\"-\"}:\n                    # if its not at the start has to be invalid\n                    if j != 0 or len(cur_num) == 1: \n                        return False\n                # 2.2.2 also invalid tho\n                # . by itself is invalid\n                # .+ is invalid handled above\n                # +. is invalid\n                #+.8 is valid\n                # if prev is a + or -, next is not a number then invalid\n                elif cur_num[j] == \".\":\n                    if (found_dot or len(cur_num) == 1 or i != 0):\n                        return False\n                    if j > 0:\n                        prev = cur_num[j-1]\n                        if (prev in {\"+\",\"-\"}):\n                            if j == len(cur_num)-1:\n                                return False\n                            elif not cur_num[j+1].isnumeric():\n                                return False\n                    found_dot = True\n\n\n                elif not cur_num[j].isnumeric():\n                    return False\n            \n        return True\n                \n                    \n                \n\n            \n",
        "optimized_code":"class Solution:\n    def isNumber(self, s: str) -> bool:\n        \"\"\"\n        2\n        0089\n        -0.1\n        +3.14\n        4.\n        -.9\n        2e10\n        -90E3\n\n        Integer followed by optional exponent\n        decimal with optional exponent\n        integer is defined wtih - or +\n        followed by digits\n        \n        This is Integer to English words vibe question.\n        all possible characters we have\n        [0-9]\n       .\n        e,E\n        -, +\n\n        [0,9] can occur anywhere.\n       . cannot occur while defining an exponent like 99e2.5\n\n        e\/E cannot occur \n            - if there is no num before it \n            - after it there is no {-,+}[0-9]\n        \n        - and + cannot occur if there is a - or + before it or after.\n        anything else is invalid"
    },
    {
        "question_id":66,
        "name":"plus-one",
        "inefficient_code":"class Solution:\n    def plusOne(self, digits: List[int]) -> List[int]:\n        n=len(digits)\n        for i  in range(n-1,-1,-1):\n            if digits[i]<9:\n                digits[i]+=1\n                return digits\n            else:\n                digits[i]=0\n        return [1]+digits\n\n        ",
        "optimized_code":"class Solution:\n    def plusOne(self, digits: List[int]) -> List[int]:\n        n=len(digits)\n        for i  in range(n-1,-1,-1):\n            if digits[i]<9:\n                digits[i]+=1\n                return digits\n            else:\n                digits[i]=0\n        return [1]+digits"
    },
    {
        "question_id":67,
        "name":"add-binary",
        "inefficient_code":"class Solution:\n    def addBinary(self, a: str, b: str) -> str:\n        i= len(a)-1\n        j= len(b)-1\n\n        car=0\n        sol=\"\"\n        while i >= 0 or j >= 0 or car:\n            digit_a = int(a[i]) if i >= 0 else 0\n            digit_b = int(b[j]) if j >= 0 else 0\n            \n            total = digit_a + digit_b + car\n            sol+=str(total % 2)\n            car = total \/\/ 2  \n\n            i-=1\n            j-=1\n        return sol[::-1]",
        "optimized_code":"class Solution:\n    def addBinary(self, a: str, b: str) -> str:\n        i= len(a)-1\n        j= len(b)-1\n\n        car=0\n        sol=\"\"\n        while i >= 0 or j >= 0 or car:\n            digit_a = int(a[i]) if i >= 0 else 0\n            digit_b = int(b[j]) if j >= 0 else 0\n            \n            total = digit_a + digit_b + car\n            sol+=str(total % 2)\n            car = total \/\/ 2  \n\n            i-=1\n            j-=1\n        return sol[::-1]"
    },
    {
        "question_id":68,
        "name":"text-justification",
        "inefficient_code":"class Solution:\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\n        \n        n=len(words)\n        output,line,width=[],[],0\n        \n        for w in words:\n            if width + len(w) +len(line) > maxWidth:\n                for i in range(maxWidth-width):\n                    line[i%(len(line) - 1 or 1)] += ' '\n                output += [''.join(line)]\n                line=[]\n                width=0\n            line += [w]\n            width += len(w)\n        \n        return output + [' '.join(line).ljust(maxWidth)]\n            \n            \n        \n\n        ",
        "optimized_code":"class Solution:\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\n        \n        n=len(words)\n        output=line,width=[],0\n        \n        for w in words:\n            width += len(w)\n            if width <= maxWidth:\n                line+=w\n                if width <= maxWidth-2:\n                    width+=len(w)+1\n                else:\n                    width=0\n                    line+=[' ']*(maxWidth-width)\n                    line+=w\n            else:\n                for i in range(maxWidth-width):\n                    line[i%(len(line) - 1 or 1)] +=''\n                output += [''.join(line)]\n                line=[]\n                width=0\n        \n        return output + [' '.join(line).ljust(maxWidth)]"
    },
    {
        "question_id":69,
        "name":"sqrtx",
        "inefficient_code":"class Solution:\n    def mySqrt(self, x: int) -> int:\n        if x == 0 or x == 1:\n            return x\n        for i in range(1, x+1):\n            if x\/i < i:\n                return i-1\n        ",
        "optimized_code":"class Solution:\n    def mySqrt(self, x: int) -> int:\n        if x == 0 or x == 1:\n            return x\n        left, right = 1, x\n        while left <= right:\n            mid = left + (right - left) \/\/ 2\n            if mid * mid <= x:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left - 1"
    },
    {
        "question_id":70,
        "name":"climbing-stairs",
        "inefficient_code":"class Solution:\n    def climbStairs(self, n: int) -> int:\n        return self._dfs(n, {})\n\n    def _dfs(self, n: int, memo: dict[int, int]):\n        if n == 0 or n == 1:\n            return 1\n        if n not in memo:\n            memo[n] = self._dfs(n - 1, memo) + self._dfs(n - 2, memo)\n        return memo[n]",
        "optimized_code":"class Solution:\n    def climbStairs(self, n: int) -> int:\n        if n <= 2:\n            return n\n        memo = {0: 1, 1: 1}\n        for i in range(2, n):\n            memo[i] = memo[i - 1] + memo[i - 2]\n        return memo[n]"
    },
    {
        "question_id":71,
        "name":"simplify-path",
        "inefficient_code":"class Solution:\n    def simplifyPath(self, path: str) -> str:\n        components = path.split('\/')\n        stack = []\n        \n        for component in components:\n            if component == '' or component == '.':\n                continue\n            elif component == '..':\n                if stack:\n                    stack.pop()\n            else:\n                stack.append(component)\n        \n        simplified_path = '\/' + '\/'.join(stack)\n        return simplified_path\n",
        "optimized_code":"class Solution:\n    def simplifyPath(self, path: str) -> str:\n        path = path.split('\/')\n        stack = []\n        \n        for component in path:\n            if component == '.' or component == '':\n                continue\n            elif component == '..':\n                if stack:\n                    stack.pop()\n            else:\n                stack.append(component)\n        \n        return '\/'.join(stack)"
    },
    {
        "question_id":72,
        "name":"edit-distance",
        "inefficient_code":"class Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        # memo={}\n        # def dfs(i,j):\n        #     if (i,j) in memo:\n        #         return memo[(i,j)]\n        #     if i>=len(word1):\n        #         memo[(i,j)]=len(word2)-j\n        #         return memo[(i,j)]\n        #     if j>=len(word2):\n        #         memo[(i,j)]=len(word1)-i\n        #         return memo[(i,j)]\n        #     if word1[i]==word2[j]:\n        #         memo[(i,j)]= dfs(i+1,j+1)\n        #     else:\n        #         memo[(i,j)]=min(1+dfs(i+1,j+1),1+dfs(i+1,j),1+dfs(i,j+1))\n        #     return memo[(i,j)]\n        # return dfs(0,0)\n        n=max(len(word1),len(word2))\n        dp=[[0]*(n+1) for _ in range(n+1)]\n        ans=float('inf')\n        for i in range(n,-1,-1):\n            for j in range(n,-1,-1):\n                if i>=len(word1):\n                    dp[i][j]=len(word2)-j\n                elif j>=len(word2):\n                    dp[i][j]=len(word1)-i\n                elif word1[len(word1)-i-1]==word2[len(word2)-j-1]:\n                    dp[i][j]= dp[i+1][j+1]\n                else:\n                    dp[i][j]=min(1+dp[i+1][j+1],1+dp[i+1][j],1+dp[i][j+1])\n        return dp[0][0]\n            \n            \n        ",
        "optimized_code":"class Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        n = len(word1)\n        m = len(word2)\n        dp = [[0] * (m+1) for _ in range(n+1)]\n        for i in range(n):\n            for j in range(m):\n                if word1[i] == word2[j]:\n                    dp[i+1][j+1] = dp[i][j] + 1\n                else:\n                    dp[i+1][j+1] = min(dp[i+1][j+1], dp[i+1][j], dp[i][j+1]) + 1\n        return dp[0][0]"
    },
    {
        "question_id":73,
        "name":"set-matrix-zeroes",
        "inefficient_code":"class Solution:\n    def setZeroes(self, matrix: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        allLeft = False\n        allTop = False\n        for i in range(len(matrix)):\n            if matrix[i][0] == 0:\n                allLeft = True\n        for i in range(len(matrix[0])):\n            if matrix[0][i] == 0:\n                allTop = True\n        for i in range(1, len(matrix)):\n            for j in range(1, len(matrix[0])):\n                if matrix[i][j] == 0:\n                    matrix[i][0] = 0\n                    matrix[0][j] = 0\n        for i in range(1, len(matrix)):\n            if matrix[i][0] == 0:\n                for j in range(len(matrix[0])):\n                    matrix[i][j] = 0\n        for i in range(1, len(matrix[0])):\n            if matrix[0][i] == 0:\n                for j in range(len(matrix)):\n                    matrix[j][i] = 0\n        if allLeft:\n            for i in range(len(matrix)):\n                matrix[i][0] = 0\n        if allTop:\n            for i in range(len(matrix[0])):\n                matrix[0][i] = 0\n        ",
        "optimized_code":"class Solution:\n    def setZeroes(self, matrix: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        # 1. Check the top and left of matrix\n        top = False\n        left = False\n        for i in range(len(matrix)):\n            if matrix[i][0] == 0:\n                top = True\n            if matrix[0][i] == 0:\n                left = True\n        # 2. Set the first column and row to 0\n        for i in range(1, len(matrix[0])):\n            matrix[0][i] = 0\n        for i in range(1, len(matrix)):\n            for j in range(1, len(matrix[0])):\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\n                    matrix[i][j] = 0\n        # 3. Set the"
    },
    {
        "question_id":74,
        "name":"search-a-2d-matrix",
        "inefficient_code":"class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        # declare variables \n        rows, cols = len(matrix), len(matrix[0])\n        left, right = 0, rows * cols - 1\n\n        #\u00a0search iteratirvelt\n        while left <= right:\n            # find middle \n            middle = (left + right) \/\/ 2\n            #\u00a0convert to 1D arra\n            row, col = middle \/\/ cols, middle % cols\n            middle_value = matrix[row][col]\n\n            # search \n            if middle_value == target:\n                return True \n\n            elif middle_value < target:\n                left = middle + 1\n\n            else:\n                right = middle - 1\n\n        return False",
        "optimized_code":"class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        # declare variables \n        rows, cols = len(matrix), len(matrix[0])\n        left, right = 0, rows * cols - 1\n\n        #\u00a0search iteratirvelt\n        while left <= right:\n            # find middle \n            middle = (left + right) \/\/ 2\n            #\u00a0convert to 1D arra\n            row, col = middle \/\/ cols, middle % cols\n            middle_value = matrix[row][col]\n\n            # search \n            if middle_value == target:\n                return True \n\n            elif middle_value < target:\n                left = middle + 1\n\n            else:\n                right = middle - 1\n\n        return False"
    },
    {
        "question_id":75,
        "name":"sort-colors",
        "inefficient_code":"class Solution:\n    def sortColors(self, nums: List[int]) -> None:\n        nums.sort()\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        ",
        "optimized_code":"class Solution:\n    def sortColors(self, nums: List[int]) -> None:\n        #nums.sort()\n        nums[:] = [i for i in range(len(nums)) if i & 1 == 0]"
    },
    {
        "question_id":76,
        "name":"minimum-window-substring",
        "inefficient_code":"class Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        n = len(s)\n        t_counter = Counter(t)\n        curr_counter = t_counter.copy()\n        for key in curr_counter:\n            curr_counter[key] = 0\n        left, right = 0, 0\n        minimum_window = ''\n        length = n + 1\n        while right < n:\n            curr_counter[s[right]] += 1\n            t_counter[s[right]] += 0\n            valid = True\n            for key in t_counter:\n                if curr_counter[key] < t_counter[key]:\n                    valid = False\n            if valid:\n                while True:\n                    if curr_counter[s[left]] - 1 >= t_counter[s[left]]:\n                        curr_counter[s[left]] -= 1\n                        left += 1\n                    else:\n                        break\n                if right - left + 1 < length:\n                    minimum_window = s[left:right+1]\n                    length = len(minimum_window)\n            right += 1\n        return minimum_window",
        "optimized_code":"class Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        n = len(s)\n        t_counter = Counter(t)\n        left, right, window = 0, 0, n\n        minimum_window = ''\n        while right < n:\n            curr_counter = t_counter.copy()\n            for key in curr_counter:\n                curr_counter[key] -= 1\n            t_counter[s[right]] += 1\n            while left < right:\n                if curr_counter[s[left]] < t_counter[s[left]]:\n                    curr_counter[s[left]] += 1\n                else:\n                    break\n                left += 1\n            if left == right:\n                window += 1\n                if window == n:\n                    minimum_window = s[left:right+1]\n                right += 1\n        return minimum_window"
    },
    {
        "question_id":77,
        "name":"combinations",
        "inefficient_code":"class Solution:\n    def combine(self, n: int, k: int) -> List[List[int]]:\n        self.res = []\n\n        def dfs(tmp: List[int], start: int) -> None:\n            if len(tmp) == k:\n                self.res.append(tmp[::])\n            \n            if len(tmp) > k or start > n:\n                return\n            \n            for i in range(start, n + 1):\n                tmp.append(i)\n                dfs(tmp, i + 1)\n                tmp.pop()\n        \n        dfs([], 1)\n        return self.res\n",
        "optimized_code":"class Solution:\n    def combine(self, n: int, k: int) -> List[List[int]]:\n        self.res = []\n        self.dfs(n, 1, k)\n        return self.res\n    \n    def dfs(self, n, start, k):\n        if len(self.res) == k:\n            return\n        \n        for i in range(start, n + 1):\n            self.res.append([i])\n            self.dfs(i + 1, i + 1, k)\n            self.res.pop()"
    },
    {
        "question_id":78,
        "name":"subsets",
        "inefficient_code":"class Solution:\n    def subsets(self, nums: List[int]) -> List[List[int]]:\n        lstOut = []\n        subset = []\n        def dfs(i):\n            if i >= len(nums):\n                lstOut.append(subset.copy())\n                return\n            subset.append(nums[i])\n            dfs(i+1)\n            subset.pop()\n            dfs(i+1)\n        dfs(0)\n        return lstOut",
        "optimized_code":"class Solution:\n    def subsets(self, nums: List[int]) -> List[List[int]]:\n        lstOut = []\n        subset = []\n        def dfs(i, nums):\n            if i >= len(nums):\n                lstOut.append(subset.copy())\n                return\n            subset.append(nums[i])\n            dfs(i+1, nums)\n            subset.pop()\n            dfs(i+1, nums)\n        dfs(0, nums)\n        return lstOut"
    },
    {
        "question_id":79,
        "name":"word-search",
        "inefficient_code":"class Solution:\n    def exist(self, board: List[List[str]], word: str) -> bool:\n        path=set()\n        \n        def dfs(i,j,place):\n            if place == len(word):\n                return True\n\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or word[place] != board[i][j] or (i,j) in path:\n                return False\n\n            path.add((i,j))\n            \n\n            directions = [[1,0],[-1,0],[0,1],[0,-1]]\n            res=False\n\n\n            for dx,dy in directions:\n                res = res or dfs(i+dx,j+dy,place+1)\n\n\n            path.remove((i,j))\n\n            return res\n\n\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] == word[0]:\n                    if dfs(i,j,0):\n                        return True\n\n        return False\n\n            \n        \n\n        \n\n        ",
        "optimized_code":"class Solution:\n    def exist(self, board: List[List[str]], word: str) -> bool:\n        def dfs(i, j, place):\n            if place == len(word):\n                return True\n\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j]!= word[place]:\n                return False\n\n            path.add((i, j))\n\n            directions = [[1, 0], [-1, 0], [0, 1], [0, -1]]\n\n            for dx, dy in directions:\n                res = res or dfs(i + dx, j + dy, place + 1)\n\n            path.remove((i, j))\n\n            return res\n\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] == word[0]:\n                    if dfs(i, j, 0):\n                        return True"
    },
    {
        "question_id":80,
        "name":"remove-duplicates-from-sorted-array-ii",
        "inefficient_code":"class Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        a=1\n        c=1\n        for i in range(1,len(nums)):\n            if(nums[i-1]==nums[i]):\n                if(c<2):\n                    c+=1\n                    nums[a]=nums[i]\n                    a+=1\n\n                else:\n                    continue    \n            else:\n                c=1\n                nums[a]=nums[i]\n                a+=1\n        return a           \n",
        "optimized_code":"class Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n        i, j = 0, 1\n        while j < len(nums):\n            if nums[i]!= nums[j]:\n                i += 1\n                nums[i] = nums[j]\n                j += 1\n            else:\n                i += 1\n                nums[i] = nums[j]\n                j += 1\n        return i + 1"
    },
    {
        "question_id":81,
        "name":"search-in-rotated-sorted-array-ii",
        "inefficient_code":"class Solution:\n    def search(self, nums: List[int], target: int) -> bool:\n        left = 0\n        right = len(nums) - 1\n        while left <= right:\n            middle = (left + right) \/\/ 2\n            if nums[middle] == target:\n                return True\n            if (nums[left] == nums[middle] and nums[middle] == nums[right]):\n                left += 1\n                right -= 1\n            elif nums[left] <= nums[middle]:\n                if nums[left] <= target and target < nums[middle]:\n                    right = middle - 1\n                else:\n                    left = middle + 1 \n            else:\n                if target > nums[middle] and target <= nums[right]:\n                    left = middle + 1\n                else:\n                    right = middle - 1\n        return False\n\n                \n                ",
        "optimized_code":"class Solution:\n    def search(self, nums: List[int], target: int) -> bool:\n        left = 0\n        right = len(nums) - 1\n        while left <= right:\n            middle = (left + right) \/\/ 2\n            if nums[middle] == target:\n                return True\n            if nums[left] == nums[middle] and nums[middle] == nums[right]:\n                left += 1\n                right -= 1\n            elif nums[left] <= nums[middle]:\n                if nums[left] <= target and target < nums[middle]:\n                    right = middle - 1\n                else:\n                    left = middle + 1 \n            else:\n                if target > nums[middle] and target <= nums[right]:\n                    left = middle + 1\n                else:\n                    right = middle - 1\n        return False"
    },
    {
        "question_id":82,
        "name":"remove-duplicates-from-sorted-list-ii",
        "inefficient_code":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        fake = ListNode(-1)\n        fake.next = head\n        prev, curr = fake, head\n        while curr:\n            while curr.next and curr.val == curr.next.val:\n                curr = curr.next\n            if prev.next == curr:\n                prev = prev.next\n                curr = curr.next\n            else:\n                prev.next = curr.next\n                curr = prev.next\n        return fake.next\n      \n        ",
        "optimized_code":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head:\n            return head\n        if head.next == None:\n            return head\n        \n        prev, curr = head, head.next\n        while curr:\n            while curr.next and curr.val == curr.next.val:\n                curr = curr.next\n            if prev.next == curr:\n                prev = prev.next\n                curr = curr.next\n            else:\n                prev.next = curr.next\n                curr = prev.next\n        \n        return head"
    },
    {
        "question_id":83,
        "name":"remove-duplicates-from-sorted-list",
        "inefficient_code":"class Solution:\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\n        if not head:\n            return None\n        \n        temp = head\n        temp2 = head.next\n        last = head.val\n        \n        while temp2:  \n            if temp2.val == last:  \n                if not temp2.next:  \n                    temp.next = None\n                    break\n                temp2 = temp2.next  \n                temp.next = temp2 \n            else:  \n                temp = temp2\n                last = temp.val\n                temp2 = temp2.next\n        \n        return head  ",
        "optimized_code":"class Solution:\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\n        if not head:\n            return None\n        \n        temp = head\n        temp2 = head.next\n        last = head.val\n        \n        while temp2:  \n            if temp2.val == last:  \n                if not temp2.next:  \n                    temp.next = None\n                    break\n                temp2 = temp2.next  \n                temp.next = temp2 \n            else:  \n                temp = temp2\n                last = temp.val\n                temp2 = temp2.next\n        \n        return head"
    },
    {
        "question_id":84,
        "name":"largest-rectangle-in-histogram",
        "inefficient_code":"class Solution:\n    def largestRectangleArea(self, heights: List[int]) -> int:\n        # OK\n        # stack = []\n        # max_area = 0\n        # heights = [0] + heights + [0]  # Add dummy bars to simplify the code\n\n        # for i in range(len(heights)):\n        #     # While the current bar is lower than the bar at the top of the stack\n        #     while stack and heights[stack[-1]] > heights[i]:\n        #         # Calculate the area of the rectangle with the bar at the top of the stack as the smallest bar\n        #         h = heights[stack.pop()]\n        #         w = i - stack[-1] - 1\n        #         max_area = max(max_area, h * w)\n        #     # Push the index of the current bar onto the stack\n        #     stack.append(i)\n\n        # return max_area\n\n        # Practice:\n        st = []\n        area = 0\n        heights = [-1] + heights + [-1]  # some low value (0 works)\n        #          ^ to reference left boundary\n        #                           ^ to process as k the last, nth element from original list\n\n        for i,a in enumerate(heights):\n            while(st and heights[st[-1]] > a):\n                rr = i\n                k = st.pop()  # pop first\n                ll = st[-1]   # stack maintains next smaller index to left (larger values already popped)\n                h = heights[k]\n                length = rr - ll - 1 \n                area = max(area, heights[k] * length)\n\n            st.append(i)\n\n        return area",
        "optimized_code":"from typing import List\n\nclass Solution:\n    def largestRectangleArea(self, heights: List[int]) -> int:\n        # OK\n        # stack = []\n        # max_area = 0\n        # heights = [0] + heights + [0]  # Add dummy bars to simplify the code\n\n        # for i in range(len(heights)):\n        #     # While the current bar is lower than the bar at the top of the stack\n        #     while stack and heights[stack[-1]] > heights[i]:\n        #         # Calculate the area of the rectangle with the bar at the top of the stack as the smallest bar\n        #         h = heights[stack.pop()]\n        #         w = i - stack[-1] - 1\n        #         max_area = max(max_area, h * w)\n        #     # Push the index of the current bar onto the stack\n        #     stack.append(i)\n\n        # return max_area"
    },
    {
        "question_id":85,
        "name":"maximal-rectangle",
        "inefficient_code":"class Solution:\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\n        # dp[i][j] \u8868\u793a\u5728\u7b2ci\u884c\uff0c\u4ee5j-th \u7ed3\u5c3e\u7684\u6700\u957f1\u5b50\u4e32\u7684\u957f\u5ea6\n        # max(min(dp[k: l + 1][j]) * (l - k + 1))\n        if len(matrix) == 0 or len(matrix[0]) == 0:\n            return 0\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        dp = [[0 for _ in range(n)] for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j == 0:\n                    dp[i][j] = int(matrix[i][j])\n                else:\n                    if matrix[i][j] == \"0\":\n                        dp[i][j] = 0\n                    else:\n                        dp[i][j] = dp[i][j - 1] + 1\n        \n        # print(dp)\n        max_area = 0\n        for j in range(n):\n            for k in range(m):\n                min_len = dp[k][j]\n                if max_area < min_len:\n                    max_area = min_len\n                for l in range(k + 1, m):\n                    if dp[l][j] < min_len:\n                        min_len = dp[l][j]\n                    max_area = max(max_area, min_len * (l - k + 1))\n        \n        return max_area\n\n                        ",
        "optimized_code":"class Solution:\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\n        m = len(matrix)\n        n = len(matrix[0])\n        \n        if m == 0 or n == 0:\n            return 0\n        \n        dp = [[0 for _ in range(n)] for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j == 0:\n                    dp[i][j] = int(matrix[i][j])\n                else:\n                    if matrix[i][j] == \"0\":\n                        dp[i][j] = 0\n                    else:\n                        dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + 1\n        max_area = 0\n        for i in range(m):\n            for j in range(n):\n                min_len = dp[i][j]\n                if max_area < min_len:"
    },
    {
        "question_id":86,
        "name":"partition-list",
        "inefficient_code":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:\n        lesser = ListNode()\n        lesser.next = head\n        greater = ListNode()\n        greater.next = head\n        current = head\n        first_greater = None\n\n        while current:\n            if current.val < x:\n                if head.val >= x:\n                    head = current\n                lesser.next = current\n                lesser = current\n            \n            else:\n                if first_greater is None:\n                    first_greater = current\n                greater.next = current\n                greater = current\n\n            current = current.next\n\n        lesser.next = first_greater\n        greater.next = None\n\n        return head",
        "optimized_code":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:\n        dummy = ListNode(-1)\n        dummy.next = head\n        curr = dummy\n\n        while head:\n            if head.val < x:\n                curr.next = head\n                curr = head\n            else:\n                curr.next = ListNode(-1)\n                curr = curr.next\n\n            head = head.next\n\n        curr.next = dummy.next\n        return dummy.next"
    },
    {
        "question_id":87,
        "name":"scramble-string",
        "inefficient_code":"class Solution:\n    def isScramble(self, s1: str, s2: str) -> bool:\n        n=len(s1)\n        dp=[[[False for j in range(n)]for i in range(n)]for l in \n        range(n+1)];\n        for i in range(n):\n            for j in range(n):\n                dp[1][i][j]=s1[i]==s2[j]\n        for length in range(2,n+1):\n            for i in range(n+1-length):\n                for j in range(n+1-length):\n                    for new in range(1,length):\n                        dp1=dp[new][i]\n                        dp2=dp[length-new][i+new]\n                        dp[length][i][j]|=(\n                            dp1[j] and dp2[j+new]\n                        )\n                        dp[length][i][j]|=(\n                            dp2[j] and dp1[j+length-new]\n                        )\n        return dp[n][0][0]",
        "optimized_code":"class Solution:\n    def isScramble(self, s1: str, s2: str) -> bool:\n        n=len(s1)\n        dp=[[[False for j in range(n)]for i in range(n)]for l in \n        range(n+1)];\n        for i in range(n):\n            for j in range(n):\n                dp[1][i][j]=s1[i]==s2[j]\n        for length in range(2,n+1):\n            for i in range(n+1-length):\n                for j in range(n+1-length):\n                    for new in range(1,length):\n                        dp1=dp[new][i]\n                        dp2=dp[length-new][i+new]\n                        dp[length][i][j]|=(\n                            dp1[j] and dp2[j+new]\n                        )\n                        dp[length][i][j]|=(\n                            dp2[j] and dp1[j+length-new]\n                        )\n        return dp[n"
    },
    {
        "question_id":88,
        "name":"merge-sorted-array",
        "inefficient_code":"class Solution:\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\n        \"\"\"\n        Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        p1 = m-1\n        p2 = n-1\n        p = m+n-1\n        while p2 >= 0:\n            if p1 >= 0 and nums1[p1] > nums2[p2]:\n                nums1[p] = nums1[p1]\n                p1 -= 1\n            else:\n                nums1[p] = nums2[p2]\n                p2 -= 1\n            p -= 1\n        ",
        "optimized_code":"class Solution:\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\n        \"\"\"\n        Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        p1 = m-1\n        p2 = n-1\n        p = m+n-1\n        while p2 >= 0:\n            if p1 >= 0 and nums1[p1] > nums2[p2]:\n                nums1[p] = nums1[p1]\n                p1 -= 1\n            else:\n                nums1[p] = nums2[p2]\n                p2 -= 1\n            p -= 1\n        for i in range(p, p1+1):\n            nums1[i] = nums2[i]"
    },
    {
        "question_id":89,
        "name":"gray-code",
        "inefficient_code":"class Solution:\n    def grayCode(self, n: int) -> List[int]:\n        result=[0]\n        isPresent={0}\n        self.graycodeHelper(result,n,isPresent)\n        return result\n    def graycodeHelper(self,result,n,isPresent):\n        if len(result)==(1<<n):\n            return True\n        current=result[-1]\n        print(\"C\",current)\n        for i in range(n):\n            nextNum=current^(1<<i)#toggles the i-th bit of the variable current and assigns the result to nextNum\n            print(nextNum)\n            if nextNum not in isPresent:\n                isPresent.add(nextNum)\n                result.append(nextNum)\n                if self.graycodeHelper(result,n,isPresent):\n                    return True\n                isPresent.remove(nextNum)\n                result.pop()\n        return False\n\n\n\n        ",
        "optimized_code":"class Solution:\n    def grayCode(self, n: int) -> List[int]:\n        result=[0]\n        isPresent={0}\n        self.graycodeHelper(result,n,isPresent)\n        return result\n    def graycodeHelper(self,result,n,isPresent):\n        if len(result)==(1<<n):\n            return True\n        current=result[-1]\n        print(\"C\",current)\n        for i in range(n):\n            nextNum=current^(1<<i)#toggles the i-th bit of the variable current and assigns the result to nextNum\n            print(nextNum)\n            if nextNum not in isPresent:\n                isPresent.add(nextNum)\n                result.append(nextNum)\n                if self.graycodeHelper(result,n,isPresent):\n                    return True\n                isPresent.remove(nextNum)\n                result.pop()\n        return False"
    },
    {
        "question_id":90,
        "name":"subsets-ii",
        "inefficient_code":"class Solution:\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\n        ans=[]\n        ds=[]\n\n        def findSubsets(ind:int):\n            ans.append(ds[:])\n            for i in range(ind,len(nums)):\n                if i != ind and nums[i] == nums[i-1]:\n                    continue\n                ds.append(nums[i])\n                findSubsets(i+1)\n                ds.pop()\n        nums.sort()\n        findSubsets(0)\n        return ans\n            \n\n        ",
        "optimized_code":"class Solution:\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\n        ans=[]\n        ds=[]\n        def findSubsets(ind:int):\n            if ind == len(nums):\n                ans.append(ds[:])\n                return\n            for i in range(ind,len(nums)):\n                if i!= ind and nums[i] == nums[i-1]:\n                    continue\n                ds.append(nums[i])\n                findSubsets(i+1)\n                ds.pop()\n        nums.sort()\n        findSubsets(0)\n        return ans"
    },
    {
        "question_id":91,
        "name":"decode-ways",
        "inefficient_code":"class Solution:\n    def numDecodings(self, s: str) -> int:\n        @lru_cache(None)\n        def helper(idx):\n            if idx == len(s):\n                return 1\n            \n            if s[idx] == '0':\n                return 0\n            \n            single_digit = helper(idx + 1)\n            two_digit = 0\n            if (idx + 1 < len(s) and (s[idx] == '1' or (s[idx] == '2' and s[idx + 1] <= '6'))):\n                two_digit = helper(idx + 2)\n                \n            return single_digit + two_digit\n        return helper(0)",
        "optimized_code":"class Solution:\n    def numDecodings(self, s: str) -> int:\n        @lru_cache(None)\n        def helper(idx):\n            if idx == len(s):\n                return 1\n            \n            if s[idx] == '0':\n                return 0\n            \n            single_digit = helper(idx + 1)\n            two_digit = 0\n            if (idx + 1 < len(s) and (s[idx] == '1' or (s[idx] == '2' and s[idx + 1] <= '6'))):\n                two_digit = helper(idx + 2)\n                \n            return single_digit + two_digit\n        return helper(0)"
    },
    {
        "question_id":92,
        "name":"reverse-linked-list-ii",
        "inefficient_code":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:\n        if not head: return head\n        start = result = ListNode()\n        result.next = head\n\n        for i in range(left - 1):\n            result = result.next\n        \n        prev, curr, next = result, result.next, result.next.next\n        for i in range(right - left):\n            curr.next = next.next\n            next.next = prev.next\n            prev.next = next\n            next = curr.next\n        \n        return start.next",
        "optimized_code":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:\n        if not head: return head\n        \n        if left == 1 and right == 1:\n            return head\n        \n        if right == 1:\n            return self.reverseBetween(head.next, left - 1, 1) if head.next else head\n        \n        prev, curr, next = head, head.next, head.next.next\n        for i in range(left - 1):\n            curr.next, next = next, curr\n        \n        for i in range(right - left):\n            curr.next, next = next, curr\n        \n        return prev.next"
    },
    {
        "question_id":93,
        "name":"restore-ip-addresses",
        "inefficient_code":"class Solution:\r\n    def restoreIpAddresses(self, s: str) -> List[str]:\r\n        path = []\r\n        result = []\r\n\r\n        len_s = len(s)\r\n\r\n        def is_valid_ip(s):\r\n            if (s[0] == '0' and len(s) > 1) or int(s) > 255:\r\n                return False \r\n            else:\r\n                return True\r\n\r\n        def backtracking(start_idx, point_count):\r\n            if point_count == 4 and start_idx >= len_s:\r\n                result.append(\".\".join(path))\r\n                return \r\n\r\n            for i in range(start_idx, len_s):\r\n                temp = s[start_idx:i + 1]\r\n                if is_valid_ip(temp):\r\n                    path.append(temp)\r\n                    backtracking(i + 1, point_count + 1)\r\n                    path.pop()\r\n        \r\n        backtracking(0, 0)\r\n        return result\r\n\r\n                \r\n\r\n        ",
        "optimized_code":"class Solution:\r\n    def restoreIpAddresses(self, s: str) -> List[str]:\r\n        path = []\r\n        result = []\r\n        \r\n        def is_valid_ip(s):\r\n            if (s[0] == '0' and len(s) > 1) or int(s) > 255:\r\n                return False \r\n            else:\r\n                return True\r\n\r\n        def backtracking(start_idx, point_count):\r\n            if point_count == 4 and start_idx >= len_s:\r\n                result.append(\".\".join(path))\r\n                return \r\n\r\n            for i in range(start_idx, len_s):\r\n                temp = s[start_idx:i + 1]\r\n                if is_valid_ip(temp):\r\n                    path.append(temp)\r\n                    backtracking(i + 1, point_count + 1)\r\n                    path.pop()\r\n        \r\n        backtracking(0, 0)\r\n        return result"
    },
    {
        "question_id":94,
        "name":"binary-tree-inorder-traversal",
        "inefficient_code":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        stack = []\n        result = []\n        current = root\n\n        while current or stack:\n            while current:\n                stack.append(current)\n                current = current.left\n\n            current = stack.pop()\n            result.append(current.val)\n            current = current.right\n\n        return result\n          ",
        "optimized_code":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        result = []\n        stack = []\n        current = root\n\n        while current or stack:\n            while current:\n                stack.append(current)\n                current = current.left\n\n            current = stack.pop()\n            result.append(current.val)\n            current = current.right\n\n        return result"
    },
    {
        "question_id":95,
        "name":"unique-binary-search-trees-ii",
        "inefficient_code":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def generateTrees(self, n: int) -> List[TreeNode]:\n        def dfs(l, r):\n            if r < l: return [None]\n            arr = []\n            for m in range(l, r + 1):\n                left = dfs(l, m - 1)\n                right = dfs(m + 1, r)\n                for lNode in left:\n                    for rNode in right:\n                        new = TreeNode(m)\n                        new.left = lNode\n                        new.right = rNode\n                        arr.append(new)\n            return arr\n        res = dfs(1, n)\n        return [] if res == [None] else res",
        "optimized_code":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def generateTrees(self, n: int) -> List[TreeNode]:\n        if n == 0:\n            return []\n        if n == 1:\n            return [TreeNode(1)]\n        return self.generateTrees(1, n)"
    },
    {
        "question_id":96,
        "name":"unique-binary-search-trees",
        "inefficient_code":"class Solution:\n    def numTrees(self, n: int) -> int:\n\n        list_ = [0]*(n + 1)\n        list_[0], list_[1] = 1,1\n        for i in range(2, n+1):\n            for j in range(1,i+1):\n                list_[i] += list_[j-1]*list_[i-j]\n\n        return list_[n]\n\n",
        "optimized_code":"class Solution:\n    def numTrees(self, n: int) -> int:\n        if n < 2:\n            return 1\n        return sum([self.numTrees(i)*self.numTrees(n-i-1) for i in range(n)])"
    },
    {
        "question_id":97,
        "name":"interleaving-string",
        "inefficient_code":"class Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n\n        # dp[i][j] represents whether the first i characters in s1\n        # and the first j characters in s2\n        # can form the first i + j characters of s3\n\n        if len(s1) + len(s2) != len(s3):\n            return False\n\n        dp = [[False] * (len(s2) + 1) for _ in range((len(s1) + 1))]\n\n        # true for empty string\n        dp[0][0] = True\n\n        for i in range(len(s1) + 1):\n            for j in range(len(s2) + 1):\n                if i == 0 and j == 0:\n                    continue\n                # initialise base cases i and j\n                elif i == 0:\n                    dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\n                elif j == 0:\n                    dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\n                # interleave using either s1 OR s2\n                else:\n                    dp[i][j] = (dp[i][j - 1] and s2[j - 1] == s3[j + i - 1]) or \\\n                               (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1])\n\n        return dp[len(s1)][len(s2)]\n",
        "optimized_code":"class Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        m, n = len(s1), len(s2)\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\n        dp[0][0] = True\n\n        for i in range(m + 1):\n            for j in range(n + 1):\n                if i == 0 and j == 0:\n                    continue\n                # initialise base cases i and j\n                elif i == 0:\n                    dp[i][j] = dp[i][j - 1] and s2[j - 1] == s3[j - 1]\n                elif j == 0:\n                    dp[i][j] = dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]\n                # interleave using"
    },
    {
        "question_id":98,
        "name":"validate-binary-search-tree",
        "inefficient_code":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def helper(self,root,left,right):\n        if root is None:\n            return True\n        if not (left<root.val<right):\n            return False\n        return self.helper(root.left, left, root.val) and self.helper(root.right, root.val, right)\n    \n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\n        return self.helper(root, float('-inf'), float('inf'))\n        ",
        "optimized_code":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\n        return self.helper(root,float('-inf'),float('inf'))\n    \n    def helper(self,root,low,high):\n        if root is None:\n            return True\n        if not (low<root.val<high):\n            return False\n        return self.helper(root.left,low,root.val) and self.helper(root.right,root.val,high)"
    },
    {
        "question_id":99,
        "name":"recover-binary-search-tree",
        "inefficient_code":"class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def __init__(self):\n        self.first = None\n        self.second = None\n        self.prev = None\n\n    def recoverTree(self, root: TreeNode) -> None:\n        # Helper function for inorder traversal\n        def inorder(node: TreeNode):\n            if not node:\n                return\n            \n            # Traverse the left subtree\n            inorder(node.left)\n            \n            # Check if we found a swapped node\n            if self.prev and self.prev.val > node.val:\n                # If it's the first occurrence, set the first node\n                if not self.first:\n                    self.first = self.prev\n                # Always set the second node\n                self.second = node\n            \n            # Update prev pointer\n            self.prev = node\n            \n            # Traverse the right subtree\n            inorder(node.right)\n        \n        # Start inorder traversal to identify swapped nodes\n        inorder(root)\n        \n        # Swap the values of the two nodes\n        if self.first and self.second:\n            self.first.val, self.second.val = self.second.val, self.first.val\n",
        "optimized_code":"class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def __init__(self):\n        self.first = None\n        self.second = None\n        self.prev = None\n\n    def recoverTree(self, root: TreeNode) -> None:\n        def inorder(node: TreeNode):\n            if not node:\n                return\n            \n            # Traverse the left subtree\n            inorder(node.left)\n            \n            # Check if we found a swapped node\n            if self.prev and self.prev.val > node.val:\n                # If it's the first occurrence, set the first node\n                if not self.first:\n                    self.first = self.prev\n                # Always set the second node\n                self.second = node\n            \n            # Update prev pointer\n            self.prev = node\n            \n            # Traverse the right subtree\n            inorder(node.right)\n        \n        # Start inorder traversal"
    },
    {
        "question_id":100,
        "name":"same-tree",
        "inefficient_code":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if p == None and q == None:\n            return True\n        elif p and not q:\n            return False\n        elif not p and q:\n            return False\n        else:\n            if p.val == q.val:\n                if (p.left and not q.left) or (not p.left and q.left) or (p.right and not q.right) or (not p.right and q.right):\n                    return False\n                else:\n                    return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\n            else:\n                return False\n            \n",
        "optimized_code":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if p == None and q == None:\n            return True\n        elif p and not q:\n            return False\n        elif not p and q:\n            return False\n        else:\n            if p.val == q.val:\n                if (p.left and not q.left) or (not p.left and q.left) or (p.right and not q.right) or (not p.right and q.right):\n                    return False\n                else:\n                    return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\n            else:\n                return False"
    },
    {
        "question_id":101,
        "name":"symmetric-tree",
        "inefficient_code":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isMirror(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> bool:\n        if root1 is None and root2 is None:\n            return True\n        elif root1 is None or root2 is None:\n            return False\n        else:\n            return root1.val == root2.val and self.isMirror(root1.left, root2.right) and self.isMirror(root1.right, root2.left)\n\n\n    def isSymmetric(self, root: Optional[TreeNode]) -> bool:\n        return self.isMirror(root, root)",
        "optimized_code":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSymmetric(self, root: Optional[TreeNode]) -> bool:\n        if root is None:\n            return True\n        return self.isMirror(root.left, root.right)\n\n    def isMirror(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> bool:\n        if root1 is None or root2 is None:\n            return False\n        if root1.val!= root2.val:\n            return False\n        return self.isMirror(root1.left, root2.right) and self.isMirror(root1.right, root2.left)"
    },
    {
        "question_id":102,
        "name":"binary-tree-level-order-traversal",
        "inefficient_code":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\n        if not root: return []\n        res, stack = [], [[root]]\n\n        while stack:\n            nodes = stack.pop()\n            currents = []\n            childs = []\n            for node in nodes:\n                currents.append(node.val)\n                if node.left: childs.append(node.left)\n                if node.right: childs.append(node.right)\n\n            res.append(currents)\n            if childs: stack.append(childs)\n\n        return res",
        "optimized_code":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\n        if not root: return []\n        res, stack = [], [[root]]\n\n        while stack:\n            nodes = stack.pop()\n            currents = []\n            childs = []\n            for node in nodes:\n                if node.left: childs.append(node.left)\n                if node.right: childs.append(node.right)\n                if node.val: currents.append(node.val)\n\n            res.append(currents)\n            if childs: stack.append(childs)\n\n        return res\n\n#### Explanation:\n# The optimized code is a recursive one, and the logic is similar to the one in the first version.\n# We use a stack to store the nodes in the tree, and a"
    },
    {
        "question_id":103,
        "name":"binary-tree-zigzag-level-order-traversal",
        "inefficient_code":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\n        if not root:\n            return []\n        queue = deque([root])\n        ans = []\n        rev = False\n        while queue:\n            tmp = []\n            for _ in range(len(queue)):\n                node = queue.popleft()\n                tmp.append(node.val)\n                if node.right:\n                    queue.append(node.right)\n                if node.left:\n                    queue.append(node.left)\n            if rev:\n                ans.append(tmp)\n            else:\n                ans.append(reversed(tmp))\n            rev = not rev\n                \n        return ans\n            \n            \n        ",
        "optimized_code":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\n        if not root:\n            return []\n        queue = deque([root])\n        ans = []\n        while queue:\n            tmp = []\n            for _ in range(len(queue)):\n                node = queue.popleft()\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n                tmp.append(node.val)\n            if queue:\n                ans.append(tmp)\n            else:\n                break\n        return ans"
    },
    {
        "question_id":104,
        "name":"maximum-depth-of-binary-tree",
        "inefficient_code":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if root is None:\n            return 0\n        if root.left is None and root.right is None:\n            return 1\n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))",
        "optimized_code":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if root is None:\n            return 0\n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n\n#### Input Code:\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if root is None:\n            return 0\n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))"
    },
    {
        "question_id":105,
        "name":"construct-binary-tree-from-preorder-and-inorder-traversal",
        "inefficient_code":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\n        pre_ind = 0\n        def find(in_start, in_end):\n            nonlocal pre_ind\n            if in_start == in_end:\n                return None\n\n            for i in range(in_start, in_end):\n                if inorder[i] == preorder[pre_ind]:\n                    this_node = TreeNode(val = inorder[i])\n                    pre_ind += 1\n                    this_node.left = find(in_start,i)\n                    this_node.right = find(i+1,in_end)\n                    return this_node\n\n        return find(0,len(inorder))",
        "optimized_code":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\n        if len(preorder) == 0:\n            return None\n\n        preorder = self.preorder2inorder(preorder)\n        inorder = self.inorder2preorder(inorder)\n        return self.buildTreeHelper(preorder,inorder,0,len(inorder)-1)\n\n    def buildTreeHelper(self,preorder,inorder,pre_ind,pre_end):\n        if pre_ind == pre_end:\n            return None\n        else:\n            this_node = TreeNode(val = preorder[pre_ind])\n            this_node.left = self.buildTreeHelper(preorder,inorder,pre_ind+1,pre_ind+1)"
    },
    {
        "question_id":106,
        "name":"construct-binary-tree-from-inorder-and-postorder-traversal",
        "inefficient_code":"# Definition for a binary tree node.\nfrom typing import List\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\nclass Solution:\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\n\n        rootVal = postorder[-1]\n        root = TreeNode(rootVal)\n        if len(inorder) > 1 and len(postorder) > 1:\n            index = inorder.index(rootVal)\n            leftInorder = inorder[:index]\n            rightInorder = inorder[index+1:]\n            leftPostorder = postorder[:len(leftInorder)]\n            rightPostorder = postorder[len(leftInorder): len(postorder)-1]\n            if leftInorder and leftPostorder:\n                root.left = self.buildTree(leftInorder, leftPostorder)\n            else:\n                root.left = None\n            \n            if rightInorder and rightPostorder:\n                root.right = self.buildTree(rightInorder, rightPostorder)\n            else:\n                root.right = None\n            return root\n        else:\n            return root\n",
        "optimized_code":"# Definition for a binary tree node.\nfrom typing import List\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\nclass Solution:\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\n        if not inorder:\n            return None\n        rootVal = postorder[-1]\n        root = TreeNode(rootVal)\n        if len(inorder) > 1 and len(postorder) > 1:\n            index = inorder.index(rootVal)\n            leftInorder = inorder[:index]\n            rightInorder = inorder[index+1:]\n            leftPostorder = postorder[:len(leftInorder)]\n            rightPostorder = postorder[len(leftInorder): len(postorder)-1]\n            if leftInorder and leftPostorder:\n                root.left = self.buildTree(leftInorder, leftPost"
    },
    {
        "question_id":107,
        "name":"binary-tree-level-order-traversal-ii",
        "inefficient_code":"from collections import deque\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n\n        if not root:\n            return []\n\n        queue = deque([root])\n        solutions = deque([])\n\n        while queue:\n            level = []\n            level_size = len(queue)\n\n            for _ in range(level_size):\n                node = queue.popleft()\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n\n\n            solutions.appendleft(level)\n\n        return solutions\n\n                \n\n\n\n        ",
        "optimized_code":"from collections import deque\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n        if not root:\n            return []\n        if not root.left and not root.right:\n            return [root.val]\n        queue = deque([root])\n        solutions = deque([])\n        while queue:\n            level = []\n            level_size = len(queue)\n            for _ in range(level_size):\n                node = queue.popleft()\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            solutions.appendleft(level)\n        return solutions"
    },
    {
        "question_id":108,
        "name":"convert-sorted-array-to-binary-search-tree",
        "inefficient_code":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:\n        def helper(start_idx, end_idx):\n            if start_idx>end_idx:\n                return None\n            elif start_idx == end_idx:\n                return TreeNode(val = nums[start_idx])\n            else:\n                mid = start_idx + (end_idx-start_idx)\/\/2\n                #print(f\"{nums[mid]} {start_idx}, {end_idx}\")\n                node = TreeNode(val=nums[mid])\n                node.left = helper(start_idx, mid-1)\n                node.right = helper(mid+1, end_idx)\n\n                return node\n        #print(helper(0, len(nums)-1))\n        return helper(0, len(nums)-1)",
        "optimized_code":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:\n        if not nums:\n            return None\n        mid_idx = len(nums)\/\/2\n        root = TreeNode(nums[mid_idx])\n        root.left = self.sortedArrayToBST(nums[:mid_idx])\n        root.right = self.sortedArrayToBST(nums[mid_idx+1:])\n        return root"
    },
    {
        "question_id":109,
        "name":"convert-sorted-list-to-binary-search-tree",
        "inefficient_code":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def flatList(self, head):\n        flattenList = []\n        while(head):\n            flattenList.append(head.val)\n            head = head.next\n        return flattenList\n    \n    def arrayToBST(self, nums):\n        n = len(nums)\n        if n == 0:\n            return None\n\n        middleIndex = n \/\/ 2\n        middleValue = nums.pop(middleIndex)\n        return TreeNode(middleValue, self.arrayToBST(nums[:middleIndex]), self.arrayToBST(nums[middleIndex:]))\n\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        nums = self.flatList(head)\n        return self.arrayToBST(nums)",
        "optimized_code":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        def makeBST(root):\n            if not root:\n                return None\n            left = makeBST(root.left)\n            right = makeBST(root.right)\n            root.left = left\n            root.right = right\n            return root\n        return makeBST(head)"
    },
    {
        "question_id":110,
        "name":"balanced-binary-tree",
        "inefficient_code":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\n        balanced=[True]\n        def height(root):\n            if root is None:\n                return 0\n            \n            left_root=height(root.left)\n            if balanced[0] is False:\n                return 0\n            right_root=height(root.right)\n\n            if(abs(left_root-right_root)>1):\n                balanced[0]=False\n                return 0\n            return max(left_root,right_root)+1\n        height(root)\n        return balanced[0]\n\n        ",
        "optimized_code":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\n        def is_balanced(root):\n            if root is None:\n                return True\n            left_balanced=is_balanced(root.left)\n            right_balanced=is_balanced(root.right)\n            if abs(left_balanced-right_balanced)>1:\n                return False\n            return True\n        return is_balanced(root)"
    },
    {
        "question_id":111,
        "name":"minimum-depth-of-binary-tree",
        "inefficient_code":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def minDepth(self, root: Optional[TreeNode]) -> int:\n        def dfs(node, curr):\n            if not node:\n                return 0\n\n            if node.left == None and node.right == None:\n                return curr\n        \n            curr += 1\n            left = dfs(node.left, curr)\n            right = dfs(node.right, curr)\n            if left and right:\n                return min(left, right)\n                \n            return left or right\n        \n        return dfs(root, 1)\n            ",
        "optimized_code":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def minDepth(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n\n        if not root.left and not root.right:\n            return 1\n        \n        return 1 + min(self.minDepth(root.left), self.minDepth(root.right))"
    },
    {
        "question_id":112,
        "name":"path-sum",
        "inefficient_code":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\n\n        if not root:\n            return False\n        \n        stack = [(root, targetSum)]\n\n        while stack:\n            cur, cur_sum = stack.pop()\n            cur_sum -= cur.val\n\n            if not cur.left and not cur.right and cur_sum == 0:\n                return True\n            \n            if cur.left:\n                stack.append((cur.left, cur_sum))\n            if cur.right:\n                stack.append((cur.right, cur_sum))\n        \n        return False\n        ",
        "optimized_code":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\n\n        def helper(node, target_sum):\n            if not node:\n                return False\n            if node.left and node.left.val == target_sum - node.val:\n                return True\n            if node.right and node.right.val == target_sum - node.val:\n                return True\n            return helper(node.left, target_sum - node.val) or helper(node.right, target_sum - node.val)\n        \n        return helper(root, targetSum)"
    },
    {
        "question_id":113,
        "name":"path-sum-ii",
        "inefficient_code":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:\n        res=[]\n        def helper(root,sm,gen):\n            if root is None:\n                return \n            if root.left is None and root.right is None:\n                sm+=root.val\n                gen+=[root.val]\n                if sm==targetSum:\n                    res.append(gen[:])\n            helper(root.left,sm+root.val,gen+[root.val])\n            helper(root.right,sm+root.val,gen+[root.val])\n        helper(root,0,[])\n        return res\n        ",
        "optimized_code":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:\n        if root is None:\n            return []\n        res=[]\n        def helper(root,sm,gen):\n            if root is None:\n                return \n            if root.left is None and root.right is None:\n                sm+=root.val\n                gen+=[root.val]\n                if sm==targetSum:\n                    res.append(gen[:])\n            helper(root.left,sm+root.val,gen+[root.val])\n            helper(root.right,sm+root.val,gen+[root.val])\n        helper(root,0,[],[])\n        return res"
    },
    {
        "question_id":114,
        "name":"flatten-binary-tree-to-linked-list",
        "inefficient_code":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def flatten(self, root: Optional[TreeNode]) -> None:\n        \"\"\"\n        Do not return anything, modify root in-place instead.\n        \"\"\"\n        # if root is None:\n        #     return \n        \n        cur = root\n        while cur:\n            if cur.left!=None:\n                deep = cur.left\n                while deep.right !=None:\n                    deep = deep.right\n                \n                deep.right = cur.right\n                cur.right = cur.left\n                cur.left = None\n            cur = cur.right\n\n\n        \n",
        "optimized_code":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def flatten(self, root: Optional[TreeNode]) -> None:\n        \"\"\"\n        Do not return anything, modify root in-place instead.\n        \"\"\"\n        def flatten(root):\n            if root is None:\n                return None\n            \n            left = root.left\n            right = root.right\n            \n            root.left = None\n            root.right = left\n            \n            flatten(root.right)\n            flatten(root.left)\n            \n        flatten(root)"
    },
    {
        "question_id":115,
        "name":"distinct-subsequences",
        "inefficient_code":"class Solution:\n    def numDistinct(self, s: str, t: str) -> int:\n        #s = \"rabbbit\", t = \"rabbit\"\n\n        #ultimatly its all about moving pointers, when to move them (need to try all the possiblities of moving the pointers)\n\n        #if i == j\n            #move both and just move i (since duh not j)\n        #else:\n            #move i to find other\n\n        #store (cache) when we get to i,j we've already seen ()\n\n        dp = {}\n\n        def dfs(i,j):\n            if j == len(t):\n                return 1\n            if i == len(s):\n                return 0\n            if (i,j) in dp:\n                return dp[(i,j)]\n            \n            if s[i] == t[j]:\n                dp[(i,j)] = dfs(i + 1, j + 1) + dfs(i + 1, j)\n            else:\n                dp[(i,j)] = dfs(i + 1,j)\n\n            return dp[(i,j)]\n\n        return dfs(0,0)\n\n        ",
        "optimized_code":"class Solution:\n    def numDistinct(self, s: str, t: str) -> int:\n        #s = \"rabbbit\", t = \"rabbit\"\n        #s = \"a\", t = \"b\"\n        #s = \"ab\", t = \"acb\"\n        #s = \"ab\", t = \"ab\"\n        #s = \"ab\", t = \"abc\"\n        #s = \"ab\", t = \"ab\"\n        #s = \"ab\", t = \"ac\"\n        #s = \"ab\", t = \"abc\"\n        #s = \"ab\", t = \"abc\"\n        #s = \"ab\", t = \"abc\"\n        #s = \"ab\", t = \"abc\"\n        #s = \"ab\", t = \"abc\"\n        #s = \"ab\", t = \"abc\"\n        #s = \"ab\", t = \"abc\"\n        #s = \"ab\", t = \""
    },
    {
        "question_id":116,
        "name":"populating-next-right-pointers-in-each-node",
        "inefficient_code":"\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.next = next\n\"\"\"\n\nclass Solution:\n    def connect(self, root: 'Optional[Node]') -> 'Optional[Node]':\n        if root == None:\n            return root\n        \n        queue = [root]\n        index = 1\n        # node = queue[0]\n        prev = None\n        # node = queue[0]\n        while len(queue) > 0:   \n            node = queue.pop(0)         \n            self.visit(queue, index, node, prev)\n            prev = node\n            index += 1\n            \n        # print(index)\n        return root\n        \n    def visit(self, queue: List, index: int, node:'Optional[Node]', prev:'Optional[Node]'):\n        # if len(queue) == 0:\n        #     return\n        # node = queue[index]\n        \n        newLine = self.isPower2(index)\n        # print(index, newLine, node.val, prev)\n        if prev != None and not newLine:\n            node.next = prev\n            \n        if node.right != None:\n            queue.append(node.right)\n        if node.left != None:\n            queue.append(node.left)\n        print(node.val, node.next)\n     \n            \n    def isPower2(self, k: int)-> bool:\n        if k == 0:\n            return False\n        \n        while k > 0:\n            if k % 2 == 1:\n                if k == 1:\n                    return True\n                else:\n                    return False\n            k >>= 1\n        return False\n            \n            \n        ",
        "optimized_code":"\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.next = next\n\"\"\"\n\nclass Solution:\n    def connect(self, root: 'Optional[Node]') -> 'Optional[Node]':\n        if root == None:\n            return root\n        \n        queue = [root]\n        index = 1\n        # node = queue[0]\n        prev = None\n        # node = queue[0]\n        while len(queue) > 0:   \n            node = queue[index]\n            self.visit(node, prev, queue)\n            prev = node\n            index += 1\n            \n        # print(index)\n        return root\n        \n    def visit(self, node: 'Optional[Node]', prev: 'Optional"
    },
    {
        "question_id":117,
        "name":"populating-next-right-pointers-in-each-node-ii",
        "inefficient_code":"\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.next = next\n\"\"\"\n\nclass Solution:\n    def connect(self, root: 'Node') -> 'Node':\n        \"\"\"\n        Do BFGS; Process each layer before moving on \n        \"\"\"\n\n        if not root or (not root.left and not root.right):\n            return root\n        \n        queue = [root]\n        buffer = []\n        while len(queue) > 0:\n            \n            # add children to the next layer buffer\n            for node in queue:\n                if node.left: buffer.append(node.left)\n                if node.right: buffer.append(node.right)\n\n            # reconnect\n            i = 0\n            while i < len(queue)-1:\n                queue[i].next = queue[i+1]\n                i += 1\n            queue[i].next = None\n            \n            queue = buffer\n            buffer = []\n        \n        return root\n",
        "optimized_code":"\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.next = next\n\"\"\"\n\nclass Solution:\n    def connect(self, root: 'Node') -> 'Node':\n        \"\"\"\n        Do BFGS; Process each layer before moving on \n        \"\"\"\n\n        if not root or (not root.left and not root.right):\n            return root\n        \n        # add children to the next layer buffer\n        queue = [root]\n        buffer = []\n        while len(queue) > 0:\n            \n            # add children to the next layer buffer\n            for node in queue:\n                if node.left: buffer.append(node.left)\n                if node.right: buffer.append(node.right)\n\n            # reconnect\n            i = 0"
    },
    {
        "question_id":118,
        "name":"pascals-triangle",
        "inefficient_code":"class Solution:\n    def generate(self, numRows: int) -> List[List[int]]:\n        \n        if numRows == 1: return [[1]]\n        if numRows == 2: return [[1], [1, 1]]\n\n        prev_result = self.generate(numRows-1)\n        last_row = prev_result[-1]\n        new_result = [1]\n        for i in range(1, numRows-1):\n            new_result.append(last_row[i] + last_row[i-1])\n        new_result.append(1)\n        prev_result.append(new_result)\n        return prev_result\n",
        "optimized_code":"class Solution:\n    def generate(self, numRows: int) -> List[List[int]]:\n        if numRows == 1: return [[1]]\n        if numRows == 2: return [[1], [1, 1]]\n\n        prev_result = self.generate(numRows-1)\n        last_row = prev_result[-1]\n        new_result = [1]\n        for i in range(1, numRows-1):\n            new_result.append(last_row[i] + last_row[i-1])\n        new_result.append(1)\n        prev_result.append(new_result)\n        return prev_result"
    },
    {
        "question_id":119,
        "name":"pascals-triangle-ii",
        "inefficient_code":"class Solution:\n    def getRow(self, rowIndex: int) -> List[int]:\n        # \u5982\u679c\u53ea\u8981\u7b2c0\u5217\n        if rowIndex == 0:\n            return [1]\n\n        # \u5132\u5b58\u73fe\u5728\u9019\u5217\n        rowNums = [1,1]\n\n        for _ in range(1, rowIndex):\n            # \u65b0\u5217\n            newRow = [1]\n            for i in range(1, len(rowNums)):\n                newRow.append(rowNums[i]+rowNums[i-1])\n            rowNums = newRow + [1]\n        return rowNums\n        \n",
        "optimized_code":"class Solution:\n    def getRow(self, rowIndex: int) -> List[int]:\n        # \u5982\u679c\u53ea\u8981\u7b2c0\u5217\n        if rowIndex == 0:\n            return [1]\n\n        # \u5132\u5b58\u73fe\u5728\u9019\u5217\n        rowNums = [1,1]\n\n        for _ in range(1, rowIndex):\n            # \u65b0\u5217\n            newRow = [1"
    },
    {
        "question_id":120,
        "name":"triangle",
        "inefficient_code":"class Solution:\n    def minimumTotal(self, triangle: List[List[int]]) -> int:\n\n        # def calculateSum(arr, ind):\n        #     if len(arr) == 1:\n        #         return arr[0], ind\n\n        #     if arr[ind] < arr[ind + 1]:\n        #         return arr[ind], ind\n        #     else:\n        #         return arr[ind + 1], ind + 1\n\n        # ind = 0\n        # min_sum = 0\n        # for ele in triangle:\n        #     el, ind = calculateSum(ele, ind)\n        #     min_sum += el\n\n        # return min_sum\n\n        for row in range(len(triangle) - 2, -1, -1):\n            for col in range(len(triangle[row])):\n                \n                triangle[row][col] += min(triangle[row + 1][col], triangle[row + 1][col + 1])\n            \n        return triangle[0][0]\n",
        "optimized_code":"class Solution:\n    def minimumTotal(self, triangle: List[List[int]]) -> int:\n\n        def calculateSum(arr, ind):\n            if len(arr) == 1:\n                return arr[0], ind\n\n            if arr[ind] < arr[ind + 1]:\n                return arr[ind], ind\n            else:\n                return arr[ind + 1], ind + 1\n\n        ind = 0\n        min_sum = 0\n        for row in range(len(triangle) - 2, -1, -1):\n            for col in range(len(triangle[row])):\n                \n                triangle[row][col] += min(triangle[row + 1][col], triangle[row + 1][col + 1])\n            \n            min_sum += triangle[row][0]\n        \n        return min_sum"
    },
    {
        "question_id":121,
        "name":"best-time-to-buy-and-sell-stock",
        "inefficient_code":"class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        buy = prices[0]\n        profit = 0\n        for i in range(1, len(prices)):\n            if prices[i] < buy:\n                buy = prices[i]\n            elif prices[i] - buy > profit:\n                profit = prices[i] - buy\n        return profit",
        "optimized_code":"class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        max = 0\n        min = float('inf')\n        for i in range(1, len(prices)):\n            if prices[i] < min:\n                min = prices[i]\n            elif prices[i] - min > max:\n                max = prices[i] - min\n        return max"
    },
    {
        "question_id":122,
        "name":"best-time-to-buy-and-sell-stock-ii",
        "inefficient_code":"class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        total = 0\n        minn = prices[0]\n        l = len(prices)\n        for i in range(l):\n            if prices[i]>minn:\n                total += prices[i] - minn\n            minn = prices[i]\n        \n        return total",
        "optimized_code":"class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        total = 0\n        minn = prices[0]\n        for i in range(1, len(prices)):\n            if prices[i] > minn:\n                total += prices[i] - minn\n            minn = min(prices[i], minn)\n        \n        return total"
    },
    {
        "question_id":123,
        "name":"best-time-to-buy-and-sell-stock-iii",
        "inefficient_code":"class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        # Tabulation\n\n        n = len(prices)\n        dp = [[[0 for _ in range(3)] for _ in range(2)] for _ in range(n + 1)]\n\n        # Base cases are already covered as the dp is initialized to 0\n      \n        for i in range(n - 1, -1, -1):\n            for j in range(2):\n                for k in range(1, 3):\n                    if j == 0:\n                        dp[i][j][k] = max(-prices[i] + dp[i + 1][1][k], 0 + dp[i + 1][0][k])\n                    else:\n                        dp[i][j][k] = max(+prices[i] + dp[i + 1][0][k - 1], 0 + dp[i + 1][1][k])\n\n        return dp[0][0][2]\n\n\n\n        # # Memoization\n\n        # n = len(prices)\n        # # Create a 3D DP table with dimentions (n * 2 * 3) and initializa it with -1\n        # dp = [[[-1 for _ in range(3)] for _ in range(2)] for _ in range(n)]\n\n        # # Recursive funtion to find the maximum profit\n        # def memoization(ind, buy, cap):\n        #     # if we have reached the end of the array or used up all transactions, return zero profit\n        #     if ind == n or cap == 0:\n        #         return 0\n\n        #     # if the result is already computed, return it\n        #     if dp[ind][buy][cap] != -1:\n        #         return dp[ind][buy][cap]\n            \n        #     profit = 0\n\n        #     if buy == 0:\n        #         # We can buy the stock\n        #         profit = max(0 + memoization(ind + 1, 0, cap), -prices[ind] + memoization(ind + 1, 1, cap))\n        #     elif buy == 1:\n        #         # We can buy the stock\n        #         profit = max(0 + memoization(ind + 1, 1, cap), prices[ind] + memoization(ind + 1, 0, cap - 1))\n\n        #     dp[ind][buy][cap] = profit\n        #     return dp[ind][buy][cap]\n        \n        # return memoization(0, 0, 2)\n        # # TC: O(n * 2 * 3)\n        # # SC: O(n * 2 * 3) + O(n)\n\n\n",
        "optimized_code":"class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        n = len(prices)\n        if n < 2:\n            return 0\n\n        buy = 0\n        cap = 1\n\n        for i in range(1, n):\n            if prices[i] < prices[i - 1]:\n                buy = 1\n                cap = 1\n            elif prices[i] > prices[i - 1]:\n                buy = 0\n                cap = 0\n\n        return max(-prices[0] + self.maxProfit(prices[1:], 1) + self.maxProfit(prices[1:], 0), 0 + self.maxProfit(prices[0], 1))"
    },
    {
        "question_id":124,
        "name":"binary-tree-maximum-path-sum",
        "inefficient_code":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\n        res=-inf\n        \n        def dfs(node):\n            nonlocal res\n            if not node:\n                return 0\n            left = dfs(node.left)\n            right = dfs(node.right)\n            left = max(0,left)\n            right=max(0,right)\n            res = max(res,left+right+node.val)\n            return max(left+node.val,right+node.val)\n        dfs(root)\n        return res\n            ",
        "optimized_code":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\n        res = -inf\n        def dfs(node):\n            nonlocal res\n            if not node:\n                return 0\n            left = dfs(node.left)\n            right = dfs(node.right)\n            left = max(0,left)\n            right=max(0,right)\n            res = max(res,left+right+node.val)\n            return max(left+node.val,right+node.val)\n        dfs(root)\n        return res"
    },
    {
        "question_id":125,
        "name":"valid-palindrome",
        "inefficient_code":"class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        temp = \"\"\n        for i in s:\n            if i.isalpha() or i.isalnum():\n                temp += \"\".join(i.casefold())\n\n        result = temp[::-1]\n        if result == temp:\n            return True\n        else:\n            return False\n        ",
        "optimized_code":"class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        return s == s[::-1]"
    },
    {
        "question_id":126,
        "name":"word-ladder-ii",
        "inefficient_code":"\"\"\"\nIn a nutshell, this problem is an advanced graph traversal algorithm. Here, we use BFS to find all shortest paths\nfrom beginWord to endWord in a constructed graph  g = (V, E). \n\t- |V| = k+1 if beginWord is not in wordList and |V| = k otherwise.\n\t- an edge (u, v) is in E if and only if wordList[u] and wordList[v] differ by exactly one character.\nCheck the docstrings for all the necessary methods for an in-depth explanation of this modified BFS algorithm.\n\"\"\"\n\nfrom typing import List\nimport math\n\ndef differ(str1, str2):\n\t\"\"\"\n\tdetermines if two strings differ by one character.\n\t\"\"\"\n\tdiff = 0\n\n\tfor i in range(len(str1)):\n\t\tif str1[i] != str2[i]:\n\t\t\tdiff += 1\n\n\treturn diff == 1\n\n\ndef convert(words):\n\t\"\"\"\n\tconverts words into the adjacency list representation of a graph, as detailed above.\n\t\"\"\"\n\tedges = []\n\tgraph = [[] for _ in range(len(words))]\n\n\tfor i in range(len(words)):\n\t\tfor j in range(i, len(words)):\n\t\t\tif differ(words[i], words[j]):\n\t\t\t\tedges.append([i, j])\n\n\tfor pair in edges:\n\t\tgraph[pair[0]].append(pair[1])\n\t\tgraph[pair[1]].append(pair[0])\n\n\treturn graph\n\n\ndef bfs(graph, start):\n\t\"\"\"\n\tperforms a modified bfs search on graph with start node start.\n\n\tReturns:\n\t\t- parents, a dictionary that maps each node in the graph to a list of parents that have the shortest distance from the start node.\n\n\tstart is the index such that wordList[start] = beginWord\n\t\"\"\"\n\tdist = {start: 0}  # dictionary that maps each node in graph to the shortest distance away from start.\n\tparents = {start: None}\n\n\tfor i in range(len(graph)):\n\t\tif i != start:\n\t\t\tdist[i] = math.inf\n\t\t\tparents[i] = []\n\n\tqueue = [start]\n\n\twhile queue:\n\t\tnode = queue.pop()\n\n\t\tfor neighbor in graph[node]:\n\t\t\tif dist[neighbor] == math.inf:  # neighbor has not been visited yet\n\t\t\t\tdist[neighbor] = dist[node] + 1\n\t\t\t\tparents[neighbor].append(node)\n\t\t\t\tqueue.insert(0, neighbor)\n\n\t\t\telse:  # neighbor has been visited!\n\t\t\t\tif dist[node] + 1 == dist[neighbor]:\n\t\t\t\t\tparents[neighbor].append(node)\n\t\t\t\telif dist[node] + 1 < dist[neighbor]:  # found a quicker path to neighbor\n\t\t\t\t\tdist[neighbor] = dist[node] + 1\n\t\t\t\t\tparents[neighbor].clear()\n\t\t\t\t\tparents[neighbor].append(node)\n\n\treturn parents\n\n\ndef findPaths(pathList, currPath, currNode, parents, wordList):\n\t\"\"\"\n\ttraces back to find all paths from the end node to the start node given the parents dictionary. Returns nothing,\n\tbut modifies the input pathList to include all possible paths.\n\t\"\"\"\n\tif parents[currNode] is None:\n\t\tcurrPath.reverse()\n\t\tpathList.append(currPath)\n\n\tif parents[currNode]:\n\t\tfor parent in parents[currNode]:\n\t\t\tfindPaths(pathList, currPath + [wordList[parent]], parent, parents, wordList)\n\n\nclass Solution:\n\tdef findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\n\t\tif beginWord not in wordList:\n\t\t\twordList.append(beginWord)\n\n\t\tif endWord not in wordList:\n\t\t\treturn []\n\n\t\tendIndex = wordList.index(endWord)\n\t\tbeginIndex = wordList.index(beginWord)\n\n\t\tgraph = convert(wordList)\n\t\tparents = bfs(graph, beginIndex)\n\n\t\tpathList = []\n\t\tcurrPath = [endWord]\n\t\tfindPaths(pathList, currPath, endIndex, parents, wordList)\n\n\t\treturn pathList",
        "optimized_code":"\"\"\"\nIn a nutshell, this problem is an advanced graph traversal algorithm. Here, we use BFS to find all shortest paths\nfrom beginWord to endWord in a constructed graph  g = (V, E). \n\t- |V| = k+1 if beginWord is not in wordList and |V| = k otherwise.\n\t- an edge (u, v) is in E if and only if wordList[u] and wordList[v] differ by exactly one character.\nCheck the docstrings for all the necessary methods for an in-depth explanation of this modified BFS algorithm.\n\"\"\"\n\nfrom typing import List\nimport math\n\ndef differ(str1, str2):\n\t\"\"\"\n\tdetermines if two strings differ by one character.\n\t\"\"\"\n\tdiff = 0\n\n\tfor i in range(len(str1)):\n\t\tif str1[i]!= str2[i]:\n\t\t\tdiff += 1\n\n\treturn diff == 1\n\ndef convert(words):\n\t\"\"\"\n\tconverts words into the"
    },
    {
        "question_id":127,
        "name":"word-ladder",
        "inefficient_code":"class Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\n        wordList = set(wordList)\n\n        if endWord not in wordList:\n            return 0\n        \n        def offByOne(s, t):\n            if s == t:\n                return False\n            diff = 0\n            for i in range(len(s)):\n                if s[i] != t[i]:\n                    diff += 1\n                if diff > 1:\n                    return False\n            return True\n\n        queue = deque([(endWord, 1)])\n        seen = set()\n        while queue:\n            word, length = queue.popleft()\n            if word in seen:\n                continue\n            elif offByOne(word, beginWord):\n                return length + 1\n\n            seen.add(word)\n            for nextWord in wordList:\n                if offByOne(word, nextWord):\n                    queue.append((nextWord, length + 1))\n        return 0",
        "optimized_code":"class Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\n        wordList = set(wordList)\n        if endWord not in wordList:\n            return 0\n        \n        def offByOne(s, t):\n            if s == t:\n                return False\n            diff = 0\n            for i in range(len(s)):\n                if s[i]!= t[i]:\n                    diff += 1\n                if diff > 1:\n                    return False\n            return True\n\n        queue = deque([(endWord, 1)])\n        seen = set()\n        while queue:\n            word, length = queue.popleft()\n            if word in seen:\n                continue\n            elif offByOne(word, beginWord):\n                return length + 1\n\n            seen.add(word)\n            for nextWord in wordList:\n                if offByOne(word, nextWord):\n                    queue.append((nextWord, length +"
    },
    {
        "question_id":128,
        "name":"longest-consecutive-sequence",
        "inefficient_code":"class Solution:\n    def longestConsecutive(self, nums: List[int]) -> int:\n        numset = set(nums)\n        res = 0\n        for n in nums:\n            # check if n is a start of  seq\n            if (n-1) not in numset:\n                op = 0\n                while (n+op) in numset:\n                    op+=1\n                res = max(res,op)\n        return res",
        "optimized_code":"class Solution:\n    def longestConsecutive(self, nums: List[int]) -> int:\n        numset = set(nums)\n        res = 0\n        for n in nums:\n            # check if n is a start of  seq\n            if (n-1) not in numset:\n                op = 0\n                while (n+op) in numset:\n                    op+=1\n                res = max(res,op)\n        return res"
    },
    {
        "question_id":129,
        "name":"sum-root-to-leaf-numbers",
        "inefficient_code":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        nums = []\n        def dfs(node, val):\n            if not node:\n                return \n            temp = val + str(node.val)\n            if not node.left and not node.right:\n                nums.append(int(temp))\n                return\n            dfs(node.left, temp)\n            dfs(node.right, temp)\n        dfs(root, \"\")\n        return sum(nums)",
        "optimized_code":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        return self.sumNumbersHelper(root, 0)\n    def sumNumbersHelper(self, root, num):\n        if not root:\n            return num\n        num = num * 10 + root.val\n        if not root.left and not root.right:\n            return num\n        return self.sumNumbersHelper(root.left, num) + self.sumNumbersHelper(root.right, num)"
    },
    {
        "question_id":130,
        "name":"surrounded-regions",
        "inefficient_code":"class Solution:\n    def solve(self, board: List[List[str]]) -> None:\n        \"\"\"\n        Do not return anything, modify board in-place instead.\n        \"\"\"\n        M, N = len(board), len(board[0])\n        total_visited = set()\n        def dfs(i,j):\n            nonlocal M,N,board,total_visited\n            curr_visited = set()\n            q = [(i,j)]\n            edged = False\n            while q:\n                curr = q.pop()\n                curr_visited.add(curr)\n                for di in [(-1,0), (1,0), (0,1), (0,-1)]:\n                    new_i, new_j = curr[0]+di[0], curr[1]+di[1]\n                    if new_i >= 0 and new_i < M and new_j >= 0 and new_j < N:\n                        if board[new_i][new_j] == 'O' and (new_i, new_j) not in curr_visited:\n                            q.append((new_i, new_j))\n                    else:\n                        edged = True\n            total_visited.update(curr_visited)\n            if edged:\n                return\n            for i,j in curr_visited:\n                board[i][j] = 'X'\n                \n\n        for i in range(M):\n            for j in range(N):\n                if board[i][j] == 'O' and (i,j) not in total_visited:\n                    dfs(i,j)\n",
        "optimized_code":"class Solution:\n    def solve(self, board: List[List[str]]) -> None:\n        \"\"\"\n        Do not return anything, modify board in-place instead.\n        \"\"\"\n        M, N = len(board), len(board[0])\n        total_visited = set()\n        def dfs(i,j):\n            nonlocal M,N,board,total_visited\n            curr_visited = set()\n            q = [(i,j)]\n            while q:\n                curr = q.pop()\n                curr_visited.add(curr)\n                for di in [(-1,0), (1,0), (0,1), (0,-1)]:\n                    new_i, new_j = curr[0]+di[0], curr[1]+di[1]\n                    if new_i >= 0 and new_i < M and new_j >= 0 and new_j < N:\n                        if board[new_i][new_j] == 'O' and (new_i, new_j) not in curr_visited:\n                            q.append(("
    },
    {
        "question_id":131,
        "name":"palindrome-partitioning",
        "inefficient_code":"class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        res = []\n\n        def backtrack(i,curr):\n            if i==len(s):\n                res.append(curr[:])\n            \n            for j in range(i,len(s)):\n                if s[i:j+1]==s[i:j+1][::-1]:\n                    curr.append(s[i:j+1])\n                    backtrack(j+1,curr)\n                    curr.pop()\n\n        backtrack(0,[])\n        return res",
        "optimized_code":"class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        res = []\n        def backtrack(i,curr):\n            if i==len(s):\n                res.append(curr[:])\n            for j in range(i,len(s)):\n                if s[i:j+1]==s[i:j+1][::-1]:\n                    curr.append(s[i:j+1])\n                    backtrack(j+1,curr)\n                    curr.pop()\n\n        backtrack(0,[])\n        return res"
    },
    {
        "question_id":132,
        "name":"palindrome-partitioning-ii",
        "inefficient_code":"class Solution:\n    def minCut(self, s: str) -> int:\n        def is_palindrome(s):\n            return s == s[::-1]\n        \n        @lru_cache(None)\n        def f(s):\n            if not s or len(s) == 1 or is_palindrome(s):\n                return 0\n\n            min_ = float('inf')\n\n\n                \n            for j in range(len(s)):\n                if is_palindrome(s[:j+1]):\n                    min_ = min(min_, 1 + f(s[j+1:]))\n            return min_\n\n        return f(s)\n            \n",
        "optimized_code":"class Solution:\n    def minCut(self, s: str) -> int:\n        def is_palindrome(s):\n            return s == s[::-1]\n        \n        @lru_cache(None)\n        def f(s):\n            if not s or len(s) == 1 or is_palindrome(s):\n                return 0\n\n            min_ = float('inf')\n\n\n                \n            for j in range(len(s)):\n                if is_palindrome(s[:j+1]):\n                    min_ = min(min_, 1 + f(s[j+1:]))\n            return min_\n\n        return f(s)"
    },
    {
        "question_id":133,
        "name":"clone-graph",
        "inefficient_code":"\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, val = 0, neighbors = None):\n        self.val = val\n        self.neighbors = neighbors if neighbors is not None else []\n\"\"\"\n\nfrom typing import Optional\nclass Solution:\n    def cloneGraph(self, node: Optional['Node']) -> Optional['Node']:\n        cloneMap={}\n        def dfs(node):\n            if(node in cloneMap):\n                return cloneMap[node]\n            copy = Node(node.val)\n            cloneMap[node]=copy\n            for i in node.neighbors:\n                copy.neighbors.append(dfs(i))\n            return copy\n        return dfs(node) if node else None",
        "optimized_code":"\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, val = 0, neighbors = None):\n        self.val = val\n        self.neighbors = neighbors if neighbors is not None else []\n\"\"\"\n\nfrom typing import Optional\nclass Solution:\n    def cloneGraph(self, node: Optional['Node']) -> Optional['Node']:\n        cloneMap={}\n        def dfs(node):\n            if(node in cloneMap):\n                return cloneMap[node]\n            copy = Node(node.val)\n            cloneMap[node]=copy\n            for i in node.neighbors:\n                copy.neighbors.append(dfs(i))\n            return copy\n        return dfs(node) if node else None"
    },
    {
        "question_id":134,
        "name":"gas-station",
        "inefficient_code":"class Solution:\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\n        n = len(gas)\n        total_gas = 0\n        curr_gas = 0\n        start_index = 0\n\n        for i in range(n):\n            total_gas += gas[i] - cost[i]\n            curr_gas += gas[i] - cost[i]\n\n            if curr_gas < 0:\n                curr_gas = 0\n                start_index = i + 1\n        \n        return start_index if total_gas >= 0 else -1\n            \n\n\n# Naive: iterate through gas, then check costs. if it doesnt work, move to next starting index and continue. O(n^2) time. Can we optimize? to O(n)? extra data structure? ",
        "optimized_code":"class Solution:\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\n        n = len(gas)\n        total_gas = 0\n        curr_gas = 0\n        start_index = 0\n\n        for i in range(n):\n            total_gas += gas[i] - cost[i]\n            curr_gas += gas[i] - cost[i]\n            if curr_gas < 0:\n                curr_gas = 0\n                start_index = i + 1\n        \n        return start_index if total_gas >= 0 else -1"
    },
    {
        "question_id":135,
        "name":"candy",
        "inefficient_code":"class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        n=len(ratings)\n        sortedArr=[(ratings[i],i) for i in range(n)]\n        sortedArr.sort()\n        ans=[0]*n\n        for i in range(n):\n            curCandies=1\n            val,index=sortedArr[i]\n            if (index>0 and ratings[index-1]<ratings[index] and ans[index-1]>=curCandies):\n                curCandies=ans[index-1]+1\n            if (index<n-1 and ratings[index+1]<ratings[index] and ans[index+1]>=curCandies):\n                curCandies=ans[index+1]+1\n            ans[index]=curCandies\n        return sum(ans)\n            \n            \n        ",
        "optimized_code":"class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        n=len(ratings)\n        sortedArr=[(ratings[i],i) for i in range(n)]\n        sortedArr.sort()\n        ans=[0]*n\n        for i in range(n):\n            curCandies=1\n            val,index=sortedArr[i]\n            if (index>0 and ratings[index-1]<ratings[index] and ans[index-1]>=curCandies):\n                curCandies=ans[index-1]+1\n            if (index<n-1 and ratings[index+1]<ratings[index] and ans[index+1]>=curCandies):\n                curCandies=ans[index+1]+1\n            ans[index]=curCandies\n        return sum(ans)"
    },
    {
        "question_id":136,
        "name":"single-number",
        "inefficient_code":"class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n       dict={}\n       uni=set(nums)\n       for i in uni:\n        dict[nums.count(i)]=i\n       return dict[1]\n       \n",
        "optimized_code":"class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        return sum(nums) ^ (sum(nums) & -sum(nums))"
    },
    {
        "question_id":137,
        "name":"single-number-ii",
        "inefficient_code":"class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        ln=len(nums)\n        if ln<999999:\n                while(1):\n                    val = nums[-1]\n                    nums.pop()\n                    if val in nums:\n                        nums.insert(0,val)\n                    else:\n                        return val\n        else:\n            dicto={}\n            for i in nums:\n                if i in dicto.keys():\n                    dicto[i]+=1\n                else:\n                    dicto[i]=1\n            mini=min(dicto.values())\n            for i in dicto.items():\n                if i[1]==mini:\n                    return i[0] \n\n            \n\n        ",
        "optimized_code":"class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        ln=len(nums)\n        if ln<999999:\n                while(1):\n                    val = nums[-1]\n                    nums.pop()\n                    if val in nums:\n                        nums.insert(0,val)\n                    else:\n                        return val\n        else:\n            dicto={}\n            for i in nums:\n                if i in dicto.keys():\n                    dicto[i]+=1\n                else:\n                    dicto[i]=1\n            mini=min(dicto.values())\n            for i in dicto.items():\n                if i[1]==mini:\n                    return i[0]"
    },
    {
        "question_id":138,
        "name":"copy-list-with-random-pointer",
        "inefficient_code":"\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        old_to_new = {None:None}\n        \n        old = head\n        while old:\n            new = Node(old.val)\n            old_to_new[old] = new\n            old = old.next\n        \n        old = head\n        while old:\n            new = old_to_new[old]\n            new.next = old_to_new[old.next]\n            new.random = old_to_new[old.random]\n            old = old.next\n        \n        return old_to_new[head]",
        "optimized_code":"\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        old_to_new = {None:None}\n        \n        old = head\n        while old:\n            new = Node(old.val)\n            old_to_new[old] = new\n            old = old.next\n        \n        old = head\n        while old:\n            new = old_to_new[old]\n            new.next = old_to_new[old.next]\n            new.random = old_to_new[old.random]\n            old = old.next\n        \n        return old_to_new[head]"
    },
    {
        "question_id":139,
        "name":"word-break",
        "inefficient_code":"class Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\n        n = len(s)\n        dp = [False] * (n + 1)\n        dp[n] = True\n        for i in range(n - 1, -1, -1):\n            for w in wordDict:\n                len_word = len(w)\n                if (i + len_word <= n) and (s[i:i + len_word] == w):\n                    dp[i] = dp[i + len_word] # to ensure we covered whole s\n                if dp[i]:\n                    break\n        return dp[0]",
        "optimized_code":"class Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\n        n = len(s)\n        dp = [False] * (n + 1)\n        dp[n] = True\n        for i in range(n - 1, -1, -1):\n            for w in wordDict:\n                len_word = len(w)\n                if (i + len_word <= n) and (s[i:i + len_word] == w):\n                    dp[i] = dp[i + len_word] # to ensure we covered whole s\n                    break\n        return dp[0]"
    },
    {
        "question_id":140,
        "name":"word-break-ii",
        "inefficient_code":"class Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\n        # Time complexity: O(n\u22c52^n)\n        # Space complexity: O(2^n)\n\n        wordDict = set(wordDict)\n\n        # curr_i is where to continue iteration, stop_i is if > i then eating into next word, don't take\n        output = []\n\n        @lru_cache(None)\n        def dfs(curr_i, stop_i, word_str):\n            if stop_i == 0:\n                output.append(word_str[:-1])\n            elif curr_i < 0 or curr_i < 0:\n                return\n\n            for i in range(curr_i, -1, -1):\n                if s[i: stop_i] in wordDict:\n                    # Use a set instead of a dictionary, we can do look up of the word instead of looping through the word dic each time\n                    dfs(i - 1, i, s[i: stop_i] + \" \" + word_str)\n        \n        dfs(len(s)-1, len(s), \"\")\n        return output\n",
        "optimized_code":"class Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\n        # Time complexity: O(n\u22c52^n)\n        # Space complexity: O(2^n)\n\n        wordDict = set(wordDict)\n\n        # curr_i is where to continue iteration, stop_i is if > i then eating into next word, don't take\n        output = []\n\n        @lru_cache(None)\n        def dfs(curr_i, stop_i, word_str):\n            if stop_i == 0:\n                output.append(word_str[:-1])\n            elif curr_i < 0 or curr_i < 0:\n                return\n\n            for i in range(curr_i, -1, -1):\n                if s[i: stop_i] in wordDict:\n                    # Use a set instead of a dictionary, we can do look up of the word instead of looping through the word dic each time\n                    dfs(i - 1, i, s"
    },
    {
        "question_id":141,
        "name":"linked-list-cycle",
        "inefficient_code":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\n        slow = head\n        fast = head\n        while (fast):\n            if slow and slow.next:\n                slow = slow.next\n            elif slow:\n                return False\n            if fast and fast.next and fast.next.next:\n                fast = fast.next.next\n            elif fast:\n                return False\n            elif fast.next:\n                return False\n            \n            if slow == fast:\n                return True\n        return False",
        "optimized_code":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\n        if not head:\n            return False\n        slow = head\n        fast = head\n        while fast and fast.next:\n            if slow == fast:\n                return True\n            slow = slow.next\n            fast = fast.next.next\n        return False\n\n#### Input Code:\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\n        if not head:\n            return False\n        slow = head\n        fast = head\n        while fast and fast.next:\n            if slow == fast:\n                return True"
    },
    {
        "question_id":142,
        "name":"linked-list-cycle-ii",
        "inefficient_code":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n\n\n        # Solution 1 - using floyd's tortoise and hare\n        # Time - O(n)\n        # Space - O(1)\n\n        if not head:\n            return None\n\n        flag = False\n\n        slow, fast = head, head\n\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n\n            if fast == slow:\n                flag = True\n                break\n\n        if not flag:\n            return None\n\n        slow2 = head\n\n        while slow:\n\n            if slow == slow2:\n                return slow\n            slow = slow.next\n            slow2 = slow2.next\n\n        return None\n",
        "optimized_code":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n\n        # Solution 1 - using floyd's tortoise and hare\n        # Time - O(n)\n        # Space - O(1)\n\n        if not head:\n            return None\n\n        slow, fast = head, head\n\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n\n            if fast == slow:\n                break\n\n        if not fast:\n            return None\n\n        slow2 = head\n\n        while slow!= slow2:\n            slow = slow.next\n            slow2 = slow2.next\n\n        return slow"
    },
    {
        "question_id":143,
        "name":"reorder-list",
        "inefficient_code":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def reorderList(self, head: Optional[ListNode]) -> None:\n        \"\"\"\n        Do not return anything, modify head in-place instead.\n        \"\"\"\n        current_node = head \n        list_values = [current_node.val]\n        while current_node.next is not None:\n            current_node = current_node.next\n            list_values.append(current_node.val)\n\n        ## Check is par\n        is_par = len(list_values) % 2 == 0\n\n        ## Define the new list\n        pointier_a = 1\n        pointier_b = len(list_values) - 1\n        current_node = head\n        while pointier_a <= pointier_b:\n            ## Get values\n            value_a = list_values[pointier_a]\n            value_b = list_values[pointier_b]\n\n            ## Update the values\n            current_node.next = ListNode(value_b)\n            current_node = current_node.next\n\n            if not(pointier_a == pointier_b and is_par):\n                current_node.next = ListNode(value_a)\n                current_node = current_node.next\n\n            ## Update pointiers\n            pointier_a += 1\n            pointier_b -= 1",
        "optimized_code":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def reorderList(self, head: Optional[ListNode]) -> None:\n        \"\"\"\n        Do not return anything, modify head in-place instead.\n        \"\"\"\n        ## Get the middle\n        ## If the list is odd, the middle is the middle of the list\n        ## If the list is even, the middle is the first half of the list\n        if len(head) % 2 == 0:\n            mid = len(head) \/\/ 2\n            ## Find the first half of the list\n            head1 = head\n            head2 = head\n            for i in range(1, mid):\n                head1 = head1.next\n            ## Find the middle of the list\n            for i in range(1, mid):\n                head2 ="
    },
    {
        "question_id":144,
        "name":"binary-tree-preorder-traversal",
        "inefficient_code":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\ndef solve(root, ans):\n    if root is None:\n        return\n\n    ans.append(root.val)\n    solve(root.left,ans)\n    solve(root.right,ans)\nclass Solution:\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        ans = []\n        solve(root,ans)\n        return ans",
        "optimized_code":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\ndef solve(root, ans):\n    if root is None:\n        return\n\n    ans.append(root.val)\n    solve(root.left,ans)\n    solve(root.right,ans)\nclass Solution:\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        ans = []\n        solve(root,ans)\n        return ans\n\n#### Test Code:\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\ndef solve(root, ans):\n    if root is None:\n        return\n\n    ans.append(root.val)\n    solve(root.left,"
    },
    {
        "question_id":145,
        "name":"binary-tree-postorder-traversal",
        "inefficient_code":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        if not root: return []\n        return self.postorderTraversal(root.left) + self.postorderTraversal(root.right) + [root.val]",
        "optimized_code":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        if not root: return []\n        return self.postorderTraversal(root.left) + self.postorderTraversal(root.right) + [root.val]"
    },
    {
        "question_id":146,
        "name":"lru-cache",
        "inefficient_code":"class LRUCache:\n    cache = {}\n    lru = {}\n    capacity = 0\n    count = 0\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = {}\n        self.lru = {}\n\n    def get(self, key: int) -> int:\n        # print(\"get\")\n        # print(self.cache)\n        # print(self.lru)\n        if key in self.cache:\n            self.lru.pop(self.cache[key][1])\n            value = self.cache[key][0]\n            self.cache[key] = (value, self.count)\n            self.lru[self.count] = key\n            self.count += 1\n            return self.cache[key][0]\n        return -1\n\n    def put(self, key: int, value: int) -> None:\n        # print(\"put\")\n        if key not in self.cache and len(self.cache) >= self.capacity:\n            minimum = min(self.lru)\n            self.cache.pop(self.lru[minimum])\n            self.lru.pop(minimum)\n            # self.lru.pop(self.cache[key][1])\n        if key in self.cache:\n            self.lru.pop(self.cache[key][1])\n        self.cache[key] = (value, self.count)\n        self.lru[self.count] = key\n        self.count += 1\n        # print(self.cache)\n        # print(self.lru)\n\n\n# Your LRUCache object will be instantiated and called as such:\n# obj = LRUCache(capacity)\n# param_1 = obj.get(key)\n# obj.put(key,value)",
        "optimized_code":"class LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = {}\n        self.lru = {}\n\n    def get(self, key: int) -> int:\n        if key in self.cache:\n            value = self.cache[key]\n            self.lru.pop(value[0])\n            self.lru[value[0]] = value[1]\n            self.cache[key] = value\n            return value[0]\n        return -1\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            self.lru.pop(self.cache[key][0])\n            self.cache[key] = (value, self.cache[key][1])\n            self.lru[self.cache[key][1]] = key\n        else:\n            if len(self.cache) >= self.capacity:\n                minimum = min(self.lru)\n                self.cache.pop(self.lru[minimum])\n                self.lru.pop(minimum"
    },
    {
        "question_id":147,
        "name":"insertion-sort-list",
        "inefficient_code":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def insertionSortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next: \n            return head\n        elements = list()\n        while head: \n            elements.append(head.val)\n            head = head.next\n        \n        for k_int in range(1, len(elements)): \n            curr = elements[k_int]\n            j_int = k_int\n            while j_int > 0: \n                if elements[j_int-1] > curr:\n                    elements[j_int] = elements[j_int-1]\n                    j_int -= 1\n                else:\n                    break\n            elements[j_int] = curr\n        result = ListNode()\n        curr = result\n\n        for k_int in range(len(elements)): \n            if k_int == len(elements) - 1:\n                curr.next = ListNode(val=elements[-1], next=None)\n            else:\n                curr.next = ListNode(val=elements[k_int])\n                curr = curr.next\n\n        return result.next\n",
        "optimized_code":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def insertionSortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next: \n            return head\n        elements = list()\n        while head: \n            elements.append(head.val)\n            head = head.next\n        \n        elements.sort()\n        result = ListNode()\n        curr = result\n        for k_int in range(len(elements)): \n            curr.next = ListNode(val=elements[k_int])\n            curr = curr.next\n\n        return result.next"
    },
    {
        "question_id":148,
        "name":"sort-list",
        "inefficient_code":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        def merge(head1, head2):\n            resultHead = ListNode(0)\n            cur = resultHead\n            while head1 != None or head2 != None:\n                if head1 == None:\n                    cur.next = head2\n                    head2 = None\n                elif head2 == None:\n                    cur.next = head1\n                    head1 = None\n                else:\n                    if head1.val < head2.val:\n                        cur.next = head1\n                        cur = head1\n                        head1 = head1.next \n                    else:\n                        cur.next = head2\n                        cur = head2\n                        head2 = head2.next\n            \n            return resultHead.next\n\n\n        def findOneBeforeMiddle(head):\n            fast = head\n            slow = head\n            prev = None\n            while fast and fast.next:\n                prev = slow\n\n                fast = fast.next.next\n                slow = slow.next\n                \n            return prev\n        \n        if not head or not head.next:\n            return head\n\n        prev = findOneBeforeMiddle(head)\n        if prev != None:\n            middle = prev.next\n            prev.next = None\n\n        return merge(self.sortList(head), self.sortList(middle))\n        \n\n        ",
        "optimized_code":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        def merge(head1, head2):\n            resultHead = ListNode(0)\n            cur = resultHead\n            while head1!= None or head2!= None:\n                if head1 == None:\n                    cur.next = head2\n                    head2 = None\n                elif head2 == None:\n                    cur.next = head1\n                    head1 = None\n                else:\n                    if head1.val < head2.val:\n                        cur.next = head1\n                        cur = head1\n                        head1 = head1.next \n                    else:\n                        cur.next = head2\n                        cur = head2\n                        head2 = head2.next\n            \n            return resultHead.next"
    },
    {
        "question_id":149,
        "name":"max-points-on-a-line",
        "inefficient_code":"class Solution:\n\n    def num(self, points, p1, p2):\n        v = [p2[0]-p1[0], p2[1]-p1[1]]\n        n = [v[1], -v[0]]\n        C = p2[0]*p1[1]-p1[0]*p2[1]\n        count = 0\n        for p in points:\n            sum_v = n[0]*p[0] + n[1]*p[1] + C\n\n            if sum_v == 0:\n                count += 1\n        return count\n\n\n    def maxPoints(self, points: List[List[int]]) -> int:\n    \n        n = len(points)\n        if n == 1:\n            return 1\n        max_num = 0\n        d = {}\n        for i in range(n):\n            for j in range(i+1,n):\n                if (i,j) in d or (j,i) in d:\n                    continue\n                max_num = max(max_num, self.num(points, points[i], points[j]))\n                d[(i,j)] = max_num\n        return max_num\n        ",
        "optimized_code":"class Solution:\n\n    def maxPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        if n == 1:\n            return 1\n        max_num = 0\n        d = {}\n        for i in range(n):\n            for j in range(i+1,n):\n                if (i,j) in d or (j,i) in d:\n                    continue\n                max_num = max(max_num, self.num(points, points[i], points[j]))\n                d[(i,j)] = max_num\n        return max_num"
    },
    {
        "question_id":150,
        "name":"evaluate-reverse-polish-notation",
        "inefficient_code":"class Solution:\n    def evalRPN(self, tokens):\n        operators = ['+', '-', '*', '\/']\n        stack = []\n        for i in tokens:\n            if i not in operators:\n                stack.append(i)\n            else:\n                operation = stack.pop(-2) + i + stack.pop()\n                stack.append(str(int(eval(operation))))\n        return int(stack[0])",
        "optimized_code":"class Solution:\n    def evalRPN(self, tokens):\n        operators = ['+', '-', '*', '\/']\n        stack = []\n        for i in tokens:\n            if i not in operators:\n                stack.append(i)\n            else:\n                operation = stack.pop(-2) + i + stack.pop()\n                stack.append(str(int(eval(operation))))\n        return int(stack[0])"
    },
    {
        "question_id":151,
        "name":"reverse-words-in-a-string",
        "inefficient_code":"class Solution:\n    def reverseWords(self, s: str) -> str:\n        return \" \".join(reversed(s.split()))\n        ",
        "optimized_code":"def reverseWords(self, s: str) -> str:\n    return \" \".join(reversed(s.split()))"
    },
    {
        "question_id":152,
        "name":"maximum-product-subarray",
        "inefficient_code":"class Solution:\n    def maxProduct(self, nums: List[int]) -> int:\n        max_prod = float('-inf')\n        prefix, suffix = 1, 1\n        n = len(nums)\n        for i in range(n):\n            if prefix == 0: prefix = 1\n            if suffix == 0: suffix = 1\n\n            prefix *= nums[i]\n            suffix *= nums[n - i - 1]\n            max_prod = max(max_prod, prefix, suffix)    # update max_prod only when either\n                                                        # prefix or suffix is greater\n                                                        # else max_prod is kept as it is\n        return max_prod",
        "optimized_code":"class Solution:\n    def maxProduct(self, nums: List[int]) -> int:\n        n = len(nums)\n        max_prod = float('-inf')\n        prefix, suffix = 1, 1\n        for i in range(n):\n            if prefix == 0: prefix = 1\n            if suffix == 0: suffix = 1\n            prefix *= nums[i]\n            suffix *= nums[n - i - 1]\n            max_prod = max(max_prod, prefix, suffix)\n        return max_prod"
    },
    {
        "question_id":153,
        "name":"find-minimum-in-rotated-sorted-array",
        "inefficient_code":"class Solution:\n    def findMin(self, arr: List[int]) -> int:\n        n = len(arr)\n        l = 0\n        h = n - 1\n        ans = float('inf')\n\n        while l <= h:\n            m = (l + h) \/\/ 2\n\n            if arr[l] <= arr[h]:\n                ans = min(arr[l], ans)\n                break\n\n            if arr[l] <= arr[m]:\n                ans = min (ans, arr[l])\n                l = m + 1\n            else:\n                ans = min(ans, arr[m])\n                h = m - 1\n        return ans\n        ",
        "optimized_code":"class Solution:\n    def findMin(self, arr: List[int]) -> int:\n        n = len(arr)\n        l, h = 0, n - 1\n\n        while l <= h:\n            m = (l + h) \/\/ 2\n\n            if arr[m] <= arr[l]:\n                ans = min(arr[m], arr[l])\n                l = m + 1\n            else:\n                ans = min(arr[l], arr[m])\n                h = m - 1\n        return ans"
    },
    {
        "question_id":154,
        "name":"find-minimum-in-rotated-sorted-array-ii",
        "inefficient_code":"class Solution:\n    def findMin(self, nums: List[int]) -> int:\n        n = len(nums)\n        l, r = 0, n - 1\n        if n == 1:\n            return nums[0]\n        if n == 2:\n            if nums[0] < nums[1]:\n                return nums[0]\n            else:\n                return nums[1]\n        while l < r:\n            mid = l + (r - l) \/\/ 2\n            \n            if nums[mid] < nums[l]:\n                r = mid\n            elif nums[mid] > nums[r]:\n                l = mid + 1\n            else:\n                r -= 1\n        \n        return nums[l]\n        \n\n        ",
        "optimized_code":"class Solution:\n    def findMin(self, nums: List[int]) -> int:\n        n = len(nums)\n        left = 0\n        right = n - 1\n        while left <= right:\n            mid = left + (right - left) \/\/ 2\n            \n            if nums[mid] < nums[left]:\n                right = mid - 1\n            elif nums[mid] > nums[right]:\n                left = mid + 1\n            else:\n                right -= 1\n        \n        return nums[left]"
    },
    {
        "question_id":155,
        "name":"min-stack",
        "inefficient_code":"class MinStack:\n\n    def __init__(self):\n        self.arr= []\n        \n\n    def push(self, val: int) -> None:\n        self.arr.append(val)\n\n    def pop(self) -> None:\n        self.arr.pop()\n\n    def top(self) -> int:\n        return self.arr[-1]\n\n    def getMin(self) -> int:\n        minNum=min(self.arr)\n        return minNum\n\n# Your MinStack object will be instantiated and called as such:\n# obj = MinStack()\n# obj.push(val)\n# obj.pop()\n# param_3 = obj.top()\n# param_4 = obj.getMin()",
        "optimized_code":"class MinStack:\n\n    def __init__(self):\n        self.stack = []\n        self.min_stack = []\n\n    def push(self, val: int) -> None:\n        if not self.stack or val <= self.min_stack[-1]:\n            self.min_stack.append(val)\n        else:\n            self.min_stack.append(self.min_stack[-1])\n        self.stack.append(val)\n\n    def pop(self) -> None:\n        if self.stack[-1] == self.min_stack[-1]:\n            self.min_stack.pop()\n        else:\n            self.min_stack.pop()\n\n    def top(self) -> int:\n        return self.stack[-1]\n\n    def getMin(self) -> int:\n        return self.min_stack[-1]"
    },
    {
        "question_id":160,
        "name":"intersection-of-two-linked-lists",
        "inefficient_code":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        pA=headA\n        pB=headB\n        while pA!=pB:\n            pA=pA.next if pA else headB\n            pB=pB.next if pB else headA\n        return pA\n        ",
        "optimized_code":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        pA=headA\n        pB=headB\n        while pA!=pB:\n            pA=pA.next if pA else headB\n            pB=pB.next if pB else headA\n        return pA"
    },
    {
        "question_id":162,
        "name":"find-peak-element",
        "inefficient_code":"class Solution:\n    def findPeakElement(self, nums: List[int]) -> int:\n        prev_val = nums[0]\n\n        # nums.append(-(2**31) -1)\n\n        peak = 0\n\n        for i in range(1,len(nums)):\n          if nums[i] > prev_val:\n            peak = i\n            prev_val = nums[i]\n          else:\n            break\n\n        return peak\n",
        "optimized_code":"class Solution:\n    def findPeakElement(self, nums: List[int]) -> int:\n        if len(nums) == 1:\n            return 0\n        peak = 0\n        for i in range(1, len(nums)):\n            if nums[i] > nums[peak]:\n                peak = i\n        return peak"
    },
    {
        "question_id":164,
        "name":"maximum-gap",
        "inefficient_code":"class Solution:\n    def maximumGap(self, nums: List[int]) -> int:\n        if len(nums) < 2:\n            return 0\n        \n        # Step 1: Find the minimum and maximum values in the array\n        min_val = min(nums)\n        max_val = max(nums)\n        \n        # Step 2: Calculate the size of each bucket\n        n = len(nums)\n        bucket_size = max(1, (max_val - min_val) \/\/ (n - 1))\n        \n        # Step 3: Calculate the number of buckets\n        bucket_count = (max_val - min_val) \/\/ bucket_size + 1\n        \n        # Step 4: Initialize buckets\n        buckets = [[float('inf'), float('-inf')] for _ in range(bucket_count)]\n        \n        # Step 5: Distribute elements into buckets\n        for num in nums:\n            bucket_index = (num - min_val) \/\/ bucket_size\n            buckets[bucket_index][0] = min(buckets[bucket_index][0], num)\n            buckets[bucket_index][1] = max(buckets[bucket_index][1], num)\n        \n        # Step 6: Remove empty buckets\n        buckets = [bucket for bucket in buckets if bucket[0] != float('inf')]\n        \n        # Step 7: Calculate the maximum gap\n        max_gap = 0\n        for i in range(1, len(buckets)):\n            max_gap = max(max_gap, buckets[i][0] - buckets[i-1][1])\n        \n        return max_gap\n\n# Example usage:\nsolution = Solution()\nnums = [3, 6, 9, 1]\nprint(solution.maximumGap(nums))  # Output: 3",
        "optimized_code":"class Solution:\n    def maximumGap(self, nums: List[int]) -> int:\n        if len(nums) < 2:\n            return 0\n        \n        # Step 1: Find the minimum and maximum values in the array\n        min_val = min(nums)\n        max_val = max(nums)\n        \n        # Step 2: Calculate the size of each bucket\n        n = len(nums)\n        bucket_size = max(1, (max_val - min_val) \/\/ (n - 1))\n        \n        # Step 3: Calculate the number of buckets\n        bucket_count = (max_val - min_val) \/\/ bucket_size + 1\n        \n        # Step 4: Initialize buckets\n        buckets = [[float('inf'), float('-inf')] for _ in range(bucket_count)]\n        \n        # Step 5: Distribute elements into buckets\n        for num in nums:\n            bucket_index = (num - min_val) \/\/ bucket_size\n            buckets[bucket_index"
    },
    {
        "question_id":165,
        "name":"compare-version-numbers",
        "inefficient_code":"class Solution:\n    def compareVersion(self, version1: str, version2: str) -> int:\n        v1List = version1.split('.')\n        v2List = version2.split('.')\n        maxLen = max(len(v1List), len(v2List))\n        print(v1List)\n        print(v2List)\n\n        for i in range(maxLen):\n            num1 = int(v1List[i]) if i<len(v1List) else 0\n            num2 = int(v2List[i]) if i<len(v2List) else 0\n\n            if (num1)>(num2):\n                return 1 \n            if (num1)<(num2):\n                return -1\n        return 0\n        ",
        "optimized_code":"class Solution:\n    def compareVersion(self, version1: str, version2: str) -> int:\n        v1List = version1.split('.')\n        v2List = version2.split('.')\n        maxLen = max(len(v1List), len(v2List))\n        print(v1List)\n        print(v2List)\n\n        for i in range(maxLen):\n            num1 = int(v1List[i]) if i<len(v1List) else 0\n            num2 = int(v2List[i]) if i<len(v2List) else 0\n\n            if (num1)>(num2):\n                return 1 \n            if (num1)<(num2):\n                return -1\n        return 0"
    },
    {
        "question_id":166,
        "name":"fraction-to-recurring-decimal",
        "inefficient_code":"class Solution:\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\n        if numerator==0:\n            return \"0\"\n        if denominator == 0:\n            return\n        string = \"\"\n        if numerator * denominator < 0 :\n            string += \"-\"\n        numerator, denominator = abs(numerator), abs(denominator)\n        quo = numerator\/\/denominator\n        string += str(quo)\n        rem = numerator%denominator\n\n        if rem==0:\n            return string\n        else:\n            string += \".\"\n        seen = {}\n        while rem:\n            if rem in seen:\n                ind = seen[rem]\n                return ''.join(string[:ind]) + \"(\" + ''.join(string[ind:]) + \")\"\n            seen[rem] = len(string)\n            rem *= 10\n            quo = rem\/\/denominator\n            rem = rem%denominator\n            string += str(quo)\n        return ''.join(string)\n\n        \n\n        \n\n        ",
        "optimized_code":"class Solution:\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\n        if numerator==0:\n            return \"0\"\n        if denominator == 0:\n            return\n        string = \"\"\n        if numerator * denominator < 0 :\n            string += \"-\"\n        numerator, denominator = abs(numerator), abs(denominator)\n        quo = numerator\/\/denominator\n        string += str(quo)\n        rem = numerator%denominator\n\n        if rem==0:\n            return string\n        else:\n            string += \".\"\n        seen = {}\n        while rem:\n            if rem in seen:\n                ind = seen[rem]\n                return ''.join(string[:ind]) + \"(\" + ''.join(string[ind:]) + \")\"\n            seen[rem] = len(string)\n            rem *= 10\n            quo = rem\/\/denominator\n            rem = rem%denominator\n            string += str(quo)\n        return ''.join(string)"
    },
    {
        "question_id":167,
        "name":"two-sum-ii-input-array-is-sorted",
        "inefficient_code":"class Solution:\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\n\n        left = 0\n        right = len(numbers) - 1\n\n        while left < right:\n            total = numbers[left] + numbers[right]\n\n            if total == target:\n                return [left + 1, right + 1]\n            elif total > target:\n                right -= 1\n            else:\n                left += 1 \n        ",
        "optimized_code":"class Solution:\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\n\n        left = 0\n        right = len(numbers) - 1\n\n        while left < right:\n            total = numbers[left] + numbers[right]\n\n            if total == target:\n                return [left + 1, right + 1]\n            elif total > target:\n                right -= 1\n            else:\n                left += 1 \n        \n\n#### Comment:\n# [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]\n# [10,1,20,30,40,50,60,70,80,90,100]\n# 2 -> 10\n# 2 -> 1\n# 2 -> 20\n# 2 -> 30\n# 2 -> 40\n# 2 -> 50\n# 2 ->"
    },
    {
        "question_id":168,
        "name":"excel-sheet-column-title",
        "inefficient_code":"class Solution:\n    def convertToTitle(self, columnNumber: int) -> str:\n        alphanumeric = {val:chr(a) for a,val in zip(range(65,91), range(1,27))}\n        alphanumeric[0] = \"Z\"            \n\n        if columnNumber < 27 :\n            return alphanumeric[columnNumber]\n\n        if columnNumber % 26 == 0:\n            return self.convertToTitle((columnNumber\/\/26)-1)+alphanumeric[(columnNumber%26)]\n        \n        return self.convertToTitle((columnNumber)\/\/26) + self.convertToTitle(columnNumber%26)\n        ",
        "optimized_code":"class Solution:\n    def convertToTitle(self, columnNumber: int) -> str:\n        if columnNumber < 27:\n            return chr(alphanumeric[columnNumber])\n        \n        if columnNumber % 26 == 0:\n            return chr(alphanumeric[(columnNumber\/\/26)-1]) + chr(alphanumeric[columnNumber%26])\n        \n        return chr(alphanumeric[(columnNumber)\/\/26]) + self.convertToTitle(columnNumber%26)"
    },
    {
        "question_id":169,
        "name":"majority-element",
        "inefficient_code":"class Solution:\n    def majorityElement(self, nums: List[int]) -> int:\n        dic={}\n        maj=len(nums)\/\/2\n        for i in nums:\n            if i in dic:\n                dic[i]+=1\n            else:\n                dic[i]=1\n            \n            if dic[i]>maj:\n                return i\n            ",
        "optimized_code":"class Solution:\n    def majorityElement(self, nums: List[int]) -> int:\n        return self.find_majority(nums)"
    },
    {
        "question_id":171,
        "name":"excel-sheet-column-number",
        "inefficient_code":"class Solution:\n    def titleToNumber(self, columnTitle: str) -> int:\n        s=\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n        sum=0\n        for i in range(len(columnTitle)):\n            sum=sum+26**(len(columnTitle)-i-1)*(s.index(columnTitle[i])+1)\n        return sum\n\n        ",
        "optimized_code":"class Solution:\n    def titleToNumber(self, columnTitle: str) -> int:\n        s=\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n        sum=0\n        for i in range(len(columnTitle)):\n            sum=sum+26**(len(columnTitle)-i-1)*(s.index(columnTitle[i])+1)\n        return sum"
    },
    {
        "question_id":172,
        "name":"factorial-trailing-zeroes",
        "inefficient_code":"class Solution:\n    def trailingZeroes(self, n: int) -> int:\n        value = math.factorial(n)\n        ans = 0\n        while value%10 == 0:\n            ans+=1\n            value = value\/\/10\n        return ans",
        "optimized_code":"class Solution:\n    def trailingZeroes(self, n: int) -> int:\n        ans = 0\n        while n>0:\n            ans += n\/\/5\n            n = n\/\/5\n        return ans"
    },
    {
        "question_id":173,
        "name":"binary-search-tree-iterator",
        "inefficient_code":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass BSTIterator:\n\n    def __init__(self, root: Optional[TreeNode]):\n        self.__in_order = []\n\n        def populate(node: TreeNode) -> None:\n            if node:\n                if node.left: populate(node.left)\n                self.__in_order.append(node.val)\n                if node.right: populate(node.right)\n        populate(root)\n        self.__length = len(self.__in_order)\n        self.__i = 0\n\n    def next(self) -> int:\n        val = self.__in_order[self.__i]\n        self.__i += 1\n        return val\n\n    def hasNext(self) -> bool:\n        return self.__i < self.__length\n\n\n# Your BSTIterator object will be instantiated and called as such:\n# obj = BSTIterator(root)\n# param_1 = obj.next()\n# param_2 = obj.hasNext()",
        "optimized_code":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass BSTIterator:\n\n    def __init__(self, root: Optional[TreeNode]):\n        self.__in_order = []\n        self.__i = 0\n\n        def populate(node: TreeNode) -> None:\n            if node:\n                if node.left:\n                    populate(node.left)\n                self.__in_order.append(node.val)\n                if node.right:\n                    populate(node.right)\n        populate(root)\n        self.__length = len(self.__in_order)\n        self.__i = 0\n\n    def next(self) -> int:\n        val = self.__in_order[self.__i]\n        self.__i += 1\n        return val\n\n    def hasNext(self) -> bool:\n        return self.__i < self.__length\n\n\n# Your"
    },
    {
        "question_id":174,
        "name":"dungeon-game",
        "inefficient_code":"class Solution:\n    def calculateMinimumHP(self, arr: List[List[int]]) -> int:\n        n = len(arr)\n        m = len(arr[0])\n        def solve(idx1, idx2, cache):\n            if idx1 >= n or idx2 >= m:\n                return float('inf')\n            if idx1 == n-1 and idx2 == m-1:\n                return 1 if arr[-1][-1] >= 0 else -arr[-1][-1] + 1\n            \n            if (idx1, idx2) in cache:\n                return cache[(idx1, idx2)]\n            \n            option1 = solve(idx1 + 1, idx2, cache)\n            option2 = solve(idx1, idx2 + 1, cache)\n            cache[(idx1, idx2)] = min(option1, option2) - arr[idx1][idx2]\n            if cache[(idx1, idx2)] <= 0:\n                cache[(idx1, idx2)] = 1\n            return cache[(idx1, idx2)]\n        cache = {}\n        res = solve(0, 0, cache)\n        print(cache)\n        return res",
        "optimized_code":"class Solution:\n    def calculateMinimumHP(self, arr: List[List[int]]) -> int:\n        n = len(arr)\n        m = len(arr[0])\n        def solve(idx1, idx2, cache):\n            if idx1 >= n or idx2 >= m:\n                return float('inf')\n            if idx1 == n-1 and idx2 == m-1:\n                return 1 if arr[-1][-1] >= 0 else -arr[-1][-1] + 1\n            \n            if (idx1, idx2) in cache:\n                return cache[(idx1, idx2)]\n            \n            option1 = solve(idx1 + 1, idx2, cache)\n            option2 = solve(idx1, idx2 + 1, cache)\n            cache[(idx1, idx2)] = min(option1, option2) - arr[idx1][idx2]\n            if cache[(idx1, idx2)] <= 0:\n                cache"
    },
    {
        "question_id":179,
        "name":"largest-number",
        "inefficient_code":"def insert (n, l) :\n    l.append (n)\n    i = len (l) - 1\n    while i and str(n) + str(l[i-1]) > str(l[i-1]) + str(n): \n        l[i] = l[i-1]\n        i -= 1\n    l[i] = n\n\nclass Solution:\n    def largestNumber(self, nums: List[int]) -> str:\n        result = []\n        for i in nums :\n            insert (i, result)\n        return str (int (''.join ([str (i) for i in result])))",
        "optimized_code":"def insert (n, l) :\n    l.append (n)\n    i = len (l) - 1\n    while i and str(n) + str(l[i-1]) > str(l[i-1]) + str(n): \n        l[i] = l[i-1]\n        i -= 1\n\nclass Solution:\n    def largestNumber(self, nums: List[int]) -> str:\n        result = []\n        for i in nums :\n            insert (i, result)\n        return ''.join (str (i) for i in result)"
    },
    {
        "question_id":187,
        "name":"repeated-dna-sequences",
        "inefficient_code":"class Solution:\n    def findRepeatedDnaSequences(self, s: str) -> List[str]:\n        if len(s) < 10:\n            return []\n\n        mp = {}\n\n        l = 0\n        r = 9\n        currList = collections.deque()\n        for i in range(10):\n            currList.append(s[i])\n\n        mp[tuple(currList)] = 0\n        r = 10\n        ans = []\n\n        while r < len(s):\n            currList.append(s[r])\n            currList.popleft()\n            dna = tuple(currList)\n            if dna in mp and mp[dna] != 1:\n                ans.append(\"\".join(currList))\n                mp[dna] = 1\n            elif dna not in mp:\n                mp[dna] = 0\n            r+=1\n        return ans\n\n\n\n\n\n\n\n\n        ",
        "optimized_code":"class Solution:\n    def findRepeatedDnaSequences(self, s: str) -> List[str]:\n        if len(s) < 10:\n            return []\n\n        mp = {}\n\n        l = 0\n        r = 9\n        currList = collections.deque()\n        for i in range(10):\n            currList.append(s[i])\n\n        mp[tuple(currList)] = 0\n        r = 10\n        ans = []\n\n        while r < len(s):\n            currList.append(s[r])\n            currList.popleft()\n            dna = tuple(currList)\n            if dna in mp and mp[dna]!= 1:\n                ans.append(\"\".join(currList))\n                mp[dna] = 1\n            elif dna not in mp:\n                mp[dna] = 0\n            r+=1\n        return ans"
    },
    {
        "question_id":188,
        "name":"best-time-to-buy-and-sell-stock-iv",
        "inefficient_code":"class Solution:\n    def maxProfit(self, k: int, prices: List[int]) -> int:\n        @cache\n        def dp(i, is_held, transactions):\n            if i >= n or transactions >= k:\n                return 0\n            \n            price = dp(i + 1, is_held, transactions)\n            if is_held:\n                price = max(price, prices[i] + dp(i + 1, False, transactions + 1))\n            else:\n                price = max(price, -prices[i] + dp(i + 1, True, transactions))\n            \n            return price\n        \n        n = len(prices)\n        return dp(0, False, 0)\n",
        "optimized_code":"class Solution:\n    def maxProfit(self, k: int, prices: List[int]) -> int:\n        @cache\n        def dp(i, is_held, transactions):\n            if i >= n or transactions >= k:\n                return 0\n            \n            price = dp(i + 1, is_held, transactions)\n            if is_held:\n                price = max(price, prices[i] + dp(i + 1, False, transactions + 1))\n            else:\n                price = max(price, -prices[i] + dp(i + 1, True, transactions))\n            \n            return price\n        \n        n = len(prices)\n        return dp(0, False, 0)"
    },
    {
        "question_id":189,
        "name":"rotate-array",
        "inefficient_code":"class Solution:\n    def rotate(self, nums: List[int], k: int) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        l = len(nums)\n        if k > l:\n            k = k%l\n        \n        if k == l  :\n            return nums\n        \n\n        a = nums[-k:]\n        for i in range(l):           \n            a.append(nums[i])\n            nums[i]=a.pop(0)\n\n\n        ",
        "optimized_code":"class Solution:\n    def rotate(self, nums: List[int], k: int) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        l = len(nums)\n        if k > l:\n            k = k%l\n        \n        if k == l  :\n            return nums\n        \n\n        a = nums[-k:]\n        for i in range(l):           \n            a.append(nums[i])\n            nums[i]=a.pop(0)"
    },
    {
        "question_id":190,
        "name":"reverse-bits",
        "inefficient_code":"class Solution:\n    def reverseBits(self, n: int) -> int:\n        r=0\n        for i in range(32):\n            r=(r<<1)|(n&1)\n            n>>=1\n        return r\n\n    \n        ",
        "optimized_code":"class Solution:\n    def reverseBits(self, n: int) -> int:\n        return bin(n)[2:].zfill(32)"
    },
    {
        "question_id":191,
        "name":"number-of-1-bits",
        "inefficient_code":"class Solution:\n    def hammingWeight(self, n: int) -> int:\n        s=bin(n)\n        count=0\n        for i in range(0, len(s)):\n            if s[i] == '1':\n                count+=1\n        return count",
        "optimized_code":"class Solution:\n    def hammingWeight(self, n: int) -> int:\n        return bin(n).count('1')"
    },
    {
        "question_id":198,
        "name":"house-robber",
        "inefficient_code":"class Solution:\n    def rob(self, nums: List[int]) -> int:\n        \n        if (len(nums) == 0):\n            return 0\n        elif (len(nums) == 1):\n            return nums[0]\n        elif (len(nums) == 2):\n            return max(nums)\n        \n        dp = [0]* len(nums)\n        dp[0] = nums[0]\n        dp[1] = max(nums[0:2])\n        \n        \n        for i in range(2, len(nums)):\n            dp[i] = max(dp[i-1], dp[i-2]+nums[i])\n        return dp[-1]",
        "optimized_code":"class Solution:\n    def rob(self, nums: List[int]) -> int:\n        if (len(nums) == 0):\n            return 0\n        elif (len(nums) == 1):\n            return nums[0]\n        elif (len(nums) == 2):\n            return max(nums)\n        \n        # dp[0] = 0\n        # dp[1] = nums[0]\n        \n        # for i in range(2, len(nums)):\n        #     dp[i] = max(dp[i-1], dp[i-2]+nums[i])\n        # return dp[-1]\n        \n        dp = [0]*len(nums)\n        \n        for i in range(1, len(nums)):\n            dp[i] = max(dp[i-1], dp[i-2]+nums[i])\n        return dp[-1]"
    },
    {
        "question_id":199,
        "name":"binary-tree-right-side-view",
        "inefficient_code":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\n        def dfs(root, level):\n            if not root:\n                return\n            if len(res) == level:\n                res.append(root.val)\n            dfs(root.right, level + 1)\n            dfs(root.left, level + 1)\n        res = []\n        dfs(root, 0)\n        return res",
        "optimized_code":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\n        def dfs(root, level):\n            if not root:\n                return\n            if len(res) == level:\n                res.append(root.val)\n            dfs(root.right, level + 1)\n            dfs(root.left, level + 1)\n        res = []\n        dfs(root, 0)\n        return res"
    },
    {
        "question_id":200,
        "name":"number-of-islands",
        "inefficient_code":"class Solution:\n    def numIslands(self, grid: List[List[str]]) -> int:\n        visited = set()\n        n, m = len(grid), len(grid[0])\n        count = 0\n        moves = [(1,0),\n                 (0,1),\n                 (-1,0),\n                 (0,-1)\n        ]\n        def helper(x: int, y: int) -> None:\n            # if (x,y) in visited:\n            #     return \n            for dx, dy in moves:\n                if 0 <= x+dx <= n-1 and 0 <= y+dy <= m-1 and grid[x+dx][y+dy] == \"1\" and (x+dx, y+dy) not in visited:\n                    visited.add((x+dx, y+dy))\n                    helper(x+dx, y+dy)\n            return \n        for x in range(n):\n            for y in range(m):\n                if (x,y) not in visited and grid[x][y] == \"1\":\n                    helper(x,y)\n                    count += 1\n                #count += helper(x,y) if (x,y) not in visited and grid[x][y] == 1 else count\n        return count\n    \n    \n\n        \n\n\n\n\n# class Solution:\n#     def numIslands(self, grid: List[List[str]]) -> int:\n#         m, n = len(grid), len(grid[0])\n#         visited = set()\n#         dirs = [(1,0),(-1,0),(0,1),(0,-1)]\n#         def dfs(x,y):\n#             visited.add((x,y))\n#             for dx,dy in dirs:\n#                 newx,newy = x+dx, y+dy\n#                 if 0<=newx<=m-1 and 0<=newy<=n-1 and (newx,newy) not in visited and grid[newx][newy] == \"1\":\n#                     dfs(newx,newy)\n#             return\n#         res = 0\n#         for i in range(m):\n#             for j in range(n):\n#                 if (i,j) not in visited and grid[i][j] == \"1\":\n#                     dfs(i,j)\n#                     res += 1\n#         return res\n\n\n\n\n\n\n\n        # m, n = len(grid), len(grid[0])\n        # dirs = [(0,1),(1,0),(-1,0),(0,-1)]\n        # visited = set()\n        # def bfs(node):\n        #     queue = deque()\n        #     queue.append((node[0],node[1]))\n        #     visited.add(node)\n        #     while queue:\n        #         for i in range(len(queue)):\n        #             x,y = queue.popleft()\n        #             for dx,dy in dirs:\n        #                 if 0<=x+dx<=m-1 and 0<=y+dy<=n-1 and grid[x+dx][y+dy] == '1' and (x+dx,y+dy) not in visited:\n        #                     visited.add((x+dx,y+dy))\n        #                     queue.append((x+dx,y+dy))\n        #     return 1\n        # total = 0\n        # for i in range(m):\n        #     for j in range(n):\n        #         if grid[i][j] == \"1\" and (i,j) not in visited:\n        #             total += bfs((i,j))\n        # return total\n\n\n\n        ",
        "optimized_code":"# class Solution:\n#     def numIslands(self, grid: List[List[str]]) -> int:\n#         m, n = len(grid), len(grid[0])\n#         dirs = [(0,1),(1,0),(-1,0),(0,-1)]\n#         visited = set()\n#         count = 0\n#         def bfs(x,y):\n#             queue = deque()\n#             queue.append((x,y))\n#             visited.add((x,y))\n#             while queue:\n#                 for i in range(len(queue)):\n#                     x,y = queue.popleft()\n#                     for dx,dy in dirs:\n#                         if 0<=x+dx<=m-1 and 0<=y+dy<=n-1 and grid[x+dx][y+dy] == \"1\" and (x+dx,y+dy) not in visited:\n#                             visited.add((x+dx,y+dy))\n#                             queue.append((x"
    },
    {
        "question_id":201,
        "name":"bitwise-and-of-numbers-range",
        "inefficient_code":"class Solution:\n    def rangeBitwiseAnd(self, left: int, right: int) -> int:\n        bl = bin(left)[2:]\n        br = bin(right)[2:]\n\n        bl = '0'*(len(br)-len(bl)) + bl\n\n        n = len(br)\n        res = 0\n\n        for i in range(n):\n            if br[i] == '1':\n                if bl[i] == '1':\n                    res += 1 << (n-1-i)\n                else:\n                    break\n        \n        return res",
        "optimized_code":"class Solution:\n    def rangeBitwiseAnd(self, left: int, right: int) -> int:\n        return left & right"
    },
    {
        "question_id":202,
        "name":"happy-number",
        "inefficient_code":"class Solution:\n    def isHappy(self, n: int) -> bool:\n        def get_next(number: int) -> int:\n            total_sum = 0\n            while number > 0:\n                digit = number % 10\n                total_sum += digit * digit\n                number \/\/= 10\n            return total_sum\n        \n        seen = set()\n        while n != 1 and n not in seen:\n            seen.add(n)\n            n = get_next(n)\n        \n        return n == 1\n",
        "optimized_code":"class Solution:\n    def isHappy(self, n: int) -> bool:\n        def get_next(number: int) -> int:\n            total_sum = 0\n            while number > 0:\n                digit = number % 10\n                total_sum += digit * digit\n                number \/\/= 10\n            return total_sum\n        \n        seen = set()\n        while n!= 1 and n not in seen:\n            seen.add(n)\n            n = get_next(n)\n        \n        return n == 1"
    },
    {
        "question_id":203,
        "name":"remove-linked-list-elements",
        "inefficient_code":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\n        dummy = ListNode(next=head)\n        slow = dummy\n        runner = head\n        while runner:\n            if runner.val == val:\n                # Skip the runner node since its value is equal to 'val'\n                slow.next = runner.next\n            else:\n                # Move the slow pointer if the value is not equal to 'val'\n                slow = runner\n            \n            # Move the runner pointer forward\n            runner = runner.next\n        \n        return dummy.next",
        "optimized_code":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\n        runner = head\n        dummy = ListNode(next=head)\n        while runner:\n            if runner.val == val:\n                # Skip the runner node since its value is equal to 'val'\n                runner.next = runner.next.next\n            else:\n                # Move the slow pointer if the value is not equal to 'val'\n                dummy = dummy.next\n                runner = runner.next\n        \n        return dummy.next\n\n#### Input Code:\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeElements(self, head"
    },
    {
        "question_id":204,
        "name":"count-primes",
        "inefficient_code":"class Solution:\n    def countPrimes(self, n: int) -> int:\n        if n==0 or n==1:\n            return 0\n        c = n - 2\n        lst = [True for i in range(0, n)]\n        for i in range(2, int(sqrt(n)) + 1):\n            if lst[i] == True: \n                j = i\n                while i*j < n :\n                    if lst[i*j] == True:\n                        lst[i*j] = False\n                        c -= 1\n                    j += 1 \n        return c\n\n        ",
        "optimized_code":"class Solution:\n    def countPrimes(self, n: int) -> int:\n        if n==0 or n==1:\n            return 0\n        c = n - 2\n        lst = [True for i in range(0, n)]\n        for i in range(2, int(sqrt(n)) + 1):\n            if lst[i] == True: \n                j = i\n                while i*j < n :\n                    if lst[i*j] == True:\n                        lst[i*j] = False\n                        c -= 1\n                    j += 1 \n        return c"
    },
    {
        "question_id":205,
        "name":"isomorphic-strings",
        "inefficient_code":"class Solution:\n    def isIsomorphic(self, s: str, t: str) -> bool:\n        stot = {}\n        ttos = {}\n        for s_, t_ in zip(s, t):\n            if s_ in stot and stot.get(s_)!=t_:\n                return False\n            if t_ in ttos and ttos.get(t_)!=s_:\n                return False\n\n            stot[s_] = t_\n            ttos[t_] = s_\n        return True\n            \n\n            \n\n\n\n\n\n\n\n\n\n        # s2t_dict = {}\n        # t2s_dict = {}\n        # for key, value in zip(s, t):\n        #     if (key in s2t_dict) and value != s2t_dict[key]:\n        #         return False\n        #     if (value in t2s_dict) and key != t2s_dict[value]:\n        #         return False\n            \n        #     if key not in s2t_dict:\n        #         s2t_dict[key] = value\n        #     if value not in t2s_dict:\n        #         t2s_dict[value] = key\n        \n        # return True\n            \n        ",
        "optimized_code":"class Solution:\n    def isIsomorphic(self, s: str, t: str) -> bool:\n        if len(s)!= len(t):\n            return False\n        s2t_dict = {}\n        t2s_dict = {}\n        for i in range(len(s)):\n            if s[i] not in s2t_dict:\n                s2t_dict[s[i]] = t[i]\n            if t[i] not in t2s_dict:\n                t2s_dict[t[i]] = s[i]\n            if s2t_dict[s[i]]!= t[i]:\n                return False\n            if t2s_dict[t[i]]!= s[i]:\n                return False\n        \n        return True"
    },
    {
        "question_id":206,
        "name":"reverse-linked-list",
        "inefficient_code":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if head == None:\n            return head\n        curr = head\n        prev = None\n\n        while curr != None:\n            next = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next\n        return prev",
        "optimized_code":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if head == None:\n            return head\n        curr = head\n        prev = None\n        while curr!= None:\n            next = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next\n        return prev"
    },
    {
        "question_id":207,
        "name":"course-schedule",
        "inefficient_code":"class Solution:\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\n        n = numCourses\n        incoming = [0] * n\n        outgoing = [[] for _ in range(n)]\n        for prereq in prerequisites:\n            before, after = prereq\n            incoming[after] += 1\n            outgoing[before].append(after)\n        while True:\n            if all(i == -1 for i in incoming):\n                return True\n            node = -1\n            for i, elm in enumerate(incoming):\n                if elm == 0:\n                    node = i\n                    incoming[i] = -1\n                    break\n            if node == -1:\n                return False\n            outgoings = outgoing[node]\n            for o in outgoings:\n                incoming[o] -= 1\n            \n            \n\n",
        "optimized_code":"class Solution:\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\n        n = numCourses\n        incoming = [0] * n\n        outgoing = [[] for _ in range(n)]\n        for prereq in prerequisites:\n            before, after = prereq\n            incoming[after] += 1\n            outgoing[before].append(after)\n        while True:\n            if all(i == -1 for i in incoming):\n                return True\n            node = -1\n            for i, elm in enumerate(incoming):\n                if elm == 0:\n                    node = i\n                    incoming[i] = -1\n                    break\n            if node == -1:\n                return False\n            outgoings = outgoing[node]\n            for o in outgoings:\n                incoming[o] -= 1\n            for o in outgoings:\n                if incoming[o] == 0:\n                    return False\n        return True"
    },
    {
        "question_id":208,
        "name":"implement-trie-prefix-tree",
        "inefficient_code":"class TrieLayer:\n    def __init__(self):\n        self.ends = False\n        self.layer = [None for i in range(26)]\nclass Trie:\n    # Trie is basically made up of nested arrays\n\n    def __init__(self):\n        # make the initial array, but it's all empty. Should be of size 26 b\/c we're using english letters\n        self.first = TrieLayer()\n        \n    def index(self, letter):\n        return ord(letter) - ord('a')\n\n    def insert(self, word: str) -> None:\n        # I mark the end of a word by setting \n        curr = self.first\n        for letter in word:\n            index = self.index(letter)\n            if not curr.layer[index]:\n                curr.layer[index] = TrieLayer()\n            curr = curr.layer[index]\n        curr.ends = True\n\n    def search(self, word: str) -> bool:\n        curr = self.first\n        for letter in word:\n            index = self.index(letter)\n            if not curr.layer[index]:\n                return False\n            curr = curr.layer[index]\n        return curr.ends\n        \n\n    def startsWith(self, prefix: str) -> bool:\n        curr = self.first\n        for letter in prefix:\n            index = self.index(letter)\n            if not curr.layer[index]:\n                return False\n            curr = curr.layer[index]\n        return True\n        # we support prefix search by checking the list to see if anything exists there\n        \n\n\n# Your Trie object will be instantiated and called as such:\n# obj = Trie()\n# obj.insert(word)\n# param_2 = obj.search(word)\n# param_3 = obj.startsWith(prefix)",
        "optimized_code":"class Trie:\n    # Trie is basically made up of nested arrays\n\n    def __init__(self):\n        # make the initial array, but it's all empty. Should be of size 26 b\/c we're using english letters\n        self.first = TrieLayer()\n        \n    def index(self, letter):\n        return ord(letter) - ord('a')\n\n    def insert(self, word: str) -> None:\n        # I mark the end of a word by setting \n        curr = self.first\n        for letter in word:\n            index = self.index(letter)\n            if not curr.layer[index]:\n                curr.layer[index] = TrieLayer()\n            curr = curr.layer[index]\n        curr.ends = True\n\n    def search(self, word: str) -> bool:\n        curr = self.first\n        for letter in word:\n            index = self.index(letter)\n            if not curr.layer[index]:\n                return False\n            curr = curr.layer[index]\n        return curr.ends"
    },
    {
        "question_id":209,
        "name":"minimum-size-subarray-sum",
        "inefficient_code":"class Solution:\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\n        l = 0\n        r = 0\n        sum_count = nums[0]\n        min_len = float('inf')\n\n        while r <= len(nums) - 1:\n            if sum_count < target:\n                r += 1\n                if r <= len(nums) - 1:\n                    sum_count += nums[r]\n            else:\n                min_len = min(min_len, r-l+1)\n                sum_count -= nums[l]\n                l += 1\n        return 0 if min_len == float('inf') else min_len\n        ",
        "optimized_code":"class Solution:\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\n        l = 0\n        r = 0\n        sum_count = nums[0]\n        min_len = float('inf')\n\n        while r <= len(nums) - 1:\n            if sum_count < target:\n                r += 1\n                if r <= len(nums) - 1:\n                    sum_count += nums[r]\n            else:\n                min_len = min(min_len, r-l+1)\n                sum_count -= nums[l]\n                l += 1\n        return 0 if min_len == float('inf') else min_len"
    },
    {
        "question_id":210,
        "name":"course-schedule-ii",
        "inefficient_code":"from collections import defaultdict, deque\n\nclass Solution:\n\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\n        # define a dependency array\n        depend_array = [0 ] * numCourses\n        # course dependency map\n        course_map = defaultdict(list)\n        for pair in prerequisites:\n            depend_array[pair[1]] += 1\n            course_map[pair[0]].append(pair[1])\n        \n        queue = deque()\n        result_list = deque()\n        for i in range(len(depend_array)):\n            if depend_array[i] == 0:\n                queue.append(i)\n        while queue:\n            print(queue)\n            current_course = queue.popleft()\n            result_list.appendleft(current_course)\n            for latter_course in course_map[current_course]:\n                depend_array[latter_course] -= 1\n                if depend_array[latter_course] == 0:\n                    queue.append(latter_course)\n        if len(result_list) == numCourses:\n            return result_list\n        # elif len(result_list) != numCourses:\n            # return []\n        return []\n ",
        "optimized_code":"from collections import defaultdict, deque\n\nclass Solution:\n\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\n        # define a dependency array\n        depend_array = [0 ] * numCourses\n        # course dependency map\n        course_map = defaultdict(list)\n        for pair in prerequisites:\n            depend_array[pair[1]] += 1\n            course_map[pair[0]].append(pair[1])\n        \n        queue = deque()\n        result_list = deque()\n        for i in range(len(depend_array)):\n            if depend_array[i] == 0:\n                queue.append(i)\n        while queue:\n            current_course = queue.popleft()\n            result_list.appendleft(current_course)\n            for latter_course in course_map[current_course]:\n                depend_array[latter_course] -= 1\n                if depend_array[latter_course] == 0:\n                    queue.append(latter_course)\n        if len(result_list) == numCourses:"
    },
    {
        "question_id":211,
        "name":"design-add-and-search-words-data-structure",
        "inefficient_code":"class Node:\r\n    def __init__(self):\r\n        self.children = {}\r\n        self.isComplete = False\r\n\r\nclass WordDictionary:\r\n\r\n    def __init__(self):\r\n        self.root = Node() # create root of trie\r\n        \r\n\r\n    def addWord(self, word: str) -> None:\r\n        curNode = self.root\r\n        for letter in word:\r\n            if letter not in curNode.children:\r\n                curNode.children[letter] = Node()\r\n            curNode = curNode.children[letter]\r\n        curNode.isComplete = True\r\n\r\n    def search(self, word: str) -> bool:\r\n        def dfs(i, curNode):\r\n            if i == len(word): \r\n                return curNode.isComplete\r\n            for childLetter in curNode.children.keys():\r\n                if word[i] == childLetter:\r\n                    if dfs(i + 1, curNode.children[childLetter]):\r\n                        return True\r\n                elif word[i] == '.':\r\n                    if dfs(i + 1, curNode.children[childLetter]):\r\n                        return True\r\n        return dfs(0, self.root)",
        "optimized_code":"class Node:\r\n    def __init__(self):\r\n        self.children = {}\r\n        self.isComplete = False\r\n\r\nclass WordDictionary:\r\n\r\n    def __init__(self):\r\n        self.root = Node() # create root of trie\r\n        \r\n\r\n    def addWord(self, word: str) -> None:\r\n        curNode = self.root\r\n        for letter in word:\r\n            if letter not in curNode.children:\r\n                curNode.children[letter] = Node()\r\n            curNode = curNode.children[letter]\r\n        curNode.isComplete = True\r\n\r\n    def search(self, word: str) -> bool:\r\n        def dfs(i, curNode):\r\n            if i == len(word): \r\n                return curNode.isComplete\r\n            for childLetter in curNode.children.keys():\r\n                if word[i] == childLetter:\r\n                    if dfs(i + 1, curNode.children[childLetter]):\r\n                        return True\r\n                elif word[i] == '.':\r\n                    if dfs(i + 1, curNode.children"
    },
    {
        "question_id":212,
        "name":"word-search-ii",
        "inefficient_code":"class Trie:\n    def __init__(self):\n        self.children = [None] * 26\n        self.w = ''\n        # minor ajust, not a boolean is_end, but the whole word\n        # so it's easier for dfs to save the word\n\n    def insert(self, w):\n        node = self\n        for c in w:\n            idx = ord(c) - ord('a')\n            if node.children[idx] is None:\n                node.children[idx] = Trie()\n            node = node.children[idx]\n        node.w = w\n\n\nclass Solution:\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\n        def dfs(node, i, j):\n            idx = ord(board[i][j]) - ord('a')\n            if node.children[idx] is None:\n                return\n            node = node.children[idx]\n            if node.w:\n                ans.add(node.w)\n            c = board[i][j]\n            board[i][j] = '0' # 0 for visited already\n            for a, b in [[0, -1], [0, 1], [1, 0], [-1, 0]]:\n                x, y = i + a, j + b\n                if 0 <= x < m and 0 <= y < n and board[x][y] != '0':\n                    dfs(node, x, y)\n            board[i][y] = c\n\n        trie = Trie()\n        for w in words:\n            trie.insert(w)\n        ans = set()\n        m, n = len(board), len(board[0])\n        for i in range(m):\n            for j in range(n):\n                dfs(trie, i, j)\n        return list(ans)\n\n\n################\n\n\nclass Trie:\n    def __init__(self):\n        self.children: List[Trie | None] = [None] * 26\n        self.ref: int = -1\n\n    def insert(self, w: str, ref: int):\n        node = self\n        for c in w:\n            idx = ord(c) - ord('a')\n            if node.children[idx] is None:\n                node.children[idx] = Trie()\n            node = node.children[idx]\n        node.ref = ref\n\n\nclass Solution:\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\n        def dfs(node: Trie, i: int, j: int):\n            idx = ord(board[i][j]) - ord('a')\n            if node.children[idx] is None:\n                return\n            node = node.children[idx]\n            if node.ref >= 0:\n                ans.append(words[node.ref])\n                node.ref = -1\n            c = board[i][j]\n            board[i][j] = '#'\n            for a, b in pairwise((-1, 0, 1, 0, -1)):\n                x, y = i + a, j + b\n                if 0 <= x < m and 0 <= y < n and board[x][y] != '#':\n                    dfs(node, x, y)\n            board[i][j] = c\n\n        tree = Trie()\n        for i, w in enumerate(words):\n            tree.insert(w, i)\n        m, n = len(board), len(board[0])\n        ans = []\n        for i in range(m):\n            for j in range(n):\n                dfs(tree, i, j)\n        return ans",
        "optimized_code":"class Trie:\n    def __init__(self):\n        self.children: List[Trie | None] = [None] * 26\n        self.ref: int = -1\n\n    def insert(self, w: str, ref: int):\n        node = self\n        for c in w:\n            idx = ord(c) - ord('a')\n            if node.children[idx] is None:\n                node.children[idx] = Trie()\n            node = node.children[idx]\n        node.ref = ref\n\n\nclass Solution:\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\n        def dfs(node: Trie, i: int, j: int):\n            idx = ord(board[i][j]) - ord('a')\n            if node.children[idx] is None:\n                return\n            node = node.children[idx]\n            if node.ref >= 0:\n                ans.append(words[node.ref])\n                node.ref = -1\n            c = board"
    },
    {
        "question_id":213,
        "name":"house-robber-ii",
        "inefficient_code":"class Solution:\n    def rob(self, nums: List[int]) -> int:\n        if len(nums) == 1:\n            return nums[0]\n            \n        dp1 = [0]*(len(nums))\n        dp1[1] = nums[0]\n\n        for i in range(1,len(nums)-1):\n            dp1[i+1] = max(dp1[i-1] + nums[i], dp1[i])  \n\n        dp2 = [0]*(len(nums))\n        dp2[1] = nums[1]\n\n        for i in range(2,len(nums)):\n            dp2[i] = max(dp2[i-2] + nums[i], dp2[i-1]) \n\n        return max(max(dp1), max(dp2))\n        ",
        "optimized_code":"class Solution:\n    def rob(self, nums: List[int]) -> int:\n        if len(nums) == 1:\n            return nums[0]\n        \n        def rob_helper(nums, start, end):\n            if start > end:\n                return 0\n            \n            if start == end:\n                return nums[start]\n            \n            if start < end:\n                if nums[start] < nums[end]:\n                    return max(nums[start], rob_helper(nums, start+1, end)) \n                else:\n                    return max(nums[start], rob_helper(nums, start+1, end-1))\n                \n            else:\n                if nums[start] < nums[end]:\n                    return max(nums[start], rob_helper(nums, start+1, end-1)) \n                else:\n                    return max(nums[start], rob_helper(nums, start+1, end))\n        \n        return rob_helper(nums, 0, len(nums)-1)"
    },
    {
        "question_id":214,
        "name":"shortest-palindrome",
        "inefficient_code":"class Solution:\n    def shortestPalindrome(self, s: str) -> str:\n        n = len(s)\n        res = 0\n        for i in range(1, n+1):\n            if s[:i] == s[i-1::-1]:\n                res = i\n        return s[:res-1:-1] +s\n        ",
        "optimized_code":"class Solution:\n    def shortestPalindrome(self, s: str) -> str:\n        n = len(s)\n        res = 0\n        for i in range(1, n+1):\n            if s[:i] == s[i-1::-1]:\n                res = i\n                break\n        return s[:res-1:-1] +s"
    },
    {
        "question_id":215,
        "name":"kth-largest-element-in-an-array",
        "inefficient_code":"class Solution:\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        return heapq.nlargest(k,nums)[-1]",
        "optimized_code":"def findKthLargest(nums, k):\n    n = len(nums)\n    if k == n:\n        return nums[-1]\n    elif k == 0:\n        return nums[0]\n    elif k == 1:\n        return max(nums)\n    else:\n        return max(nums) if nums[-1] < nums[k-1] else nums[-1]"
    },
    {
        "question_id":216,
        "name":"combination-sum-iii",
        "inefficient_code":"class Solution:\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\n        if 45-(9-k)*(10-k)\/2 < n or k*(k+1)\/2 > n:\n            return []\n\n        def backtrack(comb, s, n):\n            if n == 0 and len(comb) == k:\n                output.append(comb)\n                return\n            for i in range(s, min(n+1, 10)):\n                if n-i <0:\n                    break\n                backtrack(comb + [i], i+1, n-i)\n        \n        output = []\n        backtrack([], 1, n)\n        return output",
        "optimized_code":"class Solution:\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\n        def backtrack(comb, s, n):\n            if n == 0 and len(comb) == k:\n                output.append(comb)\n                return\n            for i in range(s, min(n+1, 10)):\n                if n-i <0:\n                    break\n                backtrack(comb + [i], i+1, n-i)\n        \n        output = []\n        backtrack([], 1, n)\n        return output"
    },
    {
        "question_id":217,
        "name":"contains-duplicate",
        "inefficient_code":"class Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        seen = {}\n        for item in nums:\n            if(item in seen):\n                seen[item]+=1\n                if(seen[item]>=1):\n                    return True\n            else:\n                seen[item] = 1\n        return False\n",
        "optimized_code":"class Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        seen = set()\n        for item in nums:\n            if(item in seen):\n                return True\n            seen.add(item)\n        return False"
    },
    {
        "question_id":218,
        "name":"the-skyline-problem",
        "inefficient_code":"class Solution:\n    def getSkyline(self, buildings: List[List[int]]) -> List[List[int]]:\n        # Sort the unique positions of all the edges.\n        positions = sorted(list(set([x for building in buildings for x in building[:2]])))\n        \n        # Hast table 'edge_index_map' to record every {position : index} pairs in edges.\n        edge_index_map = {x : i for i, x in enumerate(positions)}\n\n        # Initialize 'heights' to record maximum height at each index.\n        heights = [0] * len(positions)\n        \n        # Iterate over all the buildings.\n        for left, right, height in buildings:\n            # For each building, find the indexes of its left\n            # and right edges.\n            left_idx = edge_index_map[left]\n            right_idx = edge_index_map[right]\n\n            # Update the maximum height within the range [left_idx, right_idx)\n            for i in range(left_idx, right_idx):\n                heights[i] = max(heights[i], height)\n\n        answer = []\n\n        # Iterate over 'heights'.\n        for i in range(len(heights)):\n            curr_height = heights[i]\n            curr_x = positions[i]\n\n            # Add all the positions where the height changes to 'answer'.\n            if not answer or answer[-1][1] != curr_height:\n                answer.append([curr_x, curr_height])\n        return answer",
        "optimized_code":"class Solution:\n    def getSkyline(self, buildings: List[List[int]]) -> List[List[int]]:\n        # Sort the unique positions of all the edges.\n        positions = sorted(list(set([x for building in buildings for x in building[:2]])))\n        \n        # Hast table 'edge_index_map' to record every {position : index} pairs in edges.\n        edge_index_map = {x : i for i, x in enumerate(positions)}\n\n        # Initialize 'heights' to record maximum height at each index.\n        heights = [0] * len(positions)\n        \n        # Iterate over all the buildings.\n        for left, right, height in buildings:\n            # For each building, find the indexes of its left\n            # and right edges.\n            left_idx = edge_index_map[left]\n            right_idx = edge_index_map[right]\n\n            # Update the maximum height within the range [left_idx, right_idx)\n            for i in range(left_idx, right_idx"
    },
    {
        "question_id":219,
        "name":"contains-duplicate-ii",
        "inefficient_code":"class Solution:\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\n        seen = {}\n        for i in range(len(nums)):\n            if nums[i] in seen and abs(i - seen[nums[i]]) <= k: \n                return True\n            seen[nums[i]] = i\n        return False \n\n        ",
        "optimized_code":"class Solution:\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\n        seen = {}\n        for i in range(len(nums)):\n            if nums[i] in seen and abs(i - seen[nums[i]]) <= k:\n                return True\n            seen[nums[i]] = i\n        return False"
    },
    {
        "question_id":220,
        "name":"contains-duplicate-iii",
        "inefficient_code":"class Solution:\n    def __init__(self):\n        self.bit = [0 for i in range(100005)]\n    def update(self, index, val):\n        i = index\n        while i <= 100001:\n            self.bit[i] += val\n            i += i & -i\n    def query(self, index):\n        i = index\n        ans = 0\n        while i > 0:\n            ans += self.bit[i]\n            i -= i & -i\n        return ans\n    def containsNearbyAlmostDuplicate(self, nums: List[int], indexDiff: int, valueDiff: int) -> bool:\n        indexedArray = []\n        for (i, number) in enumerate(nums):\n            indexedArray.append([number, i+1])\n        indexedArray.sort(key = lambda x:(x[0], x[1]))\n\n        bptr = -1\n        for i in range(len(indexedArray)):\n            while bptr+1 < len(indexedArray) and indexedArray[bptr+1][0]+valueDiff < indexedArray[i][0]:\n                self.update(indexedArray[bptr+1][1], -1)\n                bptr+=1\n            currIndex = indexedArray[i][1]\n            amt = self.query(min(currIndex+indexDiff, 100001)) - self.query(max(currIndex-indexDiff-1,0))\n\n            self.update(currIndex, 1)\n\n            if amt > 0:\n                return True\n        return False\n        ",
        "optimized_code":"class Solution:\n    def __init__(self):\n        self.bit = [0 for i in range(100005)]\n    def update(self, index, val):\n        i = index\n        while i <= 100001:\n            self.bit[i] += val\n            i += i & -i\n    def query(self, index):\n        i = index\n        ans = 0\n        while i > 0:\n            ans += self.bit[i]\n            i -= i & -i\n        return ans\n    def containsNearbyAlmostDuplicate(self, nums: List[int], indexDiff: int, valueDiff: int) -> bool:\n        indexedArray = []\n        for (i, number) in enumerate(nums):\n            indexedArray.append([number, i+1])\n        indexedArray.sort(key = lambda x:(x[0], x[1]))\n\n        bptr = -1\n        for i in range(len(indexedArray)):\n            while bptr+1"
    },
    {
        "question_id":221,
        "name":"maximal-square",
        "inefficient_code":"class Solution:\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\n        R, C = len(matrix), len(matrix[0])\n\n        sums = [[0 for c in range(C + 1)] for r in range(R + 1)]\n\n        for r in range(1, R + 1):\n            for c in range(1, C + 1):\n                sums[r][c] = sums[r][c - 1] + sums[r - 1][c] - sums[r - 1][c - 1] + int(matrix[r - 1][c - 1])\n\n        result = 0\n\n        for r in range(1, R + 1):\n            for c in range(1, C + 1):\n                if matrix[r - 1][c - 1] == \"0\":\n                    continue\n\n                st, en = 1, min(R - r + 1, C - c + 1)\n                while en - st > 1:\n                    md = (st + en) \/\/ 2\n                    if sums[r + md - 1][c + md - 1] - sums[r + md - 1][c - 1] - sums[r - 1][c + md - 1] + sums[r - 1][c - 1] == md * md:\n                        st = md\n                    else:\n                        en = md\n                if sums[r + en - 1][c + en - 1] - sums[r + en - 1][c - 1] - sums[r - 1][c + en - 1] + sums[r - 1][c - 1] == en * en:\n                    st = en\n\n                result = max(result, st)\n\n        return result * result\n",
        "optimized_code":"class Solution:\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\n        R, C = len(matrix), len(matrix[0])\n\n        sums = [[0 for c in range(C + 1)] for r in range(R + 1)]\n\n        for r in range(1, R + 1):\n            for c in range(1, C + 1):\n                sums[r][c] = sums[r][c - 1] + sums[r - 1][c] - sums[r - 1][c - 1] + int(matrix[r - 1][c - 1])\n\n        result = 0\n\n        for r in range(1, R + 1):\n            for c in range(1, C + 1):\n                if matrix[r - 1][c - 1] == \"0\":\n                    continue\n\n                st, en = 1, min(R - r + 1, C - c"
    },
    {
        "question_id":222,
        "name":"count-complete-tree-nodes",
        "inefficient_code":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def countNodes(self, root: Optional[TreeNode]) -> int:\n        def get_height(node, count, left=False):\n            if left:\n                if node.left:\n                    return get_height(node.left, count+1, left=left)\n                return count\n            else:\n                if node.right:\n                    return get_height(node.right, count+1, left=left)\n                return count\n                \n                \n\n        def traverse_tree(node):\n            left_height = get_height(node, 1, left=True)\n            right_height = get_height(node, 1)\n            if left_height == right_height:\n                return (2**(left_height))-1\n            left_nodes = 0\n            right_nodes = 0\n            if node.left:\n                left_nodes = traverse_tree(node.left)\n            if node.right:\n                right_nodes = traverse_tree(node.right)\n            return left_nodes + right_nodes + 1\n\n        res = 0\n        if root:\n            res = traverse_tree(root)\n        return res\n\n            \n        ",
        "optimized_code":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def countNodes(self, root: Optional[TreeNode]) -> int:\n        def get_height(node):\n            if node:\n                return 1 + max(get_height(node.left), get_height(node.right))\n            return 0\n\n        def traverse_tree(node):\n            if node:\n                left_height = get_height(node.left)\n                right_height = get_height(node.right)\n                if left_height == right_height:\n                    return 2**(left_height) - 1\n                else:\n                    return left_height + right_height + 1\n            return 0\n\n        res = 0\n        if root:\n            res = traverse_tree(root)\n        return res"
    },
    {
        "question_id":223,
        "name":"rectangle-area",
        "inefficient_code":"class Solution:\n    def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -> int:\n        int_x = set(range(ax1, ax2)).intersection(range(bx1, bx2))\n        int_y = set(range(ay1, ay2)).intersection(range(by1, by2))\n        return (ax2-ax1)*(ay2-ay1) + (bx2-bx1)*(by2-by1) - len(int_x)*len(int_y)\n        ",
        "optimized_code":"class Solution:\n    def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -> int:\n        int_x = set(range(ax1, ax2)).intersection(range(bx1, bx2))\n        int_y = set(range(ay1, ay2)).intersection(range(by1, by2))\n        return (ax2-ax1)*(ay2-ay1) + (bx2-bx1)*(by2-by1) - len(int_x)*len(int_y)"
    },
    {
        "question_id":224,
        "name":"basic-calculator",
        "inefficient_code":"from dataclasses import dataclass\nfrom abc import ABC, abstractmethod\n\nclass Input:\n    s: str\n    start: int\n\n    def __init__(self, s: str, start=0):\n        self.s = s\n        self.start = start\n    \n    def __getitem__(self, idx):\n        match idx:\n            case slice(start=start):\n                return Input(self.s, self.start + start)\n            case int():\n                return self.s[self.start + idx]\n    \n    def __len__(self):\n        return len(self.s) - self.start\n\ndef space(s: str) -> str:\n    while len(s) > 0 and s[0] == \" \":\n        s = s[1:]\n    return s\n\ndef literal(s: str) -> tuple[str, int]:\n    s = space(s)\n\n    if len(s) == 0 or s[0] not in \"0123456789\":\n        return s, None\n\n    value = 0\n\n    while len(s) > 0 and s[0] in \"0123456789\":\n        value *= 10\n        value += int(s[0])\n        s = s[1:]\n\n    # print(f\"LITERAL {value}\")\n    return s, value\n\ndef op(s: str) -> tuple[str, Callable[[int, int], int], str]:\n    def plus(a, b):\n        return a + b\n    def minus(a, b):\n        return a - b\n\n    s = space(s)\n\n    if len(s) == 0:\n        return s, None, None\n\n    if s[0] == \"+\":\n        # print(\"PLUS\")\n        return s[1:], plus, \"+\"\n    if s[0] == \"-\":\n        # print(\"MINUS\")\n        return s[1:], minus, \"-\"\n\n    return s, None, None\n\ndef expr(s: str) -> tuple[str, int]:\n    return bin_op(s)\n\ndef bin_op(s: str) -> tuple[str, int]:\n    # print(f\"BINOP with `{s}`\")\n    s, lhs = negate(s)\n    result = lhs\n\n    while True:\n        s_, o, op_str = op(s)\n        if o is None:\n            break\n        s = s_\n\n        s, rhs = negate(s)\n        if rhs is None:\n            return s, None\n        \n        result = o(result, rhs)\n\n    # print(f\"BINOP {result}\")\n    return s, result\n\ndef negate(s: str) -> tuple[str, int]:\n    # print(f\"NEGATE with `{s}`\")\n    s = space(s)\n\n    if len(s) == 0:\n        return s, None\n    \n    if s[0] == \"-\":\n        s, inner = base(s[1:])\n\n        if inner is None:\n            return s, None\n\n        # print(f\"NEGATE {inner}\")\n        return s, -inner\n    \n    return base(s)\n\ndef base(s: str) -> tuple[str, int]:\n    # print(f\"BASE with `{s}`\")\n    s = space(s)\n\n    if len(s) == 0:\n        return s, None\n    \n    s_, l = literal(s)\n    if l is not None:\n        return s_, l\n    \n    s_, g = group(s)\n    if g is not None:\n        return s_, g\n    \n    return s, None\n\ndef group(s: str) -> tuple[str, int]:\n    s = space(s)\n\n    if len(s) == 0 or s[0] != \"(\":\n        return s, None\n    \n    s, inner = expr(s[1:])\n    if inner is None:\n        return s, None\n    \n    s = space(s)\n    \n    if len(s) == 0 or s[0] != \")\":\n        return s, None\n    \n    # print(f\"GROUP {inner}\")\n    return s[1:], inner\n\n\n\"\"\"\nEXPR  = BINOP\nBINOP = NEG ( OP NEG )*\nNEG   = \"-\"? BASE\nBASE  = \"(\" EXPR \")\"\n      | LITERAL\n\"\"\"\n\nclass Solution:\n    def calculate(self, s: str) -> int:\n        s, e = expr(Input(s))\n        # print(e)\n\n        return e\n        ",
        "optimized_code":"from dataclasses import dataclass\nfrom abc import ABC, abstractmethod\n\n@dataclass\nclass Input:\n    s: str\n    start: int\n\n    def __init__(self, s: str, start=0):\n        self.s = s\n        self.start = start\n\n    def __getitem__(self, idx):\n        match idx:\n            case slice(start=start):\n                return Input(self.s, self.start + start)\n            case int():\n                return self.s[self.start + idx]\n    \n    def __len__(self):\n        return len(self.s) - self.start\n\ndef space(s: str) -> str:\n    while len(s) > 0 and s[0] == \" \":\n        s = s[1:]\n    return s\n\ndef literal(s: str) -> tuple[str, int]:\n    s = space(s)\n\n    if len(s) == 0 or s[0] not in \"0123456789\":\n        return s,"
    }
]