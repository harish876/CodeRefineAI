[
  {
    "question_id": 131,
    "name": "palindrome-partitioning",
    "prompt": "<p>Given a string <code>s</code>, partition <code>s</code> such that every <span data-keyword=\"substring-nonempty\">substring</span> of the partition is a <span data-keyword=\"palindrome-string\"><strong>palindrome</strong></span>. Return <em>all possible palindrome partitioning of </em><code>s</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> s = \"aab\"\n<strong>Output:</strong> [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> s = \"a\"\n<strong>Output:</strong> [[\"a\"]]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 16</code></li>\n\t<li><code>s</code> contains only lowercase English letters.</li>\n</ul>\n",
    "difficulty": "Medium",
    "topics": ["string", "dynamic-programming", "backtracking"],
    "runtime_inefficient_codes": [
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        res = []\n\n        def backtrack(i,curr):\n            if i==len(s):\n                res.append(curr[:])\n            \n            for j in range(i,len(s)):\n                if s[i:j+1]==s[i:j+1][::-1]:\n                    curr.append(s[i:j+1])\n                    backtrack(j+1,curr)\n                    curr.pop()\n\n        backtrack(0,[])\n        return res",
        "runtime": "441"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        ans = []\n        n = len(s)\n        \n        def is_palindrome(word):\n            return word == word[::-1]\n\n        def dfs(start, cur_path):\n            if start == n:\n                ans.append(cur_path[:])\n                return\n\n            for end in range(start + 1, n + 1):\n                prefix = s[start:end]\n                if is_palindrome(prefix):\n                    dfs(end, cur_path + [prefix])\n\n        dfs(0, [])\n        return ans",
        "runtime": "441"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        def ispalindrome(s):\n            return s == s[::-1]\n        def dfs(s, path, result):\n            if not s:\n                result.append(path)\n                return\n\n            for i in range(1, len(s)+1):\n                if ispalindrome(s[:i]):\n                    dfs(s[i:], path + [s[:i]], result)\n        result = []\n        dfs(s, [], result)\n        return result\n",
        "runtime": "446"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        \n        result = []\n        \n        def is_palindrome(s) -> bool:\n            return s == s[::-1]\n\n        def dfs(start: int, current_partition: List[str]) -> None:\n            if start == len(s):\n                result.append(current_partition[:])\n                return\n            for end in range(start, len(s)):\n                if is_palindrome(s[start:end + 1]):\n                    dfs(end + 1, current_partition + [s[start:end+1]])\n\n        dfs(0, [])\n        return result",
        "runtime": "446"
      },
      {
        "code": "class Solution:\n    def is_palindrome(self, s, start, end):\n        while start <= end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end   -= 1\n        return True\n\n    def partition(self, s: str) -> List[List[str]]:\n        ans = []\n\n        def is_valid(index, string, arr):\n            if index == len(s):\n                ans.append(arr[:])\n                return\n            \n            for i in range(index, len(s)):\n                if self.is_palindrome(s, index, i):\n                    arr.append(s[index:i+1])\n                    is_valid(i+1, s, arr)\n                    arr.pop()\n\n        is_valid(0, s, [])\n        return ans",
        "runtime": "452"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        result = []\n        self.dfs(s, [], result)\n        return result\n\n    def isPalindrome(self, s: str) -> bool:\n        return s == s[::-1]\n\n    def dfs(self, s: str, path: List[str], result: List[List[str]]):\n        if not s:\n            result.append(path)\n            return\n        for i in range(1, len(s) + 1):\n            if self.isPalindrome(s[:i]):\n                # add current substring in the currentList\n                self.dfs(s[i:], path + [s[:i]], result)\n                # backtrack and remove the current substring from currentList",
        "runtime": "452"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        def palindorm(s):\n            if not s:\n                return False\n            l, r = 0, len(s)-1\n            while l<=r:\n                if s[l] != s[r]:\n                    return False\n                l+=1\n                r-=1\n            return True\n\n        ans = []\n        def bt(index, path):\n            if index == len(s):\n                ans.append(path[:])\n            for i in range(index, len(s)+1):\n                if palindorm(s[index: i]):\n                    path.append(s[index: i])\n                    bt(i, path)\n                    path.pop()\n        bt(0, [])\n        return ans\n        ",
        "runtime": "457"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        def solve(idx,temp):\n            if idx==n:\n                ans.append(temp.copy())\n            for i in range(idx,n):\n                if s[idx:i+1]==s[idx:i+1][::-1]:\n                    temp.append(s[idx:i+1])\n                    solve(i+1,temp)\n                    temp.pop()\n        n = len(s)\n        ans = []\n        solve(0,[])\n        return ans",
        "runtime": "457"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        \n        def isPalindrome(s,l,r):\n\n            while l < r:\n\n                if s[l] != s[r]:\n                    return False\n                \n                l += 1\n                r -= 1\n            \n            return True\n        \n        current = []\n        ans = []\n        def dfs(i):\n\n            if i >= len(s):\n                ans.append(current.copy())\n                return\n            \n            for j in range(i, len(s)):\n                if isPalindrome(s,i,j):\n                    current.append(s[i:j+1])\n                    dfs(j + 1)\n                    current.pop()\n        \n        dfs(0)\n        return ans\n\n\n",
        "runtime": "463"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        partitions = []\n\n        def backtrack(curr_word, curr_partition, i):\n            if i == len(s):\n                if self.is_palindrome(curr_word):\n                    curr_partition.append(curr_word)\n                    partitions.append(curr_partition.copy())\n                return\n            \n            curr_word += s[i]\n            if self.is_palindrome(curr_word):\n                curr_partition.append(curr_word)\n                backtrack('', curr_partition.copy(), i + 1)\n                curr_partition.pop()\n            \n            backtrack(curr_word, curr_partition, i + 1)\n                \n\n        backtrack('', [], 0)\n        return partitions\n\n    def is_palindrome(self, word):\n        return word != '' and word == word[::-1]",
        "runtime": "463"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        res = []  \n        self.dfs(s, [], res)   \n        return res\n    \n    def dfs(self, s, path, res):\n        if len(s) == 0:\n            return res.append(path)  \n        for i in range(1, len(s)+1):\n            if self.is_p(s[:i]):\n                self.dfs(s[i:], path+[s[:i]], res)  \n    \n    def is_p(self, s):\n        return s == s[::-1]",
        "runtime": "469"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        res = []\n        partition = []\n        def dfs(i):\n            nonlocal res\n            if i >= len(s):\n                res.append(partition[:])\n                return\n            for j in range(i, len(s)):\n                if s[i: j + 1] == s[i: j + 1][::-1]:\n                    partition.append(s[i: j + 1])\n                    dfs(j + 1)\n                    partition.pop()\n        dfs(0)\n        return res\n",
        "runtime": "469"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n\n        def recursive(s, path, result):\n            if not s:\n                result.append(path)\n                return\n\n            for i in range(1, len(s)+1):\n                if self.isPalindrome(s[:i]):\n                    recursive(s[i:], path+[s[:i]], result)   \n\n            return\n\n        result = []\n        recursive(s, [], result)\n        return result\n    \n    def isPalindrome(self, s):\n        if s == s[::-1]:\n            return True\n        return False",
        "runtime": "474"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        def is_palindrome(left, right):\n            while left <= right:\n                if s[left] != s[right]: return False\n                left += 1\n                right -= 1\n            return True\n        res = []\n        def backtrack(i, str_list):\n            if i >= len(s):\n                res.append(str_list[::])\n                return\n            for j in range(i, len(s)):\n                if is_palindrome(i, j):\n                    str_list.append(s[i:j + 1])\n                    backtrack(j + 1, str_list)\n                    str_list.pop()\n        backtrack(0, [])\n        return res\n\n\n\"\"\"\nInput: s = \"aab\"\nOutput: [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\n  \n  a aa aab(x) \n  a  b\n  b\n  \ninput = aaab\n a    aa      aaa\n a ab(x) a     b\n a       b\n b\n\"\"\"",
        "runtime": "480"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        \n        def backtrack(i, cand):\n            if i == len(s):\n                ans.append(cand[:])\n            \n            for end in range(i, len(s)):\n                pal = s[i:end + 1]\n                if pal == pal[::-1]:\n                    backtrack(end + 1, cand + [pal])\n        \n        ans = []\n        backtrack(0, [])\n        return ans",
        "runtime": "480"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        def is_palindrome(sub_str):\n            return sub_str == sub_str[::-1]\n\n        def backtrack(start, arr):\n            if start == len(s):\n                result.append(arr[:])\n                return\n\n            for end in range(start + 1, len(s) + 1):\n                if is_palindrome(s[start:end]):\n                    arr.append(s[start:end])\n                    backtrack(end, arr)\n                    arr.pop()  # Backtrack\n\n        result = []\n        backtrack(0, [])\n        return result",
        "runtime": "486"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        \n        def check(sub):\n\n            if not sub:\n                return False\n\n            first = sub[:len(sub)//2]\n            second = sub[len(sub) - len(first):]\n\n            return first == second[::-1]\n        \n        def backtrack(path, idx):\n\n            if idx >= len(s):\n                ans.append(path[:])\n                return\n            \n\n            for i in range (idx, len(s)):\n\n                part = s[idx:i+1]\n\n                if check(part):\n\n                    backtrack(path + [part], i+1)\n\n        \n        ans = []\n\n        backtrack([], 0)\n\n        return ans",
        "runtime": "486"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        def is_palindrome(k):\n            l, r = 0, len(k)-1\n            while l < r:\n                if k[l] != k[r]:\n                    return False\n                l += 1\n                r -= 1\n            return True\n\n        n = len(s)\n        ans = []\n        def dfs(start_index, path):\n            if start_index == n:\n                ans.append(path[:])\n                return\n\n            for end in range(start_index+1, n+1):\n                new_partition = s[start_index:end]\n                \n                if not is_palindrome(new_partition):\n                    continue\n                \n                path.append(new_partition)\n                dfs(start_index + len(new_partition), path)\n                path.pop()\n            \n        dfs(0, [])\n        return ans\n        # Time complexity O(2^n * n) -> say we have \"aaaaaa\", then we can decide\n        # to put 'separators' at each letter of the word, for example:\n        # 'aaa|aaa', 'a|aaaaa', \"a|a|a|a|a|a|\", etc. so we have 2 options at each\n        # letter: to put the separator or not, thus, we can generate 2^n possible\n        # ways of separate the string. We copy each possiblity to our ans array, thus\n        # the total time complexity is O(2^n * n)\n        # Space complexity O(n) -> just consider recursion stpace, we don't consider\n        # output space.",
        "runtime": "491"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        res = []\n        partition = []\n        def dfs(i):\n            nonlocal res\n            if i >= len(s):\n                res.append(partition[:])\n                return\n            for j in range(i, len(s)):\n                if s[i: j + 1] == s[i: j + 1][::-1]:\n                    partition.append(s[i: j + 1])\n                    dfs(j + 1)\n                    partition.pop()\n        dfs(0)\n        return res\n",
        "runtime": "491"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        # for each of the n-1 spaces between characters, we have two choices: split or don't split.\n        # O(n * 2^n)\n        # using dynamic programming to determine if a string is a palindrome in constant time\n        res = []\n        n = len(s)\n\n        dp = [[False] * n for _ in range(n)]\n\n\n        def backtrack(start: int, substrs: List[str]):\n            if start == n:\n                res.append(substrs[:])\n                return\n            \n            # naming!\n            for end in range(start, n):\n                if s[start] == s[end] and (end - start <= 2 or dp[start + 1][end - 1]):\n                    dp[start][end] = True\n                    substrs.append(s[start:end + 1])\n                    backtrack(end + 1, substrs)\n                    substrs.pop()\n\n        backtrack(0, [])\n        return res",
        "runtime": "497"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        partitions = []\n        n = len(s)\n        def is_valid_palindrome(s: str) -> bool:\n            return s == s[::-1]\n\n        def find_palindrome_partitions(start: int, partition: List[str]) -> None:\n            if start == n:\n                partitions.append(partition[:])\n                return\n            \n            for end in range(start+1, n+1):\n                substring = s[start:end]\n                if is_valid_palindrome(substring):\n                    find_palindrome_partitions(end, partition[:] + [substring])\n            \n        find_palindrome_partitions(0, [])\n        return partitions",
        "runtime": "497"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        def isPalindrome(test_string):\n            return test_string == test_string[::-1]\n        def list_partitionings(start_index):\n            ans = []\n            if start_index == len(s):\n                return [[]]\n            if start_index == len(s) - 1:\n                return [[s[start_index]]]\n            char = s[start_index]\n            cur_index = start_index\n            while cur_index < len(s):\n                test_string = s[start_index:cur_index + 1]\n                if isPalindrome(test_string):\n                    for li in list_partitionings(cur_index + 1):\n                        ans.append([test_string] + li)\n                cur_index += 1\n            return ans\n        return list_partitionings(0)",
        "runtime": "503"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        dp = []\n        for i in range(len(s)):\n            dp.append([s[i]])\n            left, right = i - 1, i + 1\n            while left >= 0 and right < len(s):\n                if s[left] == s[right]:\n                    dp[left].append(s[left:right+1])\n                    left -= 1\n                    right += 1\n                else:\n                    break\n            if i < len(s) - 1 and s[i] == s[i+1]:\n                dp[-1].append(s[i:i+2])\n                left, right = i-1, i+2\n                while left >= 0 and right < len(s):\n                    if s[left] == s[right]:\n                        dp[left].append(s[left:right+1])\n                        left -= 1\n                        right += 1\n                    else:\n                        break\n        def compute(length):\n            if length == len(s):\n                return [[]]\n            res = []\n            for w in dp[length]:\n                for nxt in compute(length + len(w)):\n                    res.append([w] + nxt)\n            return res\n        return compute(0)\n",
        "runtime": "503"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> list[list[str]]:\n        ans = []\n\n        def dfs(i: int, curr: str):\n            if i == len(s):\n                ans.append(curr)\n\n            for j in range(i, len(s)):\n                sol = s[i : j + 1]\n                if self.is_palindrome(sol):\n                    dfs(j + 1, curr + [sol])\n\n        dfs(0, [])\n        return ans\n\n    def is_palindrome(self, s: str) -> bool:\n        n = len(s)\n        return all(s[i] == s[n - i - 1] for i in range(n // 2))\n",
        "runtime": "508"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> list[list[str]]:\n        ans = []\n\n        def dfs(i: int, curr: str):\n            if i == len(s):\n                ans.append(curr)\n\n            for j in range(i, len(s)):\n                sol = s[i : j + 1]\n                if self.is_palindrome(sol):\n                    dfs(j + 1, [*curr, sol])\n\n        dfs(0, [])\n        return ans\n\n    def is_palindrome(self, s: str) -> bool:\n        n = len(s)\n        return all(s[i] == s[n - i - 1] for i in range(n // 2))\n",
        "runtime": "508"
      },
      {
        "code": "# class Solution:\n#     def partition(self, s: str) -> List[List[str]]:\n#         result = []\n\n#         def isPalindrome(s):\n#             return s == s[::-1]\n\n#         def backtrack(s, path):\n#             if not s:\n#                 result.append(path)\n#                 return\n            \n#             for i in range(1, len(s) + 1):\n#                 if isPalindrome(s[:i]):\n#                     backtrack(s[:i], path + [s[:i]])\n\n#         backtrack(s, [])\n#         return result\n        \nclass Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        result = []\n        self.dfs(s, [], result)\n        return result\n\n    def isPalindrome(self, s: str) -> bool:\n        return s == s[::-1]\n\n    def dfs(self, s: str, path: List[str], result: List[List[str]]):\n        if not s:\n            result.append(path)\n            return\n        for i in range(1, len(s) + 1):\n            if self.isPalindrome(s[:i]):\n                # add current substring in the currentList\n                self.dfs(s[i:], path + [s[:i]], result)\n                # backtrack and remove the current substring from currentList",
        "runtime": "514"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        res = []\n        self.dfs(s, 0, [], res)\n        return res\n    \n    def dfs(self, s, start, path, res):\n        if start >= len(s):\n            if self.isPalindromeList(path):\n                res.append(path)\n            return\n        for i in range(start, len(s)):\n            self.dfs(s, i+1, path + [s[start:i+1]], res)\n\n    def isPalindromeList(self, path):\n        for p in path:\n            if not self.isPalindrome(p):\n                return False\n        return True\n    \n    def isPalindrome(self, s):\n        l = 0\n        r = len(s) - 1\n        while l < r:\n            if s[l] != s[r]:\n                return False\n            l += 1\n            r -= 1\n        \n        return True\n\n\n        \n        ",
        "runtime": "514"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        res = []\n        \n        @cache\n        def is_palindrome(l, r):\n            while l <= r:\n                if s[l] != s[r]:\n                    return False\n                l, r = l+1, r-1\n            return True\n\n        @cache\n        def solve(partition, idx):\n            if idx == len(s):\n                res.append(partition)\n                return\n            for i in range(idx, len(s)):\n                if is_palindrome(idx, i):\n                    solve(partition+(s[idx:i+1],), i+1)\n    \n        solve((), 0)\n        return res",
        "runtime": "519"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        result = []\n        currPartition = []\n\n        def dfs(i):\n            if i == len(s):\n                result.append(currPartition[:])\n                return\n            \n            for j in range(i, len(s)):\n                if self.isPalindrome(s, i, j):\n                    currPartition.append(s[i:j + 1])\n                    dfs(j + 1)\n                    currPartition.pop()\n\n        dfs(0)\n        return result\n\n    def isPalindrome(self, s, l, r):\n        while l <=r :\n            if s[l] != s[r]:\n                return False\n            l, r = l + 1, r - 1\n        return True\n",
        "runtime": "519"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        if not s:\n            return [[]]\n        \n        ans = []\n        for i in range(1, len(s)+1):\n            if s[:i] == s[:i][::-1]:\n                for suf in self.partition(s[i:]):\n                    ans.append([s[:i]] + suf)\n        return ans\n",
        "runtime": "525"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        res = []\n        \n        @cache\n        def is_palindrome(l, r):\n            while l <= r:\n                if s[l] != s[r]:\n                    return False\n                l, r = l+1, r-1\n            return True\n\n        @cache\n        def solve(partition, idx):\n            if idx == len(s):\n                res.append(partition)\n                return\n            for i in range(idx, len(s)):\n                if is_palindrome(idx, i):\n                    solve(partition+(s[idx:i+1],), i+1)\n    \n        solve((), 0)\n        return res",
        "runtime": "531"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        if not s:\n            return [[]]\n        \n        ans = []\n        for i in range(1, len(s)+1):\n            if s[:i] == s[:i][::-1]:\n                for suf in self.partition(s[i:]):\n                    ans.append([s[:i]] + suf)\n        return ans\n",
        "runtime": "531"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        if not s: return [[]]\n        ans = []\n        for i in range(1, len(s) + 1):\n            if s[:i] == s[:i][::-1]:  # prefix is a palindrome\n                for suf in self.partition(s[i:]):  # process suffix recursively\n                    ans.append([s[:i]] + suf)\n        return ans",
        "runtime": "536"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        if not s:\n            return[[]]\n        result=[]\n        for i in range(len(s)):\n            if self.isPalindrome(s[:i+1]):\n                for r in self.partition(s[i+1:]):\n                    result.append([s[:i+1]]+r)\n        return result\n    \n    def isPalindrome(self, s):\n        return s==s[::-1]",
        "runtime": "548"
      }
    ],
    "runtime_moderate_codes": [
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        slen = len(s)\n\n        def isPalin(start,end):\n            l = start\n            r = end\n            while(l<r):\n                if s[l]!=s[r]:\n                    return False\n                l+=1\n                r-=1\n            return True\n\n        memo = dict()\n\n        def f(start):\n            toReturn = []\n            if start == slen:\n                return []\n            \n            if start in memo:\n                return memo[start]\n            \n            subString = \"\"\n            for i in range(start,slen):\n                subString += s[i]\n                \n                if isPalin(start,i):\n                    \n                    nexts = f(i+1)\n                    if not nexts:\n                        toReturn.append([subString])\n                    else:\n                        for next in nexts:\n                            toReturn.append([subString]+next)\n            \n            memo[start] = toReturn[:]\n            return toReturn\n        \n        return f(0)",
        "runtime": "215"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        #TODO: make this comparison more efficient\n        def is_pal(s):\n            return s == s[::-1]\n        \n        #create dict of pals\n        palindromes = {}\n        for i in range(len(s)):\n            palindromes_at_i = []\n            for j in range(i + 1, len(s) + 1):\n                if is_pal(s[i:j]):\n                    palindromes_at_i.append(s[i:j])\n            palindromes[i] = palindromes_at_i\n\n        #create global list of solutions that we will add copies to\n        solutions = []\n\n        def recurse(solution_so_far, index):\n            #if we reached the end, make a copy of current solution\n            if index == len(s):\n                solutions.append(solution_so_far[:])#TODO: deep copy?\n                return\n            #for each pal starting at this index, add that palindrome, then recurse\n            #after calling recurse, pop the most recent palindrome off our solution_so_far\n            for pal in palindromes[index]:\n                solution_so_far.append(pal)\n                recurse(solution_so_far, index + len(pal))\n                solution_so_far.pop()\n\n        recurse([], 0)\n        return solutions \n        \n\n\n",
        "runtime": "215"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        result = []\n\n        def dfs(i: int, partitions: List[str], p: str) -> None:\n            if i == len(s):\n                if p == p[::-1]:\n                    result.append([*partitions, p])\n                return\n\n            if p == p[::-1]:\n                dfs(i+1, [*partitions, p], s[i])\n\n            dfs(i+1, [*partitions], p + s[i])\n\n        dfs(1, [], s[0])\n        return result\n",
        "runtime": "221"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        @cache\n        def backtrack(s) -> List[List[str]]:\n            if len(s) == 0:\n                return [[]]\n\n            sol = []\n            for i in range(1, len(s) + 1):\n                if is_palindrome(s, 0, i - 1):\n                    tails = backtrack(s[i:])\n                    for tail in tails:\n                        sol.append([s[:i]] + tail)\n\n            return sol\n\n        return backtrack(s)\n\n\ndef is_palindrome(s: str, start: int, end: int) -> bool:\n    while start < end:\n        if s[start] == s[end]:\n            start += 1\n            end -= 1\n        else:\n            return False\n\n    return True\n",
        "runtime": "226"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        res = []\n        part = []\n        def dfs(i):\n            if i > len(s) - 1:\n                res.append(part.copy())\n                return\n            for j in range(i,len(s)):\n                if self.is_pali(s , i , j):\n                    part.append(s[i:j + 1])\n                    dfs(j + 1)\n                    part.pop()\n        dfs(0)\n        return res\n\n            \n\n\n    def is_pali(self, s , l , r) -> bool:\n        while l < r:\n            if s[l] != s[r]:\n                return False\n            l += 1\n            r -= 1\n        return True\n        \n        # if not s:\n        #     return []\n        \n        # res = []\n        # curr_pali = \"\"\n        # def dfs(st):\n        #     if is_palindrome(st):\n        #         res.append\n        # return []",
        "runtime": "232"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        def is_palindrome(sub: str) -> bool:\n            return sub == sub[::-1]\n        \n        def backtrack(start: int, path: List[str]):\n            if start == len(s):\n                result.append(path[:])\n                return\n            for end in range(start + 1, len(s) + 1):\n                substring = s[start:end]\n                if is_palindrome(substring):\n                    path.append(substring)\n                    backtrack(end, path)\n                    path.pop()\n        \n        result = []\n        backtrack(0, [])\n        return result",
        "runtime": "238"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        res = []\n        part = []\n        n = len(s)\n        def ispal(s,l,r):\n            while(l<r):\n                if( s[l]!= s[r]):\n                    return False\n                l,r = l+1 , r-1\n            return True\n        def solve(i):\n            if(i>=len(s)):\n                res.append(part.copy())\n                return\n            for j in range(i,n):\n                if(ispal(s,i,j)):\n                    part.append(s[i:j+1])\n                    solve(j+1)\n                    part.pop()\n\n        solve(0)\n        return res\n\n",
        "runtime": "243"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        slen = len(s)\n\n        def isPalin(start,end):\n            l = start\n            r = end\n            while(l<r):\n                if s[l]!=s[r]:\n                    return False\n                l+=1\n                r-=1\n            return True\n\n        memo = dict()\n\n        def f(start):\n            toReturn = []\n            if start == slen:\n                return []\n            \n            if start in memo:\n                return memo[start]\n            \n            subString = \"\"\n            for i in range(start,slen):\n                subString += s[i]\n                \n                if isPalin(start,i):\n                    \n                    nexts = f(i+1)\n                    if not nexts:\n                        toReturn.append([subString])\n                    else:\n                        for next in nexts:\n                            toReturn.append([subString]+next)\n            \n            memo[start] = toReturn[:]\n            return toReturn\n        \n        return f(0)",
        "runtime": "249"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        self.cache = {\"\":[[]]}\n\n        def palindrome(s):\n            if len(s) == 1:\n                return True\n            start = 0\n            end = len(s)-1\n            while start < end:\n                if s[start] != s[end]:\n                    return False\n                start +=1\n                end -=1\n            return True\n\n        def do(s):\n            if len(s) == 1:\n                self.cache[s]=[[s]]\n            else:\n                self.cache[s] = []\n                for i in range(1, len(s)+1):\n                    if palindrome(s[:i]):\n                        if s[i:] not in self.cache:\n                            val = do(s[i:])\n                        else:\n                            val = self.cache[s[i:]]\n                        for entry in val:\n                            self.cache[s].append([s[:i]]+entry)\n            return self.cache[s]\n\n        return do(s)",
        "runtime": "260"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        # for each of the n-1 spaces between characters, we have two choices: split or don't split.\n        # O(n * 2^n)\n        # using dynamic programming to determine if a string is a palindrome in constant time\n        res = []\n        n = len(s)\n\n        dp = [[True] * n for _ in range(n)]\n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1, n):\n                dp[i][j] = s[i] == s[j] and dp[i + 1][j - 1]\n\n\n        def backtrack(start: int, substrs: List[str]):\n            if start == n:\n                res.append(substrs[:])\n                return\n            \n            # naming!\n            for end in range(start, n):\n                if dp[start][end]: \n                    substrs.append(s[start:end + 1])\n                    backtrack(end + 1, substrs)\n                    substrs.pop()\n\n        backtrack(0, [])\n        return res",
        "runtime": "260"
      },
      {
        "code": "class Solution:\n\n    def isPalindrome(self, s: str, left: int, right: int):\n        while left < right:\n            if s[left] != s[right]:\n                return False\n            left += 1\n            right -= 1\n        return True\n\n    def partition(self, s: str) -> List[List[str]]:\n        result = []\n        def backtracking(partition: list, i: int):\n\n            # Base Case\n            if i >= len(s):\n                result.append(partition.copy())\n                return\n\n            # Reccursive case\n            for j in range(i, len(s)):\n                if self.isPalindrome(s, i, j):\n                    partition.append(s[i:j+1])\n                    backtracking(partition, j+1)\n                    partition.pop()\n\n        backtracking([], 0)\n        return result\n            ",
        "runtime": "266"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        memo={}\n        def palindromes(i):\n            palis = []\n            for word_i in range(i, len(s)):\n                sub = s[i:word_i+1]\n                if sub==sub[::-1]:\n                    palis.append(sub)\n            return palis\n        def dfs(i,sub):\n            if i>=len(s):\n                res.append(sub[:])\n                return\n            if i in memo:\n                partitions=memo[i]\n            else:\n                partitions=palindromes(i)\n                memo[i]=partitions\n            for pali in partitions:\n                sub.append(pali)\n                dfs(i+len(pali),sub)\n                sub.pop(-1)\n        res=[]\n        dfs(0,[])\n        return res",
        "runtime": "266"
      },
      {
        "code": "class Solution(object): # iteration, real dp\n  def partition(self, s):\n    \"\"\"\n    :type s: str\n    :rtype: List[List[str]]\n    \"\"\"\n    pal = [[False for i in range(0, len(s))] for j in range(0, len(s))]\n    ans = [[[]]] + [[] for _ in range(len(s))] # length is n+1\n\n    for i in range(0, len(s)):\n      for j in range(0, i + 1):\n        if (s[j] == s[i]) and ((j + 1 > i - 1) or (pal[j + 1][i - 1])):\n          pal[j][i] = True\n          for res in ans[j]:\n            a = res + [s[j:i + 1]]\n            ans[i + 1].append(a)\n\n\n    return ans[-1]",
        "runtime": "271"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        ans = []\n        def ispalindrome(word):\n            return word == word[::-1]\n\n        def backtrack(comb, start): \n            # indicates you have tranversed all letters, and all were eliglble palindromes\n            if start == len(s):\n                ans.append(comb.copy())\n                return\n            for i in range(start,len(s)):\n                if ispalindrome(s[start:i+1]):\n                    comb.append(s[start:i+1])\n                    backtrack(comb,i+1)\n                    comb.pop()\n\n        backtrack([],0)\n        return ans",
        "runtime": "277"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        n = len(s)\n        dp = [[False] * n for _ in range(n)]\n\n        # from l we need stuff to right (l+1) -> backwards\n        # from r we need stuff to left (r-1) -> forwards\n\n        # base case of i==i\n        for i in range(n):\n            dp[i][i] = True\n\n        for l in range(n-2, -1, -1):\n            for r in range(l+1, n):\n                if (r-l) == 1:\n                    dp[l][r] = s[l] == s[r]\n                else:\n                    dp[l][r] = (s[l] == s[r]) and dp[l+1][r-1]\n\n        substrings = [['' for _ in range(n)] for _ in range(n)]\n    \n        for i in range(n):\n            substrings[i][i] = s[i]\n            for j in range(i+1, n):\n                substrings[i][j] = substrings[i][j-1] + s[j]   \n\n        res = []\n        def backtrack(start, curr):\n            if start == n:\n                res.append(curr.copy())\n                return\n            \n            for end in range(start, n):\n                if dp[start][end]:\n                    # backtrack(end + 1, curr + [s[start:end+1]])\n                    backtrack(end + 1, curr + [substrings[start][end]])\n\n        backtrack(0, [])\n        return res",
        "runtime": "283"
      },
      {
        "code": "class Solution:\n    def is_palindrome(self, s, start, end):\n        while start <= end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end   -= 1\n        return True\n\n    def partition(self, s: str) -> List[List[str]]:\n        ans = []\n\n        def is_valid(index, string, arr):\n            if index == len(s):\n                ans.append(arr[:])\n                return\n            \n            for i in range(index, len(s)):\n                if self.is_palindrome(s, index, i):\n                    arr.append(s[index:i+1])\n                    is_valid(i+1, s, arr)\n                    arr.pop()\n\n        is_valid(0, s, [])\n        return ans",
        "runtime": "288"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        res, part = [], []\n\n        def dfs(i):\n            if i >= len(s):\n                res.append(part.copy())\n                return\n            for j in range(i, len(s)):\n                if self.isPali(s, i, j):\n                    part.append(s[i : j + 1])\n                    dfs(j + 1)\n                    part.pop()\n\n        dfs(0)\n        return res\n\n    def isPali(self, s, l, r):\n        while l < r:\n            if s[l] != s[r]:\n                return False\n            l, r = l + 1, r - 1\n        return True\n",
        "runtime": "294"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        result = []\n\n        def backtrack(curr, start):\n            if start == len(s):\n                result.append(curr.copy())\n                return\n            \n            for i in range(start, len(s)):\n                if isPali(s, start, i):\n                    curr.append(s[start : i + 1])\n                    backtrack(curr, i + 1)\n                    curr.pop()\n                else:\n                    continue\n\n        def isPali(s, l, r):\n            while l < r:\n                if s[l] != s[r]:\n                    return False\n                l, r = l + 1, r - 1\n            return True\n\n        backtrack([], 0)\n        return result\n        \n\n            \n        ",
        "runtime": "300"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        result_map: dict[str, list[list[str]]] = {}\n\n        def is_palindrome(s: str) -> bool:\n            left, right = 0, len(s) - 1\n            while left < right:\n                if s[left] != s[right]:\n                    return False\n                left, right = left + 1, right - 1\n\n            return True\n\n        def helper(s: str) -> list[list[str]]:\n            if len(s) == 0:\n                return []\n\n            nonlocal result_map\n            if s in result_map:\n                return result_map[s]\n\n            result: list[list[str]] = []\n            for i in range(1, len(s)):\n                if is_palindrome(s[:i]):\n                    for r in helper(s[i:]):\n                        result.append([s[:i]] + r)\n\n            if is_palindrome(s):\n                result.append([s])\n\n            result_map[s] = result\n            return result\n\n        return helper(s)        ",
        "runtime": "305"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        def isPal(sub):\n            return sub == sub[::-1]\n        def track(start,path):\n            if start == len(s):\n                result.append(path[:])\n                return\n            for end in range(start+1, len(s) + 1):\n                substring = s[start:end]\n                if isPal(substring):\n                    path.append(substring)\n                    track(end,path)\n                    path.pop()\n        result=[]\n        track(0,[])\n        return result\n",
        "runtime": "311"
      },
      {
        "code": "# class Solution:\n#     def partition(self, s: str):\n        \n#         length = len(s)\n#         partitions = []\n\n#         def dfs(start, path):\n\n#             if start == length:\n#                 partitions.append(path[:])\n#                 return\n                \n#             for end in range(start + 1, length + 1):\n#                 if s[start:end] == s[start:end][::-1]:\n#                     path.append(s[start:end])\n#                     dfs(start = end, path = path)\n#                     path.pop()\n\n#         dfs(start = 0, path = [])\n#         return partitions\n\nclass Solution:\n    def partition(self, s: str):\n        \n        length = len(s)\n        partitions = []\n        \n        # \u0422\u0430\u0431\u043b\u0438\u0446\u0430 \u0434\u043b\u044f \u0437\u0430\u043f\u043e\u043c\u0438\u043d\u0430\u043d\u0438\u044f, \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u043b\u0438 \u043f\u043e\u0434\u0441\u0442\u0440\u043e\u043a\u0430 \u043f\u0430\u043b\u0438\u043d\u0434\u0440\u043e\u043c\u043e\u043c\n        dp = [[False] * length for _ in range(length)]\n\n        # \u041f\u0440\u0435\u0434\u0432\u0430\u0440\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0435 \u0437\u0430\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0435 \u0442\u0430\u0431\u043b\u0438\u0446\u044b \u043f\u0430\u043b\u0438\u043d\u0434\u0440\u043e\u043c\u043e\u0432\n        for i in range(length):\n            dp[i][i] = True  # \u0412\u0441\u0435 \u0441\u0438\u043c\u0432\u043e\u043b\u044b \u0441\u0430\u043c\u0438 \u043f\u043e \u0441\u0435\u0431\u0435 \u044f\u0432\u043b\u044f\u044e\u0442\u0441\u044f \u043f\u0430\u043b\u0438\u043d\u0434\u0440\u043e\u043c\u0430\u043c\u0438\n\n        for start in range(length - 1, -1, -1):\n            for end in range(start + 1, length):\n                if s[start] == s[end]:\n                    # \u0415\u0441\u043b\u0438 \u0441\u0438\u043c\u0432\u043e\u043b\u044b \u0440\u0430\u0432\u043d\u044b, \u043f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u043c, \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u043b\u0438 \u0432\u043d\u0443\u0442\u0440\u0435\u043d\u043d\u044f\u044f \u043f\u043e\u0434\u0441\u0442\u0440\u043e\u043a\u0430 \u043f\u0430\u043b\u0438\u043d\u0434\u0440\u043e\u043c\u043e\u043c\n                    if end - start == 1 or dp[start + 1][end - 1]:\n                        dp[start][end] = True\n        \n        def dfs(start, path):\n            if start == length:\n                partitions.append(path[:])\n                return\n                \n            for end in range(start, length):\n                if dp[start][end]:\n                    path.append(s[start:end + 1])\n                    dfs(end + 1, path)\n                    path.pop()\n\n        dfs(0, [])\n        return partitions\n\n        ",
        "runtime": "311"
      },
      {
        "code": "from typing import List\n\nclass Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        ans = []\n\t\t\t\t\n\t\t# \ud330\ub9b0\ub4dc\ub86c\uc778\uc9c0 \ud310\ubcc4\ud558\ub294 \ud568\uc218 \n        def is_palindrome(sub: str) -> bool:\n            return sub == sub[::-1]\n\n\t\t# \ubc31\ud2b8\ub798\ud0b9 \ud568\uc218 \uad6c\ud604\n        def backtracking(start, curr):\n\t\t    # base-case : \ubb38\uc790\uc5f4\uc758 \ub05d\uc5d0 \ub3c4\ub2ec\ud558\uba74, \ud604\uc7ac\uae4c\uc9c0 \ucc3e\uc740 \ud330\ub9b0\ub4dc\ub86c \ubd84\ud560\uc744 \uacb0\uacfc\uc5d0 \ucd94\uac00\n            if start == len(s):\n                ans.append(curr[:])\n                return\n\t\t\t\t\t\t\n\t\t\t# start\ubd80\ud130 s\uc758 \ub05d\uae4c\uc9c0 \ubd80\ubd84 \ubb38\uc790\uc5f4\uc744 \uc0b4\ud3b4\ubcf8\ub2e4.\n            for end in range(start + 1, len(s) + 1):\n                substring = s[start:end]\n\t\t\t\t\t\t\t\t\n\t\t\t\t# \ubd80\ubd84 \ubb38\uc790\uc5f4\uc774 \ud330\ub9b0\ub4dc\ub86c\uc778\uc9c0 \ud655\uc778\n                if is_palindrome(substring):\n\t\t            # \ud604\uc7ac \ubd80\ubd84 \ubb38\uc790\uc5f4 \ucd94\uac00\n                    curr.append(substring)\n                    \n                    # \ubb38\uc790\uc5f4\uc758 \ub2e4\uc74c \ubd80\ubd84\uc73c\ub85c \uc774\ub3d9\n                    backtracking(end, curr)\n                    \n                    # \ucd94\uac00\ud55c \ubd80\ubd84 \ubb38\uc790\uc5f4 pop -> \ub2e4\uc74c \ubc18\ubcf5 \uc900\ube44\n                    curr.pop()\n\n        backtracking(0, [])\n        return ans",
        "runtime": "317"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        len_s = len(s)\n        dp = [[False] * len_s for _ in range(len_s)]\n        result = []\n        self.dfs(result, s, 0, [], dp)\n        return result\n\n    def dfs(\n        self,\n        result: List[List[str]],\n        s: str,\n        start: int,\n        currentList: List[str],\n        dp: List[List[bool]],\n    ):\n        if start >= len(s):\n            result.append(list(currentList))\n        for end in range(start, len(s)):\n            if s[start] == s[end] and (\n                end - start <= 2 or dp[start + 1][end - 1]\n            ):\n                dp[start][end] = True\n                currentList.append(s[start : end + 1])\n                self.dfs(result, s, end + 1, currentList, dp)\n                currentList.pop()",
        "runtime": "322"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        n = len(s)\n        \n        # Precompute a DP table for palindrome checking\n        dp = [[False] * n for _ in range(n)]\n        \n        # Fill DP table for palindromes\n        for i in range(n):\n            dp[i][i] = True  # every single character is a palindrome\n        for i in range(n - 1):\n            dp[i][i + 1] = (s[i] == s[i + 1])  # two consecutive same characters are palindromes\n        \n        for length in range(3, n + 1):  # check for palindromes of length >= 3\n            for i in range(n - length + 1):\n                j = i + length - 1\n                dp[i][j] = (s[i] == s[j] and dp[i + 1][j - 1])\n        \n        # Backtracking function\n        def backtrack(start, path):\n            if start == n:\n                ans.append(path[:])\n                return\n            \n            for end in range(start, n):\n                if dp[start][end]:  # check if s[start:end+1] is a palindrome\n                    backtrack(end + 1, path + [s[start:end + 1]])\n        \n        ans = []\n        backtrack(0, [])\n        return ans\n",
        "runtime": "322"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        result = []\n\n        def pal(curr, i):\n            if i == len(s):\n                result.append(curr)\n                return\n            \n            for j in range(i + 1, len(s) + 1):\n                if s[i:j] == s[i:j][::-1]:\n                    \n                    pal(curr + [s[i:j]], j)\n        pal([], 0)\n        return result\n",
        "runtime": "328"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        \n        output = []\n\n        def backtrack(n, path):\n\n            if n == len(s):\n                output.append(path[:])\n                return\n            \n            for i in range(n, len(s)):\n                if s[n:i+1] == s[n:i+1][::-1]:\n                    path.append(s[n:i+1])\n                    backtrack(i+1, path)\n                    path.pop()\n            \n        backtrack(0, [])\n\n        return output",
        "runtime": "328"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        res = []\n        path = []\n        def isPalindrome(string):\n            return string == string[::-1]\n\n        def partitions(start):\n            if start == len(s):\n                res.append(path.copy())\n                return\n            for end in range(start, len(s)):\n                substring = s[start:end+1]\n                if isPalindrome(substring):\n                    path.append(substring)\n                    partitions(end+1)\n                    path.pop()\n        partitions(0)\n        return res",
        "runtime": "333"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        res = []\n\n        def dfs(i, part):\n            if i >= len(s):\n                res.append(part.copy())\n                return\n            \n            for j in range(i, len(s)):\n                if self.isPali(s, i, j):\n                    part.append(s[i:j + 1])\n                    dfs(j + 1, part)\n                    part.pop()\n        \n        dfs(0, [])\n        return res\n\n\n    def isPali(self, s, l, r):\n        while l < r:\n            if s[l] != s[r]:\n                return False\n            l += 1\n            r -= 1\n        return True",
        "runtime": "333"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        # def isPalindrome(s, left, right):\n        #     while left < right:\n        #         if s[left] != s[right]:\n        #             return False\n        #         left += 1\n        #         right -= 1\n        #     return True\n        \n        # def backtrack(s, start, current_partition, result):\n        #     if start == len(s):\n        #         result.append(list(current_partition))\n        #         return\n        #     for end in range(start, len(s)):\n\n        #         if isPalindrome(s, start, end):\n        #             current_partition.append(s[start:end+1])\n\n        #             backtrack(s, end+1, current_partition, result)\n\n        #             current_partition.pop()\n        # res = []\n        # backtrack(s, 0, [], res)\n        # return res\n\n        def dfs(start):\n            if start == len(s):\n                return [[]]\n            if start in memo:\n                return memo[start]\n\n            res = []\n            for end in range(start + 1, len(s) + 1):\n                tmp_word = s[start:end]\n                if tmp_word == tmp_word[::-1]:\n                    for rest in dfs(end):\n                        res.append([tmp_word] + rest)\n            memo[start] = res\n            return res\n\n        memo = {}\n        return dfs(0)",
        "runtime": "339"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n\n        res = []\n        part = []\n        def dfs(i):\n            if i >= len(s):\n                res.append(part.copy())\n                return\n            \n            for j in range(i, len(s)):\n                if isPalin(s, i, j):\n                    part.append(s[i:j+1])\n                    dfs(j + 1)\n                    part.pop()\n        \n        def isPalin(s, l, r):\n            while l < r:\n                if s[l] != s[r]:\n                    return False\n\n                l += 1\n                r -= 1\n            return True\n        \n        dfs(0)\n        return res\n",
        "runtime": "339"
      },
      {
        "code": "class Solution:\n    @cache\n    def partition(self, s: str) -> List[List[str]]:\n        if not s:\n            return [[]]\n\n        res = []\n\n        for i in range(len(s)):\n            subString = s[:i+1]\n\n            if subString == subString[::-1]:\n                res += [ [subString] + subPalindromes for subPalindromes in self.partition(s[i+1:]) ] \n\n        return res",
        "runtime": "345"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        results = []\n        \n        def backtrack(i: int, part: list):\n            if i == len(s):\n                results.append(part.copy())\n                return\n            \n            for j in range(i, len(s)):\n                if self.is_palindrome(s, i, j):\n                    part.append(s[i : j+1])\n                    backtrack(j + 1, part)\n                    part.pop()\n        \n        backtrack(0, [])\n        return results\n    \n    def is_palindrome(self, s: str, left: int, right: int):\n        while left < right:\n            if s[left] != s[right]:\n                return False\n            left += 1\n            right -= 1\n        return True\n",
        "runtime": "345"
      },
      {
        "code": "class Solution:\n    def isPalindrome(self, s, l, r):\n        while l < r:\n            if s[l] != s[r]:\n                return False\n            l+=1\n            r-=1\n        return True\n\n    def partition(self, s: str) -> List[List[str]]:\n        ans = []\n        def dfs(ix, arr):\n            if ix >= len(s):\n               ans.append(arr[:])\n               return \n            for i in range(ix, len(s)):\n                temp = s[ix:i+1]\n                if self.isPalindrome(temp, 0, len(temp) -1):    \n                    arr.append(temp)\n                    dfs(i+1, arr)\n                    arr.pop()\n        dfs(0, [])\n        return ans\n                ",
        "runtime": "350"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        n = len(s)\n\n        def is_palindrome(s):\n            return s == s[::-1]\n\n        def dfs(start, path):\n            if start == n:\n                res.append(path[:])\n                return\n            \n            for end in range(start + 1, n + 1):\n                prefix = s[start:end]\n                if is_palindrome(prefix):\n                    path.append(prefix)\n                    dfs(start + len(prefix), path)\n                    path.pop()\n        \n        res = []\n        if s:\n            dfs(0, [])\n        return res\n\n# Time Complexity: \n# Space Complexity: O(n*)",
        "runtime": "350"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        \n        result = []\n        current = []\n\n        def dfs(i):\n\n            if i >= len(s):\n                result.append(current.copy())\n            \n            for j in range(i, len(s)):\n                if self.isPalindrome(s, i, j):\n                    current.append(s[i : j + 1])\n                    dfs(j + 1)\n                    current.pop()\n        \n        dfs(0)\n\n        return result\n\n    def isPalindrome(self, s, left, right):\n        \n        while left < right:\n            if s[left] != s[right]:\n                return False\n            left += 1\n            right -= 1\n        \n        return True",
        "runtime": "356"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        res, sub = [], []\n        def bt(i):\n            if i == len(s): return res.append(sub[:])\n            for j in range(i, len(s)):\n                if isPali(i, j):\n                    sub.append(s[i:j+1])\n                    bt(j+1)\n                    sub.pop()\n        \n        def isPali(l, r):\n            while l < r:\n                if s[l] != s[r]: return False\n                l += 1\n                r -= 1\n            return True\n            \n        bt(0)\n        return res",
        "runtime": "356"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        res=[]\n        def pall(s):\n            if s==s[::-1]:\n                return True\n            else:\n                return False\n\n        def bk(start,p):\n            if start==len(s):\n                res.append(p[:])\n                return\n            for i in range(start+1,len(s)+1):\n                if(pall(s[start:i])):\n                    p.append(s[start:i])\n                    bk(i,p)\n                    p.pop()\n        bk(0,[])\n        return res\n        ",
        "runtime": "367"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        res = []\n        partition = []\n        \n        def isPalindrome(s, l, r): \n            while l < r: \n                if s[l] != s[r]: \n                    return False \n                l += 1\n                r -= 1\n            return True \n\n        def backtrack(i): \n            if i >= len(s):\n                res.append(partition[:]) \n                return \n            for j in range(i, len(s)): \n                if isPalindrome(s, i, j): \n                    partition.append(s[i: j + 1]) \n                    backtrack(j + 1)\n                    partition.pop() \n        backtrack(0) \n        return res\n\n",
        "runtime": "373"
      },
      {
        "code": "class Solution:\n    def isPalindrome(self, s, l, r):\n        while l < r:\n            if s[l] != s[r]:\n                return False\n            l+=1\n            r-=1\n        return True\n\n    def partition(self, s: str) -> List[List[str]]:\n        ans = []\n        def dfs(ix, arr):\n            if ix >= len(s):\n               ans.append(arr[:])\n               return \n            for i in range(ix, len(s)):\n                temp = s[ix:i+1]\n                if self.isPalindrome(temp, 0, len(temp) -1):    \n                    arr.append(temp)\n                    dfs(i+1, arr)\n                    arr.pop()\n        dfs(0, [])\n        return ans\n                ",
        "runtime": "379"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        res = []\n        part = []\n        def dfs(i):\n            if i >= len(s):\n                res.append(part[:])\n                return\n            for j in range(i, len(s)):\n                if self.is_pali(s[i:j+1]):\n                    part.append(s[i:j+1])\n                    dfs(j + 1)\n                    part.pop()\n        dfs(0)\n        return res\n\n    \n    def is_pali(self, s):\n        # while l < r:\n        #     if s[l] != s[r]:\n        #         return False\n        #     l, r = l + 1, r - 1\n        # return True\n        return s == s[::-1]",
        "runtime": "379"
      },
      {
        "code": "# class Solution:\n#     def partition(self, s: str):\n        \n#         length = len(s)\n#         partitions = []\n\n#         def dfs(start, path):\n\n#             if start == length:\n#                 partitions.append(path[:])\n#                 return\n                \n#             for end in range(start + 1, length + 1):\n#                 if s[start:end] == s[start:end][::-1]:\n#                     path.append(s[start:end])\n#                     dfs(start = end, path = path)\n#                     path.pop()\n\n#         dfs(start = 0, path = [])\n#         return partitions\n\nclass Solution:\n    def partition(self, s: str):\n        \n        length = len(s)\n        partitions = []\n        \n        # \u0422\u0430\u0431\u043b\u0438\u0446\u0430 \u0434\u043b\u044f \u0437\u0430\u043f\u043e\u043c\u0438\u043d\u0430\u043d\u0438\u044f, \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u043b\u0438 \u043f\u043e\u0434\u0441\u0442\u0440\u043e\u043a\u0430 \u043f\u0430\u043b\u0438\u043d\u0434\u0440\u043e\u043c\u043e\u043c\n        dp = [[False] * length for _ in range(length)]\n\n        # \u041f\u0440\u0435\u0434\u0432\u0430\u0440\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0435 \u0437\u0430\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0435 \u0442\u0430\u0431\u043b\u0438\u0446\u044b \u043f\u0430\u043b\u0438\u043d\u0434\u0440\u043e\u043c\u043e\u0432\n        for i in range(length):\n            dp[i][i] = True  # \u0412\u0441\u0435 \u0441\u0438\u043c\u0432\u043e\u043b\u044b \u0441\u0430\u043c\u0438 \u043f\u043e \u0441\u0435\u0431\u0435 \u044f\u0432\u043b\u044f\u044e\u0442\u0441\u044f \u043f\u0430\u043b\u0438\u043d\u0434\u0440\u043e\u043c\u0430\u043c\u0438\n\n        for start in range(length - 1, -1, -1):\n            for end in range(start + 1, length):\n                if s[start] == s[end]:\n                    # \u0415\u0441\u043b\u0438 \u0441\u0438\u043c\u0432\u043e\u043b\u044b \u0440\u0430\u0432\u043d\u044b, \u043f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u043c, \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u043b\u0438 \u0432\u043d\u0443\u0442\u0440\u0435\u043d\u043d\u044f\u044f \u043f\u043e\u0434\u0441\u0442\u0440\u043e\u043a\u0430 \u043f\u0430\u043b\u0438\u043d\u0434\u0440\u043e\u043c\u043e\u043c\n                    if end - start == 1 or dp[start + 1][end - 1]:\n                        dp[start][end] = True\n        \n        def dfs(start, path):\n            if start == length:\n                partitions.append(path[:])\n                return\n                \n            for end in range(start, length):\n                if dp[start][end]:\n                    path.append(s[start:end + 1])\n                    dfs(end + 1, path)\n                    path.pop()\n\n        dfs(0, [])\n        return partitions\n\n        ",
        "runtime": "384"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        result = []\n        self.dfs(s, [], result)\n        return result\n\n    def isPalindrome(self, s: str) -> bool:\n        return s == s[::-1]\n\n    def dfs(self, s: str, path: List[str], result: List[List[str]]):\n        if not s:\n            result.append(path)\n            return\n        for i in range(1, len(s) + 1):\n            if self.isPalindrome(s[:i]):\n                # add current substring in the currentList\n                self.dfs(s[i:], path + [s[:i]], result)\n                # backtrack and remove the current substring from currentList\n        ",
        "runtime": "384"
      },
      {
        "code": "# class Solution:\n#     def partition(self, s: str):\n        \n#         length = len(s)\n#         partitions = []\n\n#         def dfs(start, path):\n\n#             if start == length:\n#                 partitions.append(path[:])\n#                 return\n                \n#             for end in range(start + 1, length + 1):\n#                 if s[start:end] == s[start:end][::-1]:\n#                     path.append(s[start:end])\n#                     dfs(start = end, path = path)\n#                     path.pop()\n\n#         dfs(start = 0, path = [])\n#         return partitions\n\n# class Solution:\n#     def partition(self, s: str):\n        \n#         length = len(s)\n#         partitions = []\n        \n#         # \u0422\u0430\u0431\u043b\u0438\u0446\u0430 \u0434\u043b\u044f \u0437\u0430\u043f\u043e\u043c\u0438\u043d\u0430\u043d\u0438\u044f, \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u043b\u0438 \u043f\u043e\u0434\u0441\u0442\u0440\u043e\u043a\u0430 \u043f\u0430\u043b\u0438\u043d\u0434\u0440\u043e\u043c\u043e\u043c\n#         dp = [[False] * length for _ in range(length)]\n\n#         # \u041f\u0440\u0435\u0434\u0432\u0430\u0440\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0435 \u0437\u0430\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0435 \u0442\u0430\u0431\u043b\u0438\u0446\u044b \u043f\u0430\u043b\u0438\u043d\u0434\u0440\u043e\u043c\u043e\u0432\n#         for i in range(length):\n#             dp[i][i] = True  # \u0412\u0441\u0435 \u0441\u0438\u043c\u0432\u043e\u043b\u044b \u0441\u0430\u043c\u0438 \u043f\u043e \u0441\u0435\u0431\u0435 \u044f\u0432\u043b\u044f\u044e\u0442\u0441\u044f \u043f\u0430\u043b\u0438\u043d\u0434\u0440\u043e\u043c\u0430\u043c\u0438\n\n#         for start in range(length - 1, -1, -1):\n#             for end in range(start + 1, length):\n#                 if s[start] == s[end]:\n#                     # \u0415\u0441\u043b\u0438 \u0441\u0438\u043c\u0432\u043e\u043b\u044b \u0440\u0430\u0432\u043d\u044b, \u043f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u043c, \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u043b\u0438 \u0432\u043d\u0443\u0442\u0440\u0435\u043d\u043d\u044f\u044f \u043f\u043e\u0434\u0441\u0442\u0440\u043e\u043a\u0430 \u043f\u0430\u043b\u0438\u043d\u0434\u0440\u043e\u043c\u043e\u043c\n#                     if end - start == 1 or dp[start + 1][end - 1]:\n#                         dp[start][end] = True\n        \n#         def dfs(start, path):\n#             if start == length:\n#                 partitions.append(path[:])\n#                 return\n                \n#             for end in range(start, length):\n#                 if dp[start][end]:\n#                     path.append(s[start:end + 1])\n#                     dfs(end + 1, path)\n#                     path.pop()\n\n#         dfs(0, [])\n#         return partitions\n\nclass Solution:\n    def partition(self, s: str):\n        \n        length = len(s)\n        partitions = []\n        \n        # \u0422\u0430\u0431\u043b\u0438\u0446\u0430 \u0434\u043b\u044f \u0437\u0430\u043f\u043e\u043c\u0438\u043d\u0430\u043d\u0438\u044f, \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u043b\u0438 \u043f\u043e\u0434\u0441\u0442\u0440\u043e\u043a\u0430 \u043f\u0430\u043b\u0438\u043d\u0434\u0440\u043e\u043c\u043e\u043c\n        dp = [[False] * length for _ in range(length)]\n        \n        def is_palindrome(start, end):\n            # \u041f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u043c, \u0435\u0441\u043b\u0438 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442 \u0443\u0436\u0435 \u0431\u044b\u043b \u043f\u043e\u0441\u0447\u0438\u0442\u0430\u043d \u0440\u0430\u043d\u0435\u0435\n            if dp[start][end]:\n                return True\n            # \u0415\u0441\u043b\u0438 \u043f\u043e\u0434\u0441\u0442\u0440\u043e\u043a\u0430 \u0434\u043b\u0438\u043d\u043e\u0439 1 \u0441\u0438\u043c\u0432\u043e\u043b \u0438\u043b\u0438 \u0434\u0432\u0430 \u043e\u0434\u0438\u043d\u0430\u043a\u043e\u0432\u044b\u0445 \u0441\u0438\u043c\u0432\u043e\u043b\u0430\n            if start == end or (start + 1 == end and s[start] == s[end]):\n                dp[start][end] = True\n                return True\n            # \u0415\u0441\u043b\u0438 \u043a\u0440\u0430\u0439\u043d\u0438\u0435 \u0441\u0438\u043c\u0432\u043e\u043b\u044b \u0441\u043e\u0432\u043f\u0430\u0434\u0430\u044e\u0442 \u0438 \u0432\u043d\u0443\u0442\u0440\u0435\u043d\u043d\u044f\u044f \u043f\u043e\u0434\u0441\u0442\u0440\u043e\u043a\u0430 \u0442\u0430\u043a\u0436\u0435 \u043f\u0430\u043b\u0438\u043d\u0434\u0440\u043e\u043c\n            if s[start] == s[end] and is_palindrome(start + 1, end - 1):\n                dp[start][end] = True\n                return True\n            return False\n        \n        def dfs(start, path):\n            if start == length:\n                partitions.append(path[:])\n                return\n                \n            for end in range(start, length):\n                if is_palindrome(start, end):\n                    path.append(s[start:end + 1])\n                    dfs(end + 1, path)\n                    path.pop()\n\n        dfs(0, [])\n        return partitions\n        ",
        "runtime": "390"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        def is_palindrome(start, end):\n            while start < end:\n                if s[start] != s[end]:\n                    return False\n                start += 1\n                end -= 1\n            return True\n\n        n = len(s)\n        result = []\n        stack = [([], 0)]  # (current_partition, start_index)\n\n        while stack:\n            current_partition, start = stack.pop()\n\n            if start == n:\n                result.append(current_partition[:])\n                continue\n\n            for end in range(start, n):\n                if is_palindrome(start, end):\n                    new_partition = current_partition + [s[start:end+1]]\n                    stack.append((new_partition, end + 1))\n\n        return result",
        "runtime": "390"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        res = []\n        self.backtracking(s,[],res,0)\n        return res\n\n    def backtracking(self,s,path,res,start_index):\n        if start_index == len(s):\n            res.append(path.copy())\n            return\n\n        for end_index in range(start_index,len(s)):\n            if self.is_palindrome(s,start_index,end_index):\n                substr = s[start_index:(end_index+1)]\n                path.append(substr)\n                self.backtracking(s,path,res,end_index+1)\n                path.pop()\n\n    def is_palindrome(self,s,start_index,end_index):\n        substr = s[start_index:(end_index+1)]\n        if substr == substr[::-1]:\n            return True\n        else:\n            return False\n        ",
        "runtime": "395"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        def pali(s, l, r):\n            while l < r:\n                if s[l] != s[r]:\n                    return False\n                l += 1\n                r -= 1\n            return True\n\n        def backtrack(i):\n            if i == len(s):\n                res.append(part[:])\n                return\n\n            for j in range(i, len(s)):\n                if pali(s, i, j):\n                    part.append(s[i:j+1])\n                    backtrack(j + 1)\n                    part.pop()\n\n        res = []\n        part = []\n        backtrack(0)\n        return res\n        ",
        "runtime": "395"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        def is_palindrome(sub):\n            return sub == sub[::-1]\n\n        def backtrack(start, path):\n            if start == len(s):\n                partitions.append(path[:])\n                return\n            \n            for end in range(start + 1, len(s) + 1):\n                if is_palindrome(s[start:end]):\n                    path.append(s[start:end])\n                    backtrack(end, path)\n                    path.pop()\n\n        partitions = []\n        backtrack(0, [])\n        return partitions",
        "runtime": "401"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        res = []\n        n = len(s)\n        \n        def is_palindrome(s):\n            return s == s[::-1]\n\n        def dfs(start_index, cur_path):\n            if start_index == n:\n                res.append(cur_path[:])\n                return\n\n            for end in range(start_index + 1, n + 1):\n                prefix = s[start_index:end]\n                if is_palindrome(prefix):\n                    dfs(start_index + len(prefix), cur_path + [prefix])\n\n        if s:\n            dfs(0, [])\n        return res",
        "runtime": "401"
      },
      {
        "code": "class Solution:\n    def isPalindrome(self, s, l, r):\n        while l < r:\n            if s[l] != s[r]:\n                return False\n            l+=1\n            r-=1\n        return True\n    def partition(self, s: str) -> List[List[str]]:\n        ans = []\n        def dfs(t, arr):\n            if len(t) == 0:\n               ans.append(arr[:])\n               return \n            for i in range(len(t)):\n                temp = t[:i+1]\n                if self.isPalindrome(temp, 0, len(temp) -1):    \n                    arr.append(t[:i+1])\n                    dfs(t[i+1:], arr)\n                    arr.pop()\n        dfs(s, [])\n        return ans\n                ",
        "runtime": "407"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        def pali(s, l, r):\n            while l < r:\n                if s[l] != s[r]:\n                    return False\n                l += 1\n                r -= 1\n            return True\n\n        def backtrack(i):\n            if i == len(s):\n                res.append(part[:])\n                return\n\n            for j in range(i, len(s)):\n                if pali(s, i, j):\n                    part.append(s[i:j+1])\n                    backtrack(j + 1)\n                    part.pop()\n                \n\n        res = []\n        part = []\n        backtrack(0)\n        return res\n        ",
        "runtime": "407"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        def isPalindrome(s, start, end):\n            while start < end:\n                if s[start] != s[end]:\n                    return False\n                start += 1\n                end -= 1\n            \n            return True\n\n        def backtrack(start, curPar):\n            if start == len(s):\n                res.append(curPar.copy())\n                return\n            \n            for i in range(start, len(s)):\n                if isPalindrome(s, start, i):\n                    curPar.append(s[start:i+1])\n                    backtrack(i + 1, curPar)\n                    curPar.pop()\n\n        \n        res = []\n        backtrack(0, [])\n        return res",
        "runtime": "412"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        res = []\n        comb = []\n\n        def dfs(index):\n            if index == len(s):\n                res.append(comb.copy())\n                return\n            else:\n                for i in range(index+1, len(s)+1):\n                    if s[index:i] == s[index:i][::-1]:\n                        comb.append(s[index:i])\n                        dfs(i)\n                        comb.pop()\n        dfs(0)\n        return res\n\n            \n",
        "runtime": "412"
      },
      {
        "code": "class Solution:\n    def backtrack(self, start, path):\n        if start == len(self.s):\n            self.ans.append(path[:])\n            return\n\n        for end in range(start + 1, len(self.s) + 1):\n            sub = self.s[start : end]\n\n            if sub == sub[::-1]:\n                self.backtrack(end, path + [sub])\n\n    def partition(self, s: str) -> List[List[str]]:\n        '''\n        find a palindrome, backtrack to find others in remainder of string\n        '''\n        self.ans = []\n        self.s = s\n        self.backtrack(0, [])\n        return self.ans\n\n    ",
        "runtime": "418"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        if not s: return []\n\n        def is_palindrome(s):\n            return s == s[::-1]\n        \n        ans = []\n        def backtrack(s, index, partitions):\n            nonlocal ans\n            if index >= len(s): \n                ans.append(partitions)\n                return\n\n            for i in range(index, len(s)):\n                candidate = s[index:i+1]\n                if is_palindrome(candidate):\n                    backtrack(s, i+1, partitions + [candidate])\n            \n        backtrack(s, 0, [])\n        return ans",
        "runtime": "418"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        def is_palindrome(substring):\n            return substring == substring[::-1]\n        def backtrack(start, path):\n            if start == len(s):\n                result.append(path[:])\n                return\n            for end in range(start + 1, len(s) + 1):\n                if is_palindrome(s[start:end]):\n                    path.append(s[start:end])\n                    backtrack(end, path)\n                    path.pop()\n        result = []\n        backtrack(0, [])\n        return result\n",
        "runtime": "424"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        res = []\n\n        def backtrack(i,curr):\n            if i==len(s):\n                res.append(curr[:])\n            \n            for j in range(i,len(s)):\n                if s[i:j+1]==s[i:j+1][::-1]:\n                    curr.append(s[i:j+1])\n                    backtrack(j+1,curr)\n                    curr.pop()\n\n        backtrack(0,[])\n        return res",
        "runtime": "424"
      },
      {
        "code": "# class Solution:\n#     def partition(self, s: str):\n        \n#         length = len(s)\n#         partitions = []\n\n#         def dfs(start, path):\n\n#             if start == length:\n#                 partitions.append(path[:])\n#                 return\n                \n#             for end in range(start + 1, length + 1):\n#                 if s[start:end] == s[start:end][::-1]:\n#                     path.append(s[start:end])\n#                     dfs(start = end, path = path)\n#                     path.pop()\n\n#         dfs(start = 0, path = [])\n#         return partitions\n\n# class Solution:\n#     def partition(self, s: str):\n        \n#         length = len(s)\n#         partitions = []\n        \n#         # \u0422\u0430\u0431\u043b\u0438\u0446\u0430 \u0434\u043b\u044f \u0437\u0430\u043f\u043e\u043c\u0438\u043d\u0430\u043d\u0438\u044f, \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u043b\u0438 \u043f\u043e\u0434\u0441\u0442\u0440\u043e\u043a\u0430 \u043f\u0430\u043b\u0438\u043d\u0434\u0440\u043e\u043c\u043e\u043c\n#         dp = [[False] * length for _ in range(length)]\n\n#         # \u041f\u0440\u0435\u0434\u0432\u0430\u0440\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0435 \u0437\u0430\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0435 \u0442\u0430\u0431\u043b\u0438\u0446\u044b \u043f\u0430\u043b\u0438\u043d\u0434\u0440\u043e\u043c\u043e\u0432\n#         for i in range(length):\n#             dp[i][i] = True  # \u0412\u0441\u0435 \u0441\u0438\u043c\u0432\u043e\u043b\u044b \u0441\u0430\u043c\u0438 \u043f\u043e \u0441\u0435\u0431\u0435 \u044f\u0432\u043b\u044f\u044e\u0442\u0441\u044f \u043f\u0430\u043b\u0438\u043d\u0434\u0440\u043e\u043c\u0430\u043c\u0438\n\n#         for start in range(length - 1, -1, -1):\n#             for end in range(start + 1, length):\n#                 if s[start] == s[end]:\n#                     # \u0415\u0441\u043b\u0438 \u0441\u0438\u043c\u0432\u043e\u043b\u044b \u0440\u0430\u0432\u043d\u044b, \u043f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u043c, \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u043b\u0438 \u0432\u043d\u0443\u0442\u0440\u0435\u043d\u043d\u044f\u044f \u043f\u043e\u0434\u0441\u0442\u0440\u043e\u043a\u0430 \u043f\u0430\u043b\u0438\u043d\u0434\u0440\u043e\u043c\u043e\u043c\n#                     if end - start == 1 or dp[start + 1][end - 1]:\n#                         dp[start][end] = True\n        \n#         def dfs(start, path):\n#             if start == length:\n#                 partitions.append(path[:])\n#                 return\n                \n#             for end in range(start, length):\n#                 if dp[start][end]:\n#                     path.append(s[start:end + 1])\n#                     dfs(end + 1, path)\n#                     path.pop()\n\n#         dfs(0, [])\n#         return partitions\n\nclass Solution:\n    def partition(self, s: str):\n        \n        length = len(s)\n        partitions = []\n        \n        # \u0422\u0430\u0431\u043b\u0438\u0446\u0430 \u0434\u043b\u044f \u0437\u0430\u043f\u043e\u043c\u0438\u043d\u0430\u043d\u0438\u044f, \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u043b\u0438 \u043f\u043e\u0434\u0441\u0442\u0440\u043e\u043a\u0430 \u043f\u0430\u043b\u0438\u043d\u0434\u0440\u043e\u043c\u043e\u043c\n        dp = [[False] * length for _ in range(length)]\n        \n        def is_palindrome(start, end):\n            # \u041f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u043c, \u0435\u0441\u043b\u0438 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442 \u0443\u0436\u0435 \u0431\u044b\u043b \u043f\u043e\u0441\u0447\u0438\u0442\u0430\u043d \u0440\u0430\u043d\u0435\u0435\n            if dp[start][end]:\n                return True\n            # \u0415\u0441\u043b\u0438 \u043f\u043e\u0434\u0441\u0442\u0440\u043e\u043a\u0430 \u0434\u043b\u0438\u043d\u043e\u0439 1 \u0441\u0438\u043c\u0432\u043e\u043b \u0438\u043b\u0438 \u0434\u0432\u0430 \u043e\u0434\u0438\u043d\u0430\u043a\u043e\u0432\u044b\u0445 \u0441\u0438\u043c\u0432\u043e\u043b\u0430\n            if start == end or (start + 1 == end and s[start] == s[end]):\n                dp[start][end] = True\n                return True\n            # \u0415\u0441\u043b\u0438 \u043a\u0440\u0430\u0439\u043d\u0438\u0435 \u0441\u0438\u043c\u0432\u043e\u043b\u044b \u0441\u043e\u0432\u043f\u0430\u0434\u0430\u044e\u0442 \u0438 \u0432\u043d\u0443\u0442\u0440\u0435\u043d\u043d\u044f\u044f \u043f\u043e\u0434\u0441\u0442\u0440\u043e\u043a\u0430 \u0442\u0430\u043a\u0436\u0435 \u043f\u0430\u043b\u0438\u043d\u0434\u0440\u043e\u043c\n            if s[start] == s[end] and is_palindrome(start + 1, end - 1):\n                dp[start][end] = True\n                return True\n            return False\n        \n        def dfs(start, path):\n            if start == length:\n                partitions.append(path[:])\n                return\n                \n            for end in range(start, length):\n                if is_palindrome(start, end):\n                    path.append(s[start:end + 1])\n                    dfs(end + 1, path)\n                    path.pop()\n\n        dfs(0, [])\n        return partitions\n        ",
        "runtime": "429"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        def is_palindrome(substring):\n            return substring==substring[::-1]\n        res=[]\n        def backtrack(start,path):\n            if start==len(s):\n                res.append(path[:])\n            for end in range(start,len(s)):\n                sub=s[start:end+1]\n                if is_palindrome(sub):\n                    path.append(sub)\n                    backtrack(end+1,path)\n                    path.pop()\n        backtrack(0,[])\n        return res ",
        "runtime": "429"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n\n        def is_palindrome(sub_string):\n            return sub_string == sub_string[::-1]\n        \n        def backtrack(start, cur_path):\n\n            if start == len(s):\n                res.append(cur_path.copy())\n                return\n\n            for end in range(start+1, len(s)+1):\n                temp = s[start:end]\n                if is_palindrome(temp):\n                    cur_path.append(temp)\n                    backtrack(end, cur_path)\n                    cur_path.pop()\n\n        res = []\n\n        backtrack(0, [])\n\n        return res\n",
        "runtime": "435"
      },
      {
        "code": "#2023/04/30\n# class Solution:\n#     def partition(self, s: str) -> List[List[str]]:\n#         output=[]\n#         def backtracking(temp,start):\n#             if start>=len(s):\n#                 # if self.isP(str(temp)):\n#                 output.append(temp[:])\n#                 return \n#             for i in range(start,len(s)):\n#                 if self.isP(s, start, i):\n#                     temp.append(s[start: i+1])\n#                     backtracking(temp,i+1)\n#                     temp.pop()\n#         backtracking([],0)\n#         return output\n    \n#     def isP(self,s,l,r):\n#         while l<r:\n#             if s[l]!=s[r]:\n#                 return False\n#             l+=1\n#             r-=1\n#         return True\n\n# #2023/05/21\n# '''\n# O\uff08n*2^n)\n# \u5faa\u73af:  aab\n#   a   aa   aab\n#   for i in range(start,end)\n#   \u6240\u4ee5str[start:i+1]\u4ee3\u8868\u7684\u662f\u5355\u5c42\u5faa\u73af\u7684\u6bcf\u4e00\u79cd\u9009\u62e9==>\u9700\u8981\u4e00\u4e2astart\n# \u5355\u5c42\u903b\u8f91\uff1a\n#     \u5982\u679c\u5f53\u524d\u5b50\u4e32\u662f\u56de\u6587\u624d\u7ee7\u7eed\uff0c\u4e0d\u662f\u5c31\u4e0d\u7ee7\u7eed\n# '''\n# class Solution:\n#     def partition(self, s: str) -> List[List[str]]:\n#         path=[]\n#         res=[]\n#         end=len(s)\n#         def backtracking(start):\n#             if start>=end:\n#                 res.append(path.copy())\n#                 return\n#             for i in range(start,end):\n#                 temp=s[start:i+1]\n#                 if self.isP(temp):\n#                     path.append(temp)\n#                     backtracking(i+1)#\u8fd9\u4e00\u5c42\u5305\u542b\u4e86i\u4e86\n#                     path.pop()\n#                 else:\n#                     continue\n#         backtracking(0)\n#         return res\n#     def isP(self,s):\n#         l=0\n#         r=len(s)-1\n#         while l<r:\n#             if s[l]!=s[r]:\n#                 return False\n#             l+=1\n#             r-=1\n#         return True\n\n\n\n#2023/09/01\n# class Solution:\n#     def partition(self, s: str) -> List[List[str]]:\n#         def isP(word):\n#             l=0\n#             r=len(word)-1\n#             while l<r:\n#                 if word[l]!=word[r]:\n#                     return False\n#                 l+=1\n#                 r-=1\n#             return True\n#         path=[]\n#         res=[]\n#         def backtracking(start):\n#             if start==len(s):\n#                 res.append(path.copy())\n#                 return \n#             for i in range(start,len(s)):\n#                 temp=s[start:i+1]\n#                 if isP(temp):\n#                     path.append(temp)\n#                     backtracking(i+1)\n#                     path.pop()\n#         backtracking(0)\n#         return res\n                    \n#2023/09/20\n# class Solution:\n#     def partition(self, s: str) -> List[List[str]]:\n#         path=[]\n#         res=[]\n#         def dfs(startIdx):\n#             if startIdx==len(s):\n#                 res.append(path.copy())\n#                 return \n#             if startIdx>len(s):\n#                 return\n#             for i in range(startIdx,len(s)):\n#                 if self.check(startIdx,i,s):\n#                     path.append(s[startIdx:i+1])\n#                     dfs(i+1)\n#                     path.pop()\n#         dfs(0)\n#         return res\n\n\n#     def check(self,l,r,s):\n#         while l<r:\n#             if s[l]!=s[r]:\n#                 return False\n#             l+=1\n#             r-=1\n#         return True\n\n\n#2023/10/14\n# class Solution:\n#     def partition(self, s: str) -> List[List[str]]:\n#         res=[]\n#         path=[]\n#         def check(part):\n#             l=0\n#             r=len(part)-1\n#             while l<r:\n#                 if part[l]!=part[r]:\n#                     return False\n#                 l+=1\n#                 r-=1\n#             return True\n#         def backtracking(startIdx):\n#             if startIdx==len(s):\n#                 res.append(path.copy())\n#                 return\n#             for i in range(startIdx,len(s)):\n#                 if check(s[startIdx:i+1]):\n#                     path.append(s[startIdx:i+1])\n#                     backtracking(i+1)\n#                     path.pop()\n#         backtracking(0)\n#         return res\n\n#2024/02/14\n# class Solution:\n#     def partition(self, s: str) -> List[List[str]]:\n#         res=[]\n#         path=[]\n#         def check(temp):\n#             l=0\n#             r=len(temp)-1\n#             while l<r:\n#                 if temp[l]!=temp[r]:\n#                     return False\n#                 l+=1\n#                 r-=1\n#             return True\n#         def backtracking(idx):\n#             if idx==len(s):\n#                 res.append(path.copy())\n#                 return\n#             for i in range(idx,len(s)):\n#                 if check(s[idx:i+1]):\n#                     path.append(s[idx:i+1])\n#                     backtracking(i+1)\n#                     path.pop()\n#         backtracking(0)\n#         return res\n\n\n#2024/05/25\n'''\n\u5bf9\u4e8es\u62c6\u5206\uff0c\u5fc5\u987b\u62c6\u5206\u4e3a\u90fd\u662f\u56de\u6587\n\u90a3\u4e48\u4e00\u65e6\u9047\u5230\u5f53\u524d\u7684string\u4e0d\u662f\u56de\u6587\u5c31\u7ed3\u675f\u672c\u6b21\uff0c\u5982\u679c\u5230\u4e86\u6700\u540e\u90a3\u5c31\u8bf4\u660e\u6ee1\u8db3\u6761\u4ef6\n\u5355\u5c42\u5faa\u73af\u5730\u6bcf\u4e2a\u9009\u62e9\u662fa,aa,aab\uff0c\u6240\u4ee5\u4ecestart\u5230i+1\u4ee3\u8868\u5f53\u524d\u9009\u62e9\n\u7136\u540e\u68c0\u67e5\u8fd9\u4e2a\u9009\u62e9\uff0c\u53ea\u6709\u7b26\u5408\u8981\u6c42\u624d\u7ee7\u7eed\n'''\n# class Solution:\n#     def partition(self, s: str) -> List[List[str]]:\n#         path=[]\n#         res=[]\n#         def check(l,r):\n#             while l<r:\n#                 if s[l]!=s[r]:\n#                     return False\n#                 l+=1\n#                 r-=1\n#             return True\n#         def backtracking(idx):\n#             if idx==len(s):\n#                 res.append(path.copy())\n#                 return\n#             for i in range(idx,len(s)):\n#                 if check(idx,i):\n#                     path.append(s[idx:i+1])\n#                     backtracking(i+1)\n#                     path.pop()\n#         backtracking(0)\n#         return res\n\n#2024/09/15\n'''\n\u7ed9\u4e00\u4e2as\uff0c\u628as\u62c6\u5206\u4e3a\u90fd\u662f\u56de\u6587\n\u90a3\u4e48\u6bcf\u4e00\u4e2a\u6570\u90fd\u53ef\u4ee5\u5206\u4e00\u6b21,\u9700\u8981\u4e00\u4e2aidx\u6765track\u5206\u5230\u54ea\u91cc\u4e86\n\n\u6240\u4ee5\u5355\u5c42\uff1a\nfor i in range(start,len(s)):\n    curr=s[start:i+1]\n    if not check(curr):\n        continue\n    path.append(curr)\n'''\nclass Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        res=[]\n        path=[]\n        def check(string):\n            l=0\n            r=len(string)-1\n            while l<r:\n                if string[l]!=string[r]:\n                    return False\n                l+=1\n                r-=1\n            return True\n        def backtracking(idx):\n            if idx==len(s):\n                res.append(path.copy())\n                return\n            for i in range(idx,len(s)):\n                curr=s[idx:i+1]\n                if not check(curr):\n                    continue\n                path.append(curr)\n                backtracking(i+1)\n                path.pop()\n        backtracking(0)\n        return res",
        "runtime": "435"
      }
    ],
    "runtime_efficient_codes": [
      {
        "code": "def is_palindrome(s, l, r):\n    while l < r:\n        if s[l] != s[r]:\n            return False\n\n        l, r = l + 1, r - 1\n\n    return True\n\n\nclass Solution:\n    def partition(self, s):\n        dp = [[] for _ in range(len(s) + 1)]\n        dp[-1] = [[]]\n        for l in range(len(s) - 1, -1, -1):\n            for r in range(l, len(s)):\n                if not is_palindrome(s, l, r):\n                    continue\n                \n                strlist = [s[l:r + 1]]\n                dpresult = dp[r + 1]\n                for plist in dpresult:\n                    dp[l].append(strlist + plist)\n        \n        return dp[0]",
        "runtime": "114"
      },
      {
        "code": "class Solution:\n\n    def partition(self, s: str) -> List[List[str]]:\n        self.cache = {\"\": []}\n    \n        def dfs(s):\n            if s in self.cache:\n                return self.cache[s]\n            res = []\n            if len(s) == 1:\n                return [[s]]\n            left = 0\n            while left <= len(s):\n                cur = s[0:left+1]\n                if left == len(s):\n                    if cur == cur[::-1]:\n                        res.append([cur])\n                else:\n                    if cur == cur[::-1]:\n                        rightSet = dfs(s[left+1:])\n                        for suffix in rightSet:\n                            res.append([cur] + suffix)\n                left += 1\n            \n            self.cache[s] = res\n            return res\n        \n        return dfs(s)",
        "runtime": "119"
      },
      {
        "code": "from typing import List\n\n\ndef is_palindrome(s: str) -> bool:\n    return s == s[::-1]\n\n\n# Recursive. Time: O(n * 2 ^ n), space: O(n ^ 2), n = len(s)\nclass Solution0:\n    def partition(self, s: str) -> List[List[str]]:\n        if not s:\n            return [[]]\n        res = []\n        for i in range(1, len(s) + 1):\n            first_cut = s[:i]\n            if is_palindrome(first_cut):\n                subproblem = self.partition(s[i:])\n                for sub in subproblem:\n                    res.append([first_cut] + sub)\n        return res\n\n\nclass Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        @cache\n        def _partition(start: int) -> List[List[str]]:\n            if start >= len(s):\n                return [[]]\n            res = []\n            for i in range(start + 1, len(s) + 1):\n                first_cut = s[start:i]\n                if is_palindrome(first_cut):\n                    subproblem = _partition(i)\n                    for sub in subproblem:\n                        res.append([first_cut] + sub)\n            return res\n\n        return _partition(0)\n\n",
        "runtime": "125"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        \n        dp = [[] for _ in range(len(s)+1)]\n        dp[-1].append([])\n        m = set()\n\n        def isPali(i, j):\n\n            while i <= j:\n                if s[i] != s[j]:\n                    return False\n                i, j = i+1, j-1\n            return True\n\n        for i in range(len(s)-1, -1, -1):\n            for j in range(i+1, len(s)+1):\n\n                cur = s[i:j]\n                if cur in m or isPali(i, j-1):\n                    m.add(cur)\n                    for val in dp[j]:\n                        dp[i].append([cur] + val)\n\n        return dp[0]\n\n        ",
        "runtime": "131"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        n = len(s)\n        dp = [[] for _ in range(n + 1)]\n        dp[-1].append([])\n        def isPalindrome(i, j):\n            while i < j:\n                if s[i] != s[j]:\n                    return False\n                i += 1\n                j -= 1\n            return True\n            \n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1, n + 1):\n                cur = s[i:j]\n                if isPalindrome(i, j - 1):\n                    for val in dp[j]:\n                        dp[i].append([cur] + val)\n        return dp[0]\n",
        "runtime": "136"
      },
      {
        "code": "from typing import List\n\nclass Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        def dfs(start):\n            if start == len(s):\n                return [[]]\n            if start in memo:\n                return memo[start]\n\n            res = []\n            for end in range(start + 1, len(s) + 1):\n                tmp_word = s[start:end]\n                if tmp_word == tmp_word[::-1]:\n                    for rest in dfs(end):\n                        res.append([tmp_word] + rest)\n            memo[start] = res\n            return res\n\n        memo = {}\n        return dfs(0)\n",
        "runtime": "142"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        n = len(s)\n        final, part = [], []\n        dp = [[False]*n for _ in range(n)]\n\n        for i in range(n):\n            dp[i][i] = True\n        \n        for length in range(2, n+1):\n            for i in range(n-length+1):\n                j = i+length-1\n                if length == 2:\n                    dp[i][j] = (s[i] == s[j])\n                else:\n                    dp[i][j] = (s[i] == s[j] and dp[i+1][j-1])\n        \n        def dfs(i):\n            if i >= n:\n                final.append(part.copy())\n            \n            for j in range(i, n):\n                if dp[i][j]:\n                    part.append(s[i:j+1])\n                    dfs(j+1)\n                    part.pop()\n        \n        dfs(0)\n        return final\n\n        ",
        "runtime": "147"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        return self.dfs(s, {})\n    \n    def dfs(self, s, memo):\n        if s in memo:\n            return memo[s]\n        \n        partitions = []\n        \n        if s == \"\":\n            return partitions\n        \n        for i in range(1, len(s)):\n            prefix = s[:i]\n            if not self.is_palindrome(prefix):\n                continue\n            \n            suffix = s[i:]\n            sub_partitions = self.dfs(suffix, memo)\n            for sub_partition in sub_partitions:\n                partitions.append([prefix] + sub_partition)\n            \n        if self.is_palindrome(s):\n            partitions.append([s])\n        \n        memo[s] = partitions\n\n        return partitions\n    \n    def is_palindrome(self, s):\n        return s == s[::-1]",
        "runtime": "153"
      },
      {
        "code": "from functools import cache\n\nclass Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        output = []\n        dp = [[False] * len(s) for _ in range(len(s))]\n        for i in range(len(s)):\n            dp[i][i] = True\n        for i in range(len(s)-1):\n            if s[i] == s[i+1]:\n                dp[i][i+1] = True\n\n        def isPalin(start, end):\n            return start == end or (s[start] == s[end] and (end-start<2 or dp[start+1][end-1]))\n        \n        @cache\n        def backtrack(i):\n            if i == len(s):\n                return -1\n            out = []\n            for idx in range(i+1, len(s)+1):\n                if isPalin(i, idx-1):\n                    consider = [s[i:idx]]\n                    dp[i][idx-1] = True\n                    res = backtrack(idx)\n                    if not res:\n                        return []\n                    elif res == -1:\n                        out.append([s[i:idx]])\n                    else:\n                        for p in res:\n                            out.append(consider + p)\n            return out\n        return backtrack(0)\n    ",
        "runtime": "159"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        def isPali(i, j):\n            while i < j:\n                if s[i] != s[j]:\n                    return False\n                i += 1\n                j -= 1\n            return True\n\n        memo = dict()\n\n        def helper(i):\n            result = []\n            if i == len(s):\n                return []\n            \n            if i in memo:\n                return memo[i]\n            \n            temp = \"\"\n            for j in range(i, len(s)):\n                temp += s[j]\n                \n                if isPali(i,j):\n                    bundle_list = helper(j+1)\n                    if not bundle_list:\n                        result.append([temp])\n                    else:\n                        for bundle in bundle_list:\n                            result.append([temp]+bundle)\n            \n            memo[i] = result.copy()\n            return result\n        \n        return helper(0)",
        "runtime": "164"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n\n        @lru_cache(None)\n        def find(ind):\n            if ind == len(s):\n                return [[]]\n            ans = []\n            for i in range(ind, len(s)):\n                temp = s[ind:i+1]\n                if temp == temp[::-1]:\n                    next = find(i+1)\n                    ans.extend([[temp] + a for a in next])\n            return ans\n        \n        return find(0)",
        "runtime": "170"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        palindromes = [[char] for char in s]\n        for i in range(1, len(s)):\n            a, b = i-1, i\n            while a >= 0 and b < len(s) and s[a] == s[b]:\n                palindromes[a].append(s[a:b+1])\n                a -= 1\n                b += 1\n            if i < len(s) - 1:\n                a, b = i-1, i+1\n                while a >= 0 and b < len(s) and s[a] == s[b]:\n                    palindromes[a].append(s[a:b+1])\n                    a -= 1\n                    b += 1\n        ans = []\n\n        def dfs(i, partition):\n            nonlocal ans\n            if i == len(s):\n                ans.append(partition.copy()) #NEED COPY HERE\n            elif i < len(s):\n                for palindrome in palindromes[i]:\n                    partition.append(palindrome)\n                    dfs(i + len(palindrome), partition)\n                    partition.pop()\n        dfs(0, [])\n        return ans\n            ",
        "runtime": "176"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        dp = []\n        for i in range(len(s)):\n            dp.append([s[i]])\n            left, right = i - 1, i + 1\n            while left >= 0 and right < len(s):\n                if s[left] == s[right]:\n                    dp[left].append(s[left:right+1])\n                    left -= 1\n                    right += 1\n                else:\n                    break\n            if i < len(s) - 1 and s[i] == s[i+1]:\n                dp[-1].append(s[i:i+2])\n                left, right = i-1, i+2\n                while left >= 0 and right < len(s):\n                    if s[left] == s[right]:\n                        dp[left].append(s[left:right+1])\n                        left -= 1\n                        right += 1\n                    else:\n                        break\n        save = dict()\n        def compute(length):\n            if length == len(s):\n                return [[]]\n            if length in save:\n                return save[length]\n            res = []\n            for w in dp[length]:\n                for nxt in compute(length + len(w)):\n                    res.append([w] + nxt)\n            save[length] = res\n            return res\n        return compute(0)\n",
        "runtime": "181"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        def is_palindrome(l, r):\n            while l <= r:\n                if s[l] != s[r]:\n                    return False\n                l += 1\n                r -= 1\n            return True\n\n        @cache\n        def check(start):\n            out = []\n\n            for i in range(start, len(s)):\n                curr_str = s[start: i+1]\n\n                if is_palindrome(start, i):\n                    if i + 1 == len(s):\n                        out.append([curr_str])\n                    else:\n                        for right_parts in check(i+1):\n                            out.append([curr_str, *right_parts])\n\n            return out\n\n        return check(0)",
        "runtime": "187"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        N = len(s)\n        if N == 0:\n            return []\n        is_pal = [[False] * N for i in range(N)]\n        for i in range(N):\n            is_pal[i][i] = True\n\n        for l in range(2, N + 1):\n            for i in range(N):\n                j = i + l - 1\n                if j >= N:\n                    break\n                if l == 2:\n                    is_pal[i][j] = s[i] == s[j]\n                else:\n                    is_pal[i][j] = (s[i] == s[j]) and is_pal[i + 1][j - 1]\n        \n        ans = [[[]]]\n        for i in range(0, N):\n            result = []\n            for j in range(0, i + 1):\n                if is_pal[j][i]:\n                    sub = s[j: i + 1]\n                    prev = ans[j - 1 + 1]\n                    for x in prev:\n                        result.append(x + [sub])  \n            ans.append(result)\n\n        return ans[-1]\n\n\n\n        ",
        "runtime": "193"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        \n        @cache\n        def backtrack(i):\n            if i == len(s):\n                return [[]]\n\n            ways = []\n\n            for j in range(i + 1, len(s) + 1):\n                part = s[i:j]\n                if part == part[::-1]:\n                    start = [part]\n                    for end in backtrack(j):\n                        ways.append(start + end)\n            \n            return ways\n\n        return backtrack(0)",
        "runtime": "198"
      },
      {
        "code": "class Solution:\n  def partition(self, s: str) -> List[List[str]]:\n    @cache\n    def helper(s) -> List[List[str]]:\n      res = []\n      for i in range(1, len(s)+1):\n        tmp_s = s[:i]\n        if tmp_s == tmp_s[::-1]:\n          rights = helper(s[i:])\n          if not rights:\n            res.append([tmp_s])\n          else:\n            for r in rights:\n                res.append([tmp_s, *r])\n      return res\n\n    return helper(s)\n",
        "runtime": "209"
      }
    ],
    "memory_inefficient_codes": [
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        hsh = defaultdict(list)\n        hsh[-1].append([])\n        for n in range(len(s)):\n            for l, r in [[n, n], [n-1, n]]:\n                while l > -1 and r < len(s) and s[l] == s[r]:\n                    for m in hsh[l-1]:\n                        hsh[r].append([] + m + [s[l:r+1]])\n                    l -= 1\n                    r += 1\n        \n        return hsh[len(s) - 1]\n                ",
        "memory": "35126"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        hsh = defaultdict(list)\n        hsh[-1].append([])\n        for n in range(len(s)):\n            for l, r in [[n, n], [n-1, n]]:\n                while l > -1 and r < len(s) and s[l] == s[r]:\n                    for m in hsh[l-1]:\n                        hsh[r].append([] + m + [s[l:r+1]])\n                    l -= 1\n                    r += 1\n        \n        return hsh[len(s) - 1]\n                ",
        "memory": "35126"
      },
      {
        "code": "\nclass Solution:\n    def __init__(self):\n        self.cache = {}\n\n    def is_palindrome(self, s: str) -> bool:\n        N = len(s)\n        for i in range(N // 2):\n            if s[i] != s[N - 1 - i]:\n                return False\n        return True\n\n    def partition(self, s: str) -> List[List[str]]:\n        if s in self.cache:\n            return self.cache[s]\n\n        if len(s) == 1:\n            self.cache[s] = [[s]]\n            return self.cache[s]\n\n        res = []\n        # if s is palindrome\n        if self.is_palindrome(s):\n            res.append([s])\n\n        for length in range(1, len(s)):\n            # separate string\n            prefix, suffix = s[:length], s[length:]\n            if self.is_palindrome(suffix):\n                for prefix_partition in self.partition(prefix):\n                    partition = prefix_partition.copy()\n                    partition.append(suffix)\n                    res.append(partition)\n        self.cache[s] = res.copy()\n        return res",
        "memory": "35534"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        length = len(s)\n        val = [[None] * length for _ in range(length)]\n\n        def valid(l0, r0):\n            if val[l0][r0] is not None:\n                return val[l0][r0]\n            l, r = l0, r0\n            while l < r:\n                if s[l] != s[r]:\n                    val[l][r] = False\n                    return False\n                l += 1\n                r -= 1\n            val[l0][r0] = True\n            return True\n        \n        dp = [None for _ in range(length)]\n        def helper(r):\n            if r < 0:\n                return [[]]\n            if r == 0:\n                return [[s[0]]]\n            if dp[r] is not None:\n                return dp[r]\n            out = []\n            for l in range(r, -1, -1):\n                if valid(l, r):\n                    ss = s[l:r + 1]\n                    for ls in deepcopy(helper(l - 1)):\n                        ls.append(ss)\n                        out.append(ls)\n            dp[r] = out\n            return out\n        \n        out = helper(length - 1)\n        return out",
        "memory": "35738"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        n = len(s)\n        saved = dict()\n        if n==1:\n            return s\n        def isPalindrome(start, end):\n            while start <= end:\n                if s[start] != s[end]:\n                    return False\n                start+=1\n                end-=1\n            return True\n        def splits(beg, end):\n            res = set()\n            if beg == end:\n                res.add((s[beg],))\n                return res\n            if end < beg:\n                return res\n            curr = s[beg:end+1]\n            if curr in saved:\n                return saved[curr] \n            if isPalindrome(beg, end):\n                res.add((curr,))\n            for i in range(end-1, beg-1, -1):\n                l_split = splits(beg, i)\n                r_split = splits(i+1, end)\n                for l in l_split:\n                    for r in r_split:\n                        res.add(l + r)\n            saved[curr] = res\n            return res\n        return splits(0, n-1)    \n        ",
        "memory": "35738"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        result_map: dict[str, list[list[str]]] = {}\n\n        def is_palindrome(s: str) -> bool:\n            left, right = 0, len(s) - 1\n            while left < right:\n                if s[left] != s[right]:\n                    return False\n                left, right = left + 1, right - 1\n\n            return True\n\n        def helper(s: str) -> list[list[str]]:\n            if len(s) == 0:\n                return []\n\n            nonlocal result_map\n            if s in result_map:\n                return result_map[s]\n\n            result: list[list[str]] = []\n            for i in range(1, len(s)):\n                if is_palindrome(s[:i]):\n                    for r in helper(s[i:]):\n                        result.append([s[:i]] + r)\n\n            if is_palindrome(s):\n                result.append([s])\n\n            result_map[s] = result\n            return result\n\n        return helper(s)        ",
        "memory": "35941"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        result = []\n\n        def dfs(i: int, partitions: List[str], p: str) -> None:\n            if i == len(s):\n                if p == p[::-1]:\n                    result.append([*partitions, p])\n                return\n\n            if p == p[::-1]:\n                dfs(i+1, [*partitions, p], s[i])\n\n            dfs(i+1, [*partitions], p + s[i])\n\n        dfs(1, [], s[0])\n        return result\n",
        "memory": "35941"
      },
      {
        "code": "class Solution:\n    def isPalindrome(self, s):\n        return s == s[::-1]\n    \n    def partition(self, s: str, cache = None) -> List[List[str]]:\n        if not s:\n            return [[]]\n        if not cache:\n            cache = dict()\n        if len(s) == 1:\n            cache[s] = [[s]]\n        if s in cache:\n            return cache[s]\n        else:\n            for i in range(1,len(s)+1):\n                if self.isPalindrome(s[:i]):\n                    substringPartitions = self.partition(s[i:],cache)\n                    res = []\n                    if substringPartitions:\n                        for substringPartition in substringPartitions:\n                            res.append([s[:i]]+substringPartition)\n                        if s in cache:\n                            cache[s] = cache[s] + res\n                        else:\n                            cache[s] = res\n            return cache[s] if s in cache else []\n                    \n                    \n        ",
        "memory": "36145"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> list[list[str]]:\n        ans = []\n\n        def dfs(i: int, curr: str):\n            if i == len(s):\n                ans.append(curr)\n\n            for j in range(i, len(s)):\n                sol = s[i : j + 1]\n                if self.is_palindrome(sol):\n                    dfs(j + 1, [*curr, sol])\n\n        dfs(0, [])\n        return ans\n\n    def is_palindrome(self, s: str) -> bool:\n        n = len(s)\n        return all(s[i] == s[n - i - 1] for i in range(n // 2))\n",
        "memory": "36145"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n      def isP(word):\n\n        return word == word[::-1]\n      \n\n      # find all substrings then check if isP\n      ret = []\n      def help(path, cw, ind):\n        if ind >= len(s):\n          # if isP(cw):\n          #   path.append(cw)\n          if path and len(cw) == 0: \n            ret.append([''.join(row) for row in path])\n          return \n        tempWord = cw+s[ind]\n        if isP(tempWord):\n          # if the word + char is pal, then can include it in partition\n          help(path+[[tempWord]], '', ind+1)\n        help(path, cw+s[ind], ind+1)\n      \n      help([], '', 0)\n      return ret\n\n\n\n        ",
        "memory": "36349"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        n = len(s)\n        dp = [[(s[i] == s[j]) for j in range(n)] for i in range(n)]\n\n        # build dp differently \n        for diag in range(2, n):\n            for i in range(n-diag):\n                if not dp[i+1][i+diag-1]:\n                    dp[i][i+diag] = False\n\n        answers = []\n\n        def backtrack(output, idx):\n            if idx == n:\n                answers.append([string for string in output])\n                return\n            \n            i = idx\n            for j in range(i, n):\n                if (i == j or \\\n                    (j == i+1 and dp[i][j-1]) or \\\n                    (j > i+1 and i < n-1 and dp[i+1][j-1])) \\\n                        and dp[i][j]:\n\n                    output.append(s[i:j+1])\n                    backtrack(output, j+1)\n                    output.pop()\n\n        backtrack([], 0)\n        return answers",
        "memory": "36349"
      },
      {
        "code": "class Solution:\n    def solve(self, s, index, ds, res):\n        if index == len(s):\n            res.add(tuple(ds))\n            return\n        for i in range(index, len(s)):\n            if s[index:i+1] == s[index:i+1][::-1]:\n                ds.append(s[index:i+1])\n                self.solve(s, i + 1, ds, res)\n                ds.pop()\n    def partition(self, s: str) -> List[List[str]]:\n        ds = []\n        res = set()\n        self.solve(s, 0, ds, res)\n        return list(map(lambda x: list(x), res))",
        "memory": "36553"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        output = []\n        index_to_list = dict()\n\n        def solver(start):\n            if start in index_to_list:\n                return index_to_list[start]\n            if start == len(s):\n                return [[]]\n            # otherwise, find the whole list\n            index_to_list[start] = []\n            for i in range(start + 1, len(s) + 1):\n                if s[start:i] == s[start:i][::-1]:\n                    copy = solver(i).copy()\n                    put_back = [[s[start:i]] + suffix_list for suffix_list in copy]\n                    index_to_list[start].extend(put_back)\n            return index_to_list[start]\n            \n        return solver(0)",
        "memory": "36553"
      },
      {
        "code": "class Solution:\n    def validPartitioner(self, i, combination):\n        # exceeded str\n        if i == self.n:\n            self.ans.add(tuple(combination))\n            return\n\n        for j in range(i, self.n):\n            if self.dp[i][j] == 1:\n                subStr = self.s[i:(j+1)]\n                combination.append(subStr)\n                self.validPartitioner(j+1, combination)\n                combination.pop()\n\n    def partition(self, s: str) -> List[List[str]]:\n        self.n, self.s = len(s), s\n\n        self.dp = [[-1]*self.n for _ in range(self.n)]\n        for i in range(self.n):\n            self.dp[i][i] = 1 # every single char is a palindrome\n            \n        for length in range(2, self.n+1):\n            for i in range(self.n-length+1):\n\n                if length == 2:\n                    self.dp[i][i+length-1] = 1 if self.s[i] == self.s[i+length-1] else 0\n                else:\n                    self.dp[i][i+length-1] = 1 if (self.s[i] == self.s[i+length-1] and self.dp[i+1][i+length-2] == 1) else 0\n\n        self.ans = set()\n        self.validPartitioner(0, [])\n        return [list(c) for c in self.ans]\n        ",
        "memory": "36756"
      },
      {
        "code": "class Solution:\n    def is_palindrome(self, s: str) -> bool:\n        l, r = 0, len(s) - 1\n        while l < r:\n            if s[l] != s[r]:\n                return False\n            l += 1\n            r -= 1\n        return True\n\n    def partition(self, s: str) -> list[list[str]]:\n        res = []\n\n        def backtrack(s2: str, curr: list[str]):\n            if len(s2) < 1:\n                res.append(curr)\n                return\n            for i in range(len(s2)):\n                sub = s2[:i + 1]\n                if self.is_palindrome(sub):\n                    new = curr.copy()\n                    new.append(sub)\n                    backtrack(s2[i + 1:], new)\n\n        backtrack(s, [])\n\n        return res\n",
        "memory": "37368"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        def isPal(arr):\n            j = len(arr) - 1\n            for i in range(len(arr) // 2):\n                if arr[i] != arr[j]:\n                    return False\n                j -= 1\n            return True\n        \n        out = []\n\n        def getpartition(arr, res):\n            if not arr:\n                out.append(res)\n                return\n\n            for i in range(len(arr)):\n                string = arr[:i+1]\n                if isPal(string):\n                    tmp = res.copy()\n                    tmp.append(string)\n                    getpartition(arr[i + 1:], tmp)\n        \n        getpartition(s, [])\n        return out\n\n\n",
        "memory": "37368"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        n = len(s)\n        saved = dict()\n        if n==1:\n            return s\n        def isPalindrome(start, end):\n            while start <= end:\n                if s[start] != s[end]:\n                    return False\n                start+=1\n                end-=1\n            return True\n        def splits(beg, end):\n            res = set()\n            if beg == end:\n                res.add((s[beg],))\n                return res\n            if end < beg:\n                return res\n            curr = s[beg:end+1]\n            if curr in saved:\n                return saved[curr] \n            if isPalindrome(beg, end):\n                res.add((curr,))\n            for i in range(end-1, beg-1, -1):\n                if isPalindrome(beg, i):\n                    l = (s[beg:i+1],)\n                    r_split = splits(i+1, end)\n                    for r in r_split:\n                        res.add(l + r)\n            saved[curr] = res\n            return res\n        return splits(0, n-1)    \n        ",
        "memory": "37571"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        result = []\n        \n        n = len(s)\n        dp = [[False] * n for _ in range(n)]\n        for l in range(1,n+1):\n            for i in range(n-l+1):\n                j = i+l-1\n                dp[i][j] = (i == j) or (s[i] == s[j] and (j == i+1 or dp[i+1][j-1]))\n\n        self.get_partitions(s, 0, [], dp, result)\n        return result\n        \n    def get_partitions(self, s, i, partitions, dp, result):\n        if i == len(s):\n            result.append([''.join(p) for p in partitions])\n            return\n        partitions.append([])\n        for j in range(i, len(s)):\n            partitions[-1].append(s[j])\n            if dp[i][j]:\n                self.get_partitions(s,j+1,partitions, dp, result)\n\n        \n        partitions.pop()\n",
        "memory": "38183"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n\n        ans=set()\n        n=len(s)\n        dp_yes=set()\n        dp_no=set()\n        def calculate(i,l):\n            if i>=n:\n                f=0\n                if tuple(l) in dp_yes:\n                    ans.add(tuple(l))\n                    return\n                else:\n                    if tuple(l) in dp_no:\n                        return\n                    else:\n                        for j in l:\n                            if j!=j[::-1]:\n                                f=1\n                                break\n                        if f==0:\n                            ans.add(tuple(l))\n                            dp_yes.add(tuple(l))\n                        else:\n                            dp_no.add(tuple(l))\n                        return\n            calculate(i+1,l+[s[i]])\n            if l:   \n                calculate(i+1,l[:-1]+[l[-1]+s[i]])\n        calculate(0,[])\n        \n            \n        return ans\n        \n        ",
        "memory": "38386"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n\n        ans=set()\n        n=len(s)\n        dp_yes=set()\n        dp_no=set()\n        def calculate(i,l):\n            if i>=n:\n                f=0\n                if tuple(l) in dp_yes:\n                    ans.add(tuple(l))\n                    return\n                else:\n                    if tuple(l) in dp_no:\n                        return\n                    else:\n                        for j in l:\n                            if j!=j[::-1]:\n                                f=1\n                                break\n                        if f==0:\n                            ans.add(tuple(l))\n                            dp_yes.add(tuple(l))\n                        else:\n                            dp_no.add(tuple(l))\n                        return\n            calculate(i+1,l+[s[i]])\n            if l:   \n                calculate(i+1,l[:-1]+[l[-1]+s[i]])\n        calculate(0,[])\n        \n            \n        return ans\n        \n        ",
        "memory": "38386"
      },
      {
        "code": "class Solution:\n    part = []\n    parts = []\n\n    def partitions(self, s : str, n : int, p : List[List[int]]) :\n        if n == len(s) :\n            if len(self.part) != 0 :\n                self.parts.append(self.part[:])\n                return\n        \n        for i in range(n, len(s)) :\n            if (s[i] == s[n]) and (((n + 2) >= i) or (p[n + 1][i - 1] == 1)) :\n                p[n][i] = 1\n                self.part.append(s[n : i + 1])\n                self.partitions(s, i + 1, p)\n                del self.part[-1]\n\n    def partition(self, s: str) -> List[List[str]]:\n        self.part = []\n        self.parts = []\n        self.partitions(s, 0, [[0 for i in range(len(s))] for i in range(len(s))])\n\n        return copy.deepcopy(self.parts)",
        "memory": "38590"
      },
      {
        "code": "class Solution:\n    part = []\n    parts = []\n\n    def partitions(self, s : str, n : int, p : List[List[int]]) :\n        if n == len(s) :\n            if len(self.part) != 0 :\n                self.parts.append(self.part[:])\n                return\n        \n        for i in range(n, len(s)) :\n            if (s[i] == s[n]) and (((n + 2) >= i) or (p[n + 1][i - 1] == 1)) :\n                p[n][i] = 1\n                self.part.append(s[n : i + 1])\n                self.partitions(s, i + 1, p)\n                del self.part[-1]\n\n    def partition(self, s: str) -> List[List[str]]:\n        self.part = []\n        self.parts = []\n        self.partitions(s, 0, [[0 for i in range(len(s))] for i in range(len(s))])\n\n        return copy.deepcopy(self.parts)",
        "memory": "38590"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        output = []\n        def backtrack(currIdx, path):\n            if currIdx == len(s):\n                output.append(path)\n                return\n            for i in range(currIdx + 1, len(s) + 1):\n                if s[currIdx:i] == s[currIdx:i][::-1]:\n                    backtrack(i, path + [s[currIdx:i][::-1]])\n                \n        backtrack(0, [])\n        return output",
        "memory": "38794"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        output = []\n        def backtrack(currIdx, path):\n            if currIdx == len(s):\n                output.append(path)\n                return\n            for i in range(currIdx + 1, len(s) + 1):\n                if s[currIdx:i] == s[currIdx:i][::-1]:\n                    backtrack(i, path + [s[currIdx:i][::-1]])\n                \n        backtrack(0, [])\n        return output",
        "memory": "38794"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        n = len(s)\n\n        def helper(i):\n            result = []\n            for j in range(n - i):\n                sub_s = s[i: i + j + 1]\n                if sub_s == sub_s[::-1]:\n                    if i + j + 1 < n:\n                        for x in helper(i + j + 1):\n                            result.append([s[i: i + j + 1]] + x)\n                    else:\n                        result.append([s[i: i + j + 1]])\n            return result\n\n        return helper(0)",
        "memory": "38998"
      }
    ],
    "memory_moderate_codes": [
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        if not s:\n            return [[]]\n\n        res = []\n\n        for i in range(len(s)):\n            subString = s[:i+1]\n\n            if subString == subString[::-1]:\n                res += [ [subString] + subPalindromes for subPalindromes in self.partition(s[i+1:]) ] \n\n        return res",
        "memory": "26976"
      },
      {
        "code": "def is_palindrome(s):\n    # Remove non-alphanumeric characters and convert to lowercase\n    s = ''.join(char.lower() for char in s if char.isalnum())\n    \n    # Compare the string with its reverse\n    return s == s[::-1]\n\nclass Solution:\n    def partition(self, s):\n        self.s = s  # Store the input string as an instance variable\n        return self.dfs(0, \"\", [])  # Start DFS from index 0 with empty current string and list\n\n    def dfs(self, index, curr_string, curr_list):\n        s = self.s  # Get the stored input string\n        if index >= len(s):\n            return []  # Base case: if index is out of bounds, return empty list\n\n        char = s[index]  # Get the current character\n        curr_string += char  # Add the current character to the current string\n\n        ret_list = []  # Initialize the list to store results\n\n        if is_palindrome(curr_string):\n            new_list = curr_list.copy()  # Create a copy of the current list\n            new_list.append(curr_string)  # Add the current palindrome to the new list\n\n            if index == len(s) - 1:\n                return [new_list]  # If we've reached the end, return the current partition\n            \n            # Recursively call DFS with the next index, empty current string, and updated list\n            ret_list.extend(self.dfs(index + 1, \"\", new_list))\n\n        # Recursively call DFS with the next index, current string, and current list\n        ret_list.extend(self.dfs(index + 1, curr_string, curr_list))\n        \n        return ret_list  # Return the list of all valid partitions\n",
        "memory": "27180"
      },
      {
        "code": "class Solution:\n    def rec(self, i, last, substr):\n        if i == -1:\n            sum_length = 0\n            for s in substr:\n                sum_length += len(s)\n                if s != s[::-1]:\n                    break\n            else:\n                if sum_length == len(self.s):\n                    self.ans.append(substr[::-1])\n            return\n\n        self.rec(i - 1, last, substr)\n        self.rec(i - 1, i, substr + [self.s[i:last]])\n\n    def partition(self, s: str) -> List[List[str]]:\n        self.ans = []\n        self.s = s\n        self.rec(len(s) - 1, len(s), [])\n        return self.ans",
        "memory": "27384"
      },
      {
        "code": "class Solution:\n    def isPalindrome(self, s):\n        return s == s[::-1]\n\n    def solve(self, str, tempList, ans):\n        if len(str) == 0:\n            ans.append(tempList[:])  # add a copy\n            return\n\n        for i in range(1, len(str) + 1):\n            a = str[:i]\n            b = str[i:]\n            if self.isPalindrome(a):\n                tempList.append(a)\n                self.solve(b, tempList, ans)\n                tempList.pop()  # backtrack\n\n    def partition(self, s: str) -> List[List[str]]:\n        ans = []\n        tempList = []\n\n        self.solve(s, tempList, ans)\n\n        return ans\n",
        "memory": "27588"
      },
      {
        "code": "class Solution:\n    def is_palindrome(self, s):\n        return s == s[::-1]\n\n    def dfs(self, s, partition = []):\n        if s == \"\":\n            self.result.append(partition)\n            return\n\n        for i in range(1, len(s) + 1):\n            if self.is_palindrome(s[:i]):\n                self.dfs(s[i:], partition + [s[:i]])\n\n    def partition(self, s: str) -> List[List[str]]:\n        self.result = []\n        self.dfs(s)\n        return self.result\n        ",
        "memory": "27791"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        result = []\n        self.dfs(s, [], result)\n        return result\n\n    def isPalindrome(self, s: str) -> bool:\n        return s == s[::-1]\n\n    def dfs(self, s: str, path: List[str], result: List[List[str]]):\n        if not s:\n            result.append(path)\n            return\n        for i in range(1, len(s) + 1):\n            if self.isPalindrome(s[:i]):\n                # add current substring in the currentList\n                self.dfs(s[i:], path + [s[:i]], result)\n                # backtrack and remove the current substring from currentList",
        "memory": "27995"
      },
      {
        "code": "class Solution:\n    def check(self, split):\n        # for i in range(len(split)//2):\n        #     if split[i] != split[-i-1]:\n        #         return False\n        \n        return split == split[::-1]\n\n    def solve(self, i, s, sub, res):\n        if i == len(s):\n            if sub:\n                res.append(sub.copy())\n            \n            return\n        \n        split = \"\"\n        for j in range(i, len(s)):\n            split += s[j]\n            if self.check(split):\n                sub.append(split)\n                self.solve(j+1, s, sub, res)\n                sub.pop()\n\n    def partition(self, s: str) -> List[List[str]]:\n        res = []\n        \n        self.solve(0, s, [], res)\n\n        return res",
        "memory": "27995"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        result = []\n        self.dfs(s, [], result)\n        return result\n\n    def isPalindrome(self, s: str) -> bool:\n        return s == s[::-1]\n\n    def dfs(self, s: str, path: List[str], result: List[List[str]]):\n        if not s:\n            result.append(path)\n            return\n        for i in range(1, len(s) + 1):\n            if self.isPalindrome(s[:i]):\n                # add current substring in the currentList\n                self.dfs(s[i:], path + [s[:i]], result)\n                # backtrack and remove the current substring from currentList\n        ",
        "memory": "28199"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        len_s = len(s)\n        dp = [[False] * len_s for _ in range(len_s)]\n        result = []\n        self.dfs(result, s, 0, [], dp)\n        return result\n\n    def dfs(\n        self,\n        result: List[List[str]],\n        s: str,\n        start: int,\n        currentList: List[str],\n        dp: List[List[bool]],\n    ):\n        if start >= len(s):\n            result.append(list(currentList))\n        for end in range(start, len(s)):\n            if s[start] == s[end] and (\n                end - start <= 2 or dp[start + 1][end - 1]\n            ):\n                dp[start][end] = True\n                currentList.append(s[start : end + 1])\n                self.dfs(result, s, end + 1, currentList, dp)\n                currentList.pop()",
        "memory": "28199"
      },
      {
        "code": "class Solution:\n    def backtrack(self,current,s):\n        if len(s)==0: \n            self.out.append(current)\n            return\n        tmp = \"\"\n        for i,c in enumerate(s):\n            tmp+=c\n            if tmp==tmp[::-1]:\n                self.backtrack(current+[tmp],s[i+1:])\n        return \n\n\n\n    def partition(self, s: str) -> List[List[str]]:\n        self.out = []\n        self.backtrack([],s)\n        return self.out",
        "memory": "28403"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        # can generate all possible combinations and then check if each is a palindrome\n        # checking for a palindrome would be O(N) where n is length of string\n\n        def backtrack(s, idx, cur, ans):\n            def isPalindrome(l):\n                left = 0\n                right = len(l)-1\n                while left < right:\n                    if l[left] != l[right]:\n                        return False\n                    left += 1\n                    right -= 1\n                return True\n\n            if idx == len(s):\n                # if is palindrome\n                ok = True\n                for l in cur:\n                    if not isPalindrome(l):\n                        ok = False\n                        break\n                if ok:\n                    ans.append(list(cur))\n                return\n\n            curString = []\n            for i in range(idx, len(s)):\n                curString.append(s[i])\n                cur.append(\"\".join(curString))\n                backtrack(s, i+1, cur, ans)\n                cur.pop()\n\n        ans = []\n        backtrack(s, 0, [], ans)\n        return ans",
        "memory": "28403"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        # def isPalindrome(s, left, right):\n        #     while left < right:\n        #         if s[left] != s[right]:\n        #             return False\n        #         left += 1\n        #         right -= 1\n        #     return True\n        \n        # def backtrack(s, start, current_partition, result):\n        #     if start == len(s):\n        #         result.append(list(current_partition))\n        #         return\n        #     for end in range(start, len(s)):\n\n        #         if isPalindrome(s, start, end):\n        #             current_partition.append(s[start:end+1])\n\n        #             backtrack(s, end+1, current_partition, result)\n\n        #             current_partition.pop()\n        # res = []\n        # backtrack(s, 0, [], res)\n        # return res\n\n        def dfs(start):\n            if start == len(s):\n                return [[]]\n            if start in memo:\n                return memo[start]\n\n            res = []\n            for end in range(start + 1, len(s) + 1):\n                tmp_word = s[start:end]\n                if tmp_word == tmp_word[::-1]:\n                    for rest in dfs(end):\n                        res.append([tmp_word] + rest)\n            memo[start] = res\n            return res\n\n        memo = {}\n        return dfs(0)",
        "memory": "28606"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        out = []\n        for i in range(1, len(s)+1):\n            t = s[:i]\n            if t == t[::-1]:\n                if i < len(s):\n                    sublist = self.partition(s[i:])\n                    out.extend([[t] + x for x in sublist])\n                else:\n                    out.append([t])\n        \n        return out\n        ",
        "memory": "28606"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:  \n        n = len(s)  # O(N * 2^N), when all substrings are palindrome, e.g., 'a'*N\n        @functools.lru_cache(None)\n        def dfs(start):\n            if start == n: return [[]]\n            res = []\n            for i in range(start, n):  # O(N)\n                cur = s[start:i+1]  # O(N) partition 1\n                if cur == cur[::-1]:  # O(N)  # check if it's a palindrome\n                    res += [[cur] + rest for rest in dfs(i+1)]  # partition 2\n            return res\n        return dfs(0)",
        "memory": "29014"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:  # O(N * 2^N), when all substrings are palindrome, e.g., 'a'*N\n        n = len(s)\n        @functools.lru_cache(None)\n        def dfs(start):\n            if start == n: return [[]]\n            res = []\n            for i in range(start, n):  # O(N)\n                cur = s[start:i+1]  # O(N) partition 1\n                if cur == cur[::-1]:  # O(N)  # check if it's a palindrome\n                    res += [[cur] + rest for rest in dfs(i+1)]  # partition 2\n            return res\n        return dfs(0)",
        "memory": "29218"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        slen = len(s)\n\n        def isPalin(start,end):\n            l = start\n            r = end\n            while(l<r):\n                if s[l]!=s[r]:\n                    return False\n                l+=1\n                r-=1\n            return True\n\n        memo = dict()\n\n        def f(start):\n            toReturn = []\n            if start == slen:\n                return []\n            \n            if start in memo:\n                return memo[start]\n            \n            subString = \"\"\n            for i in range(start,slen):\n                subString += s[i]\n                \n                if isPalin(start,i):\n                    \n                    nexts = f(i+1)\n                    if not nexts:\n                        toReturn.append([subString])\n                    else:\n                        for next in nexts:\n                            toReturn.append([subString]+next)\n            \n            memo[start] = toReturn[:]\n            return toReturn\n        \n        return f(0)",
        "memory": "29218"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        def isPali(i, j):\n            while i < j:\n                if s[i] != s[j]:\n                    return False\n                i += 1\n                j -= 1\n            return True\n\n        memo = dict()\n\n        def helper(i):\n            result = []\n            if i == len(s):\n                return []\n            \n            if i in memo:\n                return memo[i]\n            \n            temp = \"\"\n            for j in range(i, len(s)):\n                temp += s[j]\n                \n                if isPali(i,j):\n                    bundle_list = helper(j+1)\n                    if not bundle_list:\n                        result.append([temp])\n                    else:\n                        for bundle in bundle_list:\n                            result.append([temp]+bundle)\n            \n            memo[i] = result[:]\n            return result\n        \n        return helper(0)",
        "memory": "29421"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        def isPali(i, j):\n            while i < j:\n                if s[i] != s[j]:\n                    return False\n                i += 1\n                j -= 1\n            return True\n\n        memo = dict()\n\n        def helper(i):\n            result = []\n            if i == len(s):\n                return []\n            \n            if i in memo:\n                return memo[i]\n            \n            temp = \"\"\n            for j in range(i, len(s)):\n                temp += s[j]\n                \n                if isPali(i,j):\n                    bundle_list = helper(j+1)\n                    if not bundle_list:\n                        result.append([temp])\n                    else:\n                        for bundle in bundle_list:\n                            result.append([temp]+bundle)\n            \n            memo[i] = result.copy()\n            return result\n        \n        return helper(0)",
        "memory": "29421"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n\n        @lru_cache(None)\n        def find(ind):\n            if ind == len(s):\n                return [[]]\n            ans = []\n            for i in range(ind, len(s)):\n                temp = s[ind:i+1]\n                if temp == temp[::-1]:\n                    next = find(i+1)\n                    ans.extend([[temp] + a for a in next])\n            return ans\n        \n        return find(0)",
        "memory": "29625"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        if len(s)==0 : return []\n        if len(s)==1 : return [s]\n        def check_pal(st) :\n            if len(st)<=1 : return True\n            i = 0\n            j = len(st)-1\n            while i<j : \n                if st[i]!=st[j] : return False\n                i += 1\n                j -= 1\n            return True\n        ans = []\n        for i in range(1, len(s)) :\n            first = s[:i]\n            second =  s[i:]\n            if check_pal(first):\n                temp = []\n                two = self.partition(second)\n                temp = [[first, *b] for b in two]\n                ans.extend(temp)\n        if check_pal(s) : ans.append([s])\n        return ans",
        "memory": "29829"
      },
      {
        "code": "from collections import defaultdict\nclass Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        \"\"\"\n        idea: build a list of lists, L, where L[i][j] = j'th partition in the i'th partitioning\n        starting from x=0, and y=1, set i = 0 and j = 0.\n        while s[x:y] is a palindrome, append the substring \n        s[x:y] to L[i] and increment i.\n        when while condition fails, increment j.\n        repeat while loop above except picking up where we left off in each partitioning\n        i.e. start at x=1 and y=2 if we left off at y=1 (need a mapping of i -> x).\n        \"\"\"\n        L = []\n        partition_to_offset = defaultdict(int)\n        n = len(s)\n        x = 0\n        y = 1\n        i = 0\n        j = 0\n        #initialize list of lists\n        for y in range(x+1,n+1):\n            if self.isPalindrome(s[x:y]):\n                L.append([s[x:y]])\n                partition_to_offset[i] = y\n                i+=1\n        while min(partition_to_offset.values()) < n:\n            l = len(L)\n            for i in range(l):\n                partitioning = L[i].copy()\n                x = partition_to_offset[i]\n                y = x+1\n                if y<=n and x<n:\n                    L[i].append(s[x:y])\n                    partition_to_offset[i] = y\n                y+=1\n                for y in range(x+2,n+1):\n                    if self.isPalindrome(s[x:y]):\n                        L.append(partitioning + [s[x:y]])\n                        partition_to_offset[len(L)-1] = y\n                        y+=1\n            \n        return L\n                \n    def isPalindrome(self, s:str) -> bool:\n        n = len(s)\n        for k in range(n//2):\n            if s[k] != s[n-k-1]:\n                return False\n        return True\n        ",
        "memory": "30033"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        output = []\n        def is_palindrome(s):\n            s = s.replace(\" \", \"\").lower()\n            # Check if the string is equal to its reverse\n            return s == s[::-1]\n\n        def dfs(string):\n            if len(string)==1:\n                return [[string]]\n            stores = []\n            for i in range(len(string)):\n                firstString = string[0:i+1]\n                if is_palindrome(firstString):\n                    if i+1 == len(string):\n                        stores.append([firstString])\n                        return stores\n                    secondString = dfs(string[i+1:])\n                    for store in secondString:\n                        store.insert(0,firstString)\n                    stores.extend(secondString)\n            return stores\n            \n        return dfs(s)\n                    \n\n\n    \n",
        "memory": "30644"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        output = []\n        def is_palindrome(s):\n            s = s.replace(\" \", \"\").lower()\n            # Check if the string is equal to its reverse\n            return s == s[::-1]\n\n        def dfs(string):\n            if len(string)==1:\n                return [[string]]\n            stores = []\n            for i in range(len(string)):\n                firstString = string[0:i+1]\n                if is_palindrome(firstString):\n                    if i+1 == len(string):\n                        stores.append([firstString])\n                        return stores\n                    secondString = dfs(string[i+1:])\n                    for store in secondString:\n                        store.insert(0,firstString)\n                    stores.extend(secondString)\n            return stores\n\n            \n        return dfs(s)\n                    \n\n\n    \n",
        "memory": "30644"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n\n\n        dp = [[] for _ in range(len(s) + 1)]\n        dp[0] = [[]]\n\n        for i in range(len(s)+1):\n            string = s[:i]\n            for j in range(i-1, -1, -1):\n                currentStr = string[j:]\n                if currentStr != currentStr[::-1]:\n                    continue\n                partitions = dp[j]\n                for partition in partitions:\n                    partitionCopy = partition[:]\n                    partitionCopy.append(currentStr)\n                    dp[i].append(partitionCopy)\n\n        return dp[-1]",
        "memory": "30848"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n\n\n        dp = [[] for _ in range(len(s) + 1)]\n        dp[0] = [[]]\n\n        for i in range(len(s)+1):\n            string = s[:i]\n            for j in range(i-1, -1, -1):\n                currentStr = string[j:]\n                if currentStr != currentStr[::-1]:\n                    continue\n                partitions = dp[j]\n                for partition in partitions:\n                    partitionCopy = partition[:]\n                    partitionCopy.append(currentStr)\n                    dp[i].append(partitionCopy)\n\n        return dp[-1]",
        "memory": "30848"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        res = []\n        part = []\n\n        def pali(s: str, l: int, r: int) -> bool:\n            while l < r:\n                if s[l] != s[r]:\n                    return False\n                l += 1\n                r -= 1\n            return True\n\n        def backtrack(i):\n            if i == len(s):\n                res.append(part.copy())\n                return\n\n            # we keep part as a separate variable since \n            # we do not want to append multiple values and carry \n            # them over each time\n\n            for j in range(i, len(s)):\n                if pali(s, i, j):\n                    part.append(s[i:j+1]) # + 1 to prevent off by one\n                    backtrack(j + 1) # backtrack current index + 1\n                    part.pop()\n        \n        backtrack(0)\n        return res",
        "memory": "31255"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        all_parts = [[s[0]]]\n        for c in s[1:]:\n            new_parts = []\n            for i in all_parts:\n                new_parts += [i + [c]]\n                new_parts += [i[:-1] + [i[-1] + c]]\n            all_parts = new_parts\n\n        valids = []\n        for i in all_parts:\n            is_valid = True\n            for j in i:\n                if not self.is_pallindrone(j):\n                    is_valid = False\n                    break\n            if is_valid:\n                valids.append(i)\n        return valids\n\n    def is_pallindrone(self, s):\n        return s == s[::-1]",
        "memory": "31663"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n\n        ans=set()\n        n=len(s)\n        def calculate(i,l):\n            if i>=n:\n                f=0\n                for j in l:\n                    if j!=j[::-1]:\n                        f=1\n                        break\n                if f==0:\n                    ans.add(tuple(l))\n                return\n            calculate(i+1,l+[s[i]])\n            if l:   \n                calculate(i+1,l[:-1]+[l[-1]+s[i]])\n        calculate(0,[])\n        \n            \n        return ans\n        \n        ",
        "memory": "31866"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n\n        ans=set()\n        n=len(s)\n        def calculate(i,l):\n            if i>=n:\n                f=0\n                for j in l:\n                    if j!=j[::-1]:\n                        f=1\n                        break\n                if f==0:\n                    ans.add(tuple(l))\n                return\n            calculate(i+1,l+[s[i]])\n            if l:   \n                calculate(i+1,l[:-1]+[l[-1]+s[i]])\n        calculate(0,[])\n        \n            \n        return ans\n        \n        ",
        "memory": "32070"
      },
      {
        "code": "\"\"\"\nNaive:\n- Try every partitioning combination and check if they are all palindromes\n    - Use two pointer: \nTime: O(n! * n)\n\n- Iterate throught the string\n- At each index, try to expand the palindromes => for each palindrome that I found => concat them to all possible previous partition\naab\n{\n    1: [a],\n    2: [a, a], [aa]\n    3: [a, a, b], [aa, b]\n}\n\naabbb\ncombs = {\n    1: [[a]]\n    2: [[aa], [a, a]]\n    3: [[aa, b], [a, a, b]]\n    4: [[aa, bb], [a, a, bb], [aa, b, b], [a, a, b, b]]\n    5: [[aa, bbb], [a, a, bbb], [aa, b, bb], [a, a, b, bb], [aa, bb, b], [a, a, bb, b], [aa, b, b, b], [a, a, b, b, b]]\n}\n\ni = 0\n0,0\n0,1\n\ni = 1\n1,1 => [a,a]\n1, 2\n\ni = 2\n2, 2\n2, 3\n\ni = 3\n3, 3 => 2, 4\n3, 4 => 2, 5\n\ni = 4\n4, 4\n4, 5\n\n\"\"\"\n\nclass Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        combs = defaultdict(list)\n        \n        def helper(left, right):\n            nonlocal s\n            nonlocal combs\n\n            while left >= 0 and right < len(s):\n                if s[left] != s[right]:\n                    break\n                \n                # add new combination\n                prev_combs = combs[left]\n                \n                new_combs = []\n                substr = s[left: right+1]\n                for comb in prev_combs:\n                    new_comb = comb.copy()\n                    new_comb.append(substr)\n                    new_combs.append(new_comb)\n                if not new_combs:\n                    new_combs = [[substr]]\n                combs[right+1].extend(new_combs)\n                # expand\n                left -= 1\n                right += 1\n            \n            return\n\n        \n        for i in range(len(s)):\n            # odd palindrome\n            helper(i, i)\n            # even palindrome\n            helper(i, i+1)\n        \n        return combs[len(s)]\n",
        "memory": "32478"
      },
      {
        "code": "class Solution(object): # iteration, real dp\n  def partition(self, s):\n    \"\"\"\n    :type s: str\n    :rtype: List[List[str]]\n    \"\"\"\n    pal = [[False for i in range(0, len(s))] for j in range(0, len(s))]\n    ans = [[[]]] + [[] for _ in range(len(s))] # length is n+1\n\n    for i in range(0, len(s)):\n      for j in range(0, i + 1):\n        if (s[j] == s[i]) and ((j + 1 > i - 1) or (pal[j + 1][i - 1])):\n          pal[j][i] = True\n          for res in ans[j]:\n            a = res + [s[j:i + 1]]\n            ans[i + 1].append(a)\n\n\n    return ans[-1]",
        "memory": "32681"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        self.ret = []\n        self.partition = []\n        def dfs(start, end, currLen):\n            if end > len(s):\n                if currLen == len(s):\n                    self.ret.append(self.partition.copy())\n                return\n            if s[start: end] == s[start: end][::-1]:\n                self.partition.append(s[start: end])\n                dfs(end, end + 1, currLen + len(s[start:end]))\n                self.partition.pop()\n            end = end + 1\n            dfs(start, end, currLen)\n        dfs(0, 1, 0)\n        return self.ret\n\n",
        "memory": "33089"
      },
      {
        "code": "class Solution:\n\n    def isPalindrome(self, s):\n        length = len(s)\n        rev_s = \"\".join(reversed(s))\n\n        for i in range(length):\n            if s[i] != rev_s[i]:\n                return False\n        return True\n        \n\n    def partition(self, s: str) -> List[List[str]]:\n        \n        sol = []\n        def backtrack(index, path):\n            if index == len(s):\n                res.append(list(path))\n            else:\n                path.append(s[index])\n                backtrack(index+1, path)\n                path.pop()\n\n                if path:\n                    path[-1] = path[-1] + s[index]\n                    backtrack(index+1, path)\n    \n        res = []\n        backtrack(0, [])\n\n        for strL in res:\n            pal = True\n            for item in strL:\n                if not self.isPalindrome(item):\n                    pal = False\n            if pal == True:\n                sol.append(strL)\n        \n        return sol\n        ",
        "memory": "33293"
      },
      {
        "code": "class Solution:\n    def isPalindrome(self, s, l, r):\n        while (l < r):\n            if s[l] != s[r]:\n                return False\n            l += 1\n            r -= 1\n        return True\n    def partition(self, s: str) -> List[List[str]]:\n        self.res = []\n        def getPartitions(start, currP):\n\n            if start == len(s):\n\n                self.res.append(currP.copy())\n                return\n\n            for i in range(start, len(s)):\n                if self.isPalindrome(s, start, i):\n                    currP.append(s[start:i+1])\n                    getPartitions(i + 1, currP)\n                    currP.pop()\n\n        getPartitions(0, [])\n        return self.res\n\n\n\n        ",
        "memory": "33496"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        def palindorm(s):\n            if not s:\n                return False\n            return s == s[::-1]\n\n        ans = []\n        def bt(index, path):\n            if index == len(s):\n                ans.append(path[:])\n            for i in range(index, len(s)+1):\n                if palindorm(s[index: i]):\n                    path.append(s[index: i])\n                    bt(i, path)\n                    path.pop()\n        bt(0, [])\n        return ans\n        ",
        "memory": "33700"
      },
      {
        "code": "class Solution:\r\n    def partition(self, s: str) -> List[List[str]]:\r\n        path = []\r\n        result = []\r\n\r\n        len_s = len(s)\r\n\r\n        def is_Palindrome(s, start_idx, end_idx):\r\n            s_in = s[start_idx:end_idx+1]\r\n            return s_in == s_in[::-1]\r\n\r\n        def backtracking(start_idx):\r\n            if start_idx >= len_s:\r\n                result.append(path.copy())\r\n\r\n            for i in range(start_idx, len_s):\r\n                if is_Palindrome(s, start_idx, i):\r\n                    path.append(s[start_idx:i + 1])\r\n                    backtracking(i + 1)\r\n                    path.pop()\r\n\r\n        backtracking(0)\r\n        return result",
        "memory": "33904"
      },
      {
        "code": "\"\"\"\nbefore state = \"\"\n    after state = \"a\"\n\"\"\"\n\nfrom typing import List\n\nclass Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        def is_palindrome(sub: str) -> bool:\n            return sub == sub[::-1]  # Check if a substring is a palindrome\n\n        def backtrack(curr_path: List[str], remaining_chars: str):\n            if not remaining_chars:  # Base case: no more characters to process\n                result.append(curr_path.copy())  # Add the current partition to result\n                return\n            \n            # Try every possible substring from the start of remaining_chars\n            for i in range(1, len(remaining_chars) + 1):\n                substring = remaining_chars[:i]\n                if is_palindrome(substring):\n                    curr_path.append(substring)  # Include the palindrome substring in the partition\n                    # Recursive call with updated partition and remaining characters\n                    backtrack(curr_path, remaining_chars[i:])\n                    curr_path.pop()  # Backtrack: remove the last added substring\n\n        result = []  # List to store all possible partitions\n        backtrack([], s)  # Start the recursion with an empty partition and the full string\n        return result",
        "memory": "34108"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        ans = []\n        def ispalindrome(word):\n            return word == word[::-1]\n\n        def backtrack(comb, start): \n            # indicates you have tranversed all letters, and all were eliglble palindromes\n            if start == len(s):\n                ans.append(comb.copy())\n                return\n            for i in range(start,len(s)):\n                if ispalindrome(s[start:i+1]):\n                    comb.append(s[start:i+1])\n                    backtrack(comb,i+1)\n                    comb.pop()\n\n        backtrack([],0)\n        return ans",
        "memory": "34108"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        res = []\n\n        def backtrack(i,curr):\n            if i==len(s):\n                res.append(curr[:])\n            \n            for j in range(i,len(s)):\n                if s[i:j+1]==s[i:j+1][::-1]:\n                    curr.append(s[i:j+1])\n                    backtrack(j+1,curr)\n                    curr.pop()\n\n        backtrack(0,[])\n        return res",
        "memory": "34311"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        res = []\n\n        def backtrack(i,curr):\n            if i==len(s):\n                res.append(curr[:])\n            \n            for j in range(i,len(s)):\n                if s[i:j+1]==s[i:j+1][::-1]:\n                    curr.append(s[i:j+1])\n                    backtrack(j+1,curr)\n                    curr.pop()\n\n        backtrack(0,[])\n        return res",
        "memory": "34311"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        res = []\n        temp = []\n        def backtrack(i):\n            if i == len(s):\n                res.append(temp.copy())\n                return \n            for j in range(i,len(s)+1):\n                if s[i:j+1] == s[i:j+1][::-1]:\n                    temp.append(s[i:j+1])\n                    backtrack(j+1)\n                    temp.pop()\n            return\n        backtrack(0)\n        return res",
        "memory": "34515"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        res = []\n        cur = []\n        \n        def dfs(i):\n            if i >= len(s):\n                res.append(cur.copy())\n                return\n            for j in range(i, len(s)):\n                if self.isPali(s, i, j):\n                    cur.append(s[i:j+1])\n                    dfs(j+1)\n                    cur.pop()\n        dfs(0)\n        return res\n    def isPali(self, s, l, r):\n        while l<r:\n            if s[l] != s[r]:\n                return False\n            l+=1\n            r-=1\n        return True\n",
        "memory": "34515"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        partitions = []\n\n        def backtrack(curr_word, curr_partition, i):\n            if i == len(s):\n                if self.is_palindrome(curr_word):\n                    curr_partition.append(curr_word)\n                    partitions.append(curr_partition.copy())\n                return\n            \n            curr_word += s[i]\n            if self.is_palindrome(curr_word):\n                curr_partition.append(curr_word)\n                backtrack('', curr_partition.copy(), i + 1)\n                curr_partition.pop()\n            \n            backtrack(curr_word, curr_partition, i + 1)\n                \n\n        backtrack('', [], 0)\n        return partitions\n\n    def is_palindrome(self, word):\n        return word != '' and word == word[::-1]",
        "memory": "34719"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        \n        output = []\n\n        def backtrack(n, path):\n\n            if n == len(s):\n                output.append(path[:])\n                return\n            \n            for i in range(n, len(s)):\n                if s[n:i+1] == s[n:i+1][::-1]:\n                    path.append(s[n:i+1])\n                    backtrack(i+1, path)\n                    path.pop()\n            \n        backtrack(0, [])\n\n        return output",
        "memory": "34719"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        res = []\n        partition = []\n        \n        def isPalindrome(s, l, r): \n            while l < r: \n                if s[l] != s[r]: \n                    return False \n                l += 1\n                r -= 1\n            return True \n\n        def backtrack(i): \n            if i >= len(s):\n                res.append(partition[:]) \n                return \n            for j in range(i, len(s)): \n                if isPalindrome(s, i, j): \n                    partition.append(s[i: j + 1]) \n                    backtrack(j + 1)\n                    partition.pop() \n        backtrack(0) \n        return res\n\n",
        "memory": "34923"
      }
    ],
    "memory_efficient_codes": [
      {
        "code": "from collections.abc import Generator\nfrom functools import lru_cache\n\nclass Solution:\n    def partition(self, string: str) -> Generator[list[str], None, None]:\n        @lru_cache()\n        def is_palindrome(left: int, right: int) -> bool:\n            while left < right:\n                if string[left] != string[right]:\n                    return False\n                left, right = left + 1, right - 1\n            return True\n\n        def backtrack(path: list[str], left: int) -> Generator[list[str], None, None]:\n            if left == end:\n                yield path.copy()\n                return\n            for right in range(left, end):\n                if is_palindrome(left, right):\n                    path.append(string[left : right + 1])\n                    yield from backtrack(path, right + 1)\n                    del path[-1]\n\n        end = len(string)\n        return backtrack([], 0)",
        "memory": "22901"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        def f(s,l,a,p):\n            def g(s,l,r):\n                while l<r:\n                    if s[l]!=s[r]:return False\n                    l,r=l+1,r-1\n                return True\n            if a==l:yield p;return;\n            for b in range(a,l):\n                if g(s,a,b):\n                    p.append(s[a:b+1])\n                    yield from f(s,l,b+1,p)\n                    p.pop()\n        yield from f(s,len(s),0,deque())\n",
        "memory": "22901"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        dp = []\n        for i in range(len(s)):\n            dp.append([s[i]])\n            left, right = i - 1, i + 1\n            while left >= 0 and right < len(s):\n                if s[left] == s[right]:\n                    dp[left].append(s[left:right+1])\n                    left -= 1\n                    right += 1\n                else:\n                    break\n            if i < len(s) - 1 and s[i] == s[i+1]:\n                dp[-1].append(s[i:i+2])\n                left, right = i-1, i+2\n                while left >= 0 and right < len(s):\n                    if s[left] == s[right]:\n                        dp[left].append(s[left:right+1])\n                        left -= 1\n                        right += 1\n                    else:\n                        break\n        def compute(length):\n            if length == len(s):\n                return [[]]\n            res = []\n            for w in dp[length]:\n                for nxt in compute(length + len(w)):\n                    res.append([w] + nxt)\n            return res\n        return compute(0)\n",
        "memory": "23105"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        length = len(s)\n        def helper(l, r): \n            while l >= 0 and r < length and s[l] == s[r]:\n                palindromes[l].append(s[l:r+1]) \n                l -= 1 \n                r += 1\n                \n\n        palindromes = defaultdict(list) \n        for i in range(length): \n            if i != length - 1: \n                helper(i, i+1)\n            helper(i, i) \n        \n        d = deque([]) \n        res = [] \n        for pali in palindromes[0]: \n            d.append([pali]) \n\n        while d: \n            path = d.popleft()\n            curr = ''.join(path)\n            length = len(curr) \n            if length == len(s): \n                res.append(path) \n\n            for pali in palindromes[length]: \n                d.append(path + [pali])  # Append a new path with the palindrome added\n\n        return res\n",
        "memory": "23309"
      },
      {
        "code": "class Solution:\n\n    \n    def backtracking(self, s, index, path, res):\n        if index == len(s):\n            res.append(path[:])\n            return\n        for i in range(index, len(s)):\n            if s[index:i+1] == s[index:i+1][::-1]:\n                path.append(s[index:i+1])\n                self.backtracking(s, i+1, path, res)\n                path.pop()\n\n    def partition(self, s: str) -> List[List[str]]:\n\n        res = []\n        self.backtracking(s, 0, [], res)\n        return res\n\n",
        "memory": "23513"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        \n        ret = []\n        def backtrack(substr, combo, ret):\n            if len(substr) == 0:\n                ret.append(combo.copy())\n            \n            for i in range(len(substr)):\n                if substr[:i+1] == (substr[:i+1])[::-1]:\n                    combo.append(substr[:i+1])\n                    backtrack(substr[i+1:], combo, ret)\n                    combo.pop()\n        \n        backtrack(s, [], ret)\n        return ret",
        "memory": "23716"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        n = len(s)\n        def dfs(start, path, res):\n            # Append at the end of the tree node\n            if start == n:\n                res.append(path[:])\n            # Start creating strings by iterating from index after start\n            for end in range(start + 1, n + 1):\n                substring = s[start:end]\n                if self.p(substring):\n                    dfs(end, path + [substring], res)\n            return res\n        return dfs(0, [], [])\n\n    def p(self, s):\n        return s == s[::-1]\n",
        "memory": "23920"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        result = []\n\n        def palindrome(s: str) -> bool:\n            return s == s[::-1] # compare to its reverse\n        \n        # s = the string\n        # j = current starting index for substring exploration\n        # path = current partition (to add to result)\n        # result = all complete paths\n        def dfs(s: str, j: int, path: List[str], result: List[List[str]]) -> None:\n            if j == len(s):\n                result.append(path)\n                return\n            for i in range(j, len(s)):\n                if palindrome(s[j: i + 1]):\n                    dfs(s, i + 1, path + [s[j: i + 1]], result)\n            \n        dfs(s, 0, [], result)\n        return result\n        \n    # Time: O(n*2^n)\n    # Space: O(n)",
        "memory": "24124"
      },
      {
        "code": "class Solution:\n   \n    def partition(self, s: str) -> List[List[str]]:\n        res = []\n        self.dfs(s, [],res)\n        return res\n\n    def dfs(self, s, tmp, res):\n        if len(s) == 0:\n            res.append(list(tmp))   \n            return\n\n        for i in range(1, len(s)+1):\n            if s[:i] == s[:i][::-1]:\n                self.dfs(s[i:],tmp + [s[:i]], res)\n\n        return\n        \n\n    \n\n        ",
        "memory": "24328"
      },
      {
        "code": "class Solution:\n    def backtrack(self, start, path):\n        if start == len(self.s):\n            self.ans.append(path[:])\n            return\n\n        for end in range(start + 1, len(self.s) + 1):\n            sub = self.s[start : end]\n\n            if sub == sub[::-1]:\n                self.backtrack(end, path + [sub])\n\n    def partition(self, s: str) -> List[List[str]]:\n        '''\n        find a palindrome, backtrack to find others in remainder of string\n        '''\n        self.ans = []\n        self.s = s\n        self.backtrack(0, [])\n        return self.ans\n\n    ",
        "memory": "24531"
      },
      {
        "code": "class Solution:\n    def check(self, split):\n        # for i in range(len(split)//2):\n        #     if split[i] != split[-i-1]:\n        #         return False\n        \n        return split == split[::-1]\n\n    def solve(self, i, s, sub, res):\n        if i == len(s):\n            if sub:\n                res.append(sub.copy())\n            \n            return\n        \n        split = \"\"\n        for j in range(i, len(s)):\n            split += s[j]\n            if self.check(split):\n                sub.append(split)\n                self.solve(j+1, s, sub, res)\n                sub.pop()\n\n    def partition(self, s: str) -> List[List[str]]:\n        res = []\n        \n        self.solve(0, s, [], res)\n\n        return res",
        "memory": "24531"
      },
      {
        "code": "class Solution:\n    def check(self, split):\n        for i in range(len(split)//2):\n            if split[i] != split[-i-1]:\n                return False\n        \n        return True\n\n    def solve(self, i, s, sub, res):\n        if i == len(s):\n            if sub:\n                res.append(sub.copy())\n            \n            return\n        \n        split = \"\"\n        for j in range(i, len(s)):\n            split += s[j]\n            if self.check(split):\n                sub.append(split)\n                self.solve(j+1, s, sub, res)\n                sub.pop()\n\n    def partition(self, s: str) -> List[List[str]]:\n        res = []\n        \n        self.solve(0, s, [], res)\n\n        return res",
        "memory": "24735"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        def isPalindrome(s):\n            return s == s[::-1]\n\n        def backtracking(s, curr):\n            if s == \"\":\n                return [curr]\n            ans = []\n            for i in range(1, len(s) + 1):\n                if isPalindrome(s[:i]):\n                    res = backtracking(s[i:], curr + [s[:i]])\n                    if res:\n                        ans += res\n            return ans if ans else None\n\n        \n        return backtracking(s, [])\n\n\n        ### Neetcode Backtracking\n        # res, part = [], []\n        # def isPali(s, l, r):\n        #     while l < r:\n        #         if s[l] != s[r]:\n        #             return False\n        #         l, r = l + 1, r - 1\n        #     return True\n        # def dfs(i):\n        #     if i >= len(s):\n        #         res.append(part.copy())\n        #         return\n        #     for j in range(i, len(s)):\n        #         if isPali(s, i, j):\n        #             part.append(s[i : j + 1])\n        #             dfs(j + 1)\n        #             part.pop()\n        # dfs(0)\n        # return res\n\n    ",
        "memory": "24939"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        sol = list()\n        #find all palindromes in string\n        paliDict = {}\n\n        #paliDict[startIdx] = [(endIdx, palindrome)]\n        for i in range(len(s)-1):\n            # find palindromes from middle\n            # even\n            lhs = i\n            rhs = i\n            palindrome = \"\"\n            while lhs >= 0 and rhs < len(s) and s[lhs] == s[rhs]:\n                newChar = s[lhs]\n                if len(palindrome) == 0:\n                    palindrome = newChar\n                    paliDict[lhs] = [(lhs + 1, palindrome)]\n                else:\n                    palindrome = newChar + palindrome + newChar\n                    paliDict[lhs].append((rhs + 1, palindrome))\n                lhs -= 1\n                rhs += 1\n            # odd\n            lhs = i\n            rhs = i + 1\n            palindrome = \"\"\n            while lhs >= 0 and rhs < len(s) and s[lhs] == s[rhs]:\n                newChar = s[lhs]\n                palindrome = newChar + palindrome + newChar\n                paliDict[lhs].append((rhs + 1, palindrome))\n                lhs -= 1\n                rhs += 1\n\n        lastIdx = len(s) - 1\n        paliDict[lastIdx] = [(len(s), s[lastIdx])]\n\n        #find all combinations of ranges\n        sol = list()\n        self.helper(sol, paliDict, s, 0, list())\n        return sol\n\n    def helper(self, sol, paliDict, s, currIdx, combo):\n        if currIdx == len(s):\n            sol.append(combo)\n            return\n        for elem in paliDict[currIdx]:\n            endIdx = elem[0]\n            currPalindrome = elem[1]\n            comboCopy = combo.copy()\n            comboCopy.append(currPalindrome)\n            self.helper(sol, paliDict, s, endIdx, comboCopy)",
        "memory": "25143"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        current, res, visited = [], set(), set()\n        self.backtrack(s, current, res, 0, visited)\n        return list(res)\n\n    def backtrack(self, s, current, res, i, visited):\n        if (tuple(current), i) in visited:\n            return\n        if i == len(s):\n            allPalindrome = True\n            for sub in current:\n                if sub != sub[::-1]:\n                    allPalindrome = False\n            if allPalindrome:\n                res.add(tuple(current))\n            return\n        for j in range(i + 1, len(s) + 1):\n            # i=0, current = \"a\", j = 1\n                # i=1, current [\"a\", \"a\"], j =2\n                    # i=2, current [\"a\", \"a\", \"b\"], j =3\n                # i=1, current [\"a\", \"ab\"], j =3\n\n            # i=0, current = \"aa\", j = 2\n                # i=2, current [\"aa\", \"b\"], j = 3\n\n            # i=0, current = \"aab\", j = 3 -> allPalindrome = false => return\n            if (tuple(current + [s[i:j]]), i) not in visited:\n                visited.add((tuple(current + [s[i:j]]), i))\n                self.backtrack(s, current + [s[i:j]], res, j, visited)\n                visited.remove((tuple(current + [s[i:j]]), i))\n",
        "memory": "25346"
      },
      {
        "code": "class Solution:\n    def dp(self,i,s,st):\n        if i>=len(s):\n            self.lst.append(tuple(st))\n            return \n        for j in range(i,len(s)):\n            if s[i:j+1]==''.join(reversed(s[i:j+1])):\n                st.append(s[i:j+1])\n                x=self.dp(j+1,s,st)\n                st.pop()\n        return\n    def partition(self, s: str) -> List[List[str]]:\n        self.lst=[]\n        self.dp(0,s,[])\n        return self.lst",
        "memory": "25550"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        if s == None or len(s) == 0:\n            return []\n        self.result = []\n        self.backtrack(s, [])\n        return self.result\n    def backtrack(self, s: str, path: List[int]) -> None:\n        #base\n        if len(s) == 0:\n            self.result.append([num for num in path])\n            return\n        #logic\n        for i in range(len(s)):\n            sub = s[:i+1]\n            if self.isPalindrome(sub):\n                #action\n                path.append(sub)\n                #recurse\n                self.backtrack(s[i+1:], path)\n                #backtrack\n                path.pop()\n    def isPalindrome(self, s:str) -> bool:\n        return s == s[::-1]\n",
        "memory": "25754"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        self.ans = []\n        self.track = []\n        self.backtrack(s, 0)\n        return self.ans\n\n    def backtrack(self, s, start):\n        if start == len(s):\n            self.ans.append(copy.deepcopy(self.track))\n            return\n\n        for i in range(start, len(s)):\n            if not self.is_palindrome(s, start, i):\n                continue\n            self.track.append(s[start : i + 1])\n            self.backtrack(s, i + 1)\n            self.track.pop(-1)\n\n    def is_palindrome(self, s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n        return True\n",
        "memory": "25958"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        N = len(s)\n        if N == 0:\n            return []\n        is_pal = [[False] * N for i in range(N)]\n        for i in range(N):\n            is_pal[i][i] = True\n\n        for l in range(2, N + 1):\n            for i in range(N):\n                j = i + l - 1\n                if j >= N:\n                    break\n                if l == 2:\n                    is_pal[i][j] = s[i] == s[j]\n                else:\n                    is_pal[i][j] = (s[i] == s[j]) and is_pal[i + 1][j - 1]\n        \n        ans = [[[]]]\n        for i in range(0, N):\n            result = []\n            for j in range(0, i + 1):\n                if is_pal[j][i]:\n                    sub = s[j: i + 1]\n                    prev = ans[j - 1 + 1]\n                    for x in prev:\n                        result.append(x + [sub])  \n            ans.append(result)\n\n        return ans[-1]\n\n\n\n        ",
        "memory": "26161"
      },
      {
        "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        memo={}\n        def palindromes(i):\n            palis = []\n            for word_i in range(i, len(s)):\n                sub = s[i:word_i+1]\n                if sub==sub[::-1]:\n                    palis.append(sub)\n            return palis\n        def dfs(i,sub):\n            if i>=len(s):\n                res.append(sub[:])\n                return\n            if i in memo:\n                partitions=memo[i]\n            else:\n                partitions=palindromes(i)\n                memo[i]=partitions\n            for pali in partitions:\n                sub.append(pali)\n                dfs(i+len(pali),sub)\n                sub.pop(-1)\n        res=[]\n        dfs(0,[])\n        return res",
        "memory": "26569"
      },
      {
        "code": "class Solution:\n    def partition(self, t: str) -> List[List[str]]:\n        \n        def partitioner(s):\n            if len(s) == 0:\n                return [[]]\n            else:\n                res = []\n                for i in range(1,len(s) + 1):\n                    cur_string = s[:i]\n                    if cur_string == cur_string[::-1]:\n                        current_res = partitioner(s[i:])\n                        current_res = [[cur_string] + val for val in current_res]\n                        res += current_res\n                return res\n        \n        return partitioner(t)",
        "memory": "26773"
      }
    ],
    "import_code": "from typing import List\nimport random\nimport string",
    "setup_code": "# Define necessary classes and functions\n\nclass Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        memo = {}\n\n        def palindromes(i):\n            palis = []\n            for word_i in range(i, len(s)):\n                sub = s[i:word_i + 1]\n                if sub == sub[::-1]:\n                    palis.append(sub)\n            return palis\n\n        def dfs(i, sub):\n            if i >= len(s):\n                res.append(sub[:])\n                return\n            if i in memo:\n                partitions = memo[i]\n            else:\n                partitions = palindromes(i)\n                memo[i] = partitions\n            for pali in partitions:\n                sub.append(pali)\n                dfs(i + len(pali), sub)\n                sub.pop(-1)\n        \n        res = []\n        dfs(0, [])\n        return res\n\n\nclass TestCaseGenerator:\n    def generate(self) -> dict:\n        length = random.randint(1, 16)\n        s = ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n        return {'s': s}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['s']\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}",
    "libraries": ["from typing import List"],
    "entry_point": "partition",
    "test_cases": [
      {
        "input": "xpbpmgnkxz",
        "output": "[['x', 'p', 'b', 'p', 'm', 'g', 'n', 'k', 'x', 'z'], ['x', 'pbp', 'm', 'g', 'n', 'k', 'x', 'z']]"
      },
      {
        "input": "xkjqqfmlwuccu",
        "output": "[['x', 'k', 'j', 'q', 'q', 'f', 'm', 'l', 'w', 'u', 'c', 'c', 'u'], ['x', 'k', 'j', 'q', 'q', 'f', 'm', 'l', 'w', 'u', 'cc', 'u'], ['x', 'k', 'j', 'q', 'q', 'f', 'm', 'l', 'w', 'uccu'], ['x', 'k', 'j', 'qq', 'f', 'm', 'l', 'w', 'u', 'c', 'c', 'u'], ['x', 'k', 'j', 'qq', 'f', 'm', 'l', 'w', 'u', 'cc', 'u'], ['x', 'k', 'j', 'qq', 'f', 'm', 'l', 'w', 'uccu']]"
      },
      {
        "input": "ntrhulheaycu",
        "output": "[['n', 't', 'r', 'h', 'u', 'l', 'h', 'e', 'a', 'y', 'c', 'u']]"
      },
      {
        "input": "izxdqzit",
        "output": "[['i', 'z', 'x', 'd', 'q', 'z', 'i', 't']]"
      },
      {
        "input": "tlfqmxipsvybwo",
        "output": "[['t', 'l', 'f', 'q', 'm', 'x', 'i', 'p', 's', 'v', 'y', 'b', 'w', 'o']]"
      },
      {
        "input": "fiqgmspa",
        "output": "[['f', 'i', 'q', 'g', 'm', 's', 'p', 'a']]"
      },
      {
        "input": "fbpyhtgj",
        "output": "[['f', 'b', 'p', 'y', 'h', 't', 'g', 'j']]"
      },
      {
        "input": "hyqwnvpghno",
        "output": "[['h', 'y', 'q', 'w', 'n', 'v', 'p', 'g', 'h', 'n', 'o']]"
      },
      {
        "input": "bbb",
        "output": "[['b', 'b', 'b'], ['b', 'bb'], ['bb', 'b'], ['bbb']]"
      },
      {
        "input": "iiwibbns",
        "output": "[['i', 'i', 'w', 'i', 'b', 'b', 'n', 's'], ['i', 'i', 'w', 'i', 'bb', 'n', 's'], ['i', 'iwi', 'b', 'b', 'n', 's'], ['i', 'iwi', 'bb', 'n', 's'], ['ii', 'w', 'i', 'b', 'b', 'n', 's'], ['ii', 'w', 'i', 'bb', 'n', 's']]"
      },
      {
        "input": "hgikilwvfhbhdzc",
        "output": "[['h', 'g', 'i', 'k', 'i', 'l', 'w', 'v', 'f', 'h', 'b', 'h', 'd', 'z', 'c'], ['h', 'g', 'i', 'k', 'i', 'l', 'w', 'v', 'f', 'hbh', 'd', 'z', 'c'], ['h', 'g', 'iki', 'l', 'w', 'v', 'f', 'h', 'b', 'h', 'd', 'z', 'c'], ['h', 'g', 'iki', 'l', 'w', 'v', 'f', 'hbh', 'd', 'z', 'c']]"
      },
      {
        "input": "cceoeauiddsdl",
        "output": "[['c', 'c', 'e', 'o', 'e', 'a', 'u', 'i', 'd', 'd', 's', 'd', 'l'], ['c', 'c', 'e', 'o', 'e', 'a', 'u', 'i', 'd', 'dsd', 'l'], ['c', 'c', 'e', 'o', 'e', 'a', 'u', 'i', 'dd', 's', 'd', 'l'], ['c', 'c', 'eoe', 'a', 'u', 'i', 'd', 'd', 's', 'd', 'l'], ['c', 'c', 'eoe', 'a', 'u', 'i', 'd', 'dsd', 'l'], ['c', 'c', 'eoe', 'a', 'u', 'i', 'dd', 's', 'd', 'l'], ['cc', 'e', 'o', 'e', 'a', 'u', 'i', 'd', 'd', 's', 'd', 'l'], ['cc', 'e', 'o', 'e', 'a', 'u', 'i', 'd', 'dsd', 'l'], ['cc', 'e', 'o', 'e', 'a', 'u', 'i', 'dd', 's', 'd', 'l'], ['cc', 'eoe', 'a', 'u', 'i', 'd', 'd', 's', 'd', 'l'], ['cc', 'eoe', 'a', 'u', 'i', 'd', 'dsd', 'l'], ['cc', 'eoe', 'a', 'u', 'i', 'dd', 's', 'd', 'l']]"
      },
      {
        "input": "fg",
        "output": "[['f', 'g']]"
      },
      {
        "input": "qywzhiwimwmgxlo",
        "output": "[['q', 'y', 'w', 'z', 'h', 'i', 'w', 'i', 'm', 'w', 'm', 'g', 'x', 'l', 'o'], ['q', 'y', 'w', 'z', 'h', 'i', 'w', 'i', 'mwm', 'g', 'x', 'l', 'o'], ['q', 'y', 'w', 'z', 'h', 'iwi', 'm', 'w', 'm', 'g', 'x', 'l', 'o'], ['q', 'y', 'w', 'z', 'h', 'iwi', 'mwm', 'g', 'x', 'l', 'o']]"
      },
      {
        "input": "gfx",
        "output": "[['g', 'f', 'x']]"
      },
      {
        "input": "tcnybsjtivprev",
        "output": "[['t', 'c', 'n', 'y', 'b', 's', 'j', 't', 'i', 'v', 'p', 'r', 'e', 'v']]"
      },
      {
        "input": "hsmgui",
        "output": "[['h', 's', 'm', 'g', 'u', 'i']]"
      },
      {
        "input": "kfwdxczzqfm",
        "output": "[['k', 'f', 'w', 'd', 'x', 'c', 'z', 'z', 'q', 'f', 'm'], ['k', 'f', 'w', 'd', 'x', 'c', 'zz', 'q', 'f', 'm']]"
      },
      {
        "input": "whbmbdann",
        "output": "[['w', 'h', 'b', 'm', 'b', 'd', 'a', 'n', 'n'], ['w', 'h', 'b', 'm', 'b', 'd', 'a', 'nn'], ['w', 'h', 'bmb', 'd', 'a', 'n', 'n'], ['w', 'h', 'bmb', 'd', 'a', 'nn']]"
      },
      {
        "input": "bzfd",
        "output": "[['b', 'z', 'f', 'd']]"
      },
      {
        "input": "zvxxfvzkfevfmqky",
        "output": "[['z', 'v', 'x', 'x', 'f', 'v', 'z', 'k', 'f', 'e', 'v', 'f', 'm', 'q', 'k', 'y'], ['z', 'v', 'xx', 'f', 'v', 'z', 'k', 'f', 'e', 'v', 'f', 'm', 'q', 'k', 'y']]"
      },
      {
        "input": "jtekqpmlrkhngqyx",
        "output": "[['j', 't', 'e', 'k', 'q', 'p', 'm', 'l', 'r', 'k', 'h', 'n', 'g', 'q', 'y', 'x']]"
      },
      {
        "input": "erfbsxhqwivseebr",
        "output": "[['e', 'r', 'f', 'b', 's', 'x', 'h', 'q', 'w', 'i', 'v', 's', 'e', 'e', 'b', 'r'], ['e', 'r', 'f', 'b', 's', 'x', 'h', 'q', 'w', 'i', 'v', 's', 'ee', 'b', 'r']]"
      },
      {
        "input": "pdsqgsowrk",
        "output": "[['p', 'd', 's', 'q', 'g', 's', 'o', 'w', 'r', 'k']]"
      },
      {
        "input": "ukwoyy",
        "output": "[['u', 'k', 'w', 'o', 'y', 'y'], ['u', 'k', 'w', 'o', 'yy']]"
      },
      {
        "input": "nzdmohvmczulhg",
        "output": "[['n', 'z', 'd', 'm', 'o', 'h', 'v', 'm', 'c', 'z', 'u', 'l', 'h', 'g']]"
      },
      {
        "input": "xxultckmebds",
        "output": "[['x', 'x', 'u', 'l', 't', 'c', 'k', 'm', 'e', 'b', 'd', 's'], ['xx', 'u', 'l', 't', 'c', 'k', 'm', 'e', 'b', 'd', 's']]"
      },
      {
        "input": "gwg",
        "output": "[['g', 'w', 'g'], ['gwg']]"
      },
      {
        "input": "nwyohqjade",
        "output": "[['n', 'w', 'y', 'o', 'h', 'q', 'j', 'a', 'd', 'e']]"
      },
      {
        "input": "xabwvyxbfnws",
        "output": "[['x', 'a', 'b', 'w', 'v', 'y', 'x', 'b', 'f', 'n', 'w', 's']]"
      },
      {
        "input": "mxugky",
        "output": "[['m', 'x', 'u', 'g', 'k', 'y']]"
      },
      {
        "input": "pataap",
        "output": "[['p', 'a', 't', 'a', 'a', 'p'], ['p', 'a', 't', 'aa', 'p'], ['p', 'ata', 'a', 'p']]"
      },
      {
        "input": "rivuiliyoknrwjd",
        "output": "[['r', 'i', 'v', 'u', 'i', 'l', 'i', 'y', 'o', 'k', 'n', 'r', 'w', 'j', 'd'], ['r', 'i', 'v', 'u', 'ili', 'y', 'o', 'k', 'n', 'r', 'w', 'j', 'd']]"
      },
      {
        "input": "nblkyacvyw",
        "output": "[['n', 'b', 'l', 'k', 'y', 'a', 'c', 'v', 'y', 'w']]"
      },
      {
        "input": "hpbxxsaadq",
        "output": "[['h', 'p', 'b', 'x', 'x', 's', 'a', 'a', 'd', 'q'], ['h', 'p', 'b', 'x', 'x', 's', 'aa', 'd', 'q'], ['h', 'p', 'b', 'xx', 's', 'a', 'a', 'd', 'q'], ['h', 'p', 'b', 'xx', 's', 'aa', 'd', 'q']]"
      },
      {
        "input": "k",
        "output": "[['k']]"
      },
      {
        "input": "siubvcxowzejk",
        "output": "[['s', 'i', 'u', 'b', 'v', 'c', 'x', 'o', 'w', 'z', 'e', 'j', 'k']]"
      },
      {
        "input": "juuc",
        "output": "[['j', 'u', 'u', 'c'], ['j', 'uu', 'c']]"
      },
      {
        "input": "kkngk",
        "output": "[['k', 'k', 'n', 'g', 'k'], ['kk', 'n', 'g', 'k']]"
      },
      {
        "input": "mnlu",
        "output": "[['m', 'n', 'l', 'u']]"
      },
      {
        "input": "ghx",
        "output": "[['g', 'h', 'x']]"
      },
      {
        "input": "lkqnuxy",
        "output": "[['l', 'k', 'q', 'n', 'u', 'x', 'y']]"
      },
      {
        "input": "vjyqirjbeajn",
        "output": "[['v', 'j', 'y', 'q', 'i', 'r', 'j', 'b', 'e', 'a', 'j', 'n']]"
      },
      {
        "input": "p",
        "output": "[['p']]"
      },
      {
        "input": "kyw",
        "output": "[['k', 'y', 'w']]"
      },
      {
        "input": "r",
        "output": "[['r']]"
      },
      {
        "input": "raw",
        "output": "[['r', 'a', 'w']]"
      },
      {
        "input": "ymjoabrq",
        "output": "[['y', 'm', 'j', 'o', 'a', 'b', 'r', 'q']]"
      },
      {
        "input": "iudioxjsnotafwu",
        "output": "[['i', 'u', 'd', 'i', 'o', 'x', 'j', 's', 'n', 'o', 't', 'a', 'f', 'w', 'u']]"
      },
      {
        "input": "ejoftll",
        "output": "[['e', 'j', 'o', 'f', 't', 'l', 'l'], ['e', 'j', 'o', 'f', 't', 'll']]"
      },
      {
        "input": "xvlbbitxazld",
        "output": "[['x', 'v', 'l', 'b', 'b', 'i', 't', 'x', 'a', 'z', 'l', 'd'], ['x', 'v', 'l', 'bb', 'i', 't', 'x', 'a', 'z', 'l', 'd']]"
      },
      {
        "input": "f",
        "output": "[['f']]"
      },
      {
        "input": "tyrvaubu",
        "output": "[['t', 'y', 'r', 'v', 'a', 'u', 'b', 'u'], ['t', 'y', 'r', 'v', 'a', 'ubu']]"
      },
      {
        "input": "ssrepphg",
        "output": "[['s', 's', 'r', 'e', 'p', 'p', 'h', 'g'], ['s', 's', 'r', 'e', 'pp', 'h', 'g'], ['ss', 'r', 'e', 'p', 'p', 'h', 'g'], ['ss', 'r', 'e', 'pp', 'h', 'g']]"
      },
      {
        "input": "azt",
        "output": "[['a', 'z', 't']]"
      },
      {
        "input": "nhxjbvygzn",
        "output": "[['n', 'h', 'x', 'j', 'b', 'v', 'y', 'g', 'z', 'n']]"
      },
      {
        "input": "mtlrjawfkxootd",
        "output": "[['m', 't', 'l', 'r', 'j', 'a', 'w', 'f', 'k', 'x', 'o', 'o', 't', 'd'], ['m', 't', 'l', 'r', 'j', 'a', 'w', 'f', 'k', 'x', 'oo', 't', 'd']]"
      },
      {
        "input": "qjtqpwfp",
        "output": "[['q', 'j', 't', 'q', 'p', 'w', 'f', 'p']]"
      },
      {
        "input": "m",
        "output": "[['m']]"
      },
      {
        "input": "eijdbujinrt",
        "output": "[['e', 'i', 'j', 'd', 'b', 'u', 'j', 'i', 'n', 'r', 't']]"
      },
      {
        "input": "mygvjlbp",
        "output": "[['m', 'y', 'g', 'v', 'j', 'l', 'b', 'p']]"
      },
      {
        "input": "ncdpq",
        "output": "[['n', 'c', 'd', 'p', 'q']]"
      },
      {
        "input": "stopirvd",
        "output": "[['s', 't', 'o', 'p', 'i', 'r', 'v', 'd']]"
      },
      {
        "input": "oyzkeeay",
        "output": "[['o', 'y', 'z', 'k', 'e', 'e', 'a', 'y'], ['o', 'y', 'z', 'k', 'ee', 'a', 'y']]"
      },
      {
        "input": "qouc",
        "output": "[['q', 'o', 'u', 'c']]"
      },
      {
        "input": "yxdvzwdnlgktja",
        "output": "[['y', 'x', 'd', 'v', 'z', 'w', 'd', 'n', 'l', 'g', 'k', 't', 'j', 'a']]"
      },
      {
        "input": "yhgpsxzhtgnna",
        "output": "[['y', 'h', 'g', 'p', 's', 'x', 'z', 'h', 't', 'g', 'n', 'n', 'a'], ['y', 'h', 'g', 'p', 's', 'x', 'z', 'h', 't', 'g', 'nn', 'a']]"
      },
      {
        "input": "qvdpamh",
        "output": "[['q', 'v', 'd', 'p', 'a', 'm', 'h']]"
      },
      {
        "input": "whrybbzsqjzg",
        "output": "[['w', 'h', 'r', 'y', 'b', 'b', 'z', 's', 'q', 'j', 'z', 'g'], ['w', 'h', 'r', 'y', 'bb', 'z', 's', 'q', 'j', 'z', 'g']]"
      },
      {
        "input": "hogiwffcarnz",
        "output": "[['h', 'o', 'g', 'i', 'w', 'f', 'f', 'c', 'a', 'r', 'n', 'z'], ['h', 'o', 'g', 'i', 'w', 'ff', 'c', 'a', 'r', 'n', 'z']]"
      },
      {
        "input": "orwyaitmzhyjnwf",
        "output": "[['o', 'r', 'w', 'y', 'a', 'i', 't', 'm', 'z', 'h', 'y', 'j', 'n', 'w', 'f']]"
      },
      {
        "input": "iolfho",
        "output": "[['i', 'o', 'l', 'f', 'h', 'o']]"
      },
      {
        "input": "unuyvdrvewtjpdzx",
        "output": "[['u', 'n', 'u', 'y', 'v', 'd', 'r', 'v', 'e', 'w', 't', 'j', 'p', 'd', 'z', 'x'], ['unu', 'y', 'v', 'd', 'r', 'v', 'e', 'w', 't', 'j', 'p', 'd', 'z', 'x']]"
      },
      {
        "input": "c",
        "output": "[['c']]"
      },
      {
        "input": "mqx",
        "output": "[['m', 'q', 'x']]"
      },
      {
        "input": "haipfeeylpjrm",
        "output": "[['h', 'a', 'i', 'p', 'f', 'e', 'e', 'y', 'l', 'p', 'j', 'r', 'm'], ['h', 'a', 'i', 'p', 'f', 'ee', 'y', 'l', 'p', 'j', 'r', 'm']]"
      },
      {
        "input": "lrnasicsxrrv",
        "output": "[['l', 'r', 'n', 'a', 's', 'i', 'c', 's', 'x', 'r', 'r', 'v'], ['l', 'r', 'n', 'a', 's', 'i', 'c', 's', 'x', 'rr', 'v']]"
      },
      {
        "input": "ubxmnthbv",
        "output": "[['u', 'b', 'x', 'm', 'n', 't', 'h', 'b', 'v']]"
      },
      {
        "input": "gjjbjlkddki",
        "output": "[['g', 'j', 'j', 'b', 'j', 'l', 'k', 'd', 'd', 'k', 'i'], ['g', 'j', 'j', 'b', 'j', 'l', 'k', 'dd', 'k', 'i'], ['g', 'j', 'j', 'b', 'j', 'l', 'kddk', 'i'], ['g', 'j', 'jbj', 'l', 'k', 'd', 'd', 'k', 'i'], ['g', 'j', 'jbj', 'l', 'k', 'dd', 'k', 'i'], ['g', 'j', 'jbj', 'l', 'kddk', 'i'], ['g', 'jj', 'b', 'j', 'l', 'k', 'd', 'd', 'k', 'i'], ['g', 'jj', 'b', 'j', 'l', 'k', 'dd', 'k', 'i'], ['g', 'jj', 'b', 'j', 'l', 'kddk', 'i']]"
      },
      {
        "input": "vhmkjtej",
        "output": "[['v', 'h', 'm', 'k', 'j', 't', 'e', 'j']]"
      },
      {
        "input": "rn",
        "output": "[['r', 'n']]"
      },
      {
        "input": "zqrcu",
        "output": "[['z', 'q', 'r', 'c', 'u']]"
      },
      {
        "input": "mwwlcbghpn",
        "output": "[['m', 'w', 'w', 'l', 'c', 'b', 'g', 'h', 'p', 'n'], ['m', 'ww', 'l', 'c', 'b', 'g', 'h', 'p', 'n']]"
      },
      {
        "input": "dtkvaoswvtnwk",
        "output": "[['d', 't', 'k', 'v', 'a', 'o', 's', 'w', 'v', 't', 'n', 'w', 'k']]"
      },
      {
        "input": "stbrayupjd",
        "output": "[['s', 't', 'b', 'r', 'a', 'y', 'u', 'p', 'j', 'd']]"
      },
      {
        "input": "b",
        "output": "[['b']]"
      },
      {
        "input": "aqzlbqotz",
        "output": "[['a', 'q', 'z', 'l', 'b', 'q', 'o', 't', 'z']]"
      },
      {
        "input": "eyvisyyljqtl",
        "output": "[['e', 'y', 'v', 'i', 's', 'y', 'y', 'l', 'j', 'q', 't', 'l'], ['e', 'y', 'v', 'i', 's', 'yy', 'l', 'j', 'q', 't', 'l']]"
      },
      {
        "input": "hrubjncxxyfefi",
        "output": "[['h', 'r', 'u', 'b', 'j', 'n', 'c', 'x', 'x', 'y', 'f', 'e', 'f', 'i'], ['h', 'r', 'u', 'b', 'j', 'n', 'c', 'x', 'x', 'y', 'fef', 'i'], ['h', 'r', 'u', 'b', 'j', 'n', 'c', 'xx', 'y', 'f', 'e', 'f', 'i'], ['h', 'r', 'u', 'b', 'j', 'n', 'c', 'xx', 'y', 'fef', 'i']]"
      },
      {
        "input": "mlucjozkrfweadtv",
        "output": "[['m', 'l', 'u', 'c', 'j', 'o', 'z', 'k', 'r', 'f', 'w', 'e', 'a', 'd', 't', 'v']]"
      },
      {
        "input": "wufnksafzvv",
        "output": "[['w', 'u', 'f', 'n', 'k', 's', 'a', 'f', 'z', 'v', 'v'], ['w', 'u', 'f', 'n', 'k', 's', 'a', 'f', 'z', 'vv']]"
      },
      {
        "input": "hjhrbxbegbd",
        "output": "[['h', 'j', 'h', 'r', 'b', 'x', 'b', 'e', 'g', 'b', 'd'], ['h', 'j', 'h', 'r', 'bxb', 'e', 'g', 'b', 'd'], ['hjh', 'r', 'b', 'x', 'b', 'e', 'g', 'b', 'd'], ['hjh', 'r', 'bxb', 'e', 'g', 'b', 'd']]"
      },
      {
        "input": "twcfytd",
        "output": "[['t', 'w', 'c', 'f', 'y', 't', 'd']]"
      },
      {
        "input": "tgjkfz",
        "output": "[['t', 'g', 'j', 'k', 'f', 'z']]"
      },
      {
        "input": "zwlpy",
        "output": "[['z', 'w', 'l', 'p', 'y']]"
      },
      {
        "input": "tpv",
        "output": "[['t', 'p', 'v']]"
      },
      {
        "input": "qoyxcummmo",
        "output": "[['q', 'o', 'y', 'x', 'c', 'u', 'm', 'm', 'm', 'o'], ['q', 'o', 'y', 'x', 'c', 'u', 'm', 'mm', 'o'], ['q', 'o', 'y', 'x', 'c', 'u', 'mm', 'm', 'o'], ['q', 'o', 'y', 'x', 'c', 'u', 'mmm', 'o']]"
      },
      {
        "input": "y",
        "output": "[['y']]"
      },
      {
        "input": "picpmmegzbjql",
        "output": "[['p', 'i', 'c', 'p', 'm', 'm', 'e', 'g', 'z', 'b', 'j', 'q', 'l'], ['p', 'i', 'c', 'p', 'mm', 'e', 'g', 'z', 'b', 'j', 'q', 'l']]"
      },
      {
        "input": "lgophreevsk",
        "output": "[['l', 'g', 'o', 'p', 'h', 'r', 'e', 'e', 'v', 's', 'k'], ['l', 'g', 'o', 'p', 'h', 'r', 'ee', 'v', 's', 'k']]"
      },
      {
        "input": "kj",
        "output": "[['k', 'j']]"
      },
      {
        "input": "c",
        "output": "[['c']]"
      },
      {
        "input": "ddltc",
        "output": "[['d', 'd', 'l', 't', 'c'], ['dd', 'l', 't', 'c']]"
      },
      {
        "input": "ntazv",
        "output": "[['n', 't', 'a', 'z', 'v']]"
      },
      {
        "input": "cguowunkprjt",
        "output": "[['c', 'g', 'u', 'o', 'w', 'u', 'n', 'k', 'p', 'r', 'j', 't']]"
      },
      {
        "input": "owcbiztuwez",
        "output": "[['o', 'w', 'c', 'b', 'i', 'z', 't', 'u', 'w', 'e', 'z']]"
      },
      {
        "input": "vwef",
        "output": "[['v', 'w', 'e', 'f']]"
      },
      {
        "input": "gypyrnrvet",
        "output": "[['g', 'y', 'p', 'y', 'r', 'n', 'r', 'v', 'e', 't'], ['g', 'y', 'p', 'y', 'rnr', 'v', 'e', 't'], ['g', 'ypy', 'r', 'n', 'r', 'v', 'e', 't'], ['g', 'ypy', 'rnr', 'v', 'e', 't']]"
      },
      {
        "input": "xpfmrqou",
        "output": "[['x', 'p', 'f', 'm', 'r', 'q', 'o', 'u']]"
      },
      {
        "input": "uwkdfcfkvzq",
        "output": "[['u', 'w', 'k', 'd', 'f', 'c', 'f', 'k', 'v', 'z', 'q'], ['u', 'w', 'k', 'd', 'fcf', 'k', 'v', 'z', 'q']]"
      },
      {
        "input": "ycwutohjmqrwz",
        "output": "[['y', 'c', 'w', 'u', 't', 'o', 'h', 'j', 'm', 'q', 'r', 'w', 'z']]"
      },
      {
        "input": "wwh",
        "output": "[['w', 'w', 'h'], ['ww', 'h']]"
      },
      {
        "input": "gfmeeigzchx",
        "output": "[['g', 'f', 'm', 'e', 'e', 'i', 'g', 'z', 'c', 'h', 'x'], ['g', 'f', 'm', 'ee', 'i', 'g', 'z', 'c', 'h', 'x']]"
      },
      {
        "input": "wuzoacphcuuhcj",
        "output": "[['w', 'u', 'z', 'o', 'a', 'c', 'p', 'h', 'c', 'u', 'u', 'h', 'c', 'j'], ['w', 'u', 'z', 'o', 'a', 'c', 'p', 'h', 'c', 'uu', 'h', 'c', 'j']]"
      },
      {
        "input": "vvfhbwvvxihc",
        "output": "[['v', 'v', 'f', 'h', 'b', 'w', 'v', 'v', 'x', 'i', 'h', 'c'], ['v', 'v', 'f', 'h', 'b', 'w', 'vv', 'x', 'i', 'h', 'c'], ['vv', 'f', 'h', 'b', 'w', 'v', 'v', 'x', 'i', 'h', 'c'], ['vv', 'f', 'h', 'b', 'w', 'vv', 'x', 'i', 'h', 'c']]"
      },
      {
        "input": "zgolgkedadank",
        "output": "[['z', 'g', 'o', 'l', 'g', 'k', 'e', 'd', 'a', 'd', 'a', 'n', 'k'], ['z', 'g', 'o', 'l', 'g', 'k', 'e', 'd', 'ada', 'n', 'k'], ['z', 'g', 'o', 'l', 'g', 'k', 'e', 'dad', 'a', 'n', 'k']]"
      },
      {
        "input": "wejhphmduehmd",
        "output": "[['w', 'e', 'j', 'h', 'p', 'h', 'm', 'd', 'u', 'e', 'h', 'm', 'd'], ['w', 'e', 'j', 'hph', 'm', 'd', 'u', 'e', 'h', 'm', 'd']]"
      },
      {
        "input": "lppposiwdybzxy",
        "output": "[['l', 'p', 'p', 'p', 'o', 's', 'i', 'w', 'd', 'y', 'b', 'z', 'x', 'y'], ['l', 'p', 'pp', 'o', 's', 'i', 'w', 'd', 'y', 'b', 'z', 'x', 'y'], ['l', 'pp', 'p', 'o', 's', 'i', 'w', 'd', 'y', 'b', 'z', 'x', 'y'], ['l', 'ppp', 'o', 's', 'i', 'w', 'd', 'y', 'b', 'z', 'x', 'y']]"
      },
      {
        "input": "werlxj",
        "output": "[['w', 'e', 'r', 'l', 'x', 'j']]"
      },
      {
        "input": "ydcfjhtqt",
        "output": "[['y', 'd', 'c', 'f', 'j', 'h', 't', 'q', 't'], ['y', 'd', 'c', 'f', 'j', 'h', 'tqt']]"
      },
      {
        "input": "yzpm",
        "output": "[['y', 'z', 'p', 'm']]"
      },
      {
        "input": "rjfdbtiimgahytk",
        "output": "[['r', 'j', 'f', 'd', 'b', 't', 'i', 'i', 'm', 'g', 'a', 'h', 'y', 't', 'k'], ['r', 'j', 'f', 'd', 'b', 't', 'ii', 'm', 'g', 'a', 'h', 'y', 't', 'k']]"
      },
      {
        "input": "pdwicfkztihyre",
        "output": "[['p', 'd', 'w', 'i', 'c', 'f', 'k', 'z', 't', 'i', 'h', 'y', 'r', 'e']]"
      },
      {
        "input": "fmfxcuirobkkhv",
        "output": "[['f', 'm', 'f', 'x', 'c', 'u', 'i', 'r', 'o', 'b', 'k', 'k', 'h', 'v'], ['f', 'm', 'f', 'x', 'c', 'u', 'i', 'r', 'o', 'b', 'kk', 'h', 'v'], ['fmf', 'x', 'c', 'u', 'i', 'r', 'o', 'b', 'k', 'k', 'h', 'v'], ['fmf', 'x', 'c', 'u', 'i', 'r', 'o', 'b', 'kk', 'h', 'v']]"
      },
      {
        "input": "nvby",
        "output": "[['n', 'v', 'b', 'y']]"
      },
      {
        "input": "lpeji",
        "output": "[['l', 'p', 'e', 'j', 'i']]"
      },
      {
        "input": "ss",
        "output": "[['s', 's'], ['ss']]"
      },
      {
        "input": "fnbzvgupjv",
        "output": "[['f', 'n', 'b', 'z', 'v', 'g', 'u', 'p', 'j', 'v']]"
      }
    ]
  },
  {
    "question_id": 132,
    "name": "palindrome-partitioning-ii",
    "prompt": "<p>Given a string <code>s</code>, partition <code>s</code> such that every <span data-keyword=\"substring-nonempty\">substring</span> of the partition is a <span data-keyword=\"palindrome-string\">palindrome</span>.</p>\n\n<p>Return <em>the <strong>minimum</strong> cuts needed for a palindrome partitioning of</em> <code>s</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;aab&quot;\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> The palindrome partitioning [&quot;aa&quot;,&quot;b&quot;] could be produced using 1 cut.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;a&quot;\n<strong>Output:</strong> 0\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;ab&quot;\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 2000</code></li>\n\t<li><code>s</code> consists of lowercase English letters only.</li>\n</ul>\n",
    "difficulty": "Hard",
    "topics": ["string", "dynamic-programming"],
    "runtime_inefficient_codes": [
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        def is_palindrome(s):\n            return s == s[::-1]\n        \n        @lru_cache(None)\n        def f(s):\n            if not s or len(s) == 1 or is_palindrome(s):\n                return 0\n\n            min_ = float('inf')\n\n\n                \n            for j in range(len(s)):\n                if is_palindrome(s[:j+1]):\n                    min_ = min(min_, 1 + f(s[j+1:]))\n            return min_\n\n        return f(s)\n            \n",
        "runtime": "3502"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        dp={}\n        def palindromePartitioning(w,ans):\n            if w in dp:return dp[w]\n            \n            if w==w[::-1]:\n                return 0\n            \n            \n            for i in range(len(w)):\n                curr=w[:i+1]\n                \n                if curr==curr[::-1]:\n                    ans=min(ans,1+palindromePartitioning(w[i+1:],ans))\n                    dp[w]=ans\n                \n                \n            \n            \n\n            return ans\n        \n\n        return palindromePartitioning(s,len(s)-1)",
        "runtime": "3560"
      },
      {
        "code": "from functools import cache\n\n\ndef is_palindrome(s: str) -> bool:\n    return s == s[::-1]\n\n\n# See problem 131. palindrome-partitioning\n# Time: O(n * 2 ^ n), space: O(n * 2 ^ n), n = len(s)\nclass Solution:\n    @cache\n    def minCut(self, s: str) -> int:\n        if is_palindrome(s):\n            return 0\n\n        res = len(s)\n        for i in range(1, len(s)):\n            if not is_palindrome(s[:i]):\n                continue\n            suffix_result = self.minCut(s[i:])\n            res = min(res, 1 + suffix_result)\n        return res\n\n\n# class Solution:\n#     def minCut(self, s: str) -> int:\n#         return 0\n\n",
        "runtime": "3560"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        memo={}\n        def isPalindrome(s,start,e):\n            return s[start:e+1]==s[start:e+1][::-1]\n        def f(s,idx):\n            if idx==len(s):\n                return 0\n            if idx in memo:\n                return memo[idx]\n            mn=float('inf')\n            for i in range(idx,len(s)):\n                if isPalindrome(s,idx,i):\n                    mn=min(mn,1+f(s,i+1))\n            memo[idx] = mn\n            return mn\n        return f(s,0)-1\n",
        "runtime": "3617"
      },
      {
        "code": "class Solution:\n    from functools import cache\n    def minCut(self, s: str) -> int:\n        @cache        \n        def dfs(s):\n            if s==s[::-1]:\n                return 0            \n            cuts=float(\"inf\")            \n            for i in range(len(s)):\n                if s[:i+1]==s[:i+1][::-1]:\n                    cuts=min(cuts,1+dfs(s[i+1:]))            \n            return cuts        \n        return dfs(s)        ",
        "runtime": "3617"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        d={}\n\n        def isPalindrome(i,c):\n            return s[i:c+1] == s[i:c+1][::-1]\n\n        def dfs(i):\n            if i==len(s):\n                return 0\n            if i in d:\n                return d[i]\n\n            res = float('inf')\n            for c in range(i,len(s)):\n                if isPalindrome(i,c):\n                    res=min(res,dfs(c+1))\n            d[i] = res+1\n            return res+1\n        \n        return dfs(0)-1\n",
        "runtime": "3674"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        \n        n = len(s)\n\n        def isPalindrome(i,j):\n\n            return s[i:j+1] == s[i:j+1][::-1]\n        \n        dp = [-1 for _ in range(n)]\n        palindrom_dp = [[-1 for _ in range(n)] for _ in range(n)]\n        def f(i):\n            if i == n:\n                return 0\n\n            if dp[i] != -1:\n                return dp[i]\n\n            _min = float('inf')\n\n            for idx in range(i,n):\n                if isPalindrome(i,idx):\n                    cuts = 1 + f(idx+1)\n                    _min = min(_min,cuts)\n            dp[i] = _min\n            return _min\n        \n        return f(0)-1",
        "runtime": "3674"
      },
      {
        "code": "class Solution:\n    def solve(self,s,i,dp):\n        if i==len(s):\n            return 0\n        ans=float('inf')\n        if dp.get(i):\n            return dp[i]\n        for j in range(i,len(s)):\n            if s[i:j+1]==s[i:j+1][::-1]:\n                ans=min(ans,1+self.solve(s,j+1,dp))\n        dp[i]=ans\n        return ans\n    def minCut(self, s: str) -> int:\n        dp={}\n        return self.solve(s,0,dp)-1\n        ",
        "runtime": "3731"
      },
      {
        "code": "class Solution:\n    def minCut(self, s):\n        @lru_cache(None)\n        def function(s):\n            if not s:\n                return 0 \n\n            min_val = float(\"inf\")\n\n            for i in range(1,len(s)+1):\n                if s[:i] == s[:i][::-1]:\n                    min_val = min(min_val,1+function(s[i:]))\n\n            return min_val \n\n        return function(s)-1",
        "runtime": "3731"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n\n        def is_palindrome(s):\n            return s == s[::-1]\n\n        def min_cuts(s, cache):\n            if len(s) == 0 or len(s) == 1:\n                return 0\n            elif s in cache:\n                return cache[s]\n            elif is_palindrome(s):\n                cache[s] = 0\n                return 0\n\n            min_cuts_here = len(s) + 100\n            for next_cut in range(1, len(s)):\n                curr = s[:next_cut]\n                rest = s[next_cut:]\n\n                if is_palindrome(curr):\n                    min_if_cut_here = 1 + min_cuts(rest, cache)\n                    min_cuts_here = min(min_cuts_here, min_if_cut_here)\n\n            cache[s] = min_cuts_here\n            return min_cuts_here\n\n        return min_cuts(s, {})\n\n\n                \n\n        ",
        "runtime": "3788"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        dic={}\n        def partition(s: str) -> int:\n            nonlocal dic\n            if not s:\n                return []\n            if s in dic:\n                return dic[s]\n            res=len(s)\n            for i in range(len(s)):\n                if s[:i+1]==s[i::-1]:\n                    if i==len(s)-1:\n                        res=0\n                    else:\n                        res=min(res,partition(s[i+1:])+1)\n            dic[s]=res\n            return res\n        return partition(s)\n        ",
        "runtime": "3845"
      },
      {
        "code": "class Solution:\n    @cache\n    def minCut(self, s: str) -> int:\n        if not s: return -1\n        ans = inf\n        for i in range(1, len(s) + 1):\n            if s[:i] == s[:i][::-1]:\n                ans = min(ans, 1 + self.minCut(s[i:]))\n        return ans\n                \n        ",
        "runtime": "3903"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        n = len(s)\n        # Helper function to check if a string is a palindrome\n        def is_palindrome(sub: str) -> bool:\n            return sub == sub[::-1]\n        \n        # Generate all substrings\n        palindromic_substrings = set()\n        for i in range(n):\n            for j in range(i + 1, n + 1):\n                sub = s[i:j]\n                if is_palindrome(sub):\n                    palindromic_substrings.add(sub)\n        \n        # Convert set to list for easier processing\n        palindromic_substrings = list(palindromic_substrings)\n        palindromic_substrings.sort(key=len, reverse=True)  # Sort by length in descending order\n        \n        # Dynamic Programming to find the minimum cuts\n        dp = [float('inf')] * (n + 1)\n        dp[0] = -1  # No cuts needed before the first character\n        \n        for i in range(1, n + 1):\n            for sub in palindromic_substrings:\n                length = len(sub)\n                if i >= length and s[i-length:i] == sub:\n                    dp[i] = min(dp[i], dp[i-length] + 1)\n        \n        return dp[n]\n\n",
        "runtime": "3960"
      },
      {
        "code": "class Solution:\n    def __init__(self):\n        self.min_dict = {}\n\n    def minCut(self, s: str) -> int:\n        if s in self.min_dict:\n            return self.min_dict[s]\n        if len(s) == 0:\n            return -1\n        res = 20000\n        for i in range(len(s)):\n            if s[:i+1] == s[:i+1][::-1]:\n                res = min(res, 1 + self.minCut(s[i+1:]))\n            \n        self.min_dict[s] = res\n        return res",
        "runtime": "4017"
      },
      {
        "code": "class Solution:\n    def min_partition(self, idx, s, dp):\n        if idx == len(s)-1:\n            return 0\n        s_temp = s[idx:]\n        if s_temp == s_temp[::-1]:\n            return 0\n        if dp[idx]!=-1:\n            return dp[idx]\n        mini = 1e9\n        for j in range(idx, len(s)-1):\n            temp = s[idx:j+1]\n            if temp == temp[::-1]:\n                mini = min(mini, 1+self.min_partition(j+1, s, dp))\n                dp[idx] = mini\n        return dp[idx]\n\n    def minCut(self, s: str) -> int:\n        dp = [-1 for _ in range(len(s))]\n        return self.min_partition(0, s, dp)",
        "runtime": "4074"
      },
      {
        "code": "from math import inf\n\nclass Solution:\n\n    def cutIntoPalindromicStrings(self, dp, s, i, j, n):\n        \n        if j == n: \n            return 0 if s[i:j] == s[i:j][::-1] else inf\n        \n        if dp[i][j] != -1: return dp[i][j]\n\n        else:\n            cuts = inf\n            cuts = min(cuts, self.cutIntoPalindromicStrings(dp, s, i, j + 1, n))\n            if s[i:j] == s[i:j][::-1]: \n                cuts = min(cuts, 1 + self.cutIntoPalindromicStrings(dp, s, j, j+1, n))\n            dp[i][j] = cuts\n            return cuts\n\n    def minCut(self, s: str) -> int:\n\n        n = len(s)\n        dp = [[-1]*(n+1) for _ in range(n)]\n\n        return self.cutIntoPalindromicStrings(dp, s, 0, 1, n)\n\n",
        "runtime": "4303"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        is_palindrome = [[False for _ in range(len(s) + 1)] for _ in range(len(s) + 1)]\n        \n        for i in range(len(s) + 1):\n            for j in range(len(s) + 1):\n                is_palindrome[i][j] = self.is_palindrome(s[i:j])\n                \n        dp = [sys.maxsize for _ in range(len(s) + 1)]\n        \n        dp[0] = 0\n        dp[1] = 0\n        \n        for i in range(1, len(s) + 1):\n            j = i - 1\n            while j >= 0:\n                curr_s = s[j:i]\n                if is_palindrome[j][i] and j == 0:\n                    dp[i] = min(dp[i], dp[j])\n                elif is_palindrome[j][i]:\n                    dp[i] = min(dp[i], dp[j] + 1)\n                \n                j -= 1\n        \n        return dp[-1]\n\n    def is_palindrome(self, s):\n        return s == s[::-1]\n",
        "runtime": "4303"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n\n        n = len(s)\n\n        @cache\n        def isPalindrome(i, j):\n            if j < 0:\n                return False\n\n            str = s[j : i + 1]\n            rev_str = s[i : j - 1 : -1] if j > 0 else s[i::-1]\n\n            return str == rev_str\n\n        @cache\n        def getPartitions(start):\n            min_count = math.inf\n\n            if isPalindrome(n - 1, start):\n                return 0\n\n            for i in range(start + 1, n):\n                if isPalindrome(i - 1, start):\n                    min_count = min(min_count, getPartitions(i) + 1)\n\n            return min_count\n\n        return getPartitions(0)",
        "runtime": "4360"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        def palin(s):\n            return s==s[::-1]\n        def re(s,st,memo):\n            if s==len(s) or palin(s[st:]):\n                return 0\n            if st in memo:\n                return memo[st]\n            mi=float('inf')\n            for i in range(st,len(s)):\n                if palin(s[st:i+1]):\n                    mi=min(mi,re(s,i+1,memo)+1)\n            memo[st]=mi\n            return mi\n        memo={}\n        return re(s,0,memo)\n",
        "runtime": "4360"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        n = len(s)\n\n        def isPallindrome(s):\n            return s == s[::-1]\n        \n        cache = {}\n\n        for l in range(n):\n            for r in range(l + 1, n + 1):\n                cache[(l, r)] = isPallindrome(s[l:r])\n        \n        dp = [math.inf for i in range(n + 1)]\n        dp[0] = 0\n\n        for r in range(1, n + 1):\n            if cache[(0, r)]:\n                dp[r] = 0\n                continue\n            \n            for l in range(1, r):\n                if cache[(l, r)]:\n                    dp[r] = min(dp[r], dp[l] + 1)\n        return dp[-1]",
        "runtime": "4417"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        if s == s[::-1]:\n            return 0\n        \n        n = len(s)\n        memo = {}\n\n        def rec(i, j):\n            if i >= j:\n                return 0\n            if s[i:j] == s[i:j][::-1]:  # Check if the entire substring is a palindrome\n                return 0\n            if (i, j) in memo:\n                return memo[(i, j)]\n            \n            ans = float(\"inf\")\n            for k in range(i+1, j+1):\n                if s[i:k] == s[i:k][::-1]:  # Check if the current substring is a palindrome\n                    ans = min(ans, 1 + rec(k, j))  # Recursively compute for the rest\n            \n            memo[(i, j)] = ans\n            return ans\n\n        return rec(0, n)\n",
        "runtime": "4417"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n\n        @lru_cache(None)\n        def isP(i, j):\n            if i > j:\n                return False\n            if i == j or s[i:j+1] == s[i:j+1][::-1]:\n                return True\n            return False\n\n        @lru_cache(None)\n        def search(i, j):\n            res = j - i + 1\n            if isP(i, j):\n                return 1\n            for d in range(i, j):\n                if isP(i, d):\n                    res = min(res, 1+ search(d+1, j))\n            return res\n\n        return search(0, len(s)-1)-1",
        "runtime": "4475"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        def is_palindrome(s):\n            return s == s[::-1]\n\n        def helper(i, j):\n            if i >= j:\n                return 0\n            if is_palindrome(s[i:j+1]):\n                return 0\n            if t[i][j] != -1:\n                return t[i][j]\n\n            res = float(\"inf\")\n            for k in range(i, j):\n                if is_palindrome(s[i:k+1]):\n                    temp = 1 + helper(k + 1, j)\n                    res = min(res, temp)\n\n            t[i][j] = res\n            return t[i][j]\n\n        t = [[-1 for _ in range(len(s))] for _ in range(len(s))]\n        return helper(0, len(s) - 1)\n",
        "runtime": "4475"
      },
      {
        "code": "class Solution:\n    def validate_pali(self, s: str, start: int, end: int) -> bool:\n        if start>=end:\n            return True\n        elif (start, end) in self.is_valid_cache:\n            return self.is_valid_cache[(start,end)]\n        else:\n            if s[start]!=s[end]:\n                self.is_valid_cache[(start, end)] = False\n                return False\n            else:\n                res = self.validate_pali(s, start+1, end-1)\n                self.is_valid_cache[(start, end)] = res\n                return res\n            \n    def find_cut(self, s: str, start: int, end: int) -> int:\n        if start>=end:\n            return 0\n        elif (start, end) in self.min_cache:\n            return self.min_cache[(start, end)]\n        else:\n            if self.is_valid_cache[(start, end)]:\n                self.min_cache[(start, end)] = 0\n                return 0\n            else:\n                res = self.INF\n                for mid in range(start, end+1):\n                    if self.is_valid_cache[(start, mid)]:\n                        tmp = self.find_cut(s, mid+1, end)\n                        res = min(res, 1+tmp)\n                self.min_cache[(start, end)] = res\n                return res\n    \n    def minCut(self, s: str) -> int:\n        self.is_valid_cache = {}\n        for start in range(len(s)):\n            for end in range(start, len(s)):\n                if (start, end) in self.is_valid_cache:\n                    continue\n                self.is_valid_cache[(start, end)] = self.validate_pali(s, start, end)\n        \n        self.min_cache = {}\n        self.INF = 10**9\n        res = self.find_cut(s, 0, len(s)-1)\n        return res",
        "runtime": "4532"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        \n        memo1 = {}\n        def get_palindromes(s):\n            if s in memo1:\n                return memo1[s]\n            res = set()\n            for i in range(1, len(s)):\n                if s[:i] == s[:i][::-1]:\n                    res.add(s[:i])\n            # memo1[s] = res\n            return res\n\n        memo2 = {}\n        def helper(s):\n            if s in memo2:\n                return memo2[s]\n            \n            if len(s) <= 1:\n                return 0\n            \n            if s == s[::-1]:\n                return 0\n            palindromes = get_palindromes(s)\n            best = float(\"inf\")\n            for pal in palindromes:\n                suffix = s[len(pal):]\n                best = min(best, 1 + helper(suffix))\n            memo2[s] = best\n            return best\n\n        return helper(s)\n\n\n            \n",
        "runtime": "4532"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        N = len(s)\n        INF = 10 ** 20\n        dp = [INF for _ in range(N)]\n        dp[0] = 0\n\n        @cache\n        def good(x, y):\n            return s[x: y + 1] == s[x: y + 1][::-1]\n\n        for i in range(1, N):\n            dp[i] = dp[i - 1] + 1\n\n            for j in range(i - 1, -1, -1):\n                if good(j, i):\n                    dp[i] = min(dp[i], (dp[j - 1] + 1) if j > 0 else 0)\n\n        return dp[N - 1]",
        "runtime": "4589"
      }
    ],
    "runtime_moderate_codes": [
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        if s == s[::-1]:\n            return 0\n        \n        for i in range(len(s)):\n            if s[:i] == s[:i][::-1] and s[i:] == s[i:][::-1]:\n                return 1\n        \n        l=len(s)\n        x=[[0 for i  in range(l)] for j in range(l)]\n        for i in range(l):\n          for j in range(i,l):\n            st=s[i:j+1]\n            x[i][j]= (st==st[::-1])     \n        p=[0 for c in range(l)]\n        for i in range(1,l):\n          if x[0][i]:\n            p[i]=0\n          else:\n            m=float(\"inf\")\n            for j in range(i,0,-1):\n              if x[j][i]: \n                m=min(m,p[j-1])\n            p[i]=m+1\n        return p[-1]",
        "runtime": "1215"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        if s == s[::-1]:\n            return 0\n        \n        for i in range(len(s)):\n            if s[:i] == s[:i][::-1] and s[i:] == s[i:][::-1]:\n                return 1\n        \n        l=len(s)\n        x=[[0 for i  in range(l)] for j in range(l)]\n        for i in range(l):\n          for j in range(i,l):\n            st=s[i:j+1]\n            x[i][j]= (st==st[::-1])     \n        p=[0 for c in range(l)]\n        for i in range(1,l):\n          if x[0][i]:\n            p[i]=0\n          else:\n            m=float(\"inf\")\n            for j in range(i,0,-1):\n              if x[j][i]: \n                m=min(m,p[j-1])\n            p[i]=m+1\n        return p[-1]",
        "runtime": "1215"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        n = len(s)\n\n        @cache\n        def is_panlindrome(i, j): \n            if i == j: \n                return True\n            elif i + 1 == j: \n                return s[i] == s[j]\n            elif s[i] != s[j]:\n                return False\n            else:\n                return is_panlindrome(i + 1, j - 1)\n\n        @cache\n        def min_cut(i): \n            if i == -1: return -1\n            res = n - 1\n            for start in range(i + 1): \n                if is_panlindrome(start, i): \n                    res = min(res, min_cut(start - 1) + 1)\n                    if res == 0: return res\n            return res\n\n        return min_cut(n - 1)",
        "runtime": "1272"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        dic={}\n        n=len(s)\n        palindromeTable = [[False] * n for _ in range(n)]\n        for i in range(n):\n            palindromeTable[i][i] = True\n        for prefix_len in range(2, n + 1):\n            for start in range(n - prefix_len + 1):\n                end = start + prefix_len - 1\n                if s[start] == s[end]:\n                    if prefix_len == 2 or palindromeTable[start + 1][end - 1]:\n                        palindromeTable[start][end] = True\n\n        def partition(start:int,end:int) -> int:\n            nonlocal dic\n            if start>end:\n                return []\n            if (start,end) in dic:\n                return dic[(start,end)]\n            res=end-start+1\n            for i in range(start,end+1):\n                if palindromeTable[start][i]:\n                    if i==end:\n                        res=0\n                    else:\n                        res=min(res,partition(i+1,end)+1)\n            dic[(start,end)]=res\n            return res\n        return partition(0,len(s)-1)\n        ",
        "runtime": "1272"
      },
      {
        "code": "class Solution:\n    def __init__(self):\n        self.p = None\n\n    def palindrome(self, s, i, j):\n        if i > j:\n            return True\n\n        if self.p[i][j] != -1:\n            return self.p[i][j]\n\n        if i == j:\n            self.p[i][j] = True\n            self.p[j][i] = True\n        else:\n            if s[i] == s[j]:\n                self.p[i][j] = self.palindrome(s, i+1, j-1)\n            else:\n                self.p[i][j] = False\n        \n        return self.p[i][j]\n            \n    def solve(self, s, n, i, dp):\n        if i == n:\n            return 0\n        \n        if dp[i] != -1:\n            return dp[i]\n\n        if self.palindrome(s, i, n-1):\n            ans = 0\n        else:\n            ans = n - i - 1\n            temp = 0\n\n            for idx in range(i, n-1):\n                if self.palindrome(s, i, idx):\n                    temp = 1 + self.solve(s, n, idx+1, dp)\n                    ans = min(ans, temp)\n\n        dp[i] = ans\n\n        return ans\n\n    def minCut(self, s: str) -> int:\n        n = len(s)\n        # dp = [-1 for _ in range(n)]\n        # return self.solve(s, n, 0, dp)\n\n        dp = [0 for _ in range(n+1)]\n        self.p = [[-1 for _ in range(n+1)] for _ in range(n+1)]\n\n        for i in range(n-2, -1, -1):\n            if self.palindrome(s, i, n-1) == False:\n                ans = 1 + dp[i+1]\n                for idx in range(i+1, n-1):\n                    if self.palindrome(s, i, idx):\n                        temp = 1 + dp[idx+1]\n                        ans = min (ans, temp)\n                dp[i] = ans\n        \n        return dp[0]",
        "runtime": "1329"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        n = len(s)\n        memo_c = [None]*n\n        memo_p = [[None]*n for _ in range(n)]\n        \n        def helper(start, end):\n            cut = end\n            if start==end or is_p(start, end): return 0\n            if memo_c[start] is not None: return memo_c[start]\n            for i in range(start, end+1):\n                if is_p(start, i):\n                    cut = min(cut, 1+helper(i+1, end))\n            memo_c[start] = cut\n            return cut\n        \n        def is_p(start, end):\n            if start>=end: return True\n            if memo_p[start][end] is not None: return memo_p[start][end]\n            memo_p[start][end]=s[start]==s[end] and is_p(start+1, end-1)\n            return memo_p[start][end]\n        \n        return helper(0, n-1)\n                ",
        "runtime": "1329"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        n = len(s)\n\n        dp2 = [[-1]*(n+1) for _ in range(n+1)]\n\n        def isPalindrome(s, i, j):\n            if(dp2[i][j]!=-1):\n                return dp2[i][j]     \n            if(i>=j):\n                return True\n            if(s[i] == s[j-1]):\n                dp2[i][j] = isPalindrome(s, i+1, j-1)\n                return dp2[i][j]\n            else:\n                dp2[i][j] = False\n                return False\n\n\n        dp = [-1]*(n+1)\n\n        def rec(i):\n            if(i==n):\n                return 0\n            if(i>n):\n                return 10000\n\n            if(dp[i]!=-1):\n                return dp[i]\n            \n            min_cuts = 10000\n\n            for j in range(i+1, n+1):\n                if(isPalindrome(s, i, j)):\n                   \n                    min_cuts = min(min_cuts, 1+rec(j))\n\n            dp[i] = min_cuts\n            return dp[i]\n\n        return rec(0)-1\n",
        "runtime": "1386"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        n = len(s)\n        memo_c = [None]*n\n        memo_p = [[None]*n for _ in range(n)]\n        \n        def helper(start, end):\n            cut = end\n            if start==end or is_p(start, end): return 0\n            if memo_c[start] is not None: return memo_c[start]\n            \n            for i in range(start, end + 1):\n                if is_p(start, i): cut = min(cut, 1+helper(i+1, end))\n            memo_c[start] = cut\n            return cut\n\n        def is_p(start, end):\n            if start >= end: return True\n            if memo_p[start][end] is not None: return memo_p[start][end]\n            memo_p[start][end]=s[start]==s[end] and is_p(start+1, end-1)\n            return memo_p[start][end]\n        \n        return helper(0, n-1)",
        "runtime": "1386"
      },
      {
        "code": "class Solution:\n    def __init__(self):\n        self.memo_cuts = []\n        self.memo_palindrome = []\n\n    def minCut(self, s: str) -> int:\n        self.memo_cuts = [None] * len(s)\n        self.memo_palindrome = [[None] * len(s) for _ in range(len(s))]\n\n        def recur(index):\n            if index >= len(s):\n                return -1\n            if self.memo_cuts[index] is not None:\n                return self.memo_cuts[index]\n            cut = float('inf')\n            for i in range(index, len(s)):\n                if self.is_palindrome(s, index, i):\n                    cut = min(cut, recur(i + 1) + 1)\n            self.memo_cuts[index] = cut\n            return cut\n\n        return recur(0)\n\n    def is_palindrome(self, s, start, end):\n        if start >= end:\n            return True\n        if self.memo_palindrome[start][end] is not None:\n            return self.memo_palindrome[start][end]\n        self.memo_palindrome[start][end] = s[start] == s[\n            end\n        ] and self.is_palindrome(s, start + 1, end - 1)\n        return self.memo_palindrome[start][end]",
        "runtime": "1444"
      },
      {
        "code": "class Solution:\n    def __init__(self):\n        self.memo_cuts = []\n        self.memo_palindrome = []\n\n    def minCut(self, s: str) -> int:\n        self.memo_cuts = [None] * len(s)\n        self.memo_palindrome = [[None] * len(s) for _ in range(len(s))]\n        return self.find_minimum_cut(s, 0, len(s) - 1, len(s) - 1)\n\n    def find_minimum_cut(\n        self, s: str, start: int, end: int, minimum_cut: int\n    ) -> int:\n        # base case\n        if start == end or self.is_palindrome(s, start, end):\n            return 0\n        # check for results in memo_cuts\n        if self.memo_cuts[start] is not None:\n            return self.memo_cuts[start]\n        for current_end_index in range(start, end + 1):\n            if self.is_palindrome(s, start, current_end_index):\n                minimum_cut = min(\n                    minimum_cut,\n                    1\n                    + self.find_minimum_cut(\n                        s, current_end_index + 1, end, minimum_cut\n                    ),\n                )\n        self.memo_cuts[start] = minimum_cut\n        return minimum_cut\n\n    def is_palindrome(self, s: str, start: int, end: int) -> bool:\n        if start >= end:\n            return True\n        # check for results in memo_palindrome\n        if self.memo_palindrome[start][end] is not None:\n            return self.memo_palindrome[start][end]\n        self.memo_palindrome[start][end] = s[start] == s[\n            end\n        ] and self.is_palindrome(s, start + 1, end - 1)\n        return self.memo_palindrome[start][end]\n\n\n        ",
        "runtime": "1444"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        memoCuts = [[None] * len(s) for _ in range(len(s))]\n        memoPalindrome = [[None] * len(s) for _ in range(len(s))]\n\n        def isPalindrome(s, start, end):\n            if start >= end:\n                return True\n            if memoPalindrome[start][end] is not None:\n                return memoPalindrome[start][end]\n            memoPalindrome[start][end] = s[start] == s[end] and isPalindrome(s, start + 1, end - 1)\n            return memoPalindrome[start][end]\n\n        def findMinimumCut(start, end):\n            if start == end or isPalindrome(s, start, end):\n                return 0\n            if memoCuts[start][end] is not None:\n                return memoCuts[start][end]\n            minimumCut = float('inf')\n            for i in range(start, end + 1):\n                if isPalindrome(s, start, i):\n                    minimumCut = min(minimumCut, 1 + findMinimumCut(i + 1, end))\n            memoCuts[start][end] = minimumCut\n            return minimumCut\n\n        return findMinimumCut(0, len(s) - 1)\n",
        "runtime": "1501"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        self.memoCuts, self.memoPalindrome = [], []\n        self.memoCuts = [None] * len(s)\n        self.memoPalindrome = [[None] * len(s) for _ in range(len(s))]\n        return self.findMinimumCut(s, 0, len(s)-1, len(s)-1)\n    \n    def findMinimumCut(self, s, start, end, minimumCut):\n        if start==end or self.isPalindrome(s, start, end):\n            return 0\n        if self.memoCuts[start]!=None:\n            return self.memoCuts[start]\n        \n        for currentEndIndex in range(start, end+1):\n            if self.isPalindrome(s, start, currentEndIndex):\n                minimumCut = min(minimumCut, 1+self.findMinimumCut(s, currentEndIndex+1, end, minimumCut))\n        self.memoCuts[start] = minimumCut\n        return minimumCut\n    \n    def isPalindrome(self, s, start, end):\n        if start>=end: return True\n        if self.memoPalindrome[start][end]!=None:\n            return self.memoPalindrome[start][end]\n        self.memoPalindrome[start][end] = (s[start]==s[end]) and self.isPalindrome(s, start+1, end-1)\n        return self.memoPalindrome[start][end]\n                ",
        "runtime": "1501"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        n = len(s)\n        dp = [[-1 for j in range(n)] for i in range(n)]\n        t = [[-1 for j in range(n)]for i in range(n)]\n        def isPalindrome(s,i,j):\n            if i>=j :\n                return True\n            if t[i][j] != -1:\n                return t[i][j]\n            t[i][j] = s[i]==s[j] and isPalindrome(s,i+1,j-1)\n            return t[i][j]\n        def solve(s,i,j,dp):\n            if dp[i][j] != -1:\n                return dp[i][j]\n            if i>= j or isPalindrome(s,i,j):\n                return 0\n            mn = float('inf')\n            for k in range(i,j):\n                if isPalindrome(s,i,k):\n                    if dp[k+1][j] != -1:\n                        tmp = dp[k+1][j]\n                    else:\n                        tmp = solve(s,k+1,j,dp)\n                    ans = tmp + 1\n                    mn = min(ans,mn)\n            dp[i][j] = mn\n            return dp[i][j] \n        return solve(s,0,n-1,dp)\n                \n            ",
        "runtime": "1558"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        n = len(s)\n        dp1 = [[-1 for i in range(n)]for i in range(n)]\n        def isPalindrome(i,j):\n            if i>=j:\n                return True\n            if dp1[i][j]!=-1:\n                return dp1[i][j]\n            if s[i] == s[j]:\n                dp1[i][j] = isPalindrome(i+1,j-1)\n            else:\n                dp1[i][j] = False\n            return dp1[i][j]\n        for i in range(n):\n            for j in range(i,n):\n                if i == j:\n                    dp1[i][j] = True\n                else:\n                    isPalindrome(i,j)\n        dp = [-1]*(n+1)\n        dp[n] = 0\n        for i in range(n-1,-1,-1):\n            cnt = 0\n            mini = 2001\n            for j in range(i,n):\n                if dp1[i][j]:\n                    cnt = 1+dp[j+1]\n                    mini = min(mini,cnt)\n            dp[i] = mini\n        return dp[0]-1\n        ",
        "runtime": "1558"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        n = len(s)\n        isPalindrome = [[0]*n for _ in range(n)]\n        for i in range(n): \n            isPalindrome[i][i] = 1\n            if i<n-1: isPalindrome[i][i+1] = int(s[i] == s[i+1])\n        isValid = lambda nr,nc: nr>=0 and nr<n and nc>=0 and nc<n\n        for i in range(2,n):\n            row = 0\n            col = i\n            while isValid(row,col):\n                isPalindrome[row][col] = int(s[row] == s[col] and isPalindrome[row+1][col-1] == 1)\n                row += 1\n                col += 1\n\n        def f(i):\n            if i == n: return 0\n            if dp[i] != -1: return dp[i]\n            mini = float('inf')\n            for j in range(i,n):\n                if isPalindrome[i][j]:\n                    cnt = 1 + f(j+1)\n                    mini = min(mini, cnt)\n            dp[i] = mini\n            return mini\n        dp = [-1]*n\n        return f(0)-1",
        "runtime": "1615"
      },
      {
        "code": "class Solution:\n    def __init__(self):\n        self.memoCuts = []\n        self.memoPalindrome = []\n\n    def minCut(self, s: str) -> int:\n        self.memoCuts = [[None] * len(s) for _ in range(len(s))]\n        self.memoPalindrome = [[None] * len(s) for _ in range(len(s))]\n        return self.findMinimumCut(s, 0, len(s) - 1, len(s) - 1)\n\n    def findMinimumCut(self, s, start, end, minimumCut):\n        # base case\n        if start == end or self.isPalindrome(s, start, end):\n            return 0\n        # check for results in memoCuts\n        if self.memoCuts[start][end] != None:\n            return self.memoCuts[start][end]\n        for currentEndIndex in range(start, end + 1):\n            if self.isPalindrome(s, start, currentEndIndex):\n                minimumCut = min(\n                    minimumCut,\n                    1\n                    + self.findMinimumCut(\n                        s, currentEndIndex + 1, end, minimumCut\n                    ),\n                )\n        self.memoCuts[start][end] = minimumCut\n        return self.memoCuts[start][end]\n\n    def isPalindrome(self, s, start, end):\n        if start >= end:\n            return True\n        # check for results in memoPalindrome\n        if self.memoPalindrome[start][end] != None:\n            return self.memoPalindrome[start][end]\n        self.memoPalindrome[start][end] = (\n            s[start] == s[end]\n        ) and self.isPalindrome(s, start + 1, end - 1)\n        return self.memoPalindrome[start][end]",
        "runtime": "1672"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        n = len(s)\n        dp = [0 for i in range(n+1)]\n        palins = [[-1 for i in range(n+1)] for j in range(n+1)]\n        def isP(i,j):\n            nonlocal palins\n            if i >= j:\n                palins[i][j] = 1\n                return palins[i][j]\n            if palins[i][j] != -1:\n                return palins[i][j]\n\n            if s[i] != s[j]:\n                palins[i][j] = 0\n                return palins[i][j]\n            else:\n                val = isP(i+1,j-1)\n                palins[i][j] = val\n                return palins[i][j]\n\n        for i in range(n):\n            for j in range(i,n):\n                isP(i,j)\n\n\n        \n\n        def solve(i):\n            nonlocal dp\n            if i == n:\n                return 0\n            if dp[i] != -1:\n                return dp[i]\n            cuts = float('inf')\n\n            for k in range(i,n):\n                if isP(i,k):\n                    val = 1 + solve(k+1)\n                    cuts = min(cuts,val)\n                   \n            \n            dp[i] = cuts\n            return cuts\n        \n        #ans = solve(0)\n        #return ans-1\n\n        for i in range(n-1,-1,-1):\n            cuts = float('inf')\n\n            for k in range(i,n):\n                if isP(i,k):\n                   \n                    val = 1 + dp[k+1]\n                    cuts = min(cuts,val)\n                   \n            \n            dp[i] = cuts\n\n        return dp[0]-1\n\n\n        ",
        "runtime": "1730"
      },
      {
        "code": "class Solution:\n    def __init__(self):\n        self.memoCuts = []\n        self.memoPalindrome = []\n\n    def minCut(self, s: str) -> int:\n        self.memoCuts = [[None] * len(s) for _ in range(len(s))]\n        self.memoPalindrome = [[None] * len(s) for _ in range(len(s))]\n        return self.findMinimumCut(s, 0, len(s) - 1, len(s) - 1)\n\n    def findMinimumCut(self, s, start, end, minimumCut):\n        # base case\n        if start == end or self.isPalindrome(s, start, end):\n            return 0\n        # check for results in memoCuts\n        if self.memoCuts[start][end] != None:\n            return self.memoCuts[start][end]\n        for currentEndIndex in range(start, end + 1):\n            if self.isPalindrome(s, start, currentEndIndex):\n                minimumCut = min(\n                    minimumCut,\n                    1\n                    + self.findMinimumCut(\n                        s, currentEndIndex + 1, end, minimumCut\n                    ),\n                )\n        self.memoCuts[start][end] = minimumCut\n        return self.memoCuts[start][end]\n\n    def isPalindrome(self, s, start, end):\n        if start >= end:\n            return True\n        # check for results in memoPalindrome\n        if self.memoPalindrome[start][end] != None:\n            return self.memoPalindrome[start][end]\n        self.memoPalindrome[start][end] = (\n            s[start] == s[end]\n        ) and self.isPalindrome(s, start + 1, end - 1)\n        return self.memoPalindrome[start][end]",
        "runtime": "1787"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        n = len(s)\n        dp = [[-1 for j in range(n)] for i in range(n)]\n        t = [[-1 for j in range(n)]for i in range(n)]\n        def isPalindrome(s,i,j):\n            if i>=j :\n                return True\n            if t[i][j] != -1:\n                return t[i][j]\n            t[i][j] = s[i]==s[j] and isPalindrome(s,i+1,j-1)\n            return t[i][j]\n        def solve(s,i,j,dp):\n            if i>= j or isPalindrome(s,i,j):\n                return 0\n            if dp[i][j] != -1:\n                return dp[i][j]\n            mn = float('inf')\n            for k in range(i,j):\n                if isPalindrome(s,i,k):\n                    ans = solve(s,k+1,j,dp) + 1\n                    mn = min(ans,mn)\n            dp[i][j] = mn\n            return dp[i][j] \n        return solve(s,0,n-1,dp)\n                \n            ",
        "runtime": "1844"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        n = len(s)\n        dp = [[-1 for _ in range(n)] for _ in range(n)]\n        palindrome_dp = [[-1 for _ in range(n)] for _ in range(n)]\n        \n        def is_palindrome(s, i, j):\n            if i >= j:\n                return True\n            if palindrome_dp[i][j] != -1:\n                return palindrome_dp[i][j]\n            palindrome_dp[i][j] = (s[i] == s[j]) and is_palindrome(s, i + 1, j - 1)\n            return palindrome_dp[i][j]\n        \n        def solve(s, i, j, dp):\n            if i >= j or is_palindrome(s, i, j):\n                return 0\n            if dp[i][j] != -1:\n                return dp[i][j]\n            \n            mn = float('inf')\n            for k in range(i, j):\n                if is_palindrome(s, i, k):\n                    temp = 1 + solve(s, k + 1, j, dp)\n                    mn = min(mn, temp)\n            \n            dp[i][j] = mn\n            return mn\n        \n        return solve(s, 0, n - 1, dp)\n",
        "runtime": "1844"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        \n        dp = [[False for _ in range(len(s))] for _ in range(len(s))]\n        for i in range(len(s)-1,-1,-1):\n            for j in range(len(s)-1,-1,-1):\n                if (i==j) or (j - i == 1 and s[j] == s[i]) or (j-i >= 2 and s[i] == s[j] and dp[i+1][j-1]):\n                    dp[i][j] = True\n        \n        def findMin(s,l,r,compute,dp):\n            if l == r:\n                return 0\n            if (l,r) in dp:\n                return dp[(l,r)]\n            dp[(l,r)] = 1e7\n            for i in range(l,r):\n                if compute[l][i]:\n                    dp[(l,r)] = min(dp[(l,r)],1 + findMin(s,i+1,r,compute,dp))\n            dp[(l,r)] =  0 if dp[(l,r)] == 1e7 else dp[(l,r)]\n            return dp[(l,r)]\n\n\n        return findMin(s,0,len(s),dp,{}) - 1\n                \n\n",
        "runtime": "1901"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        n = len(s)\n        t = [[-1 for i in range(n)] for _ in range(n)]\n        dp = [[None for i in range(n)] for _ in range(n)]\n\n        def isPalindrome(string, i, j):\n            if i >= j:\n                return True\n            if dp[i][j] != None:\n                return dp[i][j]\n            dp[i][j] = string[i] == string[j] and isPalindrome(string, i + 1, j - 1)\n            return dp[i][j]\n\n        def solve(i, j):\n            if i >= j:\n                return 0\n            if isPalindrome(s, i, j):\n                return 0\n            if t[i][j] != -1:\n                return t[i][j]\n            t[i][j] = float(\"inf\")\n            for k in range(i, j):\n                if isPalindrome(s, i, k):\n                    t[i][j] = min(t[i][j], 1 + solve(k + 1, j))\n            return t[i][j]\n\n        return solve(0, n - 1)\n",
        "runtime": "1901"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        dp = [float('inf')] * (len(s) + 1)\n        dp[0] = 0\n        indices = defaultdict(list)\n        for i, ch in enumerate(s):\n            indices[ch].append(i)\n        for j in range(len(dp)):\n            dp[j] = min(dp[j], dp[j - 1] + 1)\n            for i in indices[s[j - 1]]:\n                if i == j: break\n                t = s[i:j]\n                if t == t[::-1]:\n                    dp[j] = min(dp[j], dp[i] + 1)\n        return dp[-1] - 1",
        "runtime": "2015"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        n = len(s)\n        dp = [[-1 for j in range(n)] for i in range(n)]\n        t = [[-1 for j in range(n)]for i in range(n)]\n        def isPalindrome(s,i,j):\n            if i>=j :\n                return True\n            if t[i][j] != -1:\n                return t[i][j]\n            t[i][j] = s[i]==s[j] and isPalindrome(s,i+1,j-1)\n            return t[i][j]\n        def solve(s,i,j,dp):\n            if i>= j or isPalindrome(s,i,j):\n                return 0\n            if dp[i][j] != -1:\n                return dp[i][j]\n            mn = float('inf')\n            for k in range(i,j):\n                if isPalindrome(s,i,k):\n                    ans = solve(s,k+1,j,dp) + 1\n                    mn = min(ans,mn)\n            dp[i][j] = mn\n            return dp[i][j] \n        return solve(s,0,n-1,dp)\n                \n            ",
        "runtime": "2015"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        n = len(s)\n        \n        @cache\n        def isPalindrome(l: int, r: int) -> bool:\n            return l >= r or (s[l] == s[r] and isPalindrome(l + 1, r - 1))\n        \n        @cache\n        def dp(l: int) -> int:\n            return 0 if l == n else min(dp(r + 1) + 1 for r in range(l, n) if isPalindrome(l, r))\n        \n        return dp(0) - 1",
        "runtime": "2073"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        @cache\n        def isPalindrome(start, end):\n            if start >= end:\n                return True\n            return s[start] == s[end] and isPalindrome(start + 1, end - 1)\n\n        @cache\n        def minNumberOfPalindromes(start, end):\n            if start == end or isPalindrome(start, end):\n                return 1\n            min_pals = math.inf\n            for i in range(start, end + 1):\n                if isPalindrome(start, i):\n                    min_pals = min(min_pals, 1 + minNumberOfPalindromes(i + 1, end))\n            return min_pals\n\n        return minNumberOfPalindromes(0, len(s) - 1) - 1\n",
        "runtime": "2073"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        @cache\n        def checkPalindrome(left , right):\n            if left>=right:\n                return True\n            if s[left] != s[right]:\n                return False\n            else:\n                return checkPalindrome(left+1,right-1)\n        @cache\n        def partition(start):\n            if start>= len(s):\n                return 0\n            else:\n                minPartitions=float(\"inf\")\n\n                for end in range(start , len(s)):\n                    if checkPalindrome(start,end):\n                        minPartitions=min(minPartitions , 1 + partition(end+1))\n                return minPartitions\n        return partition(0)-1\n        ",
        "runtime": "2244"
      },
      {
        "code": "from functools import cache\nclass Solution:\n    def minCut(self, s: str) -> int:\n\n        n = len(s)\n\n        @cache\n        def isPalindrome(i,j):\n            if i >= j:\n                return True\n            if s[i] != s[j]:\n                return False\n            return isPalindrome(i+1,j-1)\n\n        @cache\n        def func(i):\n            if i == n:\n                return -1\n            cuts = n-1\n            for idx in range(i,n):\n                if isPalindrome(i,idx):\n                    cuts = min(cuts,1+func(idx+1))\n            return cuts\n\n        return func(0)\n\n        \n\n        ",
        "runtime": "2244"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        N = len(s)\n\n        palindromes = set()\n        # precompute all palindromes in n^2\n        for i in range(len(s)):\n            # odd\n            l = r = i\n            while l >= 0 and r < N and s[l] == s[r]:\n                palindromes.add((l, r))\n                l -= 1\n                r += 1\n            \n            # even\n            l, r = i, i + 1\n            while l >= 0 and r < N and s[l] == s[r]:\n                palindromes.add((l, r))\n                l -= 1\n                r += 1\n\n        \n        cache = {}\n        def dfs(index):\n            if index >= N:\n                return -1\n            \n            if index in cache:\n                return cache[index]\n            \n            res = float('inf')\n            for end in range(index, N):\n                if (index, end) in palindromes:\n                    res = min(res, 1 + dfs(end + 1))\n            \n            cache[index] = res\n            return res\n        \n        return dfs(0)\n\n        ",
        "runtime": "2301"
      },
      {
        "code": "from functools import lru_cache\n\nclass Solution:\n    def minCut(self, s: str) -> int:\n        n = len(s)\n\n        @lru_cache(maxsize = None)\n        def isValid(left, right):\n            if left == right:\n                return True\n            if (left+1) == right:\n                return s[left] == s[right]\n            if s[left] != s[right]:\n                return False\n            return isValid(left+1, right-1)\n\n        @lru_cache(maxsize = None)\n        def helper(i):\n            if i == n:\n                return -1\n            ans = n + 1\n            for j in range(i, n):\n                if isValid(i, j):\n                    ans = min(ans, 1 + helper(j+1))\n            return ans\n\n        return helper(0)\n",
        "runtime": "2301"
      },
      {
        "code": "from functools import lru_cache\n\nclass Solution:\n    def minCut(self, s: str) -> int:\n        n = len(s)\n\n        @lru_cache(maxsize = None)\n        def isValid(left, right):\n            if left == right:\n                return True\n            if (left+1) == right:\n                return s[left] == s[right]\n            if s[left] != s[right]:\n                return False\n            return isValid(left+1, right-1)\n\n        @lru_cache(maxsize = None)\n        def helper(i):\n            if i == n:\n                return -1\n            ans = n + 1\n            for j in range(i, n):\n                if isValid(i, j):\n                    ans = min(ans, 1 + helper(j+1))\n            return ans\n\n        return helper(0)\n",
        "runtime": "2359"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        @cache\n        def checkPalindrome(left , right):\n            if left>=right:\n                return True\n            if s[left] != s[right]:\n                return False\n            else:\n                return checkPalindrome(left+1,right-1)\n        @cache\n        def partition(start):\n            if start>= len(s):\n                return 0\n            else:\n                minPartitions=float(\"inf\")\n\n                for end in range(start , len(s)):\n                    if checkPalindrome(start,end):\n                        minPartitions=min(minPartitions , 1 + partition(end+1))\n                return minPartitions\n        return partition(0)-1\n        ",
        "runtime": "2359"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        # def ispalindrome(word):\n        #     i=0\n        #     j=len(word)-1\n        #     while i<=j:\n        #         if word[i]!=word[j]:\n        #             return False\n        #         i+=1\n        #         j-=1\n        #     return True\n        # dp={}\n        # def solve(i):\n        #     if i>=len(s):\n        #         return 0\n        #     if i in dp:\n        #         return dp[i]\n        #     if ispalindrome(s[i:]):\n                \n        #         return 0\n        #     ans=float('inf')\n        #     for k in range(i+1,len(s)):\n        #         if s[i:k]==s[i:k][::-1]:\n        #             ans=min(ans,1+solve(k))\n        #     dp[i]=ans\n        #     return ans\n        # return solve(0)\n        n=len(s)\n        dp=[float('inf')]*(n+1)\n        dp[n]=0\n        for idx in range(n-1,-1,-1):\n            if s[idx:]==s[idx:][::-1]:\n                dp[idx]=0\n                continue\n            for i in range(idx+1,n):\n                cut=s[idx:i]\n                if cut==cut[::-1]:\n                    dp[idx]=min(dp[idx],1+dp[i])\n        return dp[0]\n\n        ",
        "runtime": "2473"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        def is_palin(string):\n            return string == string[::-1]\n\n        n = len(s)\n        @cache\n        def dfs(i):\n            if is_palin(s[i:]):\n                return 0\n            return 1 + min(dfs(k) for k in range(i+1, n) if is_palin(s[i:k]))\n        return dfs(0) ",
        "runtime": "2530"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        def is_palin(string):\n            return string == string[::-1]\n\n        n = len(s)\n        @cache\n        def dfs(i):\n            if is_palin(s[i:]):\n                return 0\n            return 1 + min(dfs(k) for k in range(i+1, n) if is_palin(s[i:k]))\n        return dfs(0)  ",
        "runtime": "2587"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        def is_palin(string):\n            return string == string[::-1]\n\n        n = len(s)\n        @cache\n        def dfs(i):\n            if is_palin(s[i:]):\n                return 0\n            return 1 + min(dfs(k) for k in range(i+1, n) if is_palin(s[i:k]))\n        return dfs(0)  \n        \n\n        ",
        "runtime": "2645"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        def is_palin(string):\n            return string == string[::-1]\n\n        n = len(s)\n        @cache\n        def dfs(i):\n            if is_palin(s[i:]):\n                return 0\n            return 1 + min(dfs(k) for k in range(i+1, n) if is_palin(s[i:k]))\n        ans = dfs(0)\n        dfs.cache_clear()\n        return ans       \n        \n\n        ",
        "runtime": "2645"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        n = len(s)\n\n        # We'll check our string from left to right recursively.\n\n        # We'll try to find palindromes in left substrings, and then\n        # recursively check the right substrings.\n        \n        @cache\n        def dfs(idx):\n            if idx >= n:\n                # We've covered the whole string,\n                # No more partitions needed\n                return 0\n\n            # If the whole substring is a palindrome,\n            # Dont divide further and return 0\n            if s[idx:] == s[idx:][::-1]:\n                return 0\n\n            # Base return case, in case we couldnt find a palindrome\n            a = float(\"inf\")\n\n            # Cut the string from idx to all i from idx+1 to n\n            for i in range(idx+1, n):\n\n                # Get the left part of the substring\n                cut = s[idx:i]\n\n                # Check if the left part is a palindrome\n                if cut == cut[::-1]:\n\n                    # Add 1 to partitions and recursively\n                    # check right substring further\n                    a = min(a, 1 + dfs(i))\n\n            # Return partitions found\n            return a\n\n        # Base call to check string from index 0\n        return dfs(0)\n        ",
        "runtime": "2702"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        return sol(s)\nfrom functools import cache\ndef sol(s):\n    @cache\n    def rf(i):\n        s1=s[i:]\n        if s1==s1[::-1]:\n            return 0\n        tmp=10_000\n        for k in range(1,len(s1)+1):\n            s2=s1[:k]\n            if s2==s2[::-1]:\n                tmp=min(tmp,rf(k+i))\n        return 1+tmp\n    return rf(0)\n\n",
        "runtime": "2759"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        @cache\n        def backtrack(i: int):\n            if i >= len(s):\n                return 0\n\n            if s[i:] == s[i:][::-1]:\n                return 0\n\n            cuts = inf\n            for j in range(i+1, len(s)):\n                cut = s[i:j]\n                if cut == cut[::-1]:\n                    current = 1 + backtrack(j)\n                    cuts = min(current, cuts)\n\n            return cuts\n\n        return backtrack(0)",
        "runtime": "2759"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        n=len(s)\n        dp=[-1]*(n+1)\n        dp[n]=0\n        for i in range(n-1,-1,-1):\n            temp=''\n            mini=maxsize\n            for j in range(i,n):\n                temp+=s[j]\n                if temp==temp[-1::-1]:\n                    cuts=1+dp[j+1]\n                    mini=min(mini,cuts)\n            dp[i]=mini\n        return dp[0]-1",
        "runtime": "2816"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        n = len(s)\n        def f(i, dp):\n            if i == n: return 0\n            if dp[i] != -1: return dp[i]\n            mini = float(\"inf\")\n            temp = \"\"\n            for k in range(i,n):\n                temp += s[k]\n                if temp == temp[::-1]:\n                    mini = min(mini, 1 + f(k+1, dp))\n            dp[i] = mini\n            return mini\n        \n        dp = [-1 for _ in range(n+1)]\n        # return f(0, dp) - 1\n        dp[n] = 0\n        for i in range(n-1,-1,-1):\n            mini = float(\"inf\")\n            temp = \"\"\n            for k in range(i,n):\n                temp += s[k]\n                if temp == temp[::-1]:\n                    mini = min(mini, 1 + dp[k+1])\n            dp[i] = mini\n        return dp[0] - 1",
        "runtime": "2816"
      },
      {
        "code": "from functools import cache\n\n\ndef is_palindrome(s: str) -> bool:\n    return s == s[::-1]\n\n\n# Similar to 131. TLE\nclass Solution0:\n    def minCut(self, s: str) -> int:\n        def _min_cut(start: int) -> int:\n            if is_palindrome(s[start:]):\n                return 0\n            res = float(\"inf\")\n            for i in range(start + 1, len(s) + 1):\n                prefix = s[start:i]\n                if not is_palindrome(prefix):\n                    continue\n                res = min(res, 1 + _min_cut(i))\n            return res\n\n        return _min_cut(0)\n\n# Use cache to speed up -> Top-down DP\nclass Solution:\n    def minCut(self, s: str) -> int:\n        @cache\n        def _min_cut(start: int) -> int:\n            if is_palindrome(s[start:]):\n                return 0\n            res = float(\"inf\")\n            for i in range(start + 1, len(s) + 1):\n                prefix = s[start:i]\n                if not is_palindrome(prefix):\n                    continue\n                res = min(res, 1 + _min_cut(i))\n            return res\n\n        return _min_cut(0)\n\n\n# See problem 131. palindrome-partitioning\n# Time: O(n * 2 ^ n), space: O(n * 2 ^ n), n = len(s)\nclass Solution1:\n    @cache\n    def minCut(self, s: str) -> int:\n        if is_palindrome(s):\n            return 0\n\n        res = len(s)\n        for i in range(1, len(s)):\n            if not is_palindrome(s[:i]):\n                continue\n            suffix_result = self.minCut(s[i:])\n            res = min(res, 1 + suffix_result)\n        return res\n\n\n# class Solution:\n#     def minCut(self, s: str) -> int:\n#         return 0\n\n",
        "runtime": "2873"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        INF = float('inf')\n        n = len(s)\n        dp = [INF] * (n+1)\n        \n        dp[-1] = 0\n        for i in range(n):\n            for j in range(i+1)[::-1]:\n                t = s[j:i+1]\n                if t == t[::-1]:\n                    dp[i] = min(dp[i], 1 + dp[j-1])\n                \n        return dp[n-1]-1",
        "runtime": "2873"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        \n        @cache\n        def f(i):\n            if i >= len(s):\n                return 0\n\n            best = math.inf\n\n            for j in range(i + 1, len(s) + 1):\n                sub = s[i: j]\n                if sub == sub[::-1]:\n                    best = min(best, 1 + f(j))\n\n            return best\n        \n        return f(0) - 1\n",
        "runtime": "2930"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n\n        n = len(s)\n\n        @cache\n        def dfs(i):\n            if s[i:]==s[i:][::-1]:\n                return 0\n            \n            res = math.inf\n            for j in range(i + 1, n):\n                if s[i:j] == s[i:j][::-1]:\n                    res = min(res, 1 + dfs(j))\n            return res\n        \n        return dfs(0)\n\n        ",
        "runtime": "2930"
      },
      {
        "code": "class Solution:\n    def f(self,i,n,s,dp):\n        if i==n:\n            return 0\n        if dp[i]!=-1: return dp[i]\n        mini = float('inf')\n        temp=\"\"\n        for k in range(i,n):\n            temp+=s[k]\n            if temp==temp[::-1]: \n                cost = 1 + self.f(k+1,n,s,dp)\n                mini = min(cost,mini)\n        \n        dp[i]=mini\n        return mini\n\n    def minCut(self, s: str) -> int:\n        n = len(s)\n        dp = [-1]*n\n        return self.f(0,n,s,dp)-1\n        ",
        "runtime": "2988"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        n = len(s)\n        # dp1 = [[-1 for i in range(n)]for i in range(n)]\n        def isPalindrome(s):\n        #     if i>=j:\n        #         return True\n        #     if dp1[i][j]!=-1:\n        #         return dp1[i][j]\n        #     if s[i] == s[j]:\n        #         dp1[i][j] = isPalindrome(i+1,j-1)\n        #     else:\n        #         dp1[i][j] = False\n        #     return dp1[i][j]\n        # for i in range(n):\n        #     for j in range(i,n):\n        #         if i == j:\n        #             dp1[i][j] = True\n        #         else:\n        #             isPalindrome(i,j)\n            return s == s[::-1]\n        dp = [-1]*(n+1)\n        dp[n] = 0\n        for i in range(n-1,-1,-1):\n            cnt = 0\n            mini = 2001\n            for j in range(i,n):\n                if isPalindrome(s[i:j+1]):\n                    cnt = 1+dp[j+1]\n                    mini = min(mini,cnt)\n            dp[i] = mini\n        return dp[0]-1\n        ",
        "runtime": "2988"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        def isPalin(t):\n            return t == t[::-1]\n        if isPalin(s):return 0\n        dp = [0]* (len(s)+1)\n        for i in range(len(s)-1,-1,-1):\n            minicut = float(\"inf\")\n            for j in range(i,len(s)):\n                if isPalin(s[i:j+1]):\n                    minicut = min(minicut,1+dp[j+1])\n            dp[i]= minicut if minicut != float(\"inf\") else 0\n        return dp[0]-1",
        "runtime": "3045"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        def dfs(ind):\n            if ind == n:\n                return 0\n            if dp[ind] != -1: return dp[ind]\n            mn = sys.maxsize\n            for i in range(ind, n):\n                w = s[ind:i+1]\n                if w == w[::-1]:\n                    cost = 1 + dfs(i+1)\n                    mn = min(mn, cost)\n            dp[ind] = mn\n            return dp[ind]\n        n = len(s)\n        dp = [-1] * n\n        return dfs(0) - 1\n",
        "runtime": "3045"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        n=len(s)\n        dp=[0 ]*(n+1)\n        for i in range(n-1,-1,-1):\n            mini=float('inf')\n            for k in range(i,n):\n                if s[i:k+1]==s[i:k+1][::-1]:\n                    mini=min(mini,1+dp[k+1])\n            dp[i]= mini\n        return dp[0]-1",
        "runtime": "3102"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        length = len(s)\n        memo = {}\n\n        def dfs(curr):\n            if curr == length:\n                return 0\n\n            if curr in memo:\n                return memo[curr]\n\n            word = ''\n            min_cut = length\n            for i in range(curr, length):\n                word = word + s[i]\n                if word == word[::-1]:\n                    min_cut = min(min_cut, dfs(i+1))\n\n            memo[curr] = 1 + min_cut\n            return 1 + min_cut\n\n        return dfs(0) - 1\n            \n        ",
        "runtime": "3102"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        n = len(s)\n        dp = [0] * (n + 1)\n        dp[n] = 0\n        for i in range(n - 1, -1, -1):\n            min_cost = float('inf')\n            # Iterate over possible substrings starting from index i\n            for j in range(i, n):\n                if s[i:j+1]==s[i:j+1][::-1]:\n                    # If s[i...j] is a palindrome, calculate the cost\n                    min_cost = min(min_cost, 1 + dp[j + 1])\n            dp[i] = min_cost\n\n        return dp[0] - 1",
        "runtime": "3159"
      },
      {
        "code": "class Solution:\n\n    def isPalin(self, s: str) -> bool:\n        return s[::-1] == s\n\n    def minCut(self, s: str) -> int:\n        n = len(s)\n        dp = [-1 for itr in range(n)]\n        def solve(i):\n            if i == n:\n                return 0\n            if dp[i] != -1:\n                return dp[i]\n            min_cuts = int(1e9)\n            for j in range(i, n):\n                if(self.isPalin(s[i:j+1])):\n                    min_cuts = min(min_cuts, 1 + solve(j+1))\n            \n            dp[i] = min_cuts\n            return dp[i]\n        \n        return solve(0)-1\n",
        "runtime": "3159"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        \n        def isPalindrome(string: str) -> bool:\n            return string == string[::-1]\n        \n        def compute(i: int,dp) -> int:\n            if i == len(s):\n                return 0\n\n            if dp[i] != -1:\n                return dp[i]\n            \n            minCuts = float('inf')\n            for j in range(i, len(s)):\n                if isPalindrome(s[i:j+1]):\n                    cuts = 1 + compute(j + 1,dp)\n                    minCuts = min(minCuts, cuts)\n            dp[i] = minCuts\n            return dp[i]\n        \n        n = len(s)\n\n        dp = [-1]*n\n        return compute(0,dp) - 1",
        "runtime": "3216"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        dp = [0 for i in range(len(s) + 1)]\n        for i in range(len(s) - 1, -1, -1):\n            ans = float(\"inf\")\n            for ind in range(i, len(s)):\n                if s[i : ind + 1] == s[i : ind + 1][::-1]:\n                    tmp = 1 + dp[ind + 1]\n                    ans = min(ans, tmp)\n            dp[i] = ans\n        return dp[0] - 1\n",
        "runtime": "3216"
      },
      {
        "code": "class Solution:\n\n    def minCut(self, s: str) -> int:\n        memo = {}\n        n = len(s)\n        def isPalindrome(s):\n            return s[::-1] == s \n        def solve(i,n):\n            if i == n:\n                memo[i] =-1\n                return -1\n            cuts = 100000000\n            if i in memo:\n                return memo[i]\n            for pi in range(i,n):\n                if isPalindrome(s[i:pi+1]):\n                    cuts =min(cuts, 1 + solve(pi+1,n))\n            memo[i] = cuts\n            return cuts\n        return solve(0,n)\n\n\n        ",
        "runtime": "3274"
      },
      {
        "code": "\n\nclass Solution:\n    def minCut(self, s: str) -> int:\n        \n        def isPalindrome(input_str:str) -> bool:\n            return input_str == input_str[::-1]\n        \n        n = len(s)\n        check_palindrome = [[False for _ in range(n)] for _ in range(n)]\n\n        #check_palindrome to check whether substing s[i..j] is palindrome or not\n        for i in range(n):\n            for j in range(i,n):\n                check_palindrome[i][j] = isPalindrome(s[i:j+1])\n        \n        dp = [3000 for _ in range(n)]\n        for i in range(n-1,-1,-1):\n            if check_palindrome[i][n-1] == True: dp[i]= 0\n            for j in range(i, n - 1):\n                if check_palindrome[i][j] == True:\n                    dp[i]= min(dp[i], dp[j+1] + 1)\n        \n        return dp[0]",
        "runtime": "3274"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        # start = 0\n        # \n        # dp = [-1 for i in range(len(s))]\n        # res = self.solve(s, start, dp)\n        # return res - 1\n\n        #need to do tabulation\n        #need to do top down approach\n        palindrome_dp = [[-1 for j in range(len(s))] for i in range(len(s))]\n        dp = [0 for i in range(len(s) + 1)]\n\n        for i in range(len(s) - 1, -1, -1):\n            cut = float('inf')\n            for j in range(i, len(s)):\n                if self.checkPalindrome(i, j, s, palindrome_dp):\n                    cost = 1 + dp[j + 1]\n                    cut = min(cut, cost)\n            dp[i] = cut\n        \n        return dp[0] - 1\n\n    def solve(self, s, start, dp):\n        #base case\n        if start == len(s):\n            return 0\n        \n        if dp[start] != -1:\n            return dp[start]\n\n        cut = float('inf')\n        \n        for i in range(start, len(s)):\n            if self.checkPalindrome(start, i, s):\n                \n                temp = 1 + self.solve(s, i + 1, dp)\n                cut = min(cut, temp)\n\n        dp[start] = cut\n        return dp[start]\n\n    def checkPalindrome(self, i, j, s, palindrome_dp):\n        subs = s[i: j + 1]\n        return subs == subs[::-1]",
        "runtime": "3331"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        if s==s[::-1]:\n            return 0\n        n = len(s)\n        # i = 0\n        # cut = 0\n        # while i < n:\n        #     maxi = 1\n        #     l = 1\n        #     for j in range(i+1, n):\n        #         if s[i:j+1] == s[i:j+1][::-1]:\n        #             if j - i + 1 > maxi :\n        #                 maxi = j -i +1\n        #                 l = j -i +1\n        #     cut += 1\n        #     i += l\n        # return cut-1\n\n        dp = [-1 for _ in range(n)]\n        def fun(i):\n\n            if i == n:\n                return 0\n            if dp[i] != -1:\n                return dp[i]\n            way = 1e9\n            for j in range(i,n):\n                if s[i:j+1] == s[i:j+1][::-1]:\n                    way =min(way, 1 + fun(j+1))\n            dp[i] = way\n            return way\n\n        return fun(0) - 1\n\n        ",
        "runtime": "3331"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        n = len(s)\n\n        \n\n        cache = {}\n\n        def dfs(index):\n            if index == n:\n                return -1\n\n            if index in cache:\n                return cache[index]\n\n            ans = float('inf')\n\n            for i in range(index + 1, n + 1):\n                if s[index:i] == s[index:i][::-1]:\n                    ans = min(ans, 1 + dfs(i))\n\n            cache[index] = ans\n            \n            return ans\n\n        return dfs(0)",
        "runtime": "3388"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n\n        # if len(s) == 1:\n        #     return 0\n\n\n        def isPali(s):\n            return s == s[::-1]\n        @cache\n\n        \n        def func(i):\n            if i>= len(s):\n                return 0\n            res = len(s)\n            for k in range(i,len(s)):\n                if isPali(s[i:k+1]):\n                    temp =1 +  func(k+1)\n                res = min(res,temp)\n\n\n            return res\n            \n\n            \n            \n        return func(0)-1",
        "runtime": "3388"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        def is_palindrome(s):\n            return s == s[::-1]\n        \n        @lru_cache(None)\n        def f(s):\n            # Find all palindromic partitions.\n            # Stop at each, and recursively call f on rest of the string\n            # MIN over all 1 + f(remaining)\n\n            if not s:\n                return 0\n\n            if len(s) == 1:\n                return 0\n\n            if is_palindrome(s):\n                return 0\n\n            min_ = float('inf')\n\n            for j in range(len(s)):\n                if is_palindrome(s[:j+1]):\n                    min_ = min(min_, 1 + f(s[j+1:]))\n\n            return min_\n\n        return f(s)\n            \n",
        "runtime": "3445"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        # return self.recursive_partition(s,0,len(s)-1)\n        dp = [[None for _ in range(len(s))] for _ in range(len(s))]\n        return self.memoization_partition_optimise(s, 0, len(s)-1, dp)\n\n    def __is_palindrome(self,text:str, start:int, end:int) -> bool:\n        word = text[start:end+1]\n        return word == word[::-1]\n        \n    def recursive_partition(self, text:str, start:int, end:int) -> int:\n        if start >= end:\n            return 0\n        if self.__is_palindrome(text,start,end):\n            return 0\n        \n        minimum = float('inf')\n        for k in range(start, end):\n            temp = self.recursive_partition(text,start, k) + self.recursive_partition(text, k+1, end) + 1\n            minimum = min(minimum, temp)\n        return minimum\n        \n    def memoization_partition(self, text: str, start: int, end: int, dp) -> int:\n        if start >= end:\n            return 0\n        if dp[start][end] is not None:\n            return dp[start][end]\n        if self.__is_palindrome(text, start, end):\n            return 0\n        minimum = float('inf')\n        for k in range(start, end):\n            temp = self.memoization_partition(text, start, k, dp) + self.memoization_partition(text, k + 1, end, dp) + 1\n            minimum = min(minimum, temp)\n        dp[start][end] = minimum\n        return dp[start][end]\n\n    def memoization_partition_optimise(self, text: str, start: int, end: int, dp) -> int:\n        if start >= end:\n            return 0\n        if dp[start][end] is not None:\n            return dp[start][end]\n        if self.__is_palindrome(text, start, end):\n            return 0\n        minimum = float('inf')\n        for k in range(start, end):\n            if self.__is_palindrome(text, start, k):\n                temp = self.memoization_partition_optimise(text, k + 1, end, dp) + 1\n                minimum = min(minimum, temp)\n        dp[start][end] = minimum\n        return dp[start][end]",
        "runtime": "3445"
      }
    ],
    "runtime_efficient_codes": [
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        if s == s[::-1]:\n            return 0\n        for index in range(1, len(s)):\n            if s[:index] == s[:index][::-1] and s[index:] == s[index:][::-1]:\n                return 1\n        min_cuts = [cuts for cuts in range(-1, len(s))]\n        for center in range(len(s)):\n            odd = even = 0\n            while center - odd >= 0 and center + odd < len(s) and s[center - odd] == s[center + odd]:\n                min_cuts[center + odd + 1] = min(min_cuts[center + odd + 1], min_cuts[center - odd] + 1)\n                odd += 1\n\n            while center - even >= 0 and center + even + 1 < len(s) and s[center - even] == s[center + even + 1]:\n                min_cuts[center + even + 2] = min(min_cuts[center + even + 2], min_cuts[center - even] + 1)\n                even += 1\n        return min_cuts[-1]",
        "runtime": "71"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        if s == s[::-1]:\n            return 0\n        \n        for i in range(len(s)):\n           if s[:i] == s[:i][::-1] and s[i:] == s[i:][::-1]:\n               return 1\n        \n        N = len(s)\n        N2 = 2 * N + 1\n        s2 = \"#\" + \"#\".join(s) + \"#\"\n        pd = [0] * N2\n\n        right = mid = 0\n        for i in range(1, N2):\n            if i <= right:\n                pd[i] = pd[mid - (i - mid)]\n                if pd[i] + i > right:\n                    pd[i] = right\n\n            if i + pd[i] >= right:\n                while right + 1 < N2 and s2[right + 1] == s2[i - (right + 1 - i)]:\n                    right += 1\n                pd[i] = right - i\n                mid = i\n\n        segments = []\n        for i in range(1, N2):\n            if pd[i] > 1:\n                segments.append([(i - pd[i]) // 2, pd[i]])\n\n        dp = list(range(N + 1))\n        for st, length in segments:\n            st2 = st\n            k = st + length\n            while k > st2 - 1:\n                if dp[k] > dp[st2] + 1:\n                    dp[k] = dp[st2] + 1\n                k -= 1\n                st2 += 1\n\n            ed = st + length\n            for k in range(st + 1, N + 1):\n                if dp[k] > dp[k - 1] + 1:\n                    dp[k] = dp[k - 1] + 1\n                elif k > ed:\n                    break\n\n        return dp[-1] - 1\n",
        "runtime": "71"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        if s == s[::-1]:\n            return 0\n        \n        for i in range(len(s)):\n           if s[:i] == s[:i][::-1] and s[i:] == s[i:][::-1]:\n               return 1\n        \n        def isPalindrome(l, r, s):\n            while l < r:\n                if s[l] != s[r]:\n                    return False\n                l += 1\n                r -= 1\n            return True\n            \n        n = len(s)\n        dp = [0] * (n + 1)\n        dp[n] = 0\n        for i in range(n-1, -1, -1):\n            min_cost = float('inf')\n            for j in range(i, n):\n                if isPalindrome(i, j, s):\n                    cost = 1 + dp[j + 1]\n                    min_cost = min(min_cost, cost)\n            dp[i] = min_cost\n\n        return dp[0] - 1",
        "runtime": "128"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        isPalind, dp = [True], list(range(len(s))) + [-1]\n        for i in range(len(s)):\n            isPalind.append(True)\n            for j in range(i+1):\n                isPalind[j] = isPalind[j+1] and (s[i] == s[j]) \n                if isPalind[j] and dp[j-1]+1 < dp[i]:\n                    dp[i] = dp[j-1]+1\n        return dp[-2]",
        "runtime": "243"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        n = len(s)\n        isPalind, dp = [True]*(n+1), list(range(n)) + [-1]\n        for i in range(n):\n            for j in range(i+1):\n                isPalind[j] = isPalind[j+1] and (s[i] == s[j]) \n                if isPalind[j] and dp[j-1]+1 < dp[i]:\n                    dp[i] = dp[j-1]+1\n        return dp[-2]",
        "runtime": "357"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        isPalind, dp = [True], list(range(len(s))) + [-1]\n        for i in range(len(s)):\n            isPalind.append(True)\n            for j in range(i+1):\n                isPalind[j] = (s[i] == s[j]) and isPalind[j+1]\n                if isPalind[j] and dp[j-1]+1 < dp[i]:\n                    dp[i] = dp[j-1]+1\n        return dp[-2]",
        "runtime": "414"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        n = len(s)\n        def findPals(i):\n            # find palindromes starting at i\n            for j in range(n-i-1,-1,-1):\n                for k in range(j//2+1):\n                    if s[i+k] != s[i+j-k]:\n                        break\n                else:\n                    yield s[i:i+j+1]\n\n        @cache\n        def helper(i):\n            # determines minimum number of slices necessary for s[i:]\n            if i == n-1:\n                return 0\n            if i == n:\n                return -1\n            pals = findPals(i)\n            best = n+1\n            for p in pals:\n                x = helper(i+len(p))\n                best = min(best, x)\n                if x<= 0:\n                    break\n\n            return best+1\n\n        return helper(0)",
        "runtime": "414"
      },
      {
        "code": "class Solution:\n    def minCut(self, S):\n        N = len(S)\n        dp = [-1] + [N] * N\n        for i in range(2 * N - 1):\n            l = i // 2\n            r = l + (i & 1)\n            while 0 <= l and r < N and S[l] == S[r]:\n                dp[r + 1] = min(dp[r + 1], dp[l] + 1)\n                l -= 1\n                r += 1\n        return dp[-1]",
        "runtime": "471"
      },
      {
        "code": "class Solution:\n    def minCut(self, S):\n        N = len(S)\n        dp = [-1] + [N] * N\n        for i in range(2 * N - 1):\n            l = i // 2\n            r = l + (i & 1)\n            while 0 <= l and r < N and S[l] == S[r]:\n                dp[r + 1] = min(dp[r + 1], dp[l] + 1)\n                l -= 1\n                r += 1\n        return dp[-1]",
        "runtime": "471"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        n = len(s)\n\n        dp = list(range(-1, n))\n\n        for i in range(n):\n            self.expand_around_center(s, i, i, dp)\n            self.expand_around_center(s, i, i+1, dp)\n\n        return dp[n]\n\n    def expand_around_center(self, s: str, left: int, right: int, dp: List[int]):\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            dp[right+1] = min(dp[right+1], dp[left] + 1)\n            left -= 1\n            right += 1",
        "runtime": "529"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        def palindrome(s,i,j):\n            while i<j:\n                if s[i]!=s[j]:\n                    return False\n                i+=1\n                j-=1\n            return True\n        \n        n = len(s)\n        dp = [i-1 for i in range(n+1)]\n        \n        def help(i,dp):\n            if i==n:\n                return 0\n            if dp[i]!=-1:\n                return dp[i]\n            ans = float(\"inf\")\n            for j in range(i,n):\n                if palindrome(s,i,j):\n                    cost = 1+help(j+1,dp)\n                    ans = min(ans,cost)\n            dp[i] = ans\n            return dp[i]\n\n        for i in range(n):\n            j=0\n            while i-j>=0 and i+j<n and s[i-j]==s[i+j]:\n                dp[i+j+1] =min(dp[i+j+1], 1+dp[i-j])\n                j+=1\n            \n            j=1\n            while i-j+1>=0 and i+j<n and s[i-j+1]==s[i+j]:\n                dp[i+j+1] = min(dp[i+j+1], 1+dp[i-j+1])\n                j+=1\n        return dp[n]\n",
        "runtime": "586"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        n=len(s)\n        dp=[[0]*n for x in range(n)]\n        for i in range(n-1):\n            dp[i+1][i]=1\n        for i in range(n):\n            dp[i][i]=1\n        for d in range(1,n):\n            for i in range(n-d):\n                j=i+d\n                if s[i]==s[j]:\n                    dp[i][j]=dp[i+1][j-1]\n        ans=[100000]*n\n        for i in range(n):\n            if dp[0][i]==1:\n                ans[i]=0\n            else:\n                for j in range(0,i):\n                    if dp[j+1][i]==1:\n                        ans[i]=min(ans[i],ans[j]+1)    \n        return ans[n-1]        \n",
        "runtime": "586"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        n = len(s)\n        \n        # Early exit for edge case\n        if n == 0:\n            return 0\n\n        # Precompute palindrome information\n        is_palindrome = [[False] * n for _ in range(n)]\n        for i in range(n):\n            is_palindrome[i][i] = True\n        for length in range(2, n + 1):\n            for start in range(n - length + 1):\n                end = start + length - 1\n                if s[start] == s[end]:\n                    if length == 2 or is_palindrome[start + 1][end - 1]:\n                        is_palindrome[start][end] = True\n\n        # Initialize the dp array where dp[i] represents the minimum cuts needed for s[0:i+1]\n        dp = [float('inf')] * n\n        for i in range(n):\n            if is_palindrome[0][i]:\n                dp[i] = 0  # No cuts needed if s[0:i+1] is a palindrome\n            else:\n                for j in range(i):\n                    if is_palindrome[j + 1][i]:\n                        dp[i] = min(dp[i], dp[j] + 1)\n\n        return dp[-1]",
        "runtime": "643"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        n = len(s)\n        \n        # Step 1: Precompute palindrome_dp table\n        palindrome_dp = [[False] * n for _ in range(n)]\n        \n        for i in range(n):\n            palindrome_dp[i][i] = True  # Single characters are palindromes\n\n        for i in range(n - 1):\n            palindrome_dp[i][i + 1] = (s[i] == s[i + 1])  # Two-character substrings\n\n        for length in range(3, n + 1):  # Substrings of length 3 or more\n            for i in range(n - length + 1):\n                j = i + length - 1\n                palindrome_dp[i][j] = (s[i] == s[j] and palindrome_dp[i + 1][j - 1])\n\n        # Step 2: Use dynamic programming to calculate minimum cuts\n        dp = [i for i in range(n)]  # Initialize with worst case (cut between each character)\n        \n        for i in range(n):\n            if palindrome_dp[0][i]:  # If the whole substring s[0:i+1] is a palindrome\n                dp[i] = 0\n            else:\n                for j in range(i):\n                    if palindrome_dp[j + 1][i]:  # If s[j+1:i+1] is a palindrome\n                        dp[i] = min(dp[i], dp[j] + 1)\n\n        return dp[n - 1]\n",
        "runtime": "643"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        n = len(s)\n        is_palindrome = [[False] * n for _ in range(n)]\n        for i in range(n):\n            is_palindrome[i][i] = True \n        for length in range(2, n + 1): \n            for i in range(n - length + 1):\n                j = i + length - 1\n                if length == 2:\n                    is_palindrome[i][j] = (s[i] == s[j])\n                else:\n                    is_palindrome[i][j] = (s[i] == s[j] and is_palindrome[i + 1][j - 1])\n        dp = [float('inf')] * n\n        for i in range(n):\n            if is_palindrome[0][i]:\n                dp[i] = 0\n            else:\n                for j in range(i):\n                    if is_palindrome[j + 1][i]:\n                        dp[i] = min(dp[i], dp[j] + 1)\n        return dp[-1]\n",
        "runtime": "700"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        n = len(s)\n        # Initialize DP array where dp[i] is min cuts for s[0..i]\n        dp = [0] * n\n        for i in range(n):\n            dp[i] = i  # maximum cuts\n        \n        # Create a table to store palindrome information\n        palindrome = [[False]*n for _ in range(n)]\n        \n        for i in range(n):\n            for j in range(i+1):\n                # Check if s[j..i] is a palindrome\n                if s[j] == s[i] and (i - j <= 2 or palindrome[j+1][i-1]):\n                    palindrome[j][i] = True\n                    # If the entire substring s[0..i] is a palindrome, no cut needed\n                    if j == 0:\n                        dp[i] = 0\n                    else:\n                        # Update the minimum cuts\n                        dp[i] = min(dp[i], dp[j-1] + 1)\n        \n        return dp[-1]\n",
        "runtime": "757"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        n = len(s)\n        min_i = 0\n        cut = [0] * n\n        p = [[False for _ in range(n)] for _ in range(n)] \n\n        for i in range(len(s)):\n            min_i = i\n            for j in range(i+1):\n                if s[j] == s[i] and (i - j < 3 or p[j+1][i-1]):\n                    p[j][i] = True\n                    min_i = 0 if j == 0 else min(min_i, cut[j-1] + 1)\n            cut[i] = min_i\n        \n        return cut[n-1]\n        ",
        "runtime": "815"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        \n        @cache\n        def dp(s, e):\n            if is_pal[s][e]:\n                return 0\n            \n            ans = math.inf\n            for i in range(s, e):\n                if is_pal[s][i]:\n                    ans = min(ans, 1 + dp(i + 1, e))\n            \n            return ans\n\n\n        n = len(s)\n        is_pal = [[False] * n for _ in range(n)]\n\n        for i in range(n - 1, -1, -1):\n            for j in range(i, n):\n                if s[i] == s[j]:\n                    is_pal[i][j] = j - i <= 2 or is_pal[i + 1][j - 1]\n        \n        return dp(0, n - 1)\n\n# class Solution:\n#     def minCut(self, s: str) -> int:\n        \n#         # n = len(s)\n#         # is_pal = [[False] * n for _ in range(n)]\n\n#         # for i in range(n - 1, -1, -1):\n#         #     for j in range(i, n):\n#         #         if s[i] == s[j]:\n#         #             is_pal[i][j] = j - i <= 2 or is_pal[i + 1][j - 1]\n        \n#         @cache\n#         def is_palindrome(l, r):\n#             if l >= r: return True\n#             if s[l] != s[r]: return False\n#             return is_palindrome(l + 1, r - 1)\n\n        \n#         @cache\n#         def f(i):\n#             if i >= len(s):\n#                 return 0\n\n#             best = math.inf\n\n#             for j in range(i, len(s)):\n#                 if is_palindrome(i, j):\n#                     best = min(best, 1 + f(j + 1))\n\n#             return best\n        \n#         return f(0) - 1\n\n# class Solution:\n#     def minCut(self, s: str) -> int:\n\n#         # n = len(s)\n#         # is_pal = [[False] * n for _ in range(n)]\n\n#         # for i in range(n - 1, -1, -1):\n#         #     for j in range(i, n):\n#         #         if s[i] == s[j]:\n#         #             is_pal[i][j] = j - i <= 2 or is_pal[i + 1][j - 1]\n        \n#         @cache\n#         def is_palindrome(l, r):\n#             if l >= r: return True\n#             if s[l] != s[r]: return False\n#             return is_palindrome(l + 1, r - 1)\n        \n#         @cache\n#         def f(l, r):\n#             if is_palindrome(l, r):\n#                 return 0\n            \n#             result = math.inf\n            \n#             for i in range(l, r):\n#                 res = 1 + f(l, i) + f(i + 1, r)\n#                 result = min(result, res)\n#             return result\n            \n#         return f(0, len(s) - 1)",
        "runtime": "872"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        \n        @cache\n        def dp(s, e):\n            if is_pal[s][e]:\n                return 0\n            \n            ans = math.inf\n            for i in range(s, e):\n                if is_pal[s][i]:\n                    ans = min(ans, 1 + dp(i + 1, e))\n            \n            return ans\n\n\n        n = len(s)\n        is_pal = [[False] * n for _ in range(n)]\n\n        for i in range(n - 1, -1, -1):\n            for j in range(i, n):\n                if s[i] == s[j]:\n                    is_pal[i][j] = j - i <= 2 or is_pal[i + 1][j - 1]\n        \n        return dp(0, n - 1)\n",
        "runtime": "872"
      },
      {
        "code": "class Solution:\n    def minCut(self, s):\n        d, n = defaultdict(set), len(s)\n        \n        def helper(i, j):\n            while i >= 0 and j < n and s[i] == s[j]:\n                d[i].add(j)\n                i, j = i - 1, j + 1\n        \n        for k in range(n):\n            helper(k, k)\n            helper(k, k + 1)\n\n        @lru_cache(None)\n        def dp(i):\n            if i == -1: return -1\n            return min([dp(k-1) + 1 for k in range(0, i+1) if i in d[k]])\n        \n        return dp(n-1)",
        "runtime": "929"
      },
      {
        "code": "from functools import lru_cache\n\nclass Solution:\n    def minCut(self, s: str) -> int:\n        n = len(s)\n\n        dp = [[False] * n for _ in range(n)]\n\n        for right in range(n):\n            for left in range(right + 1):\n                if s[left] == s[right] and (right - left <= 2 or dp[left + 1][right - 1]):\n                    dp[left][right] = True\n        \n        @lru_cache(maxsize=None)\n        def helper(i):\n            if i == n:\n                return -1\n            ans = n+1\n            for j in range(i, n):\n                if dp[i][j]:\n                    ans = min(ans, 1 + helper(j + 1))\n            return ans\n\n        return helper(0)\n",
        "runtime": "929"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        dp_cuts = [float('+inf') for _ in range(len(s) + 1)]\n        dp_cuts[0], dp_cuts[1] = - 1, 0\n        dp_lens = [[1 if i == j else 0 for j in range(len(s))] for i in range(len(s))]\n        for i in range(1, len(s)):\n            for j in range(0, i - 1):\n                if s[i] == s[j] and dp_lens[i-1][j+1]:\n                    dp_lens[i][j] = dp_lens[i-1][j+1] + 2\n                    dp_cuts[i+1] = min(dp_cuts[i+1], dp_cuts[i+1 - dp_lens[i][j]] + 1)\n\n            if s[i] == s[i-1]:\n                dp_lens[i][i - 1] = 2\n                dp_cuts[i+1] = min(dp_cuts[i+1], dp_cuts[i+1 - dp_lens[i][i-1]] + 1)\n            dp_cuts[i+1] = min(dp_cuts[i+1], dp_cuts[i] + 1)\n\n        return dp_cuts[-1]\n\n\n",
        "runtime": "986"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        dp = [len(s)] * len(s)\n        dp[0] = 0\n        n = len(s)\n        palin = [[0]*n for _ in range(len(s))]\n        for L in range(1, n+1):\n            for i in range(0, n-L+1):\n                j = i + L -1\n                palin[i][j] = L == 1 or s[i] == s[j] and (L==2 or palin[i+1][j-1])\n        \n        for i in range(len(s)):\n            for j in range(i+1):\n                if palin[j][i]:\n                    if j == 0:\n                        dp[i] = 0\n                    else:\n                        dp[i] = min(dp[i], 1 + dp[j-1])\n        return dp[-1]",
        "runtime": "986"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        n = len(s)\n        if s == s[::-1]: return 0\n        for i in range(1, len(s)):\n            if s[:i] == s[:i][::-1] and s[i:] == s[i:][::-1]:\n                return 1\n\n        dp = [inf for _ in range(n+1)]\n        dp[0] = -1\n\n        for i in range(n):\n            for j in range(i+1):\n                s_ = s[j:i+1]\n                if s_ == s_[::-1]:\n                    dp[i+1] = min(dp[i+1], dp[j]+1)\n        return dp[-1]\n\n        # @cache\n        # def dfs(i):\n        #     if i == n:\n        #         return 0\n            \n        #     res = inf\n        #     for j in range(i, n):\n        #         s_ = s[i:j+1]\n        #         if s_ == s_[::-1]:\n        #             res = min(res, dfs(j+1)+1)\n\n        #     return res\n        \n        # return dfs(0) - 1",
        "runtime": "1043"
      },
      {
        "code": "from functools import lru_cache\n\nclass Solution:\n    def minCut(self, s: str) -> int:\n        n = len(s)\n    \n        palindrome = [[False] * n for _ in range(n)]\n        for i in range(n):\n            palindrome[i][i] = True  \n        for length in range(2, n + 1):\n            for i in range(n - length + 1):\n                j = i + length - 1\n                if length == 2:\n                    palindrome[i][j] = (s[i] == s[j])\n                else:\n                    palindrome[i][j] = (s[i] == s[j] and palindrome[i+1][j-1])\n\n        @lru_cache(None)\n        def backtrack(i):\n            if i == n:\n                return 0\n            mini = float('inf')\n            for j in range(i, n):\n                if palindrome[i][j]:\n                    mini = min(mini, 1 + backtrack(j + 1))\n            return mini\n        \n        return backtrack(0) - 1  \n\n",
        "runtime": "1043"
      },
      {
        "code": "class Solution:\n    # def minCut(self, s: str) -> int:\n    #     n = len(s)\n    #     i, j = 0, n-1\n\n    #     dp = [-1] * (n+1)\n\n    #     def isPalindrome(s: str, i: int, j: int) -> bool:\n    #         while i < j:\n    #             if s[i] != s[j]:\n    #                 return False\n    #             i += 1\n    #             j -= 1\n    #         return True\n        \n    #     def solve(s: str, i: int, j: int) -> int:\n    #         if i >= j or isPalindrome(s, i, j):\n    #             return 0\n\n    #         if dp[i] != -1:\n    #             return dp[i]\n\n    #         ans = float('inf')\n\n    #         for k in range(i, j):\n    #             if isPalindrome(s, i, k):\n    #                 temp = solve(s, k + 1, j) + 1\n    #                 ans = min(ans, temp)\n\n    #         dp[i] = ans\n    #         return dp[i]\n        \n    #     return solve(s, i, j)\n        \n    #     # dp = [[-1] * (n+1) for _ in range(n+1)]\n    #     # def solve(s, i, j):\n    #     #     res = float('inf')\n    #     #     if i >= j or s[i:j+1] == s[i:j+1][::-1]:\n    #     #         return 0\n\n    #     #     if dp[i] != -1:\n    #     #         return dp[i]\n\n    #     #     # for k in range(i, j):\n    #     #     #     if dp[i][k] != -1:\n    #     #     #         left = dp[i][k]\n    #     #     #     else:\n    #     #     #         left = solve(s, i, k)\n    #     #     #         dp[i][k] = left\n                \n    #     #     #     if dp[k+1][j] != -1:\n    #     #     #         right = dp[k+1][j]\n    #     #     #     else:\n    #     #     #         right = solve(s, k+1, j)\n    #     #     #         dp[k+1][j] = right\n                \n    #     #     #     temp_ans = 1 + left + right\n    #     #     #     res = min(res, temp_ans)\n    #     #     #     dp[i][j] = res\n\n    #     #     for k in range(i, j):\n    #     #         if s[i:k] == s[i:k][::-1]:\n    #     #             temp_ans = solve(s, k+1, j) + 1\n    #     #             res = min(res, temp_ans)\n    #     #             dp[i] = res\n    #     #     return dp[i]\n    #     # return solve(s, i, j)\n\n    def minCut(self, s: str) -> int:\n        n = len(s)\n\n        # DP to store if a substring is a palindrome\n        palindrome_dp = [[False] * n for _ in range(n)]\n        dp = [-1] * (n + 1)\n\n        # Precompute palindrome substrings\n        for i in range(n):\n            palindrome_dp[i][i] = True  # Single character is always a palindrome\n        for length in range(2, n + 1):\n            for i in range(n - length + 1):\n                j = i + length - 1\n                if length == 2:\n                    palindrome_dp[i][j] = (s[i] == s[j])\n                else:\n                    palindrome_dp[i][j] = (s[i] == s[j] and palindrome_dp[i + 1][j - 1])\n\n        # Recursive function with memoization\n        def solve(i: int) -> int:\n            if i == n:\n                return 0\n            if dp[i] != -1:\n                return dp[i]\n\n            ans = float('inf')\n            for k in range(i, n):\n                if palindrome_dp[i][k]:  # Only make a cut if the left part is a palindrome\n                    ans = min(ans, 1 + solve(k + 1))\n\n            dp[i] = ans\n            return dp[i]\n\n        return solve(0) - 1",
        "runtime": "1100"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        n = len(s)\n        dp = [[False]*n for _ in range(n)]\n        cuts = [-1]*n\n\n        for i in range(n):\n            dp[i][i] = True\n        \n        for length in range(2, n+1):\n            for i in range(n-length+1):\n                j = i+length-1\n                if length == 2:\n                    dp[i][j] = (s[i] == s[j])\n                else:\n                    dp[i][j] = (s[i] == s[j] and dp[i+1][j-1])\n        \n        def dfs(i):\n            if i >= n:\n                return 0\n            \n            if cuts[i] != -1:\n                return cuts[i]\n            \n            res = float('inf')\n            for j in range(i, n):\n                if dp[i][j]:\n                    res = min(res, 1+dfs(j+1))\n            cuts[i] = res\n            return cuts[i]\n        \n        return dfs(0)-1",
        "runtime": "1100"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        n=len(s)\n        pdp=[[True if i==j else False for j in range(n)] for i in range(n)]\n        for i in range(n-1):\n            if s[i]==s[i+1]:\n                pdp[i][i+1]=True\n        for i in range(n-3,-1,-1):\n            for j in range(i+2,n):\n                if s[i]==s[j]:\n                    pdp[i][j]=pdp[i+1][j-1]\n                else:\n                    pdp[i][j]=False\n        def mem(i):\n            if i==len(s):\n                return 0\n            if dp[i]!=-1:\n                return dp[i]\n            cost=float(\"inf\")\n            for p in range(i,len(s)):\n                if pdp[i][p]:\n                    cost=min(cost,1+mem(p+1))\n            dp[i]=cost\n            return cost\n        dp=[-1 for _ in range(n)]\n        return mem(0)-1",
        "runtime": "1158"
      },
      {
        "code": "class Solution:\n \n    def minCutHelper(self, i, j , nums, dp, is_palindrome):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        \n        if is_palindrome[i][j]:\n            dp[i][j] = 0\n            return 0\n\n        min_cut = float('inf')\n        for k in range(i, j):\n            if is_palindrome[i][k]:\n                min_cut = min(min_cut, 1 + self.minCutHelper(k+1, j, nums, dp, is_palindrome))\n    \n        dp[i][j] = min_cut\n        return dp[i][j]\n\n    def minCut(self, s: str) -> int:\n        i = 0\n        j = len(s)-1\n\n        n = len(s)\n        is_palindrome = [[False] * n for _ in range(n)]\n        \n        for i in range(n):\n            is_palindrome[i][i] = True  \n        \n        for length in range(2, n + 1):  \n            for i in range(n - length + 1):\n                j = i + length - 1\n                if s[i] == s[j]:\n                    if length == 2 or is_palindrome[i + 1][j - 1]:\n                        is_palindrome[i][j] = True\n\n        dp = [[-1 for i in range(len(s))] for j in range(len(s))]\n        return self.minCutHelper(i, j , s, dp, is_palindrome)\n\n        ",
        "runtime": "1158"
      }
    ],
    "memory_inefficient_codes": [
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        pals = set()\n        for i in range(len(s)):\n            l, r = i, i\n            while l>=0 and r<len(s):\n                if s[l] != s[r]:\n                    break\n                pals.add((l, r))\n                l -= 1\n                r += 1\n            l, r = i, i+1\n            while l>=0 and r<len(s):\n                if s[l] != s[r]:\n                    break\n                pals.add((l, r))\n                l -= 1\n                r += 1\n\n        if (0, len(s)-1) in pals:\n            return 0\n        # dp = set()\n        # for i in range(len(s)):\n        #     if (i, len(s)-1) in pals:\n        #         dp.add(i)\n\n        # for split in range(1, len(s)):\n        #     ndp = set()\n        #     for i in range(len(s)-split):\n        #         for j in range(i, len(s)):\n        #             if (i, j) in pals and (j+1) in dp:\n        #                 ndp.add(i)\n        #                 if i == 0:\n        #                     return split\n        #                 break\n        #     dp = ndp\n        # return -1\n        check = collections.defaultdict(lambda:math.inf)\n        for i in range(len(s)-1, -1, -1):\n            for j in range(i, len(s)):\n                if (i, j) in pals:\n                    if j == len(s) - 1:\n                        check[i] = 0\n                    else:\n                        check[i] = min(check[i], 1 + check[(j+1)])\n        return check[0]\n\n\n                \n\n        \n'''\n    dp      : {(2,2)}\n\n               i\n               j\n    s       : aab\n    check   : {2:0, 1:1}\n\n\n  for split in rnage(1, len(s)):\n        ndp = set()\n        for i in range(len(s)-split):\n            for j in range(i, len(s)):\n                if (i, j) in pals and (j+1, s) in dp:\n                    ndp.add((i, j))\n                    if i == 0:\n                        return split\n           i\n           j\n          012\n    s   : aab\n        a a b\n\n    pals    : {aa, a, b}\n\n    <split is 0>\n    (0,s=0)     : aab x\n    (1,s=0)     : ab  x\n    (2,s=0)     : b \n    dp      : {2}\n\n    \n    <split is 1>\n    (0, s=1)    : aa, b\n\n\n\n    for split in rnage(1, len(s)):\n        ndp = set()\n        for i in range(len(s)-split):\n            for j in range(i, len(s)):\n                if (i, j) in pals and (j+1, s) in dp:\n                    ndp.add((i, j))\n                    if i == 0:\n                        return split\n    \n\n\n\n\n\n    \n    012\n    aab\n\n    <gap 0>\n    (0,0)   : 0\n    (1,1)   : 0\n    (2,2)   : 0\n\n    <gap 1>\n    (0,1)   : 0\n    (1,2)   : 1\n\n    <gap 2>\n    (0,2)   : 1\n\n\n\n    for g in range(len(s)):\n        for i in range(len(s)-g):\n            j = i + g\n            if s[i] == s[j]:\n                dp[(i,j)] = min(dp[(i,j)], dp[(i+1,j-1)])\n                dp[(i,j)] = min(dp[(i,j)], dp[(i+1,j)]+1)\n\n\n1. Problem\n    - Given a string s\n    - partition s such that every substring of the partition is palindrome\n    - minimum cuts needed for a palindrome partioning of s\n    \n2. TCs\n    tc1)\n    s       : aab\n    res     : aa / b => 1\n\n    tc2)\n    s       : a\n    res     : 0\n\n    tc2)\n    s       : ab\n    res     : a / b => -1\n\n    tc4)\n    s       : baab\n    res     : 0\n\n    tc5)\n    s       : aa\n    res     : 0\n\n    tc6)\n    s       : aba\n    res     : 0\n\n    tc7)\n    s       : abca\n    res     : 3\n\n3. Brain Storming\n          i\n        d(aab)\n        /               \\\n    <d(a)+d(ab)>        <d(aa)+d(b)>\n      /\n    \n\n    if len(s) == 1:\n        return 0\n    if s is pal??\n        return 0\n    res = math.inf\n    for i in range(1, len(s)):\n        res = min(res, 1 + dfs(s[:i]) + dfs(s[i:]))\n    \n    012\n    aab\n    \n    <gap is 0>\n    (0,0)   : a : 0\n    (1,1)   : a : 0\n    (2,2)   : b : 0\n\n    <gap is 1>\n    (0,1)   : aa : 0\n    (1,2)   : ab : 1\n\n    <gap is 2>\n    (0,2)   : aab : 1\n\n    for g in range(len(s)):\n        for i in range(len(s)-g):\n            j = i + g\n            if s[i] == s[j]:\n                dp[(i,j)] = min(dp[(i,j)], dp[(i+1,j-1)])\n                dp[(i,j)] = min(dp[(i,j)], dp[(i+1,j)]+1)\n    \n\n\n\n\n'''",
        "memory": "340428"
      },
      {
        "code": "class Solution:\n    def minCut(self, s):\n        d = set()\n        l = [-1]\n        for i in range(len(s)):\n            d.add((i, i))\n            temp = l[i]\n            for j in range(i):\n                if (j + 1, i) in d and s[i] == s[j]:\n                    d.add((j, i + 1)) #*4/4\n                    temp = min(temp, l[j])\n            d.add((i, i + 1))\n            l.append(temp + 1)\n        return l[-1]",
        "memory": "347251"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        cache = {}\n        for i in range(2*len(s)):\n            l = i//2\n            r = l+i%2\n            while l>=0 and r<len(s) and s[l]==s[r]:\n                cache[(l, r)]=0\n                l-=1\n                r+=1\n        dp = list(range(len(s)))\n        for i in range(len(s)):\n            if (0, i) in cache:\n                dp[i] = 0\n            else:\n                for j in range(i):\n                    if (j+1, i) in cache:\n                        dp[i] = min(dp[i], dp[j]+1)\n        return dp[len(s)-1]",
        "memory": "360899"
      },
      {
        "code": "class Solution:\n    def minCut(self, string: str) -> int:\n        # return Solution.get_min_cuts_front_partition(\n        #     string=string,\n        #     start_index=0,\n        #     end_index=len(string) - 1,\n        #     min_partition_cache=dict()\n        # )\n\n        # def get_min_cuts_front_partition(string: str, start_index: int, end_index: int, min_partition_cache: Dict[int, int]) -> int:\n        \n        #     if start_index in min_partition_cache:\n        #         return min_partition_cache.get(start_index)\n\n        #     if start_index >= end_index or is_palindrome(string[start_index: end_index+1]):\n        #         min_partition_cache[start_index] = 0\n        #         return 0\n\n        #     min_partitions: Union[float, int] = float('inf')\n        #     partition_index: int\n        #     for partition_index in range(start_index, end_index+1):\n        #         if is_palindrome(string=string[start_index: partition_index+1]):\n        #             min_partitions = min(\n        #                 min_partitions,\n        #                 1 + get_min_cuts_front_partition(\n        #                     string=string,\n        #                     start_index=partition_index+1,\n        #                     end_index=end_index,\n        #                     min_partition_cache=min_partition_cache\n        #                 )\n        #             )\n        #     min_partition_cache[start_index] = min_partitions if min_partitions != float('inf') else 0\n        #     return min_partition_cache.get(start_index)\n\n    \n        def get_min_cuts_front_partition_dp(string: str, palindrome_cache: Dict[Tuple[int, int], bool]) -> int:\n\n            min_partition_cache: List[Union[float, int]] = [float('inf')] * len(string)\n            if palindrome_cache.get((0, len(string)-1)):\n                return 0\n            \n            end_index: int = len(string) - 1\n            start_index: int\n            for start_index in range(end_index, -1, -1):\n                \n                if start_index == end_index or palindrome_cache.get((start_index, end_index)):\n                    min_partition_cache[start_index] = 0\n                else:\n                    partition_index: int\n                    for partition_index in range(start_index, end_index+1):\n                        if palindrome_cache.get((start_index, partition_index)):\n                            min_partition_cache[start_index] = min(min_partition_cache[start_index], 1 + min_partition_cache[partition_index + 1])\n                        \n            return min_partition_cache[0]\n\n        \n        def generate_palindrome_cache(string: str) -> Dict[Tuple[int, int], bool]:\n            palindrome_cache: Dict[Tuple[int, int], bool] = dict()\n            for substring_start in range(len(string)):\n                for substring_end in range(substring_start, len(string)):\n                    palindrome_cache[(substring_start, substring_end)] = is_palindrome(\n                        string=string, \n                        start_index=substring_start,\n                        end_index=substring_end, \n                        palindrome_cache=palindrome_cache\n                    )\n            \n            return palindrome_cache\n\n        \n        def is_palindrome(string: str, start_index: int, end_index: int, palindrome_cache: Dict[Tuple[int, int], bool]) -> bool:\n            curr_start_index: int = start_index\n            curr_end_index: int = end_index\n            \n            palindrome_flag: bool = True\n\n            # The Loop will break due to either of the 3 reasons:\n            # 1. The current Subarray is already found in Cache. So, curr_start_index < curr_end_index\n            # 2. No Subarray of the Current Subarray is present in Cache\n            # 2.1 There is a mismatch of characters at the curr_start_index and curr_end_index. So, here as well curr_start_index < curr_end_index\n            # 2.2 The string is Palindrome and curr_start_index has surpassed curr_end_index. So, curr_start_index > curr_end_index\n\n            while curr_start_index <= curr_end_index and string[curr_start_index] == string[curr_end_index] and (curr_start_index, curr_end_index) not in palindrome_cache:\n                curr_start_index += 1\n                curr_end_index -= 1\n\n            # If we are working on finding if string[2: 10] is palindrome or not, and we discover a character mismtach at\n            # curr_start_index = 4, and curr_end_index = 8, we are sure that the string[4 -> 8], string[3 -> 9], string[2 -> 10] are all Not Palindrome\n            \n            # Similarly, instead if we found (4, 8) in the Palindrome Cache, we can also set the Palindrome Status of \n            # string[4 -> 8], string[3 -> 9], string[2 -> 10] to PalindromeCache.get((4, 8))\n\n            # A different scenario could be, the curr_start_index, surpassed curr_end_index indicating the entire (2, 10) sub-string is palindrome. In that case, we\n            # can also set Substrings (3, 9), (4, 8), (5, 7), and (6, 6) to be Palindrome\n\n            # So, to implement this, post breakage of the loop, we just need to run a reverse traversal, ie. curr_start_index moves left and curr_end_index moves right,\n            # setting the Palindrome Status of these substrings\n\n            if curr_start_index < curr_end_index:\n                if (curr_start_index, curr_end_index) in palindrome_cache:\n                    palindrome_flag = palindrome_cache.get((curr_start_index, curr_end_index))\n                    # Since the Loop has been broken because a Subarray was found in Cache, PalindromeCache[(curr_start_index, curr_end_index)] is already present in cache\n                    # So, we start filling Palindrome Status from (StartIndex <----- curr_start_index-1, curr_end_index+1 -----> EndIndex)\n                    curr_start_index -= 1\n                    curr_end_index += 1\n                else:\n                    # Since, Loop broke due to Character mismatch, we have to fill Palindrome Status \n                    # from (StartIndex <----- curr_start_index, curr_end_index -----> EndIndex)\n                    palindrome_flag = False\n\n            else:\n                # Since, Loop broke due to curr_start_index surpassed curr_end_index, we have to bring curr_start_index and curr_end_index to a valid state and\n                # fill Palindrome Status from (StartIndex <----- curr_start_index-1, curr_end_index+1 -----> EndIndex)\n                palindrome_flag = True\n                curr_start_index -= 1\n                curr_end_index += 1\n\n            # Palindrome Status Filling\n            while curr_start_index >= start_index and curr_end_index <= end_index:\n                palindrome_cache[(curr_start_index, curr_end_index)] = palindrome_flag\n                curr_start_index -= 1\n                curr_end_index += 1\n\n            return palindrome_flag\n\n        return get_min_cuts_front_partition_dp(string=string, palindrome_cache=generate_palindrome_cache(string=string))\n",
        "memory": "374546"
      },
      {
        "code": "class Solution:\n    def validate_pali(self, s: str, start: int, end: int) -> bool:\n        if start>=end:\n            return True\n        elif (start, end) in self.is_valid_cache:\n            return self.is_valid_cache[(start,end)]\n        else:\n            if s[start]!=s[end]:\n                self.is_valid_cache[(start, end)] = False\n                return False\n            else:\n                res = self.validate_pali(s, start+1, end-1)\n                self.is_valid_cache[(start, end)] = res\n                return res\n            \n    def find_cut(self, s: str, start: int, end: int) -> int:\n        if start>=end:\n            return 0\n        elif (start, end) in self.min_cache:\n            return self.min_cache[(start, end)]\n        else:\n            if self.is_valid_cache[(start, end)]:\n                self.min_cache[(start, end)] = 0\n                return 0\n            else:\n                res = self.INF\n                for mid in range(start, end+1):\n                    if self.is_valid_cache[(start, mid)]:\n                        tmp = self.find_cut(s, mid+1, end)\n                        res = min(res, 1+tmp)\n                self.min_cache[(start, end)] = res\n                return res\n    \n    def minCut(self, s: str) -> int:\n        self.is_valid_cache = {}\n        for start in range(len(s)):\n            for end in range(start, len(s)):\n                if (start, end) in self.is_valid_cache:\n                    continue\n                self.is_valid_cache[(start, end)] = self.validate_pali(s, start, end)\n        \n        self.min_cache = {}\n        self.INF = 10**9\n        res = self.find_cut(s, 0, len(s)-1)\n        return res",
        "memory": "374546"
      },
      {
        "code": "mem=[-1 for x in range(2000)]\nclass Solution:\n    def minCut(self, s: str) -> int:  \n        ps=set()\n        def chp(i,j):\n            if i==j:return 1\n            return (i,j) in ps\n        for c in range(len(s)):\n            mem[c]=-1\n            i=c\n            j=c\n            while i>=0 and j<len(s):\n                if s[i]!=s[j]:break\n                ps.add((i,j))\n                i-=1\n                j+=1\n            i=c\n            j=c+1\n            while i>=0 and j<len(s):\n                if s[i]!=s[j]:break\n                ps.add((i,j))\n                i-=1\n                j+=1\n                \n        \n        def dp(i):\n            if i>=len(s):return 0\n            if mem[i]!=-1:return mem[i]\n            if chp(i,len(s)-1):return 0\n            a=1<<30\n            for nx in range(i+1,len(s)):\n                if not chp(i,nx-1):continue\n                a=min(a,1+dp(nx))\n            mem[i]=a\n            return a\n        return dp(0)",
        "memory": "381370"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        N = len(s)\n\n        palindromes = set()\n        # precompute all palindromes in n^2\n        for i in range(len(s)):\n            # odd\n            l = r = i\n            while l >= 0 and r < N and s[l] == s[r]:\n                palindromes.add((l, r))\n                l -= 1\n                r += 1\n            \n            # even\n            l, r = i, i + 1\n            while l >= 0 and r < N and s[l] == s[r]:\n                palindromes.add((l, r))\n                l -= 1\n                r += 1\n\n        \n        cache = {}\n        def dfs(index):\n            if index >= N:\n                return -1\n            \n            if index in cache:\n                return cache[index]\n            \n            res = float('inf')\n            for end in range(index, N):\n                if (index, end) in palindromes:\n                    res = min(res, 1 + dfs(end + 1))\n            \n            cache[index] = res\n            return res\n        \n        return dfs(0)\n\n        ",
        "memory": "395018"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n\n        '''\n        \n        for every 'i' pos check if this split leads to optimum result\n        abcbab\n\n\n        '''\n\n        palin = set()\n\n        def populate_palin(s):\n            n = len(s)\n            for o_mid in range(n):\n                p1, p2 = o_mid, o_mid\n                while p1 >=0 and p2 < n and s[p1] == s[p2]:\n                    palin.add((p1,p2))\n                    p1 -= 1\n                    p2 += 1\n            for e_mid in range(n):\n                p1, p2 = e_mid, e_mid + 1\n                while p1 >=0 and p2 < n and s[p1] == s[p2]:\n                    palin.add((p1,p2))\n                    p1 -= 1\n                    p2 += 1\n\n\n        '''\n        def palin(s, s_idx, e_idx):\n\n            key = (s_idx, e_idx)\n            if key not in palin_dp:\n                res = True\n                while s_idx < e_idx:\n                    if (s_idx, e_idx) in palin_dp:\n                        res = palin_dp[(s_idx, e_idx)]\n                        break\n                    if s[s_idx] != s[e_idx]:\n                        res = False\n                        break\n\n                    s_idx += 1\n                    e_idx -= 1\n\n                palin_dp[key] = res\n            \n            return palin_dp[key]\n        '''\n\n        self.dp_tbl = {}\n        populate_palin(s)\n\n        def partition(s_idx, n):\n            if s_idx == n:\n                return -1\n\n            key = s_idx\n\n            if key not in self.dp_tbl:\n                best = n - s_idx # all individual chars is the worst possible answer\n\n                for e_idx in range(s_idx, n):\n                    #if palin(s, s_idx, e_idx):\n                    if (s_idx, e_idx) in palin:\n                        min_cuts = 1 + partition(e_idx + 1, n)\n                        best = min(best, min_cuts)\n            \n                self.dp_tbl[key] = best\n            \n            return self.dp_tbl[key]\n\n        n = len(s)\n        return partition(0, n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                    ",
        "memory": "401841"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        memoCuts = [[None] * len(s) for _ in range(len(s))]\n        memoPalindrome = [[None] * len(s) for _ in range(len(s))]\n\n        @cache\n        def isPalindrome(start, end):\n            if start >= end:\n                return True\n            return s[start:end+1] == s[start:end+1][::-1]\n\n        @cache\n        def findMinimumCut(start, end):\n            if start == end or isPalindrome(start, end):\n                return 0\n            minimumCut = math.inf\n            for i in range(start, end + 1):\n                if isPalindrome(start, i):\n                    minimumCut = min(minimumCut, 1 + findMinimumCut(i + 1, end))\n            return minimumCut\n\n        return findMinimumCut(0, len(s) - 1)\n",
        "memory": "408665"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        memoCuts = [[None] * len(s) for _ in range(len(s))]\n        memoPalindrome = [[None] * len(s) for _ in range(len(s))]\n\n        @cache\n        def isPalindrome(start, end):\n            if start >= end:\n                return True\n            return s[start:end+1] == s[start:end+1][::-1]\n\n        @cache\n        def findMinimumCut(start, end):\n            if start == end or isPalindrome(start, end):\n                return 0\n            minimumCut = math.inf\n            for i in range(start, end + 1):\n                if isPalindrome(start, i):\n                    minimumCut = min(minimumCut, 1 + findMinimumCut(i + 1, end))\n            return minimumCut\n\n        return findMinimumCut(0, len(s) - 1)\n",
        "memory": "415489"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        n = len(s)\n\n        @cache\n        def is_panlindrome(i, j): \n            if i == j: \n                return True\n            elif i + 1 == j: \n                return s[i] == s[j]\n            elif s[i] != s[j]:\n                return False\n            else:\n                return is_panlindrome(i + 1, j - 1)\n\n        @cache\n        def min_cut(i): \n            if i == -1: return -1\n            res = n - 1\n            for start in range(i + 1): \n                if is_panlindrome(start, i): \n                    res = min(res, min_cut(start - 1) + 1)\n                    if res == 0: return res\n            return res\n\n        return min_cut(n - 1)",
        "memory": "422313"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        memoCuts = [[None] * len(s) for _ in range(len(s))]\n        memoPalindrome = [[None] * len(s) for _ in range(len(s))]\n\n        @cache\n        def isPalindrome(start, end):\n            if start >= end:\n                return True\n            return s[start] == s[end] and isPalindrome(start + 1, end - 1)\n\n        @cache\n        def findMinimumCut(start, end):\n            if start == end or isPalindrome(start, end):\n                return 0\n            minimumCut = math.inf\n            for i in range(start, end + 1):\n                if isPalindrome(start, i):\n                    minimumCut = min(minimumCut, 1 + findMinimumCut(i + 1, end))\n            return minimumCut\n\n        return findMinimumCut(0, len(s) - 1)\n",
        "memory": "429136"
      }
    ],
    "memory_moderate_codes": [
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        n = len(s)\n        dp = [[-1 for j in range(n)] for i in range(n)]\n        t = [[-1 for j in range(n)]for i in range(n)]\n        def isPalindrome(s,i,j):\n            if i>=j :\n                return True\n            if t[i][j] != -1:\n                return t[i][j]\n            t[i][j] = s[i]==s[j] and isPalindrome(s,i+1,j-1)\n            return t[i][j]\n        def solve(s,i,j,dp):\n            if i>= j or isPalindrome(s,i,j):\n                return 0\n            if dp[i][j] != -1:\n                return dp[i][j]\n            mn = float('inf')\n            for k in range(i,j):\n                if isPalindrome(s,i,k):\n                    ans = solve(s,k+1,j,dp) + 1\n                    mn = min(ans,mn)\n            dp[i][j] = mn\n            return dp[i][j] \n        return solve(s,0,n-1,dp)\n                \n            ",
        "memory": "128891"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        n = len(s)\n        dp = [[-1 for _ in range(n)] for _ in range(n)]\n        palindrome_dp = [[-1 for _ in range(n)] for _ in range(n)]\n        \n        def is_palindrome(s, i, j):\n            if i >= j:\n                return True\n            if palindrome_dp[i][j] != -1:\n                return palindrome_dp[i][j]\n            palindrome_dp[i][j] = (s[i] == s[j]) and is_palindrome(s, i + 1, j - 1)\n            return palindrome_dp[i][j]\n        \n        def solve(s, i, j, dp):\n            if i >= j or is_palindrome(s, i, j):\n                return 0\n            if dp[i][j] != -1:\n                return dp[i][j]\n            \n            mn = float('inf')\n            for k in range(i, j):\n                if is_palindrome(s, i, k):\n                    temp = 1 + solve(s, k + 1, j, dp)\n                    mn = min(mn, temp)\n            \n            dp[i][j] = mn\n            return mn\n        \n        return solve(s, 0, n - 1, dp)\n",
        "memory": "128891"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        n=len(s)\n        isPalindrome=[[0]*n for i in range(n)]\n        for l in range(1,n+1):\n            for i in range(n-l+1):\n                j=i+l-1\n                if i==j:\n                    isPalindrome[i][j]=True\n                elif s[i]==s[j] and (j==i+1 or isPalindrome[i+1][j-1]):\n                    isPalindrome[i][j]=True\n                else:\n                    isPalindrome[i][j]=False\n        dp=[[None]*n for i in range(n)] #memoization table \n        def Partition(start,end):\n            #base case\n            if start==end or isPalindrome[start][end]:\n                return 0\n            #recurrsive case\n            if dp[start][end] is not None:\n                return dp[start][end]\n            minimum=end-start\n            for end_idx in range(start,end):\n                if isPalindrome[start][end_idx]:\n                    minimum=min(minimum,1+Partition(end_idx+1,end))\n            dp[start][end]=minimum\n            return dp[start][end]\n            \n\n\n        return Partition(0,n-1)\n\n            \n                ",
        "memory": "149363"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        grid=[[-1]*len(s) for i in range(len(s))]\n        n = len(s)\n        \n        # Step 1: Preprocess the string to determine which substrings are palindromes\n        dp = [[False]*n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = True\n        for i in range(n-1):\n            if s[i] == s[i+1]:\n                dp[i][i+1] = True\n        for l in range(3, n+1):\n            for i in range(n-l+1):\n                j = i+l-1\n                if s[i] == s[j] and dp[i+1][j-1]:\n                    dp[i][j] = True\n        \n        \n        def rec(left,right):\n            if grid[left][right]!=-1:\n                return grid[left][right]\n\n            if dp[left][right]:\n                grid[left][right]=0\n                return 0\n\n            m=right-left\n            for i in range(left,right):\n                if dp[left][i]:\n                    r=rec(i+1,right)\n\n                    m=min(m, r+1)\n            \n            grid[left][right]=m\n            return m\n        \n        return rec(0, len(s)-1)\n        \n\n\n            \n        ",
        "memory": "156186"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        n = len(s)\n        dp = [[0]*(n)for _ in range(n)]\n        for l in range(1,n+1):\n            for i in range(n-l+1):\n                j = i+l-1\n                if i==j:\n                    dp[i][j]=True\n                elif s[i]==s[j] and (j==i+1 or dp[i+1][j-1]):\n                    dp[i][j]=True\n                else:\n                    dp[i][j]=False\n        res = [[None]*n for _ in range(n)]\n        def helper(start,end):\n            if start==end or dp[start][end]:\n                return 0\n            if res[start][end] is not None:\n                return res[start][end]\n            minimum = end -start\n            for end_index in range(start,end):\n                if dp[start][end_index]:\n                    minimum = min(minimum,1+helper(end_index+1,end))\n            res[start][end]=minimum\n            return res[start][end]\n        return helper(0,n-1)        ",
        "memory": "163010"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        n = len(s)\n        t = [[-1 for i in range(n)] for _ in range(n)]\n        dp = [[None for i in range(n)] for _ in range(n)]\n        def isPalindrome(string, i, j):\n            if i >= j:\n                return True\n            if dp[i][j] != None:\n                return dp[i][j]\n            dp[i][j] = string[i] == string[j] and isPalindrome(string, i + 1, j - 1)\n            return dp[i][j]\n        def solve(i, j):\n            if i >= j:\n                return 0\n            if isPalindrome(s, i, j):\n                return 0\n            if t[i][j] != -1:\n                return t[i][j]\n            t[i][j] = float('inf')\n            for k in range(i, j):\n                if isPalindrome(s, i, k):\n                    t[i][j] = min(t[i][j], 1 + solve(i, k) + solve(k + 1, j))\n            return t[i][j]\n        return solve(0, n - 1)",
        "memory": "163010"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        dp = [0]*len(s)\n        start_index = {i: set() for i in range(len(s))}\n        for i in range(len(s)):\n            c = 0\n            while(i-c >= 0 and i+c < len(s) and s[i-c] == s[i+c]):\n                start_index[i+c].add(i-c)\n                c+=1\n            c = 0\n            while(i-c-1 >= 0 and i+c < len(s) and s[i-c-1] == s[i+c]):\n                start_index[i+c].add(i-c-1)\n                c+=1\n        for i in range(1, len(s)):\n            m = dp[i-1]+1\n            for s_index in start_index[i]:\n                m = min(m, 0 if s_index == 0 else dp[s_index-1]+1)\n            dp[i] = m\n        return dp[-1]\n\n\n        ",
        "memory": "176658"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n\n        '''\n        \n        for every 'i' pos check if this split leads to optimum result\n        abcbab\n\n\n        '''\n\n        palin = {}\n\n        def populate_palin(s):\n            n = len(s)\n            for i in range(n):\n                palin[i] = set()\n\n            for o_mid in range(n):\n                p1, p2 = o_mid, o_mid\n                while p1 >=0 and p2 < n and s[p1] == s[p2]:\n                    palin[p1].add(p2)\n                    p1 -= 1\n                    p2 += 1\n            for e_mid in range(n):\n                p1, p2 = e_mid, e_mid + 1\n                while p1 >=0 and p2 < n and s[p1] == s[p2]:\n                    palin[p1].add(p2)\n                    p1 -= 1\n                    p2 += 1\n\n\n        '''\n        def palin(s, s_idx, e_idx):\n\n            key = (s_idx, e_idx)\n            if key not in palin_dp:\n                res = True\n                while s_idx < e_idx:\n                    if (s_idx, e_idx) in palin_dp:\n                        res = palin_dp[(s_idx, e_idx)]\n                        break\n                    if s[s_idx] != s[e_idx]:\n                        res = False\n                        break\n\n                    s_idx += 1\n                    e_idx -= 1\n\n                palin_dp[key] = res\n            \n            return palin_dp[key]\n        '''\n\n        self.dp_tbl = {}\n        populate_palin(s)\n\n        def partition(s_idx, n):\n            if s_idx == n:\n                return -1\n\n            key = s_idx\n\n            if key not in self.dp_tbl:\n                best = n - s_idx # all individual chars is the worst possible answer\n\n                for e_idx in palin[s_idx]:\n                    min_cuts = 1 + partition(e_idx + 1, n)\n                    best = min(best, min_cuts)\n            \n                self.dp_tbl[key] = best\n            \n            return self.dp_tbl[key]\n\n        n = len(s)\n        return partition(0, n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                    ",
        "memory": "183481"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        palindrome_endings: Dict[int, Set[int]] = defaultdict(set)\n        for idx in range(len(s)):\n            start, end = idx, idx\n            while start >= 0 and end < len(s) and s[start] == s[end]:\n                palindrome_endings[start].add(end)\n                start -= 1\n                end += 1\n            start, end = idx, idx + 1\n            while start >= 0 and end < len(s) and s[start] == s[end]:\n                palindrome_endings[start].add(end)\n                start -= 1\n                end += 1\n        if len(s) - 1 in palindrome_endings[0]:\n            return 0\n        dp = {len(s) - 1: 0, len(s): -1}\n        for i in range(len(s) - 2, -1, -1):\n            dp[i] = min([1 + dp[end+1] for end in palindrome_endings[i]])\n        return dp[0]",
        "memory": "190305"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        # return self.partition_memoize(s)\n        return self.partition_bottom_up(s)\n\n    def partition_bottom_up(self, s):\n        # to find min cuts, this problem is very similar to first one\n        # we partition in a similar way to L131 first part\n\n        n = len(s)\n        dp = [0 for _ in range(n + 1)]\n        palindromes = collections.defaultdict(set)\n\n        def generate(i, j):\n            while i >= 0 and j < n and s[i] == s[j]: # palindrome, so add indices\n                palindromes[i].add(j)\n                i -= 1\n                j += 1\n\n        for k in range(n):\n            # consider all possible middle i, j for even and odd length\n            generate(k, k)\n            generate(k, k + 1)\n\n        for i in range(n - 1, -1, -1):\n            min_cuts = n  # n-1 is the max cuts we can do on string, so safe to say n is max value for min cuts\n            for j in range(i, n):\n                if j in palindromes[i]:  # only go if palindrome\n                    # if is_palindrome(s, i, j): # only go if palindrome\n                    min_cuts = min(min_cuts, 1 + dp[j + 1])\n\n            dp[i] = min_cuts\n\n        return dp[0] - 1 # subtract 1 because recursion counts the partition at end of string too\n\n    def partition_memoize(self, s):\n        # to find min cuts, this problem is very similar to first one\n        # we partition in a similar way to L131 first part\n\n        n = len(s)\n        dp = [-1 for _ in range(n)]\n        palindromes = collections.defaultdict(set)\n\n        # we need to optimize the palindrome calculations everytime, else there is TLE\n        # def is_palindrome(s1, l, r):  # basic checker for palindrome\n        #     while l <= r:\n        #         if s1[l] != s1[r]:\n        #             return False\n        #         l += 1\n        #         r -= 1\n        #     return True\n\n        # So generate all possible palindromes\n        # We do this by taking all possible chars as a middle of palindrome and expanding outwards\n        # We need to consider even and odd length. so abba, abba is a palindrome and we generate that by starting from bb and expanding outward\n        # We store all palindromes in a dict as indices d[i] = set(j), where i to every j is a palindrome\n        def generate(i, j):\n            while i >= 0 and j < n and s[i] == s[j]: # palindrome, so add indices\n                palindromes[i].add(j)\n                i -= 1\n                j += 1\n\n        for k in range(n):\n            # consider all possible middle i, j for even and odd length\n            generate(k, k)\n            generate(k, k + 1)\n\n        def helper(i):\n            if i == n:\n                return 0\n\n            if dp[i] != -1:\n                return dp[i]\n\n            min_cuts = n # n-1 is the max cuts we can do on string, so safe to say n is max value for min cuts\n            for j in range(i, n):\n                if j in palindromes[i]: # only go if palindrome\n                # if is_palindrome(s, i, j): # only go if palindrome\n                    min_cuts = min(min_cuts, 1 + helper(j + 1))\n\n            dp[i] = min_cuts\n            return dp[i]\n\n        return helper(0) - 1 # subtract 1 because recursion counts the partition at end of string too",
        "memory": "197129"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        N = len(s)\n        if N == 1:\n            return 0\n        dp = dict()\n        def helper(i, j):\n            while i >= 0 and j < N and s[i] == s[j]:\n                if i in dp:\n                    dp[i].add(j)\n                else:\n                    dp[i] = set([j])\n                i -= 1\n                j += 1\n        \n        for k in range(N):\n            helper(k, k)\n            helper(k, k+1)\n        cache = {}\n        def solve(i):\n            if i in cache:\n                return cache[i]\n            if i > N-1:\n                return -1\n            if i == N-1:\n                return 0\n            sol = N - i -1\n            if N-1 in dp[i]:\n                return 0\n            for j in dp[i]:\n                sol = min(1 + solve(j+1), sol)\n            cache[i] = sol\n            return sol\n\n        return solve(0)",
        "memory": "203953"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        hashmap = defaultdict(set)\n        def pals(l, r):\n            while l >= 0 and r < len(s) and s[l] == s[r]:\n                hashmap[l].add(r)\n                l -= 1\n                r += 1\n        \n        for i in range(len(s)):\n            pals(i, i)\n            pals(i, i+1)\n\n        @lru_cache(None)\n        def dfs(ind):\n            if ind >= len(s):\n                return 0\n            \n            res = len(s)\n            for i in range(ind, len(s)):\n                if i in hashmap[ind]:\n                    res = min(res, dfs(i+1) + 1)\n\n            return res\n        return dfs(0) - 1",
        "memory": "210776"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n\n        dt = defaultdict(lambda: set())\n        n = len(s)\n        def exp(i):\n            c = 0\n            while i-c >= 0 and i+c < n and s[i-c] == s[i+c]:\n                dt[i-c].add(i+c)\n                c += 1\n            c = 0\n            while i-c >= 0 and i+c+1 < n and s[i-c] == s[i+c+1]:\n                dt[i-c].add(i+c+1)\n                c += 1\n        for x in range(n): exp(x)\n        \n   \n        @lru_cache(None)\n        def dfs(i):\n            if i == n: return 0\n            return 1 + min([dfs(x+1) for x in dt[i]])\n        return dfs(0)-1",
        "memory": "210776"
      },
      {
        "code": "class Solution:\n    def minCut(self, s):\n        d, n = defaultdict(set), len(s)\n        \n        def helper(i, j):\n            while i >= 0 and j < n and s[i] == s[j]:\n                d[i].add(j)\n                i, j = i - 1, j + 1\n        \n        for k in range(n):\n            helper(k, k)\n            helper(k, k + 1)\n\n        @lru_cache(None)\n        def dp(i):\n            if i == -1: return -1\n            return min([dp(k-1) + 1 for k in range(0, i+1) if i in d[k]])\n        \n        return dp(n-1)",
        "memory": "224424"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        d, n = defaultdict(set), len(s)\n        \n        def helper (i, j):\n             while i >= 0 and j < n and s[i] == s[j]:\n                d[i].add(j)\n                i,j = i-1, j+1\n            \n        for k in range(n):\n            helper (k,k)\n            helper(k, k+1)\n        \n        @lru_cache(None)\n        def dp(i):\n            if i == -1: return -1\n            return min([dp(k-1) + 1 for k in range(0, i+1) if i in d[k]])\n        \n        return dp(n-1)",
        "memory": "231248"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        d = defaultdict(set)\n        N=len(s)\n        \n        def helper(i,j):\n          while(i>=0 and j<N and s[i]==s[j]):\n            d[i].add(j)\n            i-=1\n            j+=1\n            \n        for k in range(N):\n          helper(k,k)\n          helper(k,k+1)\n          \n        @lru_cache(None)\n        def dfs(i):\n          if i==N:\n            return 0\n          tmp = []\n          for j in range(i,N+1):\n            if j in d[i]:\n              tmp.append(dfs(j+1)+1)\n          return min(tmp)\n        return dfs(0)-1\n\n          ",
        "memory": "238071"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        d = defaultdict(set)\n        N=len(s)\n        \n        def helper(i,j):\n          while(i>=0 and j<N and s[i]==s[j]):\n            d[i].add(j)\n            i-=1\n            j+=1\n            \n        for k in range(N):\n          helper(k,k)\n          helper(k,k+1)\n          \n        @lru_cache(None)\n        def dfs(i):\n          if i==N:\n            return 0\n          tmp = []\n          for j in range(i,N+1):\n            if j in d[i]:\n              tmp.append(dfs(j+1)+1)\n          return min(tmp)\n        return dfs(0)-1\n\n          ",
        "memory": "244895"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        n = len(s)\n        \n        @cache\n        def isPalindrome(l: int, r: int) -> bool:\n            return l >= r or (s[l] == s[r] and isPalindrome(l + 1, r - 1))\n        \n        @cache\n        def dp(l: int) -> int:\n            return 0 if l == n else min(dp(r + 1) + 1 for r in range(l, n) if isPalindrome(l, r))\n        \n        return dp(0) - 1",
        "memory": "251719"
      },
      {
        "code": "from functools import lru_cache\nclass Solution:\n    def minCut(self, s: str) -> int:\n        @lru_cache(None)\n        def helper(i,j):\n            if s[i:j]==s[i:j][::-1]:\n                return 0\n            ans=math.inf\n            for k in range(i+1,j):\n                if s[i:k]==s[i:k][::-1]:\n                    ans=min(ans,helper(i,k)+1+helper(k,j))\n            return ans\n        return helper(0,len(s))",
        "memory": "258543"
      },
      {
        "code": "import functools\n\nclass Solution:\n    def minCut(self, s: str) -> int:\n        string = s\n        @functools.cache\n        def isPalindrome(s, e):\n            while s<e:\n                if string[s] != string[e]:\n                    return False\n                s += 1\n                e -= 1\n            else: return True\n\n        @functools.cache\n        def recur(currindex):\n            if currindex >= len(string) or isPalindrome(currindex, len(string) -1):\n                return 0\n            sol = math.inf\n            for i in range(len(string)-1, currindex - 1, -1):\n                if isPalindrome(currindex, i):\n                    sol = min(sol, recur(i + 1) + 1)\n                    if sol == 0 or sol == 1:\n                        return sol\n            return sol\n        return recur(0)",
        "memory": "265366"
      },
      {
        "code": "import functools\n\nclass Solution:\n    def minCut(self, s: str) -> int:\n        string = s\n        @functools.cache\n        def isPalindrome(s, e):\n            while s<e:\n                if string[s] != string[e]:\n                    return False\n                s += 1\n                e -= 1\n            else: return True\n\n        @functools.cache\n        def recur(currindex):\n            if currindex >= len(string) or isPalindrome(currindex, len(string) -1):\n                return 0\n            sol = math.inf\n            for i in range(len(string)-1, currindex - 1, -1):\n                if isPalindrome(currindex, i):\n                    sol = min(sol, recur(i + 1) + 1)\n                    if sol == 0 or sol == 1:\n                        return sol\n            return sol\n\n        return recur(0)",
        "memory": "272190"
      },
      {
        "code": "import functools\n\nclass Solution:\n    def minCut(self, s: str) -> int:\n        string = s\n        @functools.cache\n        def isPalindrome(s, e):\n            while s<e:\n                if string[s] != string[e]:\n                    return False\n                s += 1\n                e -= 1\n            else: return True\n\n        @functools.cache\n        def recur(currindex):\n            if currindex >= len(string) or isPalindrome(currindex, len(string) -1):\n                return 0\n            sol = math.inf\n            for i in range(len(string)-1, currindex - 1, -1):\n                if isPalindrome(currindex, i):\n                    sol = min(sol, recur(i + 1) + 1)\n                    if sol == 0 or sol == 1:\n                        return sol\n            return sol\n        return recur(0)",
        "memory": "272190"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        n: int = len(s)\n        if n == 1:\n            return 0\n        if n == 2:\n            return 0 if s[0] == s[1] else 1\n\n        @cache\n        def dfs(i: int, j: int) -> int:\n            if s[i:j] == s[i:j][::-1]:\n                return 0\n\n            result: int = float('inf')\n            for k in range(i + 1, j):\n                if s[i:k] == s[i:k][::-1]:\n                    result = min(result, dfs(i, k) + dfs(k, j) + 1)\n            return result\n\n        return dfs(0, n)\n",
        "memory": "279014"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        n: int = len(s)\n        if n == 1 or len(set(s)) == 1:\n            return 0\n        if n == 2:\n            return 0 if s[0] == s[1] else 1\n\n        @cache\n        def dfs(i: int, j: int) -> int:\n            if s[i:j] == s[i:j][::-1]:\n                return 0\n\n            result: int = float('inf')\n            for k in range(i + 1, j):\n                if s[i:k] == s[i:k][::-1]:\n                    result = min(result, dfs(i, k) + dfs(k, j) + 1)\n            return result\n\n        return dfs(0, n)\n",
        "memory": "279014"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        if len(s) <= 1:\n            return 0\n        isPalin = lambda x: x == x[::-1]\n        cache = dict()\n        # calculate and cache all substring is palindrome or not\n        for r in range(len(s) + 1):\n            for l in range(r):\n                cache[(l, r)] = isPalin(s[l:r])\n        # save down the minimum number of cut for string[0:r] in dp[r]\n        dp = [float('inf') for i in range(len(s) + 1)]\n        dp[0] = 0\n        for r in range(1, len(s) + 1):\n            if cache[(0, r)]:\n                # if string[0:r] is palindrome, set dp[r] = 0 and skip loop\n                dp[r] = 0\n                continue\n            for l in range(1, r):\n                # if string[l:r] is palindrome, set dp[r] = min(dp[r], dp[l] + 1)\n                # dp[l] is the best number of cut in string[0:l]\n                # number 1 is come from string[l:r] is palindrome\n                if cache[(l, r)]:\n                    dp[r] = min(dp[r], dp[l] + 1)\n        return dp[-1]",
        "memory": "285838"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        N = len(s)\n        INF = 10 ** 20\n        dp = [INF for _ in range(N)]\n        dp[0] = 0\n\n        @cache\n        def good(x, y):\n            return s[x: y + 1] == s[x: y + 1][::-1]\n\n        for i in range(1, N):\n            dp[i] = dp[i - 1] + 1\n\n            for j in range(i - 1, -1, -1):\n                if good(j, i):\n                    dp[i] = min(dp[i], (dp[j - 1] + 1) if j > 0 else 0)\n\n        return dp[N - 1]",
        "memory": "299485"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        if len(s) <= 1:\n            return 0\n        isPalin = lambda x: x == x[::-1]\n        cache = dict()\n        for r in range(len(s) + 1):\n            for l in range(r):\n                cache[(l, r)] = isPalin(s[l:r])\n        dp = [float('inf') for i in range(len(s) + 1)]\n        dp[0] = 0\n        for r in range(1, len(s) + 1):\n            if cache[(0, r)]:\n                dp[r] = 0\n                continue\n            for l in range(1, r):\n                if cache[(l, r)]:\n                    dp[r] = min(dp[r], dp[l] + 1)\n        return dp[-1]",
        "memory": "306309"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        n = len(s)\n\n        def isPallindrome(s):\n            return s == s[::-1]\n        \n        cache = {}\n\n        for l in range(n):\n            for r in range(l + 1, n + 1):\n                cache[(l, r)] = isPallindrome(s[l:r])\n        \n        dp = [math.inf for i in range(n + 1)]\n        dp[0] = 0\n\n        for r in range(1, n + 1):\n            if cache[(0, r)]:\n                dp[r] = 0\n                continue\n            \n            for l in range(1, r):\n                if cache[(l, r)]:\n                    dp[r] = min(dp[r], dp[l] + 1)\n        return dp[-1]",
        "memory": "313133"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        n = len(s)\n\n        def isPallindrome(i, j):\n            return s[i:j] == s[i:j][::-1]\n        \n        cache = {}\n\n        for l in range(n):\n            for r in range(l + 1, n + 1):\n                cache[(l, r)] = isPallindrome(l, r)\n        \n        dp = [math.inf for i in range(n + 1)]\n        dp[0] = 0\n\n        for r in range(1, n + 1):\n            if cache[(0, r)]:\n                dp[r] = 0\n                continue\n            \n            for l in range(1, r):\n                if cache[(l, r)]:\n                    dp[r] = min(dp[r], dp[l] + 1)\n        return dp[-1]",
        "memory": "319956"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        palindromes = set()\n        for i in range(len(s)):\n            k = 1\n            palindromes.add((i,i))\n            while i-k >= 0 and i+k < len(s):\n                if s[i-k] == s[i+k]:\n                    palindromes.add((i-k,i+k))\n                    k += 1\n                else:\n                    break\n            k = 1\n            while i-k+1 >= 0 and i+k < len(s):\n                if s[i-k+1] == s[i+k]:\n                    palindromes.add((i-k+1,i+k))\n                    k += 1\n                else:\n                    break\n        \n        dp = {-1:-1}\n        for i in range(len(s)):\n            dp[i] = 1+dp[i-1]\n            for k in range(-1, i-1):\n                if (k+1,i) in palindromes:\n                    dp[i] = min(dp[i], 1+dp[k])\n        return dp[len(s)-1]",
        "memory": "326780"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        palindromes = set()\n\n        def palindrome(i,j) :\n            while i>=0 and j<len(s) and s[i]==s[j] :\n                palindromes.add((i,j)) \n                i-=1\n                j+=1\n\n        n = len(s)\n        for i in range(n) :\n            palindrome(i,i)\n            palindrome(i,i+1) \n        dp = [1e6]*(n+1) \n        dp[-1] = 0\n        for i in range(n-1,-1,-1) :\n            ans = 1e6\n            for j in range(i, n) :\n                if (i,j) in palindromes :\n                    ans = min(ans, 1+dp[j+1])\n            dp[i] = ans\n        return dp[0]-1\n               \n\n\n\n        ",
        "memory": "333604"
      }
    ],
    "memory_efficient_codes": [
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        N = len(s)\n        dp = [i for i in range(-1,N)]\n        for i in range(N):\n            j = 0\n            while i-j>=0 and i+j<N and s[i-j]==s[i+j]:\n                dp[i+j+1] = min(dp[i+j+1], dp[i-j]+1)\n                j+=1\n            j = 0\n            while i-j>=0 and i+j+1<N and s[i-j]==s[i+j+1]:\n                dp[i+j+2] = min(dp[i+j+2], dp[i-j]+1)\n                j+=1\n        return dp[N]",
        "memory": "19711"
      },
      {
        "code": "class Solution:\n    def minCut(self, S):\n        N = len(S)\n        dp = [-1] + [N] * N\n        for i in range(2 * N - 1):\n            l = i // 2\n            r = l + (i & 1)\n            while 0 <= l and r < N and S[l] == S[r]:\n                dp[r + 1] = min(dp[r + 1], dp[l] + 1)\n                l -= 1\n                r += 1\n        return dp[-1]",
        "memory": "19711"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        @lru_cache(maxsize=None)\n        def pp(w):\n            if not w:\n                return 0\n            minc=float(\"inf\")\n            for i in range(1,len(w)+1):\n                pref=w[:i]\n                if pref==pref[::-1]:\n                    lsuf=pp(w[i:])\n                    minc=min(minc,1+lsuf)\n            return minc\n        return pp(s)-1\n        ",
        "memory": "26535"
      },
      {
        "code": "class Solution:\n    def minCut(self, s):\n        @lru_cache(None)\n        def function(s):\n            if not s:\n                return 0 \n\n            min_val = float(\"inf\")\n\n            for i in range(1,len(s)+1):\n                if s[:i] == s[:i][::-1]:\n                    min_val = min(min_val,1+function(s[i:]))\n\n            return min_val \n\n        return function(s)-1",
        "memory": "26535"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        if s==s[::-1]: return 0\n\n        for i in range(len(s)):\n            if s[:i]==s[:i][::-1] and s[i:]==s[i:][::-1]: return 1\n        \n        d=[[0]*len(s) for _ in range(len(s))]\n        \n        for i in range(len(s)):\n            for j in range(i,len(s)):\n                st=s[i:j+1]\n                d[i][j]=(st==st[::-1])\n        \n        cuts = list(range(len(s)))\n\n        for i in range(1,len(s)):\n            if d[0][i]:\n                cuts[i]=0\n            else:\n                for j in range(0,i):\n                    if d[j+1][i]:\n                        cuts[i]=min(cuts[i],cuts[j]+1)\n        return cuts[-1]\n\n\n        ",
        "memory": "40183"
      },
      {
        "code": "from math import inf\n\nclass Solution:\n\n    def cutIntoPalindromicStrings(self, dp, s, i, j, n):\n        \n        if j == n: \n            return 0 if s[i:j] == s[i:j][::-1] else inf\n        \n        if dp[i][j] != -1: return dp[i][j]\n\n        else:\n            cuts = inf\n            cuts = min(cuts, self.cutIntoPalindromicStrings(dp, s, i, j + 1, n))\n            if s[i:j] == s[i:j][::-1]: \n                cuts = min(cuts, 1 + self.cutIntoPalindromicStrings(dp, s, j, j+1, n))\n            dp[i][j] = cuts\n            return cuts\n\n    def minCut(self, s: str) -> int:\n\n        # maximim partition can be the length of the string - 1\n\n        # we know for a any string to be palindromic the reverese should be the same\n\n        # aabbaa\n\n        # i can only partition when i find a pallindromic series\n        \n        # so whenever i find a palindrome i have an  option to either cut it or just look for a bigger palindromic string\n\n        n = len(s)\n        dp = [[-1]*(n+1) for _ in range(n)]\n\n        # for i in range(n+1):\n        #     if s[:i] != s[:i][::-1]: dp[0][i] = inf\n\n        return self.cutIntoPalindromicStrings(dp, s, 0, 1, n)\n\n",
        "memory": "47006"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        n = len(s)\n        \n        # Step 1: Preprocess the string to determine which substrings are palindromes\n        dp = [[False]*n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = True\n        for i in range(n-1):\n            if s[i] == s[i+1]:\n                dp[i][i+1] = True\n        for l in range(3, n+1):\n            for i in range(n-l+1):\n                j = i+l-1\n                if s[i] == s[j] and dp[i+1][j-1]:\n                    dp[i][j] = True\n        \n        # Step 2: Use dynamic programming to determine the minimum cuts needed\n        cuts = list(range(n))\n        for i in range(1, n):\n            if dp[0][i]:\n                cuts[i] = 0\n            else:\n                for j in range(i):\n                    if dp[j+1][i]:\n                        cuts[i] = min(cuts[i], cuts[j]+1)\n        \n        # Step 3: Return the final answer\n        return cuts[-1]",
        "memory": "47006"
      },
      {
        "code": "class Solution:\n\n    def minCut(self, s: str) -> int:\n        dp = [[-1]*(len(s)+1) for _ in range(len(s)+1)]\n        def isPalindrome(l, r , s):\n            if l > r:\n                return True\n            if dp[l][r] != -1:\n                return dp[l][r]\n            res = False\n            if s[l] == s[r]:\n                res = isPalindrome(l+1, r-1, s)\n            dp[l][r] = res\n            return res\n        helper_dp = [0]*(len(s)+1)\n\n        for i in range(len(s)-1, -1, -1):\n            min_cuts = float('inf')\n            for j in range(i, len(s)):\n                if isPalindrome(i, j, s):\n                    min_cuts = min(min_cuts, helper_dp[j+1]+1)\n            helper_dp[i] = min_cuts\n        return helper_dp[0]-1\n\n\n        # def helper(i):\n        #     if i == len(s):\n        #         return 0\n        #     if helper_dp[i] != -1:\n        #         return helper_dp[i]\n        #     min_cuts = float('inf')\n        #     for j in range(i, len(s)):\n        #         isPali = isPalindrome(i, j, s)\n        #         if isPali:\n        #             min_cuts = min(min_cuts, 1 + helper(j+1))\n        #     helper_dp[i] = min_cuts\n        #     return min_cuts\n        # return helper(0)-1\n\n      \n        \n        \n    \n",
        "memory": "53830"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        n = len(s)\n        memo_c = [None]*n\n        memo_p = [[None]*n for _ in range(n)]\n        \n        def helper(start, end):\n            cut = end\n            if start==end or is_p(start, end): return 0\n            if memo_c[start] is not None: return memo_c[start]\n            \n            for i in range(start, end + 1):\n                if is_p(start, i):\n                    cut = min(cut, 1+helper(i+1, end))\n            memo_c[start] = cut\n            return cut\n\n        def is_p(start, end):\n            if start >= end: return True\n            if memo_p[start][end] is not None:\n                return memo_p[start][end]\n            memo_p[start][end]=s[start]==s[end] and is_p(start+1, end-1)\n            return memo_p[start][end]\n        \n        return helper(0, n-1)",
        "memory": "67478"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        n = len(s)\n        memo_c = [None]*n\n        memo_p = [[None]*n for _ in range(n)]\n        \n        def helper(start, end):\n            cut = end\n            if start==end or is_p(start, end): return 0\n            if memo_c[start] is not None: return memo_c[start]\n            for i in range(start, end+1):\n                if is_p(start, i):\n                    cut = min(cut, 1+helper(i+1, end))\n                    \n            memo_c[start] = cut\n            return cut\n        \n        def is_p(start, end):\n            if start>=end: return True\n            if memo_p[start][end] is not None: return memo_p[start][end]\n            memo_p[start][end]= (s[start]==s[end] and is_p(start+1, end-1))\n            return memo_p[start][end]\n        \n        return helper(0, n-1)",
        "memory": "74301"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        N = len(s)\n\n        # Precompute palindromic substrings\n        dp = [[False] * N for _ in range(N)]\n        for i in range(N - 1, -1, -1):\n            dp[i][i] = True\n            for j in range(i + 1, N):\n                if s[i] == s[j] and (j - i == 1 or dp[i + 1][j - 1]):\n                    dp[i][j] = True\n\n        cache = {}\n\n        def checker(startIndex: int) -> int:\n            if startIndex == N:\n                return -1  # No cuts needed beyond the end of the string\n\n            if startIndex in cache:\n                return cache[startIndex]\n\n            min_cuts = float('inf')\n\n            for end in range(startIndex, N):\n                if dp[startIndex][end]:\n                    # Make a cut after the palindrome s[startIndex:end+1]\n                    cuts = 1 + checker(end + 1)\n                    if cuts < min_cuts:\n                        min_cuts = cuts\n\n            cache[startIndex] = min_cuts\n            return min_cuts\n\n        return checker(0)\n",
        "memory": "74301"
      },
      {
        "code": "# class Solution:\n#     def minCut(self, s: str) -> int:\n        \n#         @cache\n#         def dp(s, e):\n#             if is_pal[s][e]:\n#                 return 0\n            \n#             ans = math.inf\n#             for i in range(s, e):\n#                 if is_pal[s][i]:\n#                     ans = min(ans, 1 + dp(i + 1, e))\n            \n#             return ans\n\n\n        # n = len(s)\n        # is_pal = [[False] * n for _ in range(n)]\n\n        # for i in range(n - 1, -1, -1):\n        #     for j in range(i, n):\n        #         if s[i] == s[j]:\n        #             is_pal[i][j] = j - i <= 2 or is_pal[i + 1][j - 1]\n        \n#         return dp(0, n - 1)\n\n\n\n\nclass Solution:\n    def minCut(self, s: str) -> int:\n        \n\n        n = len(s)\n        is_pal = [[False] * n for _ in range(n)]\n\n        for i in range(n - 1, -1, -1):\n            for j in range(i, n):\n                if s[i] == s[j]:\n                    is_pal[i][j] = j - i <= 2 or is_pal[i + 1][j - 1]\n        \n        @cache\n        def f(i):\n            if i >= len(s):\n                return 0\n\n            best = math.inf\n\n            for j in range(i, len(s)):\n                if is_pal[i][j]:\n                    best = min(best, 1 + f(j + 1))\n\n            return best\n        \n        return f(0) - 1",
        "memory": "81125"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n\n        n = len(s)        \n        @cache\n        def dp(s):\n            if is_pal[s][n - 1]:\n                return 0\n            \n            ans = math.inf\n            for i in range(s, n):\n                if is_pal[s][i]:\n                    ans = min(ans, 1 + dp(i + 1))\n            \n            return ans\n\n\n        n = len(s)\n        is_pal = [[False] * n for _ in range(n)]\n\n        for i in range(n - 1, -1, -1):\n            for j in range(i, n):\n                if s[i] == s[j]:\n                    is_pal[i][j] = j - i <= 2 or is_pal[i + 1][j - 1]\n        \n        return dp(0)\n\n# class Solution:\n#     def minCut(self, s: str) -> int:\n        \n#         # n = len(s)\n#         # is_pal = [[False] * n for _ in range(n)]\n\n#         # for i in range(n - 1, -1, -1):\n#         #     for j in range(i, n):\n#         #         if s[i] == s[j]:\n#         #             is_pal[i][j] = j - i <= 2 or is_pal[i + 1][j - 1]\n        \n#         @cache\n#         def is_palindrome(l, r):\n#             if l >= r: return True\n#             if s[l] != s[r]: return False\n#             return is_palindrome(l + 1, r - 1)\n\n        \n#         @cache\n#         def f(i):\n#             if i >= len(s):\n#                 return 0\n\n#             best = math.inf\n\n#             for j in range(i, len(s)):\n#                 if is_palindrome(i, j):\n#                     best = min(best, 1 + f(j + 1))\n\n#             return best\n        \n#         return f(0) - 1\n\n# class Solution:\n#     def minCut(self, s: str) -> int:\n\n#         # n = len(s)\n#         # is_pal = [[False] * n for _ in range(n)]\n\n#         # for i in range(n - 1, -1, -1):\n#         #     for j in range(i, n):\n#         #         if s[i] == s[j]:\n#         #             is_pal[i][j] = j - i <= 2 or is_pal[i + 1][j - 1]\n        \n#         @cache\n#         def is_palindrome(l, r):\n#             if l >= r: return True\n#             if s[l] != s[r]: return False\n#             return is_palindrome(l + 1, r - 1)\n        \n#         @cache\n#         def f(l, r):\n#             if is_palindrome(l, r):\n#                 return 0\n            \n#             result = math.inf\n            \n#             for i in range(l, r):\n#                 res = 1 + f(l, i) + f(i + 1, r)\n#                 result = min(result, res)\n#             return result\n            \n#         return f(0, len(s) - 1)",
        "memory": "81125"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        dic={}\n        n=len(s)\n        palindromeTable = [[False] * n for _ in range(n)]\n        for i in range(n):\n            palindromeTable[i][i] = True\n        for prefix_len in range(2, n + 1):\n            for start in range(n - prefix_len + 1):\n                end = start + prefix_len - 1\n                if s[start] == s[end]:\n                    if prefix_len == 2 or palindromeTable[start + 1][end - 1]:\n                        palindromeTable[start][end] = True\n\n        def partition(start:int,end:int) -> int:\n            nonlocal dic\n            if start>end:\n                return []\n            if (start,end) in dic:\n                return dic[(start,end)]\n            res=end-start+1\n            for i in range(start,end+1):\n                if palindromeTable[start][i]:\n                    if i==end:\n                        res=0\n                    else:\n                        res=min(res,partition(i+1,end)+1)\n            dic[(start,end)]=res\n            return res\n        return partition(0,len(s)-1)\n        ",
        "memory": "94773"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        n = len(s)\n        dp = [[False] * n for _ in range(n)]\n\n        for odd_center in range(n):\n            c = 0\n            while 0 <= odd_center - c and odd_center + c <= n - 1 and s[odd_center - c] == s[odd_center + c]:\n                dp[odd_center - c][odd_center + c] = True\n                c += 1\n        for even_center in range(n - 1):\n            c = 0\n            while 0 <= even_center - c and even_center + c + 1 <= n - 1 and s[even_center - c] == s[even_center + c + 1]:\n                dp[even_center - c][even_center + c + 1] = True\n                c += 1\n        \n        # gets number of palindromes required to maximally palindromize substring s[i:j+1]\n        @cache\n        def recur(i, j) -> int:\n            if i > j:\n                return 0\n            else:\n                ans = math.inf\n                substring_length = j - i + 1\n                for l in range(substring_length, 0, -1):\n                    if dp[i][i + l - 1]:\n                        ans = min(ans, 1 + recur(i + l, j))\n                return ans\n\n        return recur(0, n - 1) - 1 # minus 1 because number of parts = number of cuts + 1\n\n        ",
        "memory": "94773"
      },
      {
        "code": "from collections import defaultdict, deque\n\nclass Solution:\n    def minCut(self, s: str) -> int:\n        def potentialSubstrings(s):\n            potential = defaultdict(lambda:[])\n            for i in range(len(s)):\n                index = 0\n                while i-index >= 0 and i+index < len(s) and s[i+index] == s[i-index]:\n                    potential[i-index].append(i+index)\n                    index += 1\n                index = 0\n                while i-index >= 0 and i+index+1 < len(s) and s[i+index+1] == s[i-index]:\n                    potential[i-index].append(i+index+1)\n                    index += 1\n            return potential\n        potential = potentialSubstrings(s)\n        neighbors = deque(potential[0])\n        visited = set()\n        ans = 0\n        while neighbors:\n            ans += 1\n            x = len(neighbors)\n            for i in range(x):\n                curr= neighbors.popleft()\n                if curr+1 >= len(s):\n                    return ans-1\n                if curr in visited:\n                    continue\n                visited.add(curr)\n                for j in range(len(potential[curr+1])):\n                    neighbors.append(potential[curr+1][j])\n\n        # def recurse(potential, currIndex, s):\n        #     if currIndex >= len(s):\n        #         return 0\n        #     if len(potential[currIndex]) == 0:\n        #         return float('inf')\n        #     ans = float('inf')\n        #     for i in range(len(potential[currIndex])):\n        #         x = recurse(potential, potential[currIndex][i]+1, s)\n        #         ans = min(ans, x+1)\n        #     return ans\n        # return recurse(potential, 0, s)-1",
        "memory": "108420"
      },
      {
        "code": "from collections import defaultdict, deque\n\nclass Solution:\n    def minCut(self, s: str) -> int:\n        def potentialSubstrings(s):\n            potential = defaultdict(lambda:[])\n            for i in range(len(s)):\n                index = 0\n                while i-index >= 0 and i+index < len(s) and s[i+index] == s[i-index]:\n                    potential[i-index].append(i+index)\n                    index += 1\n                index = 0\n                while i-index >= 0 and i+index+1 < len(s) and s[i+index+1] == s[i-index]:\n                    potential[i-index].append(i+index+1)\n                    index += 1\n            return potential\n        potential = potentialSubstrings(s)\n        neighbors = deque(potential[0])\n        visited = set()\n        ans = 0\n        while neighbors:\n            ans += 1\n            x = len(neighbors)\n            for i in range(x):\n                curr= neighbors.popleft()\n                if curr+1 >= len(s):\n                    return ans-1\n                if curr in visited:\n                    continue\n                visited.add(curr)\n                for j in range(len(potential[curr+1])):\n                    neighbors.append(potential[curr+1][j])",
        "memory": "108420"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        dp = [[False for i in range(len(s))] for i in range(len(s))]\n        for l in range(len(s)):\n            for start in range(len(s)-l):\n                i = start\n                j = start+l\n                if(l==0):\n                    dp[i][j] = True\n                elif(l==1):\n                    dp[i][j] = (s[i] == s[j])\n                else:\n                    dp[i][j] = (s[i] == s[j]) and dp[i+1][j-1]\n        valid_inds = []\n        for j in range(len(s)):\n            curr_inds = []\n            for i in range(j+1):\n                if(dp[i][j]):\n                    curr_inds.append(i)\n            valid_inds.append(curr_inds)\n        \n        sols = [float(\"inf\") for i in range(len(s))]\n        sols[0] = 0\n        for i in range(len(sols)):\n            for ind in valid_inds[i]:\n                if(ind == 0):\n                    sols[i] = 0\n                else:\n                    sols[i]= min(sols[ind-1] + 1, sols[i])\n        return sols[-1]\n        ",
        "memory": "115244"
      },
      {
        "code": "class Solution:\n  def getIdToPalindomeEndIds(self, s: str) -> Dict:\n    id_to_end_ids = {}\n    for i in range(len(s)):\n      id_to_end_ids[i] = []\n      # odd-length palindromes, consecutive characters center\n      self.expandPalindromesAroundCenter(s, i, i, id_to_end_ids)\n      # even-length palindromes, consecutive characters center\n      self.expandPalindromesAroundCenter(s, i, i + 1, id_to_end_ids)\n    return id_to_end_ids\n\n  def expandPalindromesAroundCenter(self, ss: str, lo: int, hi: int, id_to_end_ids: Dict):\n    while lo >= 0 and hi < len(ss):\n      if ss[lo] != ss[hi]:\n        break  # the first and last characters don't match!\n      id_to_end_ids[lo].append(hi)\n      # expand around the center\n      lo -= 1\n      hi += 1\n    return\n\n  def minCut(self, s: str) -> int:\n    id_to_end_ids = self.getIdToPalindomeEndIds(s)\n    # // dp[i] tracks min cut for substring s[i:].\n    dp = [None] * len(s)\n\n    def _dfs(i):\n      if i >= len(s):\n        return 0\n      min_cut = dp[i]\n      if min_cut is not None:\n        return min_cut\n\n      min_cut = math.inf\n      for end_id in id_to_end_ids.get(i, []):\n        if end_id == len(s) - 1:\n          min_cut = 0\n        else:\n          min_cut = min(min_cut, _dfs(end_id+1) + 1)\n      dp[i] = min_cut\n      return min_cut\n\n    return _dfs(0)",
        "memory": "115244"
      },
      {
        "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        def isPalindrome(s):\n            n = len(s)\n            dp = [[False] * n for _ in range(n)]\n            for i in range(n-1, -1, -1):\n                for j in range(i, n):\n                    if i == j:\n                        dp[i][j] = True\n                    elif j - i == 1:\n                        dp[i][j] = (s[i] == s[j])\n                    else:\n                        dp[i][j] = (s[i] == s[j] and dp[i+1][j-1])\n            return dp\n\n        dp = isPalindrome(s)\n        n = len(s)\n        res = float('inf')\n\n        @cache\n        def minPartition(start, res):\n            if dp[start][n-1]:\n                return 0\n\n            for i in range(start + 1, n+1):\n                if dp[start][i-1]:\n                    res = min(res, 1 + minPartition(i, res))\n            return res\n        res = minPartition(0, res)\n        return res",
        "memory": "122068"
      }
    ],
    "import_code": "import random\nimport json",
    "setup_code": "class Solution:\n    def minCut(self, s: str) -> int:\n        n = len(s)\n        memo_c = [None] * n\n        memo_p = [[None] * n for _ in range(n)]\n        \n        def helper(start, end):\n            cut = end\n            if start == end or is_p(start, end):\n                return 0\n            if memo_c[start] is not None:\n                return memo_c[start]\n            for i in range(start, end + 1):\n                if is_p(start, i):\n                    cut = min(cut, 1 + helper(i + 1, end))\n            \n            memo_c[start] = cut\n            return cut\n\n        def is_p(start, end):\n            if start >= end:\n                return True\n            if memo_p[start][end] is not None:\n                return memo_p[start][end]\n            memo_p[start][end] = (s[start] == s[end] and is_p(start + 1, end - 1))\n            return memo_p[start][end]\n\n        return helper(0, n - 1)\n\nclass TestCaseGenerator:\n    def generate(self) -> dict:\n        \"\"\"\n        Generates a test case input containing a random string `s` of length between 1 and 10.\n        This ensures we have a reasonable range for testing without excessive computation time.\n        \"\"\"\n        # Define the string length range\n        min_length = 1\n        max_length = 10\n        \n        # Create a random lowercase alphabetic string\n        length = random.randint(min_length, max_length)\n        s = ''.join(random.choices('abcdefghijklmnopqrstuvwxyz', k=length))\n        \n        return {'s': s}\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\"\n        Encodes the test case input into a JSON string.\n        \"\"\"\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\"\n        Encodes the test case output, which is an integer, to a string.\n        \"\"\"\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\"\n        Decodes a JSON string into a dictionary representing the test case input.\n        \"\"\"\n        return json.loads(input_str)",
    "libraries": ["random", "json"],
    "entry_point": "minCut",
    "test_cases": [
      {
        "input": "{\"s\": \"xmdstsmte\"}",
        "output": "6"
      },
      {
        "input": "{\"s\": \"scyzhzrmjg\"}",
        "output": "7"
      },
      {
        "input": "{\"s\": \"rxx\"}",
        "output": "1"
      },
      {
        "input": "{\"s\": \"tv\"}",
        "output": "1"
      },
      {
        "input": "{\"s\": \"dqpm\"}",
        "output": "3"
      },
      {
        "input": "{\"s\": \"mhkvndh\"}",
        "output": "6"
      },
      {
        "input": "{\"s\": \"zwk\"}",
        "output": "2"
      },
      {
        "input": "{\"s\": \"dkhvzh\"}",
        "output": "5"
      },
      {
        "input": "{\"s\": \"fngozf\"}",
        "output": "5"
      },
      {
        "input": "{\"s\": \"r\"}",
        "output": "0"
      },
      {
        "input": "{\"s\": \"x\"}",
        "output": "0"
      },
      {
        "input": "{\"s\": \"xvaqeih\"}",
        "output": "6"
      },
      {
        "input": "{\"s\": \"nnqc\"}",
        "output": "2"
      },
      {
        "input": "{\"s\": \"voskhacpzo\"}",
        "output": "9"
      },
      {
        "input": "{\"s\": \"azrl\"}",
        "output": "3"
      },
      {
        "input": "{\"s\": \"ryshaf\"}",
        "output": "5"
      },
      {
        "input": "{\"s\": \"kd\"}",
        "output": "1"
      },
      {
        "input": "{\"s\": \"ci\"}",
        "output": "1"
      },
      {
        "input": "{\"s\": \"hsyofpc\"}",
        "output": "6"
      },
      {
        "input": "{\"s\": \"u\"}",
        "output": "0"
      },
      {
        "input": "{\"s\": \"xfbq\"}",
        "output": "3"
      },
      {
        "input": "{\"s\": \"zdhelcs\"}",
        "output": "6"
      },
      {
        "input": "{\"s\": \"xpxajxdexu\"}",
        "output": "7"
      },
      {
        "input": "{\"s\": \"dieqwdh\"}",
        "output": "6"
      },
      {
        "input": "{\"s\": \"jcjcxc\"}",
        "output": "1"
      },
      {
        "input": "{\"s\": \"dpskj\"}",
        "output": "4"
      },
      {
        "input": "{\"s\": \"fmimipc\"}",
        "output": "4"
      },
      {
        "input": "{\"s\": \"e\"}",
        "output": "0"
      },
      {
        "input": "{\"s\": \"onhp\"}",
        "output": "3"
      },
      {
        "input": "{\"s\": \"dnqjchb\"}",
        "output": "6"
      },
      {
        "input": "{\"s\": \"q\"}",
        "output": "0"
      },
      {
        "input": "{\"s\": \"avzchaad\"}",
        "output": "6"
      },
      {
        "input": "{\"s\": \"y\"}",
        "output": "0"
      },
      {
        "input": "{\"s\": \"kbjchekdg\"}",
        "output": "8"
      },
      {
        "input": "{\"s\": \"ynx\"}",
        "output": "2"
      },
      {
        "input": "{\"s\": \"nf\"}",
        "output": "1"
      },
      {
        "input": "{\"s\": \"k\"}",
        "output": "0"
      },
      {
        "input": "{\"s\": \"w\"}",
        "output": "0"
      },
      {
        "input": "{\"s\": \"qskujcmoi\"}",
        "output": "8"
      },
      {
        "input": "{\"s\": \"ddzgfx\"}",
        "output": "4"
      },
      {
        "input": "{\"s\": \"fvhnoym\"}",
        "output": "6"
      },
      {
        "input": "{\"s\": \"xfrjo\"}",
        "output": "4"
      },
      {
        "input": "{\"s\": \"onhdvg\"}",
        "output": "5"
      },
      {
        "input": "{\"s\": \"uqyrod\"}",
        "output": "5"
      },
      {
        "input": "{\"s\": \"e\"}",
        "output": "0"
      },
      {
        "input": "{\"s\": \"luqv\"}",
        "output": "3"
      },
      {
        "input": "{\"s\": \"enusrmlttu\"}",
        "output": "8"
      },
      {
        "input": "{\"s\": \"vuy\"}",
        "output": "2"
      },
      {
        "input": "{\"s\": \"jsy\"}",
        "output": "2"
      },
      {
        "input": "{\"s\": \"oniakj\"}",
        "output": "5"
      },
      {
        "input": "{\"s\": \"xrnqo\"}",
        "output": "4"
      },
      {
        "input": "{\"s\": \"vbs\"}",
        "output": "2"
      },
      {
        "input": "{\"s\": \"k\"}",
        "output": "0"
      },
      {
        "input": "{\"s\": \"jgdx\"}",
        "output": "3"
      },
      {
        "input": "{\"s\": \"oohiqsp\"}",
        "output": "5"
      },
      {
        "input": "{\"s\": \"nymaiosg\"}",
        "output": "7"
      },
      {
        "input": "{\"s\": \"v\"}",
        "output": "0"
      },
      {
        "input": "{\"s\": \"tmctkbniy\"}",
        "output": "8"
      },
      {
        "input": "{\"s\": \"reiihg\"}",
        "output": "4"
      },
      {
        "input": "{\"s\": \"ayhbrvwnbf\"}",
        "output": "9"
      },
      {
        "input": "{\"s\": \"jrvagtutnx\"}",
        "output": "7"
      },
      {
        "input": "{\"s\": \"guh\"}",
        "output": "2"
      },
      {
        "input": "{\"s\": \"uswzjiaday\"}",
        "output": "7"
      },
      {
        "input": "{\"s\": \"rx\"}",
        "output": "1"
      },
      {
        "input": "{\"s\": \"id\"}",
        "output": "1"
      },
      {
        "input": "{\"s\": \"yujwdjjyqm\"}",
        "output": "8"
      },
      {
        "input": "{\"s\": \"wczk\"}",
        "output": "3"
      },
      {
        "input": "{\"s\": \"qaz\"}",
        "output": "2"
      },
      {
        "input": "{\"s\": \"iaxpfdmr\"}",
        "output": "7"
      },
      {
        "input": "{\"s\": \"phektxevl\"}",
        "output": "8"
      },
      {
        "input": "{\"s\": \"xkzhjb\"}",
        "output": "5"
      },
      {
        "input": "{\"s\": \"bsprfj\"}",
        "output": "5"
      },
      {
        "input": "{\"s\": \"kgdaevmf\"}",
        "output": "7"
      },
      {
        "input": "{\"s\": \"flgtpsir\"}",
        "output": "7"
      },
      {
        "input": "{\"s\": \"bicxmsufb\"}",
        "output": "8"
      },
      {
        "input": "{\"s\": \"rgaz\"}",
        "output": "3"
      },
      {
        "input": "{\"s\": \"l\"}",
        "output": "0"
      },
      {
        "input": "{\"s\": \"ywd\"}",
        "output": "2"
      },
      {
        "input": "{\"s\": \"kzqtvsuud\"}",
        "output": "7"
      },
      {
        "input": "{\"s\": \"fhingnig\"}",
        "output": "3"
      },
      {
        "input": "{\"s\": \"mp\"}",
        "output": "1"
      },
      {
        "input": "{\"s\": \"ygnyfnkn\"}",
        "output": "5"
      },
      {
        "input": "{\"s\": \"lsyqtxpli\"}",
        "output": "8"
      },
      {
        "input": "{\"s\": \"i\"}",
        "output": "0"
      },
      {
        "input": "{\"s\": \"zz\"}",
        "output": "0"
      },
      {
        "input": "{\"s\": \"fn\"}",
        "output": "1"
      },
      {
        "input": "{\"s\": \"glfh\"}",
        "output": "3"
      },
      {
        "input": "{\"s\": \"dkenp\"}",
        "output": "4"
      },
      {
        "input": "{\"s\": \"kexfeox\"}",
        "output": "6"
      },
      {
        "input": "{\"s\": \"yfxwcy\"}",
        "output": "5"
      },
      {
        "input": "{\"s\": \"lvoblp\"}",
        "output": "5"
      },
      {
        "input": "{\"s\": \"lpdyihrdz\"}",
        "output": "8"
      },
      {
        "input": "{\"s\": \"wjnmfc\"}",
        "output": "5"
      },
      {
        "input": "{\"s\": \"mdyouai\"}",
        "output": "6"
      },
      {
        "input": "{\"s\": \"ckjrssp\"}",
        "output": "5"
      },
      {
        "input": "{\"s\": \"kuakyeec\"}",
        "output": "6"
      },
      {
        "input": "{\"s\": \"ts\"}",
        "output": "1"
      },
      {
        "input": "{\"s\": \"livn\"}",
        "output": "3"
      },
      {
        "input": "{\"s\": \"ypfhjbybse\"}",
        "output": "7"
      },
      {
        "input": "{\"s\": \"knieipkfow\"}",
        "output": "7"
      },
      {
        "input": "{\"s\": \"yiiygeqoej\"}",
        "output": "6"
      },
      {
        "input": "{\"s\": \"wepxtey\"}",
        "output": "6"
      },
      {
        "input": "{\"s\": \"uthfjv\"}",
        "output": "5"
      },
      {
        "input": "{\"s\": \"x\"}",
        "output": "0"
      },
      {
        "input": "{\"s\": \"qxruvf\"}",
        "output": "5"
      },
      {
        "input": "{\"s\": \"mvnvgw\"}",
        "output": "3"
      },
      {
        "input": "{\"s\": \"vws\"}",
        "output": "2"
      },
      {
        "input": "{\"s\": \"ke\"}",
        "output": "1"
      },
      {
        "input": "{\"s\": \"fv\"}",
        "output": "1"
      },
      {
        "input": "{\"s\": \"rutnegqlg\"}",
        "output": "8"
      },
      {
        "input": "{\"s\": \"mdqbpml\"}",
        "output": "6"
      },
      {
        "input": "{\"s\": \"cgaw\"}",
        "output": "3"
      },
      {
        "input": "{\"s\": \"chv\"}",
        "output": "2"
      },
      {
        "input": "{\"s\": \"xykv\"}",
        "output": "3"
      },
      {
        "input": "{\"s\": \"tvghvaqi\"}",
        "output": "7"
      },
      {
        "input": "{\"s\": \"ce\"}",
        "output": "1"
      },
      {
        "input": "{\"s\": \"v\"}",
        "output": "0"
      },
      {
        "input": "{\"s\": \"vukobr\"}",
        "output": "5"
      },
      {
        "input": "{\"s\": \"rcdaw\"}",
        "output": "4"
      },
      {
        "input": "{\"s\": \"qnutssm\"}",
        "output": "5"
      },
      {
        "input": "{\"s\": \"hdvftzs\"}",
        "output": "6"
      },
      {
        "input": "{\"s\": \"at\"}",
        "output": "1"
      },
      {
        "input": "{\"s\": \"icxraaffkr\"}",
        "output": "7"
      },
      {
        "input": "{\"s\": \"iejlylu\"}",
        "output": "4"
      },
      {
        "input": "{\"s\": \"m\"}",
        "output": "0"
      },
      {
        "input": "{\"s\": \"aipgowoc\"}",
        "output": "5"
      },
      {
        "input": "{\"s\": \"riwnvtdoxn\"}",
        "output": "9"
      },
      {
        "input": "{\"s\": \"x\"}",
        "output": "0"
      }
    ]
  },
  {
    "question_id": 135,
    "name": "candy",
    "prompt": "<p>There are <code>n</code> children standing in a line. Each child is assigned a rating value given in the integer array <code>ratings</code>.</p>\n\n<p>You are giving candies to these children subjected to the following requirements:</p>\n\n<ul>\n\t<li>Each child must have at least one candy.</li>\n\t<li>Children with a higher rating get more candies than their neighbors.</li>\n</ul>\n\n<p>Return <em>the minimum number of candies you need to have to distribute the candies to the children</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> ratings = [1,0,2]\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> You can allocate to the first, second and third child with 2, 1, 2 candies respectively.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> ratings = [1,2,2]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> You can allocate to the first, second and third child with 1, 2, 1 candies respectively.\nThe third child gets 1 candy because it satisfies the above two conditions.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == ratings.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= ratings[i] &lt;= 2 * 10<sup>4</sup></code></li>\n</ul>\n",
    "difficulty": "Hard",
    "topics": ["array", "greedy"],
    "runtime_inefficient_codes": [
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        n=len(ratings)\n        sortedArr=[(ratings[i],i) for i in range(n)]\n        sortedArr.sort()\n        ans=[0]*n\n        for i in range(n):\n            curCandies=1\n            val,index=sortedArr[i]\n            if (index>0 and ratings[index-1]<ratings[index] and ans[index-1]>=curCandies):\n                curCandies=ans[index-1]+1\n            if (index<n-1 and ratings[index+1]<ratings[index] and ans[index+1]>=curCandies):\n                curCandies=ans[index+1]+1\n            ans[index]=curCandies\n        return sum(ans)\n            \n            \n        ",
        "runtime": "143"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        arr1 = [1] * len(ratings)\n        for i in range(1,len(ratings)) :\n            if ratings[i] > ratings[i - 1] :\n                arr1[i] = arr1[i - 1] + 1\n\n        arr2 = [1] * len(ratings)\n        for i in range(2,len(ratings) + 1) :\n            if ratings[-i] > ratings[-i + 1] :\n                arr2[-i] = arr2[-i + 1] + 1\n        answer = 0\n        for i in range(len(ratings)) :\n            answer += max(arr1[i], arr2[i])\n        return answer\n\n        ",
        "runtime": "145"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        candy_total = 0\n        candy_list = [0] * len(ratings)\n\n        # build up left side of hills\n        indexes = list(range(len(ratings)))\n        for i in indexes:\n            kid_rating = ratings[i]\n\n            # give 1 candy to first kid\n            if i == 0:\n                candy_list[i] = 1\n                candy_total += 1\n                continue\n\n            # give 1 more than left neighbor if higher otherwise give 1\n            amnt = 1\n            left_rating = ratings[i - 1]\n            if kid_rating > left_rating:\n                amnt = candy_list[i - 1] + 1\n\n            candy_list[i] = amnt\n            candy_total += amnt\n\n        # build up right side of hills\n        indexes.reverse()\n        for i in indexes:\n            kid_rating = ratings[i]\n\n            # skip last kid\n            if i == len(ratings) - 1:\n                continue\n\n            # give 1 more than right neighbor if higher\n            right_amnt = candy_list[i + 1] + 1\n            right_rating = ratings[i + 1]\n            if kid_rating > right_rating:\n                amnt = max(candy_list[i], right_amnt)\n                candy_total += amnt - candy_list[i]\n                candy_list[i] = amnt\n\n        return candy_total",
        "runtime": "146"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        n=len(ratings)\n        sortedArr=[(ratings[i],i) for i in range(n)]\n        sortedArr.sort()\n        ans=[0]*n\n        for i in range(n):\n            curCandies=1\n            val,index=sortedArr[i]\n            if (index>0 and ratings[index-1]<ratings[index] and ans[index-1]>=curCandies):\n                curCandies=ans[index-1]+1\n            if (index<n-1 and ratings[index+1]<ratings[index] and ans[index+1]>=curCandies):\n                curCandies=ans[index+1]+1\n                    \n            prev=val\n            ans[index]=curCandies\n        return sum(ans)\n            \n            \n        ",
        "runtime": "147"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        ratins = [(rating, index) for index, rating in enumerate(ratings)]\n        n = len(ratings); ratins.sort(); candies = [-1] * n\n        for rating, index in ratins:\n            candies[index] = 1\n            if index - 1 >= 0 and rating > ratings[index - 1] and candies[index - 1] != -1:\n                candies[index] = max(candies[index], candies[index - 1] + 1)\n            if index + 1 < n and rating > ratings[index + 1] and candies[index + 1] != -1:\n                candies[index] = max(candies[index], candies[index + 1] + 1)\n        return sum(candies)",
        "runtime": "149"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        n=len(ratings)\n        sortedArr=[(ratings[i],i) for i in range(n)]\n        sortedArr.sort(key=lambda x:(x[0],x[1]))\n        ans=[0]*n\n        for i in range(n):\n            curCandies=1\n            val,index=sortedArr[i]\n            if (index>0 and ratings[index-1]<ratings[index] and ans[index-1]>=curCandies):\n                curCandies=ans[index-1]+1\n            if (index<n-1 and ratings[index+1]<ratings[index] and ans[index+1]>=curCandies):\n                curCandies=ans[index+1]+1\n                    \n            prev=val\n            ans[index]=curCandies\n        return sum(ans)\n            \n            \n        ",
        "runtime": "149"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        ratins = [(rating, index) for index, rating in enumerate(ratings)]\n        n = len(ratings); ratins.sort(); candies = [-1] * n\n        for rating, index in ratins:\n            candies[index] = 1\n            if index - 1 >= 0 and rating > ratings[index - 1] and candies[index - 1] != -1:\n                candies[index] = max(candies[index], candies[index - 1] + 1)\n            if index + 1 < n and rating > ratings[index + 1] and candies[index + 1] != -1:\n                candies[index] = max(candies[index], candies[index + 1] + 1)\n        return sum(candies)",
        "runtime": "150"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n\n        n = len(ratings)\n\n        candy = dict()\n\n        for i in range(0, n):\n            candy[i] = None\n\n        candy[0] = 1\n\n        for i in range(0, n - 1):\n            if ratings[i + 1] > ratings[i]:\n                candy[i + 1] = candy[i] + 1\n            else:\n                candy[i + 1] = 1\n            \n        for i in range(n - 1, 0, -1):\n            if ratings[i - 1] > ratings[i] and candy[i - 1] <= candy[i]:\n                candy[i - 1] = candy[i] + 1\n                \n        s = 0\n        for i in range(0, n):\n            s += candy[i]\n\n        return s\n\n\n\n\n\n\n\n        \n        \n\n\n\n\n",
        "runtime": "150"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        candy_allocation = [0 for _ in range(len(ratings))]\n        num_of_children_got_candy = 0\n        candies_distributed = 0\n        ratings_index = {}\n        for i, n in enumerate(ratings):\n            if n not in ratings_index:\n                ratings_index[n] = []\n            ratings_index[n].append(i)\n        sorted_ratings = sorted(set(ratings))\n        for rating in sorted_ratings:\n            indexes = ratings_index[rating]\n            for i in indexes:\n                right_neighbor = 0\n                left_neighbor = 0\n                if i <= len(ratings) - 2 and ratings[i+1] < ratings[i]:  # right neihbor\n                    right_neighbor = candy_allocation[i+1]\n                if i > 0 and ratings[i-1] < ratings[i]:\n                    left_neighbor = candy_allocation[i-1]\n                max_neighbors_candies = max(right_neighbor, left_neighbor)\n                candy_allocation[i] = max_neighbors_candies + 1\n                candies_distributed += candy_allocation[i]\n                num_of_children_got_candy += 1\n\n        return candies_distributed\n",
        "runtime": "153"
      },
      {
        "code": "from collections import deque\n\nclass Solution:\n    def candy(self, ratings: List[int]) -> int:\n        # visit from lowest to highest rating\n        # greedy\n\n        ratings_indexed = [(x, i) for i, x in enumerate(ratings)]\n        ratings_indexed.sort(key = lambda x : x[0])\n\n        candies = [0 for _ in ratings]\n\n        for r, i in ratings_indexed:\n            v = 1\n\n            if i > 0 and candies[i - 1] and ratings[i - 1] < ratings[i]:\n                v = max(candies[i - 1] + 1, v)\n            \n            if i < len(ratings) - 1 and candies[i + 1] and ratings[i + 1] < ratings[i]:\n                v = max(candies[i + 1] + 1, v)\n\n            candies[i] = v\n\n        return sum(candies)\n\n",
        "runtime": "154"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        total_ratings = len(ratings)\n        distribution, total_candies = [1] * total_ratings, 0\n        ratings_table = dict()\n        for idx, rating in enumerate(ratings):\n            if rating not in ratings_table.keys():\n                ratings_table.update({rating: []})\n            ratings_table[rating].append(idx)\n        \n        distinct_ratings = list(ratings_table.keys())\n        distinct_ratings.sort()\n        # Lowest ratings all have one candy.\n        total_candies += len(ratings_table[distinct_ratings.pop(0)])\n        for distinct_rating in distinct_ratings:\n            for idx in ratings_table[distinct_rating]:\n                if idx > 0 and ratings[idx] > ratings[idx - 1]:\n                    distribution[idx] = max(distribution[idx], distribution[idx - 1] + 1)\n                \n                if idx < total_ratings - 1 and ratings[idx] > ratings[idx + 1]:\n                    distribution[idx] = max(distribution[idx], distribution[idx + 1] + 1)\n                \n                total_candies += distribution[idx]\n\n        return total_candies\n",
        "runtime": "155"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        n = len(ratings)\n        if n == 1:\n            return 1\n        ans = [0] * n\n        q = deque()\n        for i in range(n):\n            if i == 0:\n                if ratings[i] <= ratings[i + 1]:\n                    ans[0] = 1\n                    q.append(0)\n            elif i == n - 1:\n                if ratings[i] <= ratings[i - 1]:\n                    ans[n - 1] = 1\n                    q.append(n - 1)\n            else:\n                if ratings[i - 1] >= ratings[i] <= ratings[i + 1]:\n                    ans[i] = 1\n                    q.append(i)\n\n        vis = [0] * n\n        while q:\n            c = q.popleft()\n            if vis[c]:\n                continue\n            vis[c] += 1\n            if 0 <= c + 1 < n and ratings[c + 1] > ratings[c]:\n                ans[c + 1] = max(ans[c + 1], ans[c] + 1)\n                q.append(c + 1)\n            if 0 <= c - 1 < n and ratings[c - 1] > ratings[c]:\n                ans[c - 1] = max(ans[c - 1], ans[c] + 1)\n                q.append(c - 1)\n\n        return sum(ans)",
        "runtime": "156"
      },
      {
        "code": "class Solution:        \n    def candy(self, ratings: List[int]) -> int:\n        d = defaultdict(list)\n        candy_arr = [0] * len(ratings)\n        for i in range(len(ratings)):\n            d[ratings[i]].append(i)\n        for child in sorted(d):\n            children_index = d[child]\n            for child_index in children_index:\n                left_rating = 0 if child_index == 0 else ratings[child_index-1]\n                right_rating = 0 if child_index == len(ratings) - 1 else ratings[child_index+1]\n                left_num_candies = 0 if child_index == 0 else candy_arr[child_index-1]\n                right_num_candies = 0 if child_index == len(ratings) - 1 else candy_arr[child_index+1]\n                if ratings[child_index] > max(left_rating, right_rating):\n                    candy_arr[child_index] = max(left_num_candies, right_num_candies) + 1\n                elif ratings[child_index] > left_rating:\n                    candy_arr[child_index] = left_num_candies + 1\n                elif ratings[child_index] > right_rating:\n                    candy_arr[child_index] = right_num_candies + 1\n                else:\n                    candy_arr[child_index] = 1\n        return sum(candy_arr)\n",
        "runtime": "157"
      },
      {
        "code": "from collections import deque\n\nclass Solution:\n    def candy(self, ratings: List[int]) -> int:\n        # visit from lowest to highest rating\n        # greedy\n\n        ratings_indexed = [(x, i) for i, x in enumerate(ratings)]\n        ratings_indexed.sort(key = lambda x : x[0])\n\n        candies = [0 for _ in ratings]\n\n        for r, i in ratings_indexed:\n            v = 1\n\n            if i > 0 and candies[i - 1] and ratings[i - 1] < ratings[i]:\n                v = max(candies[i - 1] + 1, v)\n            \n            if i < len(ratings) - 1 and candies[i + 1] and ratings[i + 1] < ratings[i]:\n                v = max(candies[i + 1] + 1, v)\n\n            candies[i] = v\n\n        return sum(candies)\n\n",
        "runtime": "158"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        \n        \n        sorted_ratings = sorted(enumerate(ratings), key=lambda x: x[1]) # rating values are in [1]\n        n = len(sorted_ratings)\n        min_tot_candies = 0\n        dp = [1] * n\n        for i in range(1, n):\n            curr_id = sorted_ratings[i][0]\n            if curr_id-1 >= 0 and ratings[curr_id-1] < sorted_ratings[i][1] and curr_id + 1 < n and ratings[curr_id+1] < sorted_ratings[i][1] :\n                dp[curr_id] = max(dp[curr_id-1], dp[curr_id+1]) + 1\n            elif curr_id-1 >= 0 and ratings[curr_id-1] < sorted_ratings[i][1]:\n                dp[curr_id] = dp[curr_id-1] + 1\n            elif curr_id+1 < n and ratings[curr_id+1] < sorted_ratings[i][1]:\n                dp[curr_id] = dp[curr_id+1] + 1\n\n            min_tot_candies += dp[curr_id]\n        \n        return min_tot_candies+1\n\n\n                ",
        "runtime": "159"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        ratings_new = sorted((rating, ndx) for ndx, rating in enumerate(ratings))\n        dp = [0 for _ in range(len(ratings))]\n        \n        for curr, ndx in ratings_new:\n            dp[ndx] = 1\n            left = ndx - 1\n            right = ndx + 1\n            if ndx and ratings[left] < ratings[ndx]:\n                dp[ndx] = max(dp[ndx], 1 + dp[left])\n            if ndx < len(ratings) - 1 and ratings[right] < ratings[ndx]:\n                dp[ndx] = max(dp[ndx], 1 + dp[right])\n        return sum(dp)\n\n\n        \n        ",
        "runtime": "159"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        candies = [1 for _ in ratings]\n\n        fixpoint = False\n        while not fixpoint:\n            fixpoint = True\n            for i,c in enumerate(candies):\n                this_child = ratings[i]\n                \n                if i > 0 and ratings[i-1] < ratings[i] and candies[i-1] >= candies[i] : \n                    candies[i] = candies[i-1]+1\n                    fixpoint = False\n                \n                if i < len(candies)-1 and ratings[i+1] < ratings[i] and candies[i+1] >= candies[i] : \n                    candies[i] = candies[i+1]+1\n                    fixpoint = False\n\n            for i,c in reversed(list(enumerate(candies))):\n                this_child = ratings[i]\n                \n                if i > 0 and ratings[i-1] < ratings[i] and candies[i-1] >= candies[i] : \n                    candies[i] = candies[i-1]+1\n                    fixpoint = False\n                \n                if i < len(candies)-1 and ratings[i+1] < ratings[i] and candies[i+1] >= candies[i] : \n                    candies[i] = candies[i+1]+1\n                    fixpoint = False\n            \n        return sum(candies)\n        ",
        "runtime": "161"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        total_ratings = len(ratings)\n        distribution, total_candies = [1] * total_ratings, 0\n        ratings2indices = dict()\n        for idx, rating in enumerate(ratings):\n            if rating not in ratings2indices.keys():\n                ratings2indices.update({rating: []})\n            ratings2indices[rating].append(idx)\n        \n        distinct_ratings = sorted(ratings2indices.keys())\n        # Lowest ratings all have one candy.\n        total_candies += len(ratings2indices[distinct_ratings.pop(0)])\n        for distinct_rating in distinct_ratings:\n            for idx in ratings2indices[distinct_rating]:\n                if idx > 0 and ratings[idx] > ratings[idx - 1]:\n                    distribution[idx] = max(distribution[idx], distribution[idx - 1] + 1)\n                \n                if idx < total_ratings - 1 and ratings[idx] > ratings[idx + 1]:\n                    distribution[idx] = max(distribution[idx], distribution[idx + 1] + 1)\n                \n                total_candies += distribution[idx]\n\n        return total_candies\n",
        "runtime": "162"
      }
    ],
    "runtime_moderate_codes": [
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n\n        candies = [1]*len(ratings)\n\n        for i in range(1,len(ratings)):\n            if ratings[i] > ratings[i-1]:\n                candies[i] = candies[i-1]+1\n\n        for i in range(len(ratings)-2,-1,-1):\n            if ratings[i]>ratings[i+1]:\n                candies[i] = max(candies[i], candies[i+1] + 1)\n\n        return sum(candies)\n\n\n\n\n\n\"\"\"\ncount - 1 +2 +1 \n\n4 3 2 1\n\n1 1 1 1\n4  3 2 1\n3\n\n2 1 2 1\n\"\"\"",
        "runtime": "105"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        n = len(ratings)\n        candies = [1] * n\n\n        for i in range(1,n):\n            if ratings[i] > ratings[i-1] and candies[i] <= candies[i-1]:\n                candies[i] = candies[i-1] + 1\n        \n        for i in range(n-2, -1, -1):\n            if ratings[i] > ratings[i+1] and candies[i] <= candies[i+1]:\n                candies[i] = candies[i+1] + 1\n\n        total_candies = 0\n        for num in candies:\n            total_candies += num\n            \n        return total_candies\n",
        "runtime": "106"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        S=[1]*len(ratings)\n        for H in range(1,len(ratings)):\n            if ratings[H]>ratings[H-1] and S[H]<=S[H-1]:\n                S[H]=S[H-1]+1\n        for H in range(len(ratings)-2,-1,-1):\n            if ratings[H+1]<ratings[H] and S[H+1]>=S[H]:\n                S[H]=S[H+1]+1\n        return sum(S)\n",
        "runtime": "107"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        n = len(ratings)\n        candies = [1]*n\n        for i in range(1, n):\n            if ratings[i] > ratings[i-1]:\n                candies[i] = candies[i-1]+1\n        \n        for i in range(n-2,-1,-1):\n            if ratings[i] > ratings[i+1]:\n                candies[i] = max(candies[i], candies[i+1]+1)\n        return sum(candies)",
        "runtime": "108"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        S=[1]*len(ratings)\n        for H in range(1,len(ratings)):\n            if ratings[H]>ratings[H-1] and S[H]<=S[H-1]:\n                S[H]=S[H-1]+1\n        for H in range(len(ratings)-2,-1,-1):\n            if ratings[H+1]<ratings[H] and S[H+1]>=S[H]:\n                S[H]=S[H+1]+1\n        return sum(S)\n              ",
        "runtime": "109"
      },
      {
        "code": "# [1, 0, 2] -> [3, 1 ,5]\n# [1, 2, 2] -> [2, 4, 3]\n\n\n# [1, 1, 1] -> [1, 2, 1]\n\n# [1, 0, 2, 0, 5, 4, 3]\n# - [1, 1, 1, 1, 1, 1, 1]\n# - [2, 1, 2, 1, 3, 2, 1]\n\n\n# Trick is probably to greedily distribute the minimum candy\n# For each kid based on their surroundings\n# Then we take care of the edge cases...this allows us to make \n# optimum choices at each position.\n\n# If it's a trough, do nothing\n# [..., 2, 1, 2, ...]\n\n# If it's a peak,\n# [..., 1, 2, 1, ...]\n\n# if it's the same \n# [..., 1, 1, 2, ...]\n\n# Issues come with a decreasing/increasing peak\n# [..., 1, 2, 3, ...] or [..., 3, 2, 1, ...]\n\n\nclass Solution:\n    def candy(self, ratings: List[int]) -> int:\n        if len(ratings) == 1:\n            return 1\n\n        bins = [1] * len(ratings) # all childs must have at least 1\n\n        for i in range(1, len(bins)):                \n            # current larger than left\n            if ratings[i - 1] < ratings[i]:\n                bins[i] = bins[i - 1] + 1\n                \n        for i in range(len(bins) - 2, -1, -1):\n            # if current larger than right\n            if ratings[i] > ratings[i + 1]:\n                bins[i] = max(bins[i], bins[i + 1] + 1)\n\n        return sum(bins)\n\n\n\n# [1, 0, 2] -> [3, 1 ,5]\n# [1, 2, 2] -> [2, 4, 3]\n\n\n# [1, 1, 1] -> [1, 2, 1]\n\n# [1, 0, 2, 0, 5, 4, 3]\n# - [1, 1, 1, 1, 1, 1, 1]\n# - [2, 1, 2, 1, 3, 2, 1]\n\n\n# Trick is probably to greedily distribute the minimum candy\n# For each kid based on their surroundings\n# Then we take care of the edge cases...this allows us to make \n# optimum choices at each position.\n\n# If it's a trough, do nothing\n# [..., 2, 1, 2, ...]\n\n# If it's a peak,\n# [..., 1, 2, 1, ...]\n# [..., 4, 1, 1, ...]\n\n# if it's the same \n# [..., 1, 1, 1, ...]\n\n# Issues come with a decreasing/increasing peak\n# [..., 1, 2, 3, ...] or [..., 3, 2, 1, ...]\n\n\n# class Solution:\n#     def candy(self, ratings: List[int]) -> int:\n#         if len(ratings) == 1:\n#             return 1\n\n#         bins = [1] * len(ratings) # all childs must have at least 1\n\n#         for i in range(1, len(bins) - 1):\n#             # Handle trough - one less than right\n#             if ratings[i - 1] > ratings[i] < ratings[i + 1]:\n#                 bins[i] = bins[i - 1] - 1\n\n#             # Handle peaks - one more than left\n#             if ratings[i - 1] < ratings[i] > ratings[i + 1]:\n#                 bins[i] = bins[i - 1] + 1\n\n#             # Handle increasing slope - needs to have at least the same as current\n#             if ratings[i - 1] < ratings[i] < ratings[i + 1]:\n#                 bins[i + 1] = bins[i] = bins[i - 1] + 1\n\n#         if ratings[0] > ratings[1]:\n#             bins[0] = bins[1] + 1\n\n#         if ratings[-1] > ratings[-2]:\n#             bins[-1] = bins[-2] + 1\n\n#         return sum(bins)\n",
        "runtime": "109"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        res = [1] * len(ratings)\n        for i in range(1, len(ratings)):\n            if ratings[i] > ratings[i - 1]:\n                res[i] = res[i - 1] + 1\n        for i in range(len(ratings) - 2, -1, -1):\n            if ratings[i] > ratings[i + 1] and res[i] <= res[i + 1]:\n                res[i] = res[i + 1] + 1\n        return sum(res) ",
        "runtime": "110"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        n_current = 1\n        n_total = 1\n        t_descend = 0\n        n_peak = 1\n        for i, r in enumerate(ratings[1:]):\n            if r > ratings[i]:\n                n_current += 1\n            else:\n                n_current = 1\n            if r < ratings[i]:\n                t_descend += 1\n                n_total += (t_descend - 1) + (n_peak <= (n_current+t_descend-1))\n            else:\n                t_descend = 0\n                n_peak = n_current\n            n_total += n_current\n        return n_total\n",
        "runtime": "111"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        total_candy = 0\n        tmp = 0\n        pre_candy = 1\n        local_max_candy = 0\n        for i in range(len(ratings)):\n            if i == 0 or ratings[i] < ratings[i-1]:\n                tmp += 1\n                if local_max_candy == tmp:\n                    tmp += 1\n                    local_max_candy = 0\n                total_candy += tmp\n                pre_candy = 1\n            elif ratings[i] == ratings[i-1]:\n                tmp = 1\n                total_candy += 1\n                pre_candy = 1\n                local_max_candy = 0\n            else:\n                tmp = 0\n                pre_candy += 1 \n                total_candy += pre_candy\n                local_max_candy = pre_candy\n        return total_candy",
        "runtime": "112"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        n = len(ratings)\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        \n        # \u521d\u59cb\u72c0\u614b\n        total_candies = 1\n        up = 1\n        down = 0\n        peak = 1\n        \n        for i in range(1, n):\n            if ratings[i] > ratings[i-1]:\n                # \u5347\u9ad8\u5761\n                up += 1\n                peak = up  # \u8a18\u9304\u7576\u524d\u7684\u6700\u9ad8\u5cf0\n                down = 0   # \u91cd\u7f6e\u4e0b\u964d\u671f\n                total_candies += up\n            elif ratings[i] < ratings[i-1]:\n                # \u4e0b\u964d\u5761\n                down += 1\n                up = 1     # \u91cd\u7f6e\u4e0a\u5347\u671f\n                total_candies += down\n                if down >= peak:\n                    total_candies += 1  # \u82e5\u4e0b\u964d\u8d85\u904e\u5cf0\u503c\uff0c\u9700\u88dc\u5145\u591a\u4e00\u9846\u7cd6\u679c\n            else:\n                # \u8a55\u5206\u5e73\u7b49\u6642\uff0c\u5206\u914d\u4e00\u9846\u7cd6\u679c\n                up = 1\n                down = 0\n                peak = 1\n                total_candies += 1\n\n        return total_candies",
        "runtime": "113"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        n = len(ratings)\n        candies = [1] * n\n\n        for i in range(1, n):\n            if ratings[i] > ratings[i - 1]:\n                candies[i] = candies[i - 1] + 1\n            \n        for i in range(n - 2, -1, -1):\n            if ratings[i] > ratings[i + 1]:\n                candies[i] = max(candies[i], candies[i + 1] + 1)\n\n        return sum(candies)",
        "runtime": "113"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        n = len(ratings)\n        candies = [1] * n \n\n        for i in range(1, n):\n            if ratings[i] > ratings[i-1]:\n                candies[i] = candies[i-1] + 1\n\n        for i in range(n-2, -1, -1):\n            if ratings[i] > ratings[i+1]:\n                candies[i] = max(candies[i], candies[i+1] + 1)\n        \n        return sum(candies)",
        "runtime": "114"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        peak = ratings[0]\n        candy = [1]*len(ratings)\n        candies = 0\n\n        for i in range(1,len(ratings)):\n            if ratings[i] > ratings[i-1]:\n                candy[i] = candy[i-1] + 1\n\n        for b in range(len(ratings)-2,-1,-1):\n            if ratings[b] > ratings[b+1]:\n                candy[b] = max(candy[b], candy[b + 1] + 1)\n        \n        for i in range(len(candy)):\n            candies += candy[i]\n        return candies",
        "runtime": "115"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        a = ratings\n        length = len(a)\n        candy = [1]*length\n\n        for i in range(1,length):\n            if a[i]>a[i-1]:\n                candy[i] = 1+candy[i-1]\n\n        for i in range(length-1,0,-1):\n            if a[i]<a[i-1]:\n                if candy[i]>=candy[i-1]:\n                    candy[i-1] = candy[i]+1\n\n        return sum(candy)",
        "runtime": "115"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        length = len(ratings)\n        candies = [1] * length\n        for i in range(1, length):\n            if (ratings[i] > ratings[i - 1]):\n                candies[i] = candies[i - 1] + 1\n        for i in range(length - 2, -1, -1):\n            if (ratings[i] > ratings[i + 1]):\n                candies[i] = max(candies[i], candies[i + 1] + 1)\n        return sum(candies)\n",
        "runtime": "116"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        # Each child needs 1 candy\n        candies = [1] * len(ratings)\n        \n        # Ensure each child has more candies than the child before it if it should\n        for i in range(1, len(ratings)):\n            if ratings[i] > ratings[i - 1]:\n                candies[i] = candies[i - 1] + 1\n\n        for i in range(len(ratings) - 2, -1, -1):\n            if ratings[i] > ratings[i + 1] and candies[i] <= candies[i + 1]:\n                candies[i] = candies[i + 1] + 1\n        return sum(candies)",
        "runtime": "116"
      },
      {
        "code": "from typing import List\n\nclass Solution:\n    def candy(self, ratings: List[int]) -> int:\n        n = len(ratings)\n        if n <= 1:\n            return n\n\n        total_candies = 1  # Start with one candy for the first child\n        up = 1            # Length of the last ascending sequence\n        down = 0          # Length of the last descending sequence\n        peak = 1          # Candies at the peak of the last ascending sequence\n\n        for i in range(1, n):\n            if ratings[i] > ratings[i - 1]:\n                up += 1\n                peak = up\n                down = 0\n                total_candies += up\n            elif ratings[i] == ratings[i - 1]:\n                up = 1\n                down = 0\n                peak = up\n                total_candies += up\n            else:\n                down += 1\n                up = 1\n                total_candies += down\n                if down >= peak:\n                    # Add one extra candy to the peak child\n                    total_candies += 1\n\n        return total_candies",
        "runtime": "117"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings) -> int:\n        n = len(ratings)  # Get the number of children\n        \n        candies = [1] * n  # Initialize a list to store the number of candies for each child\n        \n        # First pass: Check ratings from left to right\n        for i in range(1, n):\n            if ratings[i - 1] < ratings[i] and candies[i - 1] >= candies[i]:\n                # If the current child has a higher rating and fewer or equal candies than the previous child,\n                # give them one more candy than the previous child\n                candies[i] = candies[i - 1] + 1\n        \n        # Second pass: Check ratings from right to left\n        for i in range(n - 2, -1, -1):\n            if ratings[i + 1] < ratings[i] and candies[i + 1] >= candies[i]:\n                # If the current child has a higher rating and fewer or equal candies than the next child,\n                # give them one more candy than the next child\n                candies[i] = candies[i + 1] + 1\n        \n        total_candies = sum(candies)  # Calculate the total number of candies needed\n        \n        return total_candies",
        "runtime": "118"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        l=len(ratings)\n        c=[1]*l\n        for i in range(1,l):\n            if(ratings[i]>ratings[i-1]):\n                c[i]=c[i-1]+1\n        for i in range(l-2,-1,-1):\n            if(ratings[i]>ratings[i+1]):\n                c[i]=max(c[i],c[i+1]+1)\n        return sum(c)                \n\n        \n        ",
        "runtime": "119"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        n = len(ratings)\n        candies = [1] * n \n\n        for i in range(1, n):\n            if ratings[i] > ratings[i-1]:\n                candies[i] = candies[i-1] + 1\n\n        for i in range(n-2, -1, -1):\n            if ratings[i] > ratings[i+1]:\n                candies[i] = max(candies[i], candies[i+1] + 1)\n        \n        return sum(candies)",
        "runtime": "119"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        # res = [1] * len(ratings)\n\n        # for i in range(1, len(ratings)):\n        #     if ratings[i] > ratings[i - 1]:\n        #         res[i] = res[i - 1] + 1\n        \n        # for i in range(len(ratings) - 2, -1, -1):\n        #     if ratings[i] > ratings[i + 1]:\n        #         res[i] = max(res[i + 1] + 1, res[i])\n        \n        # return sum(res)\n\n        if not ratings:\n            return 0\n        \n        ret, up, down, peak = 1, 0, 0, 0\n        \n        for prev, curr in zip(ratings[:-1], ratings[1:]):\n            if prev < curr:\n                up, down, peak = up + 1, 0, up + 1\n                ret += 1 + up\n            elif prev == curr:\n                up = down = peak = 0\n                ret += 1\n            else:\n                up, down = 0, down + 1\n                ret += 1 + down - int(peak >= down)\n        \n        return ret\n",
        "runtime": "120"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        c=[1]*(len(ratings))\n        for i in range(1,len(ratings)):\n            if ratings[i]>ratings[i-1]:\n                c[i]=c[i-1]+1\n        for j in range(len(ratings)-2,-1,-1):\n            if ratings[j]>ratings[j+1]:\n                c[j] = max(c[j],c[j+1]+1)\n        return sum(c)\n\n\n            \n\n\n\n\n        ",
        "runtime": "120"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        n=len(ratings)\n        candies=[1]*n\n        for i in range(1,n):\n            if ratings[i]>ratings[i-1]:\n                candies[i]=candies[i-1]+1\n        \n        for i in range(n-2,-1,-1):\n            if ratings[i]>ratings[i+1]:\n                candies[i]=max(candies[i+1]+1,candies[i])\n        return sum(candies)",
        "runtime": "121"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        valleys = []\n\n        ratings = [10**5] + ratings + [10 **5]\n        temp = [0] * len(ratings)\n\n        for i in range(1, len(ratings)-1):\n            if ratings[i] <= ratings[i-1] and ratings[i] <= ratings[i+1]:\n                valleys.append(i)\n        \n        for v in valleys:\n            temp[v] = 1\n\n            left = v - 1\n            left_curr = 2\n            while left > 0:\n                if ratings[left] > ratings[left + 1]:\n                    temp[left] = max(left_curr, temp[left])\n                    left -= 1\n                    left_curr+=1\n                else:\n                    break\n\n            right = v + 1\n            right_curr = 2\n            while right < len(ratings):\n                if ratings[right] > ratings[right - 1]:\n                    temp[right] = max(right_curr, temp[right])\n                    right += 1\n                    right_curr+= 1\n                else:\n                    break\n        return sum(temp[1:len(temp)-1])\n\n\n        \n\n        ",
        "runtime": "122"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        \n        n = len(ratings)\n        candies = [1]*n\n\n        for i in range(1, n):\n            if ratings[i] > ratings[i-1]:\n                candies[i]=candies[i-1]+1\n            \n        for i in range(n-2, -1, -1):\n            if ratings[i] > ratings[i+1] and candies[i] <= candies[i+1]:\n                candies[i]=candies[i+1]+1\n\n        return sum(candies) ",
        "runtime": "122"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        len_ratings = len(ratings)\n        candies = [1] * len_ratings\n\n        for idx in range(1, len_ratings):\n            if ratings[idx] > ratings[idx - 1]:\n                candies[idx] = candies[idx - 1] + 1\n\n        for idx in reversed(range(len_ratings - 1)):\n            if ratings[idx] > ratings[idx + 1]:\n                candies[idx] = max(candies[idx + 1] + 1, candies[idx])\n\n        return sum(candies)",
        "runtime": "123"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        N=len(ratings)\n        ans=[1]*N\n\n        for i in range(N-1):\n            if ratings[i+1]>ratings[i]:\n                ans[i+1]=ans[i]+1\n            \n\n        for i in range(N-2,-1,-1):\n            if ratings[i]>ratings[i+1]:\n                ans[i]=max(ans[i],ans[i+1]+1)\n        \n\n        return sum(ans)",
        "runtime": "123"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        chiru=[1]\n        for i in range(1,len(ratings)):\n            chiru.append(1)\n            if ratings[i]>ratings[i-1]:\n                chiru[i]=chiru[i-1]+1\n        for i in range(len(ratings)-2,-1,-1):\n            if ratings[i]>ratings[i+1]:\n                chiru[i]=max(chiru[i],chiru[i+1]+1)\n        return sum(chiru)",
        "runtime": "124"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        n = len(ratings)\n        candies = [1] * n \n\n        for i in range(1, n):\n            if ratings[i] > ratings[i-1]:\n                candies[i] = candies[i-1] + 1\n\n        for i in range(n-2, -1, -1):\n            if ratings[i] > ratings[i+1]:\n                candies[i] = max(candies[i], candies[i+1] + 1)\n        \n        return sum(candies)\n",
        "runtime": "124"
      },
      {
        "code": "from typing import List\n\nclass Solution:\n    def candy(self, ratings: List[int]) -> int:\n        n = len(ratings)\n        if n == 1:\n            return 1\n        \n        candies = [1] * n  # Step 1: Give each child 1 candy initially\n\n        # Step 2: Left to Right pass\n        for i in range(1, n):\n            if ratings[i] > ratings[i - 1]:\n                candies[i] = candies[i - 1] + 1\n\n        # Step 3: Right to Left pass\n        for i in range(n - 2, -1, -1):\n            if ratings[i] > ratings[i + 1]:\n                candies[i] = max(candies[i], candies[i + 1] + 1)\n\n        # Step 4: Sum up all candies\n        return sum(candies)\n",
        "runtime": "125"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        n = len(ratings)\n        i = 1\n        s = 1\n        while(i<n):\n            if ratings[i] == ratings[i-1]:\n                s += 1\n                i += 1\n                continue\n            peak = 1\n            while(i < n and ratings[i] > ratings[i-1]):\n                peak += 1\n                s += peak\n                i += 1\n            down = 1\n            while(i<n and ratings[i] < ratings[i-1]):\n                s += down\n                down += 1\n                i += 1\n            if down >= peak:\n                s = s - peak + down\n        return s\n",
        "runtime": "125"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        n = len(ratings)\n        candies = [1 for i in range(n)]\n        for i in range(1,n):\n            if ratings[i] > ratings[i-1]:\n                candies[i] = candies[i-1] + 1\n        for i in range(n-2,-1,-1):\n            if ratings[i] > ratings[i+1]:\n                candies[i] = max(candies[i], candies[i+1] + 1)\n        return sum(candies)",
        "runtime": "126"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        res=[1]*len(ratings)\n        for i in range(1,len(ratings)):\n            if ratings[i]>ratings[i-1]:\n                res[i]=res[i-1]+1\n        for i in range(len(ratings)-2,-1,-1):\n            if ratings[i]>ratings[i+1]:\n                res[i]=max(res[i],res[i+1]+1)\n        return sum(res)\n        \n",
        "runtime": "127"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        arr=[1]*len(ratings)\n        for i in range(1,len(ratings)):\n            if(ratings[i-1]<ratings[i]):\n                arr[i]=arr[i-1]+1\n        for i in range(len(ratings)-2,-1,-1):\n            if(ratings[i]>ratings[i+1]):\n                arr[i]=max(arr[i],arr[i+1]+1)\n        return sum(arr)",
        "runtime": "128"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        n = len(ratings)\n        candy = [0]*n\n        candy[0] = 1\n        for i in range(1, n):\n            if ratings[i] > ratings[i-1]:\n                candy[i] = candy[i - 1] + 1\n            else:\n                candy[i] = 1\n        for i in range(n-2, -1, -1):\n            if ratings[i] > ratings[i+1]:\n                candy[i] = max (candy[i], candy[i+1] + 1)\n        return sum(candy)",
        "runtime": "128"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        rate=ratings\n        #rate=[1, 3, 4, 5, 2] #[0,2,1,0] [1 2 3 4 1 ] [1 2 3 4 1]\n        dp=[1]*(len(rate)) #[1 1 1 1 1] [1 2 3 4 1] [1 2 3 4 1]\n        #left pass\n        for each in range(1,len(rate)):\n            if rate[each]>rate[each-1]:\n                dp[each]= dp[each-1] + 1\n        #right pass\n        for each in range(len(rate)-2,-1,-1):\n            if rate[each]>rate[each+1]:\n                dp[each]= max(dp[each+1]+1,dp[each])\n        return sum(dp)\n        ",
        "runtime": "129"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        n = len(ratings)\n        left = [1] * n\n        right = [1] * n\n        for i in range(1, n):\n            if ratings[i] > ratings[i - 1]:\n                left[i] = left[i - 1] + 1\n            else:\n                left[i] = 1\n        for i in range(n - 2, -1, -1):\n            if ratings[i] > ratings[i + 1]:\n                right[i] = right[i + 1] + 1\n            else:\n                right[i] = 1\n        ans = 0\n        for i in range(n):\n            ans += max(left[i], right[i])\n        return ans\n        ",
        "runtime": "129"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        res = [1] * len(ratings)\n\n        for i in range(1, len(ratings)):\n            if ratings[i] > ratings[i - 1]:\n                res[i] = res[i - 1] + 1\n        \n        for i in range(len(ratings) - 2, -1, -1):\n            if ratings[i] > ratings[i + 1]:\n                res[i] = max(res[i + 1] + 1, res[i])\n        \n        return sum(res)\n",
        "runtime": "130"
      },
      {
        "code": "def candy(ratings):\n    n = len(ratings)\n    if n == 0:\n        return 0\n\n    total_candies = 1\n    inc = 1  # Length of the last increasing sequence\n    dec = 0  # Length of the last decreasing sequence\n    prev_candy = 1  # Candies given to the previous child\n\n    for i in range(1, n):\n        if ratings[i] >= ratings[i - 1]:\n            dec = 0\n            if ratings[i] == ratings[i - 1]:\n                prev_candy = 1\n            else:\n                prev_candy += 1\n            total_candies += prev_candy\n            inc = prev_candy\n        else:\n            dec += 1\n            if dec == inc:\n                dec += 1  # Ensure peak child has more candies\n            total_candies += dec\n            prev_candy = 1  # Reset for the next iteration\n\n    return total_candies\n\n\nclass Solution:\n    def candy(self, ratings: List[int]) -> int:\n        return candy(ratings)",
        "runtime": "131"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        S=[1]*len(ratings)\n        for H in range(1,len(ratings)):\n            if ratings[H]>ratings[H-1] and S[H]<=S[H-1]:\n                S[H]=S[H-1]+1\n        for H in range(len(ratings)-2,-1,-1):\n            if ratings[H+1]<ratings[H] and S[H+1]>=S[H]:\n                S[H]=S[H+1]+1\n        return sum(S)\n",
        "runtime": "132"
      },
      {
        "code": "class Solution:\n  def candy(self, ratings: list[int]) -> int:\n    n = len(ratings)\n\n    ans = 0\n    l = [1] * n\n    r = [1] * n\n\n    for i in range(1, n):\n      if ratings[i] > ratings[i - 1]:\n        l[i] = l[i - 1] + 1\n\n    for i in range(n - 2, -1, -1):\n      if ratings[i] > ratings[i + 1]:\n        r[i] = r[i + 1] + 1\n\n    for a, b in zip(l, r):\n      ans += max(a, b)\n\n    return ans",
        "runtime": "134"
      },
      {
        "code": "'''\n    len(ratings) == n\n\n    each child needs at least one candy\n    children with higher ratings than their neighbors need more candy than that neighbor\n        if children have the same ratings, they can have equal candy\n    \n\n    1 0 2\n\n        X\n    X   X\n\n\n    2 1 2 3 1 2\n    \n    1 0 2 4 0 3\n          X\n          X   X\n        X X   X\n    X   X X   X\n\n    0 0 1 2 0 1\n    1 0 0 1 0 0\n\n\n          X\n    X   X X   X\n    X X X X X X\n    2 1 2 3 1 2\n\n\n'''\n\nclass Solution:\n    def candy(self, ratings: List[int]) -> int:\n        forward = [0] * len(ratings)\n        backward = [0] * len(ratings)\n        \n        b = len(ratings) - 2\n        for f in range(1, len(ratings)):\n\n            if ratings[f] > ratings[f - 1]:\n                forward[f] = forward[f - 1] + 1\n\n            if ratings[b] > ratings[b + 1]:\n                backward[b] = backward[b + 1] + 1\n                \n            b -= 1\n\n        totalCandy = len(ratings)\n        for i in range(len(ratings)):\n            totalCandy += max(forward[i], backward[i])\n        \n        return totalCandy",
        "runtime": "134"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        n = len(ratings); lcandies = [1] * n; rcandies = [1] * n; result = 0\n        for i in range(1, n):\n            if ratings[i] > ratings[i - 1]: lcandies[i] += lcandies[i - 1]\n        for i in range(n - 2, - 1, -1):\n            if ratings[i] > ratings[i + 1]: rcandies[i] += rcandies[i + 1]\n        for i in range(n): result += max(lcandies[i], rcandies[i])\n        return result",
        "runtime": "135"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        n = len(ratings)\n        candies = [1] * n \n\n        for i in range(1, n):\n            if ratings[i] > ratings[i-1]:\n                candies[i] = candies[i-1] + 1\n\n        for i in range(n-2, -1, -1):\n            if ratings[i] > ratings[i+1]:\n                candies[i] = max(candies[i], candies[i+1] + 1)\n        \n        return sum(candies)     ",
        "runtime": "137"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        n = len(ratings)\n        candies = [1] * n\n\n        for i in range(1, n):\n            if ratings[i] > ratings[i-1]:\n                candies[i] = candies[i-1] + 1\n        \n        for i in range(n-2,-1,-1):\n            if  ratings[i] > ratings[i+1]:\n                candies[i] = max(candies[i], candies[i+1] +1)\n        \n        total = 0\n        for i in range(n):\n            total += candies[i]\n        \n        return total\n",
        "runtime": "137"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        arr1 = [1] * len(ratings)\n        for i in range(1,len(ratings)) :\n            if ratings[i] > ratings[i - 1] :\n                arr1[i] = arr1[i - 1] + 1\n\n        arr2 = [1] * len(ratings)\n        for i in range(2,len(ratings) + 1) :\n            if ratings[-i] > ratings[-i + 1] :\n                arr2[-i] = arr2[-i + 1] + 1\n        answer = 0\n        for i in range(len(ratings)) :\n            answer += max(arr1[i], arr2[i])\n        return answer\n\n        ",
        "runtime": "138"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        n = len(ratings)\n        candies = [1 for _ in ratings]\n        \n        for i in range(1,n):\n            if ratings[i] > ratings[i-1]:\n                candies[i] += candies[i-1]\n\n        for i in range(n-2, -1,-1):\n            if ratings[i] > ratings[i + 1]:\n                candies[i] += candies[i+1]\n        \n        peaks = [i for i in range(1,n-1) if ratings[i] > max(ratings[i-1],ratings[i+1])]\n        for i in peaks:\n            candies[i] = max(candies[i-1], candies[i+1]) + 1\n        return sum(candies)\n",
        "runtime": "138"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        n = len(ratings)\n        left = [0 for i in range(n)]\n        right = [0 for i in range(n)]\n        left[0] = 1\n        right[n - 1] = 1\n        for i in range(1, n):\n            if ratings[i] > ratings[i - 1]:\n                left[i] = left[i - 1] + 1\n            else:\n                left[i] = 1\n        for j in range(n - 2, -1, -1):\n            if ratings[j] > ratings[j + 1]:\n                right[j] = right[j + 1] + 1\n            else:\n                right[j] = 1\n        sumi = 0\n        for i in range(n):\n            sumi += max(left[i], right[i])\n        return sumi\n\n            \n\n\n",
        "runtime": "141"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        n=len(ratings)\n        sortedArr=[(ratings[i],i) for i in range(n)]\n        sortedArr.sort()\n        ans=[0]*n\n        for i in range(n):\n            curCandies=1\n            val,index=sortedArr[i]\n            if (index>0 and ratings[index-1]<ratings[index] and ans[index-1]>=curCandies):\n                curCandies=ans[index-1]+1\n            if (index<n-1 and ratings[index+1]<ratings[index] and ans[index+1]>=curCandies):\n                curCandies=ans[index+1]+1\n                    \n            prev=val\n            ans[index]=curCandies\n        return sum(ans)\n            \n            \n        ",
        "runtime": "142"
      }
    ],
    "runtime_efficient_codes": [
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        counts = [1] * len(ratings)\n\n        for i in range(1, len(ratings)):\n            if ratings[i] > ratings[i - 1]:\n                counts[i] = counts[i - 1] + 1\n        \n        for i in range(len(ratings) - 2, -1, -1):\n            if ratings[i] > ratings[i + 1] and counts[i] <= counts[i + 1]:\n                counts[i] = counts[i + 1] + 1\n\n        return sum(counts)",
        "runtime": "96"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        candies = [1] * len(ratings)\n\n        #l->r loop:\n\n        for i in range(1,len(ratings)):\n\n            if ratings[i] > ratings[i - 1]:\n                candies[i] = candies[i - 1] + 1\n        \n        #r->l loop:\n\n        for i in range(len(ratings)-2,-1,-1):\n\n            if ratings[i]  > ratings[i + 1]:\n                if candies[i] < candies[i + 1] + 1:\n                    candies[i] = candies[i + 1] + 1\n\n        return sum(candies)",
        "runtime": "100"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        n = len(ratings)\n        arr = [1] * n\n\n        for i in range(1, n):\n            if ratings[i - 1] < ratings[i]:\n                arr[i] = arr[i - 1] + 1\n        \n        for i in range(n - 2, -1, -1):\n            if ratings[i + 1] < ratings[i]:\n                arr[i] = max(arr[i], arr[i + 1] + 1)\n        \n        total = 0\n        for val in arr:\n            total += val\n        \n        return total",
        "runtime": "102"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        # the candy for each child is the max increase sequence for left and right\n        # we need to track increasing\n        # we can track last peak as when we decend we might want to increase the peak\n        # how do we handle the descent how can we one pass this?\n        # we dont need to track in the normal sense we can just add \n        res = 1\n        n = len(ratings)\n        peak = 0\n        hi = 1\n        lo = 0\n        for i in range(1, n):\n            if ratings[i] > ratings[i-1]:\n                hi += 1\n                peak = hi\n                res += hi\n                lo = 0\n            elif ratings[i] < ratings[i-1]:\n                lo += 1\n                res += lo\n                hi = 1\n                if lo >= peak:\n                    res += 1\n            else:\n                peak = 1\n                hi = 1\n                lo = 0\n                res += 1\n        return res\n\n\n        ",
        "runtime": "103"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        if len(ratings) == 1:\n            return 1\n            \n        candies = [1] * len(ratings)\n        length = len(ratings)\n        for i in range(1, length):\n            if ratings[i] - ratings[i -1 ] > 0:\n                candies[i] = candies[i - 1] + 1\n            \n        for i in range(length - 2, -1, -1):\n            if ratings[i] > ratings[i+1]:\n                candies[i] = max(candies[i + 1] + 1, candies[i])\n        return sum(candies)",
        "runtime": "104"
      }
    ],
    "memory_inefficient_codes": [
      {
        "code": "class Solution:\n    # Function to calculate sum of first n natural numbers\n    def count(self, n):\n        return (n * (n + 1)) // 2\n    def candy(self, ratings):\n        if len(ratings) <= 1:\n            return len(ratings)\n        candies = 0\n        up = 0\n        down = 0\n        oldSlope = 0\n        for i in range(1, len(ratings)):\n            newSlope = (\n                1\n                if ratings[i] > ratings[i - 1]\n                else (-1 if ratings[i] < ratings[i - 1] else 0)\n            )\n            # slope is changing from uphill to flat or downhill\n            # or from downhill to flat or uphill\n            if (oldSlope > 0 and newSlope == 0) or (\n                oldSlope < 0 and newSlope >= 0\n            ):\n                candies += self.count(up) + self.count(down) + max(up, down)\n                up = 0\n                down = 0\n            # slope is uphill\n            if newSlope > 0:\n                up += 1\n            # slope is downhill\n            elif newSlope < 0:\n                down += 1\n            # slope is flat\n            else:\n                candies += 1\n            oldSlope = newSlope\n        candies += self.count(up) + self.count(down) + max(up, down) + 1\n        return candies",
        "memory": "20200"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        candies = [0 for _ in range(len(ratings))]\n        minima = {}\n        m_list = []\n        if len(ratings) == 1: return 1\n        \n        # find local minima and set to 1\n        for x in range(len(ratings)):\n            if x == 0:\n                if ratings[0] <= ratings[1]:\n                    candies[0] = 1\n                    m_list.append(x)\n                    minima[x] = True\n                else:\n                    minima[x] = False\n            elif x == len(ratings)-1:\n                if ratings[-1] <= ratings[-2]:\n                    candies[-1] = 1\n                    m_list.append(x)\n                    minima[x] = True\n                else:\n                    minima[x] = False\n            else:\n                if ratings[x-1] >= ratings[x] and ratings[x] <= ratings[x+1]:\n                    candies[x] = 1\n                    m_list.append(x)\n                    minima[x] = True\n                else:\n                    minima[x] = False\n        \n        # all values before first minima are decreasing\n        for x in range(m_list[0]-1, -1, -1):\n            if not minima[x]:\n                candies[x] = max(candies[x+1] + 1, candies[x])\n        \n        # all values between first minima and maxima are increasing\n        for x in range(m_list[0]+1, len(candies)):\n            if not minima[x]:\n                candies[x] = max(candies[x-1] + 1, candies[x])\n            if x == len(candies)-1: break\n            if ratings[x]>=ratings[x-1] and ratings[x]>=ratings[x+1]: break\n\n        # all values after last minima are increasing\n        for x in range(m_list[-1]+1, len(candies)):\n            if not minima[x]:\n                candies[x] = max(candies[x-1] + 1, candies[x])\n\n        for x in range(m_list[-1]-1, -1, -1):\n            if not minima[x]:\n                candies[x] = max(candies[x+1] + 1, candies[x])\n            if ratings[x]>=ratings[x-1] and ratings[x]>=ratings[x+1]: break\n\n        for m in range(1, len(m_list)-1):\n            for x in range(m_list[m]-1, -1, -1):\n                if not minima[x]:\n                    candies[x] = max(candies[x+1] + 1, candies[x])\n                if ratings[x]>=ratings[x-1] and ratings[x]>=ratings[x+1]: break\n            for x in range(m_list[m]+1, len(candies)):\n                if not minima[x]:\n                    candies[x] = max(candies[x-1] + 1, candies[x])\n                if x == len(candies)-1: break\n                if ratings[x]>=ratings[x-1] and ratings[x]>=ratings[x+1]: break\n\n        return sum(candies)\n        \n\n\n\n\n        \n\n",
        "memory": "20300"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        forward_rankings = self.get_forward_ranking(ratings)\n        backward_rankings = reversed(self.get_forward_ranking(list(reversed(ratings))))\n        rankings = [max(frank, brank) for (frank, brank) in zip(forward_rankings, backward_rankings)]\n\n        norm = min(rankings) + 1\n        candies = [relative + norm for relative in rankings]\n\n        return sum(candies)\n\n    def get_forward_ranking(self, ratings):\n        rankings = [0 for _ in range(len(ratings))]\n        for i, (prev, curr) in enumerate(zip(ratings[:-1], ratings[1:])):\n            if prev < curr:\n                new = rankings[i] + 1\n            else:\n                new = 0\n            rankings[i + 1] = new\n\n        return rankings",
        "memory": "20500"
      },
      {
        "code": "from collections import deque\n\nclass Solution:\n    def candy(self, ratings: List[int]) -> int:\n        # visit from lowest to highest rating\n        # greedy\n\n        ratings_indexed = [(x, i) for i, x in enumerate(ratings)]\n        ratings_indexed.sort(key = lambda x : x[0])\n\n        candies = [0 for _ in ratings]\n\n        for r, i in ratings_indexed:\n            v = 1\n\n            if i > 0 and candies[i - 1] and ratings[i - 1] < ratings[i]:\n                v = max(candies[i - 1] + 1, v)\n            \n            if i < len(ratings) - 1 and candies[i + 1] and ratings[i + 1] < ratings[i]:\n                v = max(candies[i + 1] + 1, v)\n\n            candies[i] = v\n\n        return sum(candies)\n\n",
        "memory": "20700"
      },
      {
        "code": "from collections import deque\n\nclass Solution:\n    def candy(self, ratings: List[int]) -> int:\n        # visit from lowest to highest rating\n        # greedy\n\n        ratings_indexed = [(x, i) for i, x in enumerate(ratings)]\n        ratings_indexed.sort(key = lambda x : x[0])\n\n        candies = [0 for _ in ratings]\n\n        for r, i in ratings_indexed:\n            v = 1\n\n            if i > 0 and candies[i - 1] and ratings[i - 1] < ratings[i]:\n                v = max(candies[i - 1] + 1, v)\n            \n            if i < len(ratings) - 1 and candies[i + 1] and ratings[i + 1] < ratings[i]:\n                v = max(candies[i + 1] + 1, v)\n\n            candies[i] = v\n\n        return sum(candies)\n\n",
        "memory": "20700"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        ratins = [(rating, index) for index, rating in enumerate(ratings)]\n        n = len(ratings); ratins.sort(); candies = [-1] * n\n        for rating, index in ratins:\n            candies[index] = 1\n            if index - 1 >= 0 and rating > ratings[index - 1] and candies[index - 1] != -1:\n                candies[index] = max(candies[index], candies[index - 1] + 1)\n            if index + 1 < n and rating > ratings[index + 1] and candies[index + 1] != -1:\n                candies[index] = max(candies[index], candies[index + 1] + 1)\n        return sum(candies)",
        "memory": "20800"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        ratins = [(rating, index) for index, rating in enumerate(ratings)]\n        n = len(ratings); ratins.sort(); candies = [-1] * n\n        for rating, index in ratins:\n            candies[index] = 1\n            if index - 1 >= 0 and rating > ratings[index - 1] and candies[index - 1] != -1:\n                candies[index] = max(candies[index], candies[index - 1] + 1)\n            if index + 1 < n and rating > ratings[index + 1] and candies[index + 1] != -1:\n                candies[index] = max(candies[index], candies[index + 1] + 1)\n        return sum(candies)",
        "memory": "20800"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        n=len(ratings)\n        sortedArr=[(ratings[i],i) for i in range(n)]\n        sortedArr.sort()\n        ans=[0]*n\n        for i in range(n):\n            curCandies=1\n            val,index=sortedArr[i]\n            if (index>0 and ratings[index-1]<ratings[index] and ans[index-1]>=curCandies):\n                curCandies=ans[index-1]+1\n            if (index<n-1 and ratings[index+1]<ratings[index] and ans[index+1]>=curCandies):\n                curCandies=ans[index+1]+1\n                    \n            prev=val\n            ans[index]=curCandies\n        return sum(ans)\n            \n            \n        ",
        "memory": "20900"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        n=len(ratings)\n        sortedArr=[(ratings[i],i) for i in range(n)]\n        sortedArr.sort()\n        ans=[0]*n\n        for i in range(n):\n            curCandies=1\n            val,index=sortedArr[i]\n            if (index>0 and ratings[index-1]<ratings[index] and ans[index-1]>=curCandies):\n                curCandies=ans[index-1]+1\n            if (index<n-1 and ratings[index+1]<ratings[index] and ans[index+1]>=curCandies):\n                curCandies=ans[index+1]+1\n            ans[index]=curCandies\n        return sum(ans)\n            \n            \n        ",
        "memory": "20900"
      }
    ],
    "memory_moderate_codes": [
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        candies = [1 for _ in ratings]\n        n = len(ratings)\n        for i in range(1, n):\n            if ratings[i] > ratings[i - 1]:\n                candies[i] = max(candies[i], 1 + candies[i - 1])\n        for i in range(n - 2, -1, -1):\n            if ratings[i] > ratings[i + 1]: # and candies[i] <= candies[i + 1]:\n                candies[i] = max(candies[i], 1 + candies[i + 1])\n        return sum(candies)",
        "memory": "18700"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        n = len(ratings)\n        candies = [1] * n\n\n        for i in range(1, n):\n            if ratings[i] > ratings[i - 1]:\n                candies[i] = candies[i - 1] + 1\n\n        for i in range(n - 2, -1, -1):\n            if ratings[i] > ratings[i + 1]:\n                candies[i] = max(candies[i + 1] + 1, candies[i])\n        \n        return sum(candies)\n                \n        ",
        "memory": "18800"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        n = len(ratings)\n        res, up, down, peak = 1, 0, 0, 0\n        for i in range(1, n):\n            if ratings[i-1] < ratings[i]:\n                up += 1\n                peak = up\n                down = 0\n                res += up + 1\n            elif ratings[i-1] == ratings[i]:\n                up = down = peak = 0\n                res += 1\n            else:\n                down += 1\n                up = 0\n                res += 1 + down - int(peak >= down)\n        return res",
        "memory": "18800"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        arr=[1]*len(ratings)\n        for i in range(1,len(ratings)):\n            if(ratings[i-1]<ratings[i]):\n                arr[i]=arr[i-1]+1\n        for i in range(len(ratings)-2,-1,-1):\n            if(ratings[i]>ratings[i+1]):\n                arr[i]=max(arr[i],arr[i+1]+1)\n        return sum(arr)",
        "memory": "18900"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        n = len(ratings)\n        if n == 0:\n            return 0\n        \n        ans = [1] * n  # Initialize each child with 1 candy\n        \n        # First pass: left to right\n        for i in range(1, n):\n            if ratings[i] > ratings[i - 1]:\n                ans[i] = ans[i - 1] + 1  # Increase candy count based on left neighbor\n\n        # Second pass: right to left\n        for i in range(n - 2, -1, -1):\n            if ratings[i] > ratings[i + 1] and ans[i]<=ans[i+1]:\n                # Ensure each child gets more than the right neighbor if their rating is higher\n                ans[i] =ans[i + 1] + 1\n        \n        # Total candies is the sum of the list\n        return sum(ans)\n",
        "memory": "18900"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        rate=ratings\n        #rate=[1, 3, 4, 5, 2] #[0,2,1,0] [1 2 3 4 1 ] [1 2 3 4 1]\n        dp=[1]*(len(rate)) #[1 1 1 1 1] [1 2 3 4 1] [1 2 3 4 1]\n        #left pass\n        for each in range(1,len(rate)):\n            if rate[each]>rate[each-1]:\n                dp[each]= dp[each-1] + 1\n        #right pass\n        for each in range(len(rate)-2,-1,-1):\n            if rate[each]>rate[each+1]:\n                dp[each]= max(dp[each+1]+1,dp[each])\n        return sum(dp)\n        ",
        "memory": "19000"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        l=len(ratings)\n        c=[1]*l\n        for i in range(1,l):\n            if(ratings[i]>ratings[i-1]):\n                c[i]=c[i-1]+1\n        for i in range(l-2,-1,-1):\n            if(ratings[i]>ratings[i+1]):\n                c[i]=max(c[i],c[i+1]+1)\n        return sum(c)                \n\n        \n        ",
        "memory": "19000"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        n = len(ratings)\n        candies = [1 for i in range(n)]\n        for i in range(1,n):\n            if ratings[i] > ratings[i-1]:\n                candies[i] = candies[i-1] + 1\n        for i in range(n-2,-1,-1):\n            if ratings[i] > ratings[i+1]:\n                candies[i] = max(candies[i], candies[i+1] + 1)\n        return sum(candies)",
        "memory": "19100"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        len_ratings = len(ratings)\n        candies = [1] * len_ratings\n\n        for idx in range(1, len_ratings):\n            if ratings[idx] > ratings[idx - 1]:\n                candies[idx] = candies[idx - 1] + 1\n\n        for idx in reversed(range(len_ratings - 1)):\n            if ratings[idx] > ratings[idx + 1]:\n                candies[idx] = max(candies[idx + 1] + 1, candies[idx])\n\n        return sum(candies)",
        "memory": "19100"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        S=[1]*len(ratings)\n        for H in range(1,len(ratings)):\n            if ratings[H]>ratings[H-1] and S[H]<=S[H-1]:\n                S[H]=S[H-1]+1\n        for H in range(len(ratings)-2,-1,-1):\n            if ratings[H+1]<ratings[H] and S[H+1]>=S[H]:\n                S[H]=S[H+1]+1\n        return sum(S)\n              ",
        "memory": "19200"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        n = len(ratings)\n        candies = [1] * n \n\n        for i in range(1, n):\n            if ratings[i] > ratings[i-1]:\n                candies[i] = candies[i-1] + 1\n\n        for i in range(n-2, -1, -1):\n            if ratings[i] > ratings[i+1]:\n                candies[i] = max(candies[i], candies[i+1] + 1)\n        \n        return sum(candies)",
        "memory": "19200"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        # res = [1] * len(ratings)\n\n        # for i in range(1, len(ratings)):\n        #     if ratings[i] > ratings[i - 1]:\n        #         res[i] = res[i - 1] + 1\n        \n        # for i in range(len(ratings) - 2, -1, -1):\n        #     if ratings[i] > ratings[i + 1]:\n        #         res[i] = max(res[i + 1] + 1, res[i])\n        \n        # return sum(res)\n\n        if not ratings:\n            return 0\n        \n        ret, up, down, peak = 1, 0, 0, 0\n        \n        for prev, curr in zip(ratings[:-1], ratings[1:]):\n            if prev < curr:\n                up, down, peak = up + 1, 0, up + 1\n                ret += 1 + up\n            elif prev == curr:\n                up = down = peak = 0\n                ret += 1\n            else:\n                up, down = 0, down + 1\n                ret += 1 + down - int(peak >= down)\n        \n        return ret\n",
        "memory": "19400"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        chiru=[1]\n        for i in range(1,len(ratings)):\n            chiru.append(1)\n            if ratings[i]>ratings[i-1]:\n                chiru[i]=chiru[i-1]+1\n        for i in range(len(ratings)-2,-1,-1):\n            if ratings[i]>ratings[i+1]:\n                chiru[i]=max(chiru[i],chiru[i+1]+1)\n        return sum(chiru)",
        "memory": "19400"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        n = len(ratings)\n        candies = 0\n        candy_arr = []\n        max_left = 1\n        if n == 1:\n            return 1\n        for i in range(n):\n            if i == 0:\n                if ratings[i] > ratings[i+1]:\n                    max_left = 2\n            else:\n                if ratings[i] > ratings[i-1]:\n                    max_left += 1\n                else:\n                    max_left = 1\n\n            candies += max_left\n            candy_arr.append(max_left)\n\n        max_right = 1\n        candies = candy_arr[n-1]\n        for i in range(n-2, -1, -1):\n            if ratings[i] > ratings[i+1] and candy_arr[i] <= candy_arr[i+1]:\n                max_right = candy_arr[i+1] + 1\n                candy_arr[i] = max_right\n            candies += candy_arr[i]\n\n        return candies\n\n\n\n        return candies\n                    \n\n\n\n        ",
        "memory": "19600"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        n = len(ratings)\n        candies = [1] * n\n\n        for i in range(1,n):\n            if ratings[i] > ratings[i-1] and candies[i] <= candies[i-1]:\n                candies[i] = candies[i-1] + 1\n        \n        for i in range(n-2, -1, -1):\n            if ratings[i] > ratings[i+1] and candies[i] <= candies[i+1]:\n                candies[i] = candies[i+1] + 1\n\n        total_candies = 0\n        for num in candies:\n            total_candies += num\n            \n        return total_candies\n",
        "memory": "19600"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        peak = ratings[0]\n        candy = [1]*len(ratings)\n        candies = 0\n\n        for i in range(1,len(ratings)):\n            if ratings[i] > ratings[i-1]:\n                candy[i] = candy[i-1] + 1\n\n        for b in range(len(ratings)-2,-1,-1):\n            if ratings[b] > ratings[b+1]:\n                candy[b] = max(candy[b], candy[b + 1] + 1)\n        \n        for i in range(len(candy)):\n            candies += candy[i]\n        return candies",
        "memory": "19700"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        total = 0\n        candies = [1] * len(ratings)\n        for i in range(1, len(ratings)):\n            if ratings[i] > ratings[i - 1]:\n                candies[i] = candies[i-1] + 1\n        \n        for j in range(len(candies)-2, -1, -1):\n            if ratings[j] > ratings[j+1]:\n                candies[j] = max(candies[j], candies[j+1]+1)\n\n        return sum(candies)\n        '''\n        total = 0\n        left2right = [1] * len(ratings)\n        right2left = [1] * len(ratings)\n        for i in range(1, len(ratings)):\n            if ratings[i] > ratings[i-1]:\n                left2right[i] = left2right[i-1] + 1\n        \n        for j in range(len(ratings)-2, -1, -1):\n            if ratings[j] > ratings[j+1]:\n                right2left[j] = right2left[j+1] + 1\n\n        for k in range(len(left2right)):\n            total += max(left2right[k], right2left[k])\n\n        return total\n        '''",
        "memory": "19700"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        res = [1] * len(ratings)\n\n        for i in range(1, len(ratings)):\n            if ratings[i] > ratings[i - 1]:\n                res[i] = res[i - 1] + 1\n        \n        for i in range(len(ratings) - 2, -1, -1):\n            if ratings[i] > ratings[i + 1]:\n                res[i] = max(res[i + 1] + 1, res[i])\n        \n        return sum(res)\n",
        "memory": "19800"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        n = len(ratings)\n        left = [0 for i in range(n)]\n        right = [0 for i in range(n)]\n        left[0] = 1\n        right[n - 1] = 1\n        for i in range(1, n):\n            if ratings[i] > ratings[i - 1]:\n                left[i] = left[i - 1] + 1\n            else:\n                left[i] = 1\n        for j in range(n - 2, -1, -1):\n            if ratings[j] > ratings[j + 1]:\n                right[j] = right[j + 1] + 1\n            else:\n                right[j] = 1\n        sumi = 0\n        for i in range(n):\n            sumi += max(left[i], right[i])\n        return sumi\n\n            \n\n\n",
        "memory": "19800"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        res=[1]*len(ratings)\n        for i in range(1,len(ratings)):\n            if ratings[i]>ratings[i-1]:\n                res[i]=res[i-1]+1\n        for i in range(len(ratings)-2,-1,-1):\n            if ratings[i]>ratings[i+1]:\n                res[i]=max(res[i],res[i+1]+1)\n        return sum(res)\n        \n",
        "memory": "19900"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        valleys = []\n\n        ratings = [10**5] + ratings + [10 **5]\n        temp = [0] * len(ratings)\n\n        for i in range(1, len(ratings)-1):\n            if ratings[i] <= ratings[i-1] and ratings[i] <= ratings[i+1]:\n                valleys.append(i)\n        \n        for v in valleys:\n            temp[v] = 1\n\n            left = v - 1\n            left_curr = 2\n            while left > 0:\n                if ratings[left] > ratings[left + 1]:\n                    temp[left] = max(left_curr, temp[left])\n                    left -= 1\n                    left_curr+=1\n                else:\n                    break\n\n            right = v + 1\n            right_curr = 2\n            while right < len(ratings):\n                if ratings[right] > ratings[right - 1]:\n                    temp[right] = max(right_curr, temp[right])\n                    right += 1\n                    right_curr+= 1\n                else:\n                    break\n        return sum(temp[1:len(temp)-1])\n\n\n        \n\n        ",
        "memory": "20000"
      },
      {
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        valleys = []\n\n        ratings = [10**5] + ratings + [10 **5]\n        temp = [0] * len(ratings)\n\n        for i in range(1, len(ratings)-1):\n            if ratings[i] <= ratings[i-1] and ratings[i] <= ratings[i+1]:\n                valleys.append(i)\n        \n        for v in valleys:\n            temp[v] = 1\n\n            left = v - 1\n            left_curr = 2\n            while left > 0:\n                if ratings[left] > ratings[left + 1]:\n                    temp[left] = max(left_curr, temp[left])\n                    left -= 1\n                    left_curr+=1\n                else:\n                    break\n\n            right = v + 1\n            right_curr = 2\n            while right < len(ratings):\n                if ratings[right] > ratings[right - 1]:\n                    temp[right] = max(right_curr, temp[right])\n                    right += 1\n                    right_curr+= 1\n                else:\n                    break\n        return sum(temp[1:len(temp)-1])\n\n\n        \n\n        ",
        "memory": "20000"
      },
      {
        "code": "from typing import List\n\nclass Solution:\n    def candy(self, ratings: List[int]) -> int:\n        n = len(ratings)\n        if n <= 1:\n            return n\n\n        total_candies = 1  # Start with one candy for the first child\n        up = 1            # Length of the last ascending sequence\n        down = 0          # Length of the last descending sequence\n        peak = 1          # Candies at the peak of the last ascending sequence\n\n        for i in range(1, n):\n            if ratings[i] > ratings[i - 1]:\n                up += 1\n                peak = up\n                down = 0\n                total_candies += up\n            elif ratings[i] == ratings[i - 1]:\n                up = 1\n                down = 0\n                peak = up\n                total_candies += up\n            else:\n                down += 1\n                up = 1\n                total_candies += down\n                if down >= peak:\n                    # Add one extra candy to the peak child\n                    total_candies += 1\n\n        return total_candies",
        "memory": "20100"
      }
    ],
    "memory_efficient_codes": [],
    "import_code": "from typing import List\nimport random",
    "setup_code": "# Define necessary data structures\nclass Solution:\n    def candy(self, ratings: List[int]) -> int:\n        return Solution().compute_candy(ratings)\n\n    def compute_candy(self, ratings: List[int]) -> int:\n        n = len(ratings)\n        left = [1] * n\n        right = [1] * n\n        for i in range(1, n):\n            if ratings[i] > ratings[i - 1]:\n                left[i] = left[i - 1] + 1\n            else:\n                left[i] = 1\n\n        for i in range(n - 2, -1, -1):\n            if ratings[i] > ratings[i + 1]:\n                right[i] = right[i + 1] + 1\n            else:\n                right[i] = 1\n\n        ans = 0\n        for i in range(n):\n            ans += max(left[i], right[i])\n        return ans\n\n# Test case generator\nclass TestCaseGenerator:\n    def generate(self) -> dict:\n        # Example Test Case\n        test_case_1 = {'ratings': [1, 0, 2]}\n        test_case_2 = {'ratings': [1, 2, 2]}\n        # Additional Test Cases\n        test_case_3 = {'ratings': [3, 2, 1]}\n        test_case_4 = {'ratings': [1, 3, 4, 5, 2]}\n        test_case_5 = {'ratings': [1, 2, 87, 87, 87, 2, 1]}\n        return random.choice([test_case_1, test_case_2, test_case_3, test_case_4, test_case_5])\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return eval(input_str)",
    "libraries": ["random", "typing"],
    "entry_point": "candy",
    "test_cases": [
      {
        "input": "{'ratings': [1, 2, 2]}",
        "output": "4"
      },
      {
        "input": "{'ratings': [1, 2, 2]}",
        "output": "4"
      },
      {
        "input": "{'ratings': [1, 2, 2]}",
        "output": "4"
      },
      {
        "input": "{'ratings': [1, 2, 87, 87, 87, 2, 1]}",
        "output": "13"
      },
      {
        "input": "{'ratings': [1, 0, 2]}",
        "output": "5"
      },
      {
        "input": "{'ratings': [1, 2, 87, 87, 87, 2, 1]}",
        "output": "13"
      },
      {
        "input": "{'ratings': [1, 2, 87, 87, 87, 2, 1]}",
        "output": "13"
      },
      {
        "input": "{'ratings': [3, 2, 1]}",
        "output": "6"
      },
      {
        "input": "{'ratings': [1, 2, 2]}",
        "output": "4"
      },
      {
        "input": "{'ratings': [1, 2, 87, 87, 87, 2, 1]}",
        "output": "13"
      },
      {
        "input": "{'ratings': [1, 3, 4, 5, 2]}",
        "output": "11"
      },
      {
        "input": "{'ratings': [1, 2, 87, 87, 87, 2, 1]}",
        "output": "13"
      },
      {
        "input": "{'ratings': [1, 2, 2]}",
        "output": "4"
      },
      {
        "input": "{'ratings': [3, 2, 1]}",
        "output": "6"
      },
      {
        "input": "{'ratings': [1, 2, 2]}",
        "output": "4"
      },
      {
        "input": "{'ratings': [1, 2, 2]}",
        "output": "4"
      },
      {
        "input": "{'ratings': [1, 2, 87, 87, 87, 2, 1]}",
        "output": "13"
      },
      {
        "input": "{'ratings': [1, 3, 4, 5, 2]}",
        "output": "11"
      },
      {
        "input": "{'ratings': [3, 2, 1]}",
        "output": "6"
      },
      {
        "input": "{'ratings': [1, 3, 4, 5, 2]}",
        "output": "11"
      },
      {
        "input": "{'ratings': [1, 3, 4, 5, 2]}",
        "output": "11"
      },
      {
        "input": "{'ratings': [3, 2, 1]}",
        "output": "6"
      },
      {
        "input": "{'ratings': [3, 2, 1]}",
        "output": "6"
      },
      {
        "input": "{'ratings': [1, 0, 2]}",
        "output": "5"
      },
      {
        "input": "{'ratings': [1, 2, 87, 87, 87, 2, 1]}",
        "output": "13"
      },
      {
        "input": "{'ratings': [3, 2, 1]}",
        "output": "6"
      },
      {
        "input": "{'ratings': [1, 2, 87, 87, 87, 2, 1]}",
        "output": "13"
      },
      {
        "input": "{'ratings': [1, 3, 4, 5, 2]}",
        "output": "11"
      },
      {
        "input": "{'ratings': [1, 3, 4, 5, 2]}",
        "output": "11"
      },
      {
        "input": "{'ratings': [3, 2, 1]}",
        "output": "6"
      },
      {
        "input": "{'ratings': [1, 3, 4, 5, 2]}",
        "output": "11"
      },
      {
        "input": "{'ratings': [1, 2, 2]}",
        "output": "4"
      },
      {
        "input": "{'ratings': [1, 3, 4, 5, 2]}",
        "output": "11"
      },
      {
        "input": "{'ratings': [1, 0, 2]}",
        "output": "5"
      },
      {
        "input": "{'ratings': [1, 2, 2]}",
        "output": "4"
      },
      {
        "input": "{'ratings': [1, 3, 4, 5, 2]}",
        "output": "11"
      },
      {
        "input": "{'ratings': [1, 2, 87, 87, 87, 2, 1]}",
        "output": "13"
      },
      {
        "input": "{'ratings': [3, 2, 1]}",
        "output": "6"
      },
      {
        "input": "{'ratings': [1, 0, 2]}",
        "output": "5"
      },
      {
        "input": "{'ratings': [1, 2, 87, 87, 87, 2, 1]}",
        "output": "13"
      },
      {
        "input": "{'ratings': [3, 2, 1]}",
        "output": "6"
      },
      {
        "input": "{'ratings': [1, 0, 2]}",
        "output": "5"
      },
      {
        "input": "{'ratings': [1, 0, 2]}",
        "output": "5"
      },
      {
        "input": "{'ratings': [1, 2, 87, 87, 87, 2, 1]}",
        "output": "13"
      },
      {
        "input": "{'ratings': [1, 0, 2]}",
        "output": "5"
      },
      {
        "input": "{'ratings': [1, 3, 4, 5, 2]}",
        "output": "11"
      },
      {
        "input": "{'ratings': [1, 0, 2]}",
        "output": "5"
      },
      {
        "input": "{'ratings': [1, 2, 87, 87, 87, 2, 1]}",
        "output": "13"
      },
      {
        "input": "{'ratings': [1, 2, 2]}",
        "output": "4"
      },
      {
        "input": "{'ratings': [1, 2, 2]}",
        "output": "4"
      },
      {
        "input": "{'ratings': [3, 2, 1]}",
        "output": "6"
      },
      {
        "input": "{'ratings': [1, 2, 2]}",
        "output": "4"
      },
      {
        "input": "{'ratings': [1, 3, 4, 5, 2]}",
        "output": "11"
      },
      {
        "input": "{'ratings': [3, 2, 1]}",
        "output": "6"
      },
      {
        "input": "{'ratings': [3, 2, 1]}",
        "output": "6"
      },
      {
        "input": "{'ratings': [1, 2, 87, 87, 87, 2, 1]}",
        "output": "13"
      },
      {
        "input": "{'ratings': [1, 0, 2]}",
        "output": "5"
      },
      {
        "input": "{'ratings': [1, 2, 2]}",
        "output": "4"
      },
      {
        "input": "{'ratings': [1, 2, 2]}",
        "output": "4"
      },
      {
        "input": "{'ratings': [1, 0, 2]}",
        "output": "5"
      },
      {
        "input": "{'ratings': [3, 2, 1]}",
        "output": "6"
      },
      {
        "input": "{'ratings': [3, 2, 1]}",
        "output": "6"
      },
      {
        "input": "{'ratings': [1, 2, 87, 87, 87, 2, 1]}",
        "output": "13"
      },
      {
        "input": "{'ratings': [1, 3, 4, 5, 2]}",
        "output": "11"
      },
      {
        "input": "{'ratings': [1, 2, 87, 87, 87, 2, 1]}",
        "output": "13"
      },
      {
        "input": "{'ratings': [3, 2, 1]}",
        "output": "6"
      },
      {
        "input": "{'ratings': [1, 3, 4, 5, 2]}",
        "output": "11"
      },
      {
        "input": "{'ratings': [1, 2, 2]}",
        "output": "4"
      },
      {
        "input": "{'ratings': [3, 2, 1]}",
        "output": "6"
      },
      {
        "input": "{'ratings': [1, 0, 2]}",
        "output": "5"
      },
      {
        "input": "{'ratings': [1, 0, 2]}",
        "output": "5"
      },
      {
        "input": "{'ratings': [1, 3, 4, 5, 2]}",
        "output": "11"
      },
      {
        "input": "{'ratings': [1, 2, 2]}",
        "output": "4"
      },
      {
        "input": "{'ratings': [1, 0, 2]}",
        "output": "5"
      },
      {
        "input": "{'ratings': [1, 2, 2]}",
        "output": "4"
      },
      {
        "input": "{'ratings': [3, 2, 1]}",
        "output": "6"
      },
      {
        "input": "{'ratings': [1, 0, 2]}",
        "output": "5"
      },
      {
        "input": "{'ratings': [1, 0, 2]}",
        "output": "5"
      },
      {
        "input": "{'ratings': [1, 2, 2]}",
        "output": "4"
      },
      {
        "input": "{'ratings': [1, 2, 2]}",
        "output": "4"
      },
      {
        "input": "{'ratings': [1, 2, 87, 87, 87, 2, 1]}",
        "output": "13"
      },
      {
        "input": "{'ratings': [1, 2, 2]}",
        "output": "4"
      },
      {
        "input": "{'ratings': [3, 2, 1]}",
        "output": "6"
      },
      {
        "input": "{'ratings': [1, 2, 87, 87, 87, 2, 1]}",
        "output": "13"
      },
      {
        "input": "{'ratings': [1, 3, 4, 5, 2]}",
        "output": "11"
      },
      {
        "input": "{'ratings': [1, 0, 2]}",
        "output": "5"
      },
      {
        "input": "{'ratings': [3, 2, 1]}",
        "output": "6"
      },
      {
        "input": "{'ratings': [1, 2, 2]}",
        "output": "4"
      },
      {
        "input": "{'ratings': [1, 0, 2]}",
        "output": "5"
      },
      {
        "input": "{'ratings': [3, 2, 1]}",
        "output": "6"
      },
      {
        "input": "{'ratings': [1, 3, 4, 5, 2]}",
        "output": "11"
      },
      {
        "input": "{'ratings': [1, 2, 2]}",
        "output": "4"
      },
      {
        "input": "{'ratings': [1, 0, 2]}",
        "output": "5"
      },
      {
        "input": "{'ratings': [1, 2, 2]}",
        "output": "4"
      },
      {
        "input": "{'ratings': [1, 0, 2]}",
        "output": "5"
      },
      {
        "input": "{'ratings': [1, 3, 4, 5, 2]}",
        "output": "11"
      },
      {
        "input": "{'ratings': [1, 0, 2]}",
        "output": "5"
      },
      {
        "input": "{'ratings': [1, 2, 2]}",
        "output": "4"
      },
      {
        "input": "{'ratings': [1, 2, 2]}",
        "output": "4"
      },
      {
        "input": "{'ratings': [3, 2, 1]}",
        "output": "6"
      },
      {
        "input": "{'ratings': [1, 3, 4, 5, 2]}",
        "output": "11"
      },
      {
        "input": "{'ratings': [1, 2, 2]}",
        "output": "4"
      },
      {
        "input": "{'ratings': [1, 0, 2]}",
        "output": "5"
      },
      {
        "input": "{'ratings': [3, 2, 1]}",
        "output": "6"
      },
      {
        "input": "{'ratings': [1, 3, 4, 5, 2]}",
        "output": "11"
      },
      {
        "input": "{'ratings': [3, 2, 1]}",
        "output": "6"
      },
      {
        "input": "{'ratings': [1, 2, 2]}",
        "output": "4"
      },
      {
        "input": "{'ratings': [3, 2, 1]}",
        "output": "6"
      },
      {
        "input": "{'ratings': [1, 3, 4, 5, 2]}",
        "output": "11"
      },
      {
        "input": "{'ratings': [1, 2, 87, 87, 87, 2, 1]}",
        "output": "13"
      },
      {
        "input": "{'ratings': [1, 0, 2]}",
        "output": "5"
      },
      {
        "input": "{'ratings': [3, 2, 1]}",
        "output": "6"
      },
      {
        "input": "{'ratings': [1, 2, 87, 87, 87, 2, 1]}",
        "output": "13"
      },
      {
        "input": "{'ratings': [1, 2, 87, 87, 87, 2, 1]}",
        "output": "13"
      },
      {
        "input": "{'ratings': [1, 2, 87, 87, 87, 2, 1]}",
        "output": "13"
      },
      {
        "input": "{'ratings': [1, 0, 2]}",
        "output": "5"
      },
      {
        "input": "{'ratings': [1, 2, 87, 87, 87, 2, 1]}",
        "output": "13"
      },
      {
        "input": "{'ratings': [3, 2, 1]}",
        "output": "6"
      },
      {
        "input": "{'ratings': [1, 2, 87, 87, 87, 2, 1]}",
        "output": "13"
      },
      {
        "input": "{'ratings': [1, 2, 2]}",
        "output": "4"
      },
      {
        "input": "{'ratings': [1, 2, 87, 87, 87, 2, 1]}",
        "output": "13"
      },
      {
        "input": "{'ratings': [1, 0, 2]}",
        "output": "5"
      },
      {
        "input": "{'ratings': [3, 2, 1]}",
        "output": "6"
      },
      {
        "input": "{'ratings': [1, 2, 87, 87, 87, 2, 1]}",
        "output": "13"
      },
      {
        "input": "{'ratings': [1, 2, 2]}",
        "output": "4"
      },
      {
        "input": "{'ratings': [1, 2, 2]}",
        "output": "4"
      },
      {
        "input": "{'ratings': [1, 2, 2]}",
        "output": "4"
      },
      {
        "input": "{'ratings': [1, 3, 4, 5, 2]}",
        "output": "11"
      }
    ]
  },
  {
    "question_id": 137,
    "name": "single-number-ii",
    "prompt": "<p>Given an integer array <code>nums</code> where&nbsp;every element appears <strong>three times</strong> except for one, which appears <strong>exactly once</strong>. <em>Find the single element and return it</em>.</p>\n\n<p>You must&nbsp;implement a solution with a linear runtime complexity and use&nbsp;only constant&nbsp;extra space.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> nums = [2,2,3,2]\n<strong>Output:</strong> 3\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> nums = [0,1,0,1,0,1,99]\n<strong>Output:</strong> 99\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li>Each element in <code>nums</code> appears exactly <strong>three times</strong> except for one element which appears <strong>once</strong>.</li>\n</ul>\n",
    "difficulty": "Medium",
    "topics": ["array", "bit-manipulation"],
    "runtime_inefficient_codes": [
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        ln=len(nums)\n        if ln<999999:\n                while(1):\n                    val = nums[-1]\n                    nums.pop()\n                    if val in nums:\n                        nums.insert(0,val)\n                    else:\n                        return val\n        else:\n            dicto={}\n            for i in nums:\n                if i in dicto.keys():\n                    dicto[i]+=1\n                else:\n                    dicto[i]=1\n            mini=min(dicto.values())\n            for i in dicto.items():\n                if i[1]==mini:\n                    return i[0] \n\n            \n\n        ",
        "runtime": "596"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        while nums:\n            j = nums.pop(0)\n            if j in nums:\n                nums.remove(j)\n                nums.remove(j)\n            else:\n                return j",
        "runtime": "605"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        seen = []\n        for i in nums:\n            if i not in seen:\n                seen.append(i)\n            else:\n                continue\n            if nums.count(i) == 1:\n                return i",
        "runtime": "605"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        for i in range(len(nums)):\n            c=nums.pop()\n            if c not in nums:\n                return c\n            nums.insert(i,c)",
        "runtime": "615"
      },
      {
        "code": "from typing import List\n\n\nclass Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        while nums:\n            i = nums.pop()\n            if nums and i in nums:\n                nums.remove(i)\n                nums.remove(i)\n                continue\n            return i\n\n",
        "runtime": "624"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        stack=[]\n        other=[]\n        for i in nums:\n            if i not in stack:\n                stack.append(i)\n            elif i in stack:\n                other.append(i)\n               \n        \n  \n        for element in stack:\n            if element not in other:\n               return element\n        return -1           \n        ",
        "runtime": "634"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        result  = 0\n        single = []\n        multiple = []\n        for i in nums:\n            if i not in single:\n                single.append(i)\n            elif i not in multiple:\n                multiple.append(i)\n        for i in single:\n            if i not in multiple:\n                return i\n",
        "runtime": "643"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        uni=[]\n        dup=[]\n        n=len(nums)\n        for i in nums:\n            if i not in uni:\n                uni.append(i)\n            elif i not in dup:\n                dup.append(i)\n        for i in nums:\n            if i not in dup:\n                return i            \n        ",
        "runtime": "643"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        actual_nums = nums.copy()\n        popped_list = []\n        for i in actual_nums:\n            if i not in popped_list:\n                nums.remove(i)\n                popped_list.append(i)\n\n        return_int = [i for i in popped_list if i not in nums]\n        return return_int[0]",
        "runtime": "652"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        f = []\n        g = []\n\n        for i in nums:\n            if i not in f:\n                f.append(i)\n            elif i not in g:\n                g.append(i)  # BEST APPROACH FOR FINDING DUPLICATES AND FIND UNIQUE\n\n        for i in g:\n            if i in f:\n                f.remove(i)\n\n        return f[0] if f else None\n",
        "runtime": "652"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        for i in nums:\n            if nums.count(i)==1:\n                return i\n        ",
        "runtime": "671"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        for i in nums:\n            if nums.count(i)==1:\n                return i",
        "runtime": "681"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        for num in nums:\n            if nums.count(num)==1:\n                return num",
        "runtime": "681"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        sola=[]\n        solb=[]\n        for n in nums:\n            if n not in sola:\n                sola.append(n)\n                continue\n            if n in sola:\n                solb.append(n)\n        \n        return [x for x in sola if x not in solb][0]",
        "runtime": "690"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        for i in nums:\n            temp=nums.count(i)\n            if(temp==1):\n                return i\n        ",
        "runtime": "690"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n       for i in range(0,len(nums)):\n            if nums.count(nums[i]) == 1:\n                return nums[i]\n    \n\n\n        ",
        "runtime": "699"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        for i in nums:\n            if nums.count(i)==1:\n                return i",
        "runtime": "699"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        for i in nums:\n            if nums.count(i) == 1:\n                return i",
        "runtime": "709"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        for i in nums:\n            if nums.count(i)==1:\n                return i",
        "runtime": "709"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        for ele in nums:\n            if nums.count(ele)==1:\n                return ele\n\n        \n        ",
        "runtime": "718"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        seen=set()\n        for i in nums:\n            if nums.count(i)<2:\n                return i",
        "runtime": "718"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        result=0\n        for i in nums:\n            if nums.count(i)!=3:\n                return i",
        "runtime": "728"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        for i in nums:\n            c=nums.count(i)\n            if c==1:\n                return i",
        "runtime": "728"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        for i in nums:\n            if(nums.count(i)==1):\n                return i",
        "runtime": "737"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        for i in nums:\n            if nums.count(i) ==1:\n                return i\n        ",
        "runtime": "737"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        for i in nums:\n            if nums.count(i)==1:\n                return i\n        ",
        "runtime": "747"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        for i in nums:\n            if nums.count(i)==1:\n                return i\n        ",
        "runtime": "747"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        if (len(nums) >= 3 * (10**4)):\n            return 0\n        for i in range(len(nums)):\n            if nums.count(nums[i]) != 3:          \n                if nums[i] >= 2**31 or nums[i] < -2**31:\n                    return 0 \n                else:\n                    return nums[i]   \n            ",
        "runtime": "756"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        s=set(nums)\n        for i in s:\n            if nums.count(i)==1:\n                return i",
        "runtime": "756"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        for num in list(set(nums)):\n            if nums.count(num) == 1:\n                return num\n        ",
        "runtime": "765"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        for i in nums:\n            if nums.count(i) == 1:\n                return i\n        ",
        "runtime": "765"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        n=set(nums)\n        if len(nums)==1:\n            return nums[0]\n        for i in n:\n            if nums.count(i)==1:\n                return i\n",
        "runtime": "775"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        # for i in nums: # 715ms | 18.40 MB\n        #     if nums.count(i) != 3 and nums.count(i) == 1:\n        #         return i\n\n        nums.sort()\n        i = 0\n        while i < len(nums):\n            if nums.count(nums[i]) == 1:\n                return nums[i]\n            i += 3",
        "runtime": "775"
      }
    ],
    "runtime_moderate_codes": [
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        seen=set()\n        while nums:\n            k=nums.pop(0)\n            if k not in nums and k not in seen:\n                return(k)\n            seen.add(k)",
        "runtime": "219"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        ln=len(nums)\n        if ln<999999:\n                while(1):\n                    val = nums[0]\n                    nums.remove(val)\n                    if val in nums:\n                        nums.append(val)\n                    else:\n                        return val\n        else:\n            dicto={}\n            for i in nums:\n                if i in dicto.keys():\n                    dicto[i]+=1\n                else:\n                    dicto[i]=1\n            mini=min(dicto.values())\n            for i in dicto.items():\n                if i[1]==mini:\n                    return i[0] \n\n            \n\n        ",
        "runtime": "219"
      },
      {
        "code": "import numpy as np\nclass Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        if len(nums) == 1:\n            return nums[0]\n        x = np.array(nums, dtype=np.int32)\n        x.sort()\n        if x[-1] != x[-2]:\n            return x[-1]\n        true_pos = (x[:-1:3] != x[1::3]).argmax()\n        return int(x[true_pos * 3])\n",
        "runtime": "229"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        s = list(set(nums))\n        dic={}\n        for i in nums:\n            if i not in dic:\n                dic[i]=1\n            elif i in s:\n                s.remove(i)\n        return s[0]",
        "runtime": "238"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        tmp=nums[:]\n        while(1):\n            val = tmp[0]\n            tmp.remove(val)\n            if val in tmp:\n                tmp.append(val)\n            else:\n                return val\n        \n\n        ",
        "runtime": "248"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        dp = defaultdict(int)\n        dpn = defaultdict(int)\n        \n\n        def cal(num):\n            for i in range(64):\n                if num < 0:\n                    curr = int(bool((-num) & (1 << i)))\n                else:\n                    curr = int(bool(num & (1 << i)))\n                if num < 0:\n                    dpn[i] += curr\n                else:\n                    dp[i] += curr\n\n        for num in nums:\n            cal(num)\n        \n        res = 0\n        val = [0]*64\n        for i in range(64):\n            if dpn[i] % 3 != 0:\n                res |= 1 << i\n        if res:\n            return -res\n            \n        for i in range(64):\n            if dp[i] % 3 != 0:\n                res |= 1 << i\n\n        return res\n                ",
        "runtime": "248"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        num_bits = int(50)\n        bit_sequence = [\"0\"] * num_bits\n        for i in range(num_bits):\n            bit_sum = 0\n            for n in nums:\n                bits = bin(n)[2:]\n                bits = (\"0\" * (num_bits - len(bits))) + bits\n                if bits[i] == \"1\":\n                    bit_sum += 1\n            if bit_sum % 3 != 0:\n                bit_sequence[i] = \"1\"\n\n\n        result = int(\"\".join(bit_sequence), 2)\n        # sign check\n        negative_count = 0\n        for n in nums:\n            bits = bin(n)\n            if bits[0] == \"-\":\n                negative_count += 1\n        \n        if negative_count % 3 != 0:\n            result *= -1\n\n        return result",
        "runtime": "257"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        tmps=nums[:]\n        used=[]\n        for i in nums:\n            if i in tmps and i not in used:\n                used.append(i)\n                tmps.remove(i)\n                if i in tmps:\n                    continue\n                else:\n                    return i\n\n \n\n        ",
        "runtime": "267"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        dupes = {}\n\n        for i in range(len(nums)):\n            num = nums[i]\n            if num in dupes:\n                next\n            elif num in nums[i + 1:]:\n                dupes[num] = 1\n            else:\n                return num",
        "runtime": "267"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        ln=len(nums)\n        if ln>1000:\n                \n                while(1):\n                    val = nums[0]\n                    nums.remove(val)\n                    if val in nums:\n                        nums.append(val)\n                    else:\n                        return val\n        else:\n            dicto={}\n            for i in nums:\n                if i in dicto.keys():\n                    dicto[i]+=1\n                else:\n                    dicto[i]=1\n            mini=min(dicto.values())\n            for i in dicto.items():\n                if i[1]==mini:\n                    return i[0] \n\ndef isin(value,arr):\n    left=0\n    right=len(arr)-1\n    mid=0\n    while(left<=right):\n            mid=(left+right)//2\n            if value==arr[mid]:\n                return True\n            elif value>arr[mid]:\n                left=mid+1\n            else:\n                right=mid-1\n    return False\n                \n    \n                \n            \n\n        ",
        "runtime": "276"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        tmps=nums[:]\n        used=[]\n        for i in nums:\n            if i in tmps and i not in used:\n                used.append(i)\n                tmps.remove(i)\n                if i in tmps:\n                    continue\n                else:\n                    return i\n\n \n\n        ",
        "runtime": "276"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        \n        i=0\n        N=len(nums)\n        visited={}\n        while i<N:\n            if nums[0] in visited and visited[nums[0]]==2:\n                del visited[nums[0]]\n            else:\n                visited[nums[0]] = visited.get(nums[0], 0) + 1\n            nums = nums[1:]\n            i+=1\n        \n        for item in visited:\n            return item\n",
        "runtime": "285"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        dict_key = {}\n        val = []\n        for i in nums:\n            if i in dict_key.keys():\n                del dict_key[i]\n                if i not in val:\n                    val.append(i)\n            else:\n                if i not in val:\n                    dict_key[i] = 1\n        return list(dict_key.keys())[0]\n        \n        ",
        "runtime": "295"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        num_bits = int(64)\n        bit_sequence = [\"0\"] * num_bits\n        for i in range(num_bits):\n            bit_sum = 0\n            for n in nums:\n                bits = bin(n)[2:]\n                bits = (\"0\" * (num_bits - len(bits))) + bits\n                if bits[i] == \"1\":\n                    bit_sum += 1\n            if bit_sum % 3 != 0:\n                bit_sequence[i] = \"1\"\n\n\n        result = int(\"\".join(bit_sequence), 2)\n        # sign check\n        negative_count = 0\n        for n in nums:\n            bits = bin(n)\n            if bits[0] == \"-\":\n                negative_count += 1\n        \n        if negative_count % 3 != 0:\n            result *= -1\n\n        return result",
        "runtime": "304"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        if len(nums) == 1: return nums[0]\n\n        for i in range(len(nums)):\n            if nums[i] not in nums[0:i] and nums[i] not in nums[i+1:]:\n                return nums[i]\n\n        ",
        "runtime": "304"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        l=list(set(nums))\n        for i in l:\n            nums.remove(i)\n        for i in l:\n            if i not in nums:\n                return i",
        "runtime": "314"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        a=0\n        for i in range(len(nums)):\n            a = nums[i]\n            nums.remove(nums[i])\n            if a not in nums:\n                return a\n            nums.insert(i, a)\n",
        "runtime": "323"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        X = nums\n        Y = set(nums)\n        for i in Y:\n            X.remove(i)\n        Z = [item for item in Y if item not in X]\n        return Z[0]\n\n",
        "runtime": "332"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        X = nums\n        Y = set(nums)\n        for i in Y:\n            X.remove(i)\n        Z = [item for item in Y if item not in X]\n        return Z[0]\n\n",
        "runtime": "342"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        X = nums\n        Y = set(nums)\n        for i in Y:\n            X.remove(i)\n        Z = [item for item in Y if item not in X]\n        return Z[0]\n\n",
        "runtime": "351"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        once = []\n        twice = []\n\n        for n in nums:\n            if n in once:\n                    once.remove(n)\n                    twice.append(n)\n            else:\n                if n in twice:\n                    twice.remove(n)\n                else:\n                    once.append(n)\n                    \n        return once[0]",
        "runtime": "361"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        num1=[]\n        for i in nums:\n            if i not in num1:\n                num1.append(i)\n        return int((3*sum(num1)-sum(nums))/2)",
        "runtime": "370"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        X = nums\n        Y = set(nums)\n        for i in Y:\n            X.remove(i)\n        Z = [item for item in Y if item not in X]\n        return Z[0]\n\n",
        "runtime": "370"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        summ = 0\n        seen =[]\n        for i in nums:\n            summ+=i \n            if i not in seen:\n                seen.append(i)\n        \n        return int(-(summ-3*sum(seen))/2)\n        ",
        "runtime": "379"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        r=[]\n        s=[]\n        for c in nums:\n            if c not in r:\n                r.append(c)\n            else:\n                s.append(c)\n        s=set(r)-set(s)\n        if s:\n            return list(s)[0]\n        else:\n            []\n        ",
        "runtime": "379"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        num1=[]\n        for i in nums:\n            if i not in num1:\n                num1.append(i)\n        return int((3*sum(num1)-sum(nums))/2)",
        "runtime": "389"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        list2=[]\n        list3=[]\n\n        for i in nums:\n            if i not in list2:\n                list2.append(i)\n            else:\n                list3.append(i)\n        for i in list2:\n            if i not in list3:\n                return i",
        "runtime": "408"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        l=list(set(nums))\n        c=0\n        for i in l:\n            if i in nums:\n                nums.remove(i)\n        for i in l:\n            if i not in nums:\n                return i",
        "runtime": "417"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        alreadySeen = []\n        duplicates = []\n        for i in range(len(nums)):\n            if nums[i] not in alreadySeen:\n                alreadySeen.append(nums[i])\n            else:\n                duplicates.append(nums[i])\n        \n        for j in range(len(alreadySeen)):\n            if alreadySeen[j] not in duplicates:\n                return alreadySeen[j]\n        ",
        "runtime": "427"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n\n        result = []\n        history = []\n        \n        for x in nums:\n\n            if x in result:\n                result.pop(result.index(x))\n            elif x not in history:\n                result.append(x)\n                history.append(x)\n\n        return result[0]\n            ",
        "runtime": "436"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        a=[]\n        b=[]\n        for c in nums:\n            if not c in b:\n                if c in a:\n                    a.remove(c)\n                    b.append(c)\n                else:\n                    a.append(c)\n        \n        return a[0]\n    ",
        "runtime": "445"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        o1 = []\n        o2 = []\n        for n in nums:\n            if n in o2:\n                o2.remove(n)\n                o1.remove(n)\n                continue\n            if n in o1:\n                o2.append(n)\n                continue\n            o1.append(n)\n        return o1[0]",
        "runtime": "455"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        for i in range(len(nums)):\n            if nums[i] not in nums[:i] + nums[i+1:]:\n                return nums[i]",
        "runtime": "464"
      },
      {
        "code": "import math\nclass Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        val2count = {}\n        if nums.count(nums[0]) == 1:\n            return nums[0]\n        marker = nums[0]\n        cache_size = 10\n        while True:\n            for i in range(len(nums)):\n                num = nums[i]\n                if num == marker:\n                    continue\n                if num in val2count:\n                    val2count[num] += 1\n                    nums[i] = marker\n                elif len(val2count) < cache_size:\n                    val2count[num] = 1\n                    nums[i] = marker\n            for val, count in val2count.items():\n                if count == 1:\n                    return val\n            val2count = {}\n        ",
        "runtime": "474"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        result = []\n        helper = []\n        for i in nums:\n            if i in result:\n                result.remove(i)\n                helper.append(i)\n            else:\n                result.append(i)\n        final_result = [item for item in result if item not in helper]\n        return final_result[0]",
        "runtime": "474"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        for i, k in enumerate(nums):\n            if k not in nums[:i] + nums[i+1:]:\n                return k\n        return -1",
        "runtime": "483"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        stack=[]\n        other=[]\n        for i in nums:\n            if i not in stack:\n                stack.append(i)\n            else:\n                other.append(i)\n               \n        \n  \n        for element in stack:\n            if element not in other:\n               return element\n        return -1           \n        ",
        "runtime": "483"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        while nums:\n            j = nums.pop(0)\n            if j in nums:\n                nums.remove(j)\n                nums.remove(j)\n            else:\n                return j",
        "runtime": "492"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        while nums:\n            j = nums.pop(0)\n            if j in nums:\n                nums.remove(j)\n                nums.remove(j)\n            else:\n                return j",
        "runtime": "502"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        \n        visited = set()\n\n        for num in nums:\n            \n            if num in visited:\n                continue\n\n            if nums.count(num) != 1:\n                visited.add(num)\n                continue\n            \n            return num\n            \n",
        "runtime": "511"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        seen = {}\n        for n in nums:\n            if n in nums:\n                seen[n] = seen.setdefault(n, 0) + 1\n                if seen[n] == 3:\n                    del seen[n]\n        return list(seen.keys())[0]\n        ",
        "runtime": "521"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        ln=len(nums)\n        if ln>10000:\n                while(1):\n                    val = nums[-1]\n                    nums.pop()\n                    if val in nums:\n                        nums.insert(0,val)\n                    else:\n                        return val\n        else:\n            dicto={}\n            for i in nums:\n                if i in dicto.keys():\n                    dicto[i]+=1\n                else:\n                    dicto[i]=1\n            mini=min(dicto.values())\n            for i in dicto.items():\n                if i[1]==mini:\n                    return i[0] \n\n            \n\n        ",
        "runtime": "530"
      },
      {
        "code": "import numpy as np\nclass Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        \n        candidates = []\n        appeared = []\n\n        for n in nums:\n            if n not in appeared:\n                if n not in candidates:\n                    candidates.append(n)\n                else:\n                    candidates.remove(n)\n                    appeared.append(n)\n\n        return candidates[0]\n            ",
        "runtime": "539"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        ln=len(nums)\n        if ln<1000000:\n                while(1):\n                    val = nums[-1]\n                    nums.pop()\n                    if val in nums:\n                        nums.insert(0,val)\n                    else:\n                        return val\n        else:\n            dicto={}\n            for i in nums:\n                if i in dicto.keys():\n                    dicto[i]+=1\n                else:\n                    dicto[i]=1\n            mini=min(dicto.values())\n            for i in dicto.items():\n                if i[1]==mini:\n                    return i[0] \n\n            \n\n        ",
        "runtime": "558"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        ln=len(nums)\n        if ln<100000:\n                while(1):\n                    val = nums[-1]\n                    nums.pop()\n                    if val in nums:\n                        nums.insert(0,val)\n                    else:\n                        return val\n        else:\n            dicto={}\n            for i in nums:\n                if i in dicto.keys():\n                    dicto[i]+=1\n                else:\n                    dicto[i]=1\n            mini=min(dicto.values())\n            for i in dicto.items():\n                if i[1]==mini:\n                    return i[0] \n\n            \n\n        ",
        "runtime": "568"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        ln=len(nums)\n        if ln>9000:\n                while(1):\n                    val = nums[-1]\n                    nums.pop()\n                    if val in nums:\n                        nums.insert(0,val)\n                    else:\n                        return val\n        else:\n            dicto={}\n            for i in nums:\n                if i in dicto.keys():\n                    dicto[i]+=1\n                else:\n                    dicto[i]=1\n            mini=min(dicto.values())\n            for i in dicto.items():\n                if i[1]==mini:\n                    return i[0] \n\n            \n\n        ",
        "runtime": "568"
      }
    ],
    "runtime_efficient_codes": [
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        cnt = defaultdict(int)\n        \n        for x in nums:\n            cnt[x] += 1\n\n        for x, freq in cnt.items():\n            if freq == 1:\n                return x\n        \n        return -1",
        "runtime": "31"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        dct = {}\n\n        for num in nums:\n            if num in dct.keys():\n                dct[num] += 1\n                if dct[num] == 3:\n                    dct.pop(num)\n            else:\n                dct[num] = 1\n            \n        for key in dct.keys():\n            return key",
        "runtime": "31"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        count_map = {}\n\n        for num in nums:\n            if num in count_map:\n                count_map[num] += 1\n            else:\n                count_map[num] = 1\n        \n        for num, count in count_map.items():\n            if count == 1:\n                return num",
        "runtime": "41"
      },
      {
        "code": "class Solution:\n  def singleNumber(self, nums: List[int]) -> int:\n    ones = 0\n    twos = 0\n\n    for num in nums:\n      ones ^= (num & ~twos)\n      twos ^= (num & ~ones)\n\n    return ones",
        "runtime": "41"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        cache = {}\n        ans = -1\n        for i in nums:\n            if i in cache: \n                cache[i] = False\n            else: \n                ans = i\n                cache[i] = True\n        for i in cache.items():\n            if i[1]: return i[0]",
        "runtime": "50"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        return ((3*sum(set(nums)))-sum(nums))//2",
        "runtime": "50"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        count = defaultdict(int)\n        \n        for i in nums:\n            count[i] += 1\n\n        for x, v in count.items():\n            if v == 1:\n                return x\n        \n        return -1",
        "runtime": "59"
      },
      {
        "code": "from collections import Counter\nclass Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        a = collections.Counter(nums)\n        for i,j in a.items():\n            if j == 1:\n                return i",
        "runtime": "59"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        ones, twos = 0, 0\n\n        for num in nums:\n            ones = (ones ^ num) & ~twos\n            twos = (twos ^ num) & ~ones\n        \n        return ones",
        "runtime": "69"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        ones, twos = 0, 0\n        for num in nums:\n            twos |= ones & num\n            ones ^= num\n            threes = ones & twos\n            ones &= ~threes\n            twos &= ~threes\n        return ones\n\n\n \n        ",
        "runtime": "69"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        loner = 0 \n        for shift in range(32): \n            bit_sum = 0 \n            for num in nums: \n                bit_sum += (num >> shift) & 1 \n            loner_bit = bit_sum % 3 \n            loner = loner | (loner_bit << shift) \n        if loner >= (1 << 31): \n            loner = loner - (1 << 32)\n        return loner ",
        "runtime": "78"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        ans = 0\n        for i in range(32):\n            tmp = sum(num >> i & 1 for num in nums)\n            ans = ans | ((tmp % 3) << i)\n        \n        return ans if ans < 2**31 else ans - (1 << 32)\n",
        "runtime": "88"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: list[int]) -> int:\n        result = 0\n\n        for i in range(32):\n            bit_count = 0\n            for num in nums:\n                if (num >> i) & 1:\n                    bit_count += 1\n\n            if bit_count % 3 != 0:\n                if i == 31:\n                    result -= 1 << i\n                else:\n                    result |= 1 << i\n\n        return result\n",
        "runtime": "88"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        bit_count = [0] * 32\n        for n in nums:\n            for i in range(32):\n                bit_count[i] += n & (1 << i)\n        res = 0\n        for i in range(32):\n            if bit_count[i] % 3:\n                res |= (1 << i)\n        return res - (1<<32) if res & (1<<31) else res # adjust single bit to negative number\n",
        "runtime": "97"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        occurs = [0] * 32\n        for num in nums:\n            for i in range(32):\n                occurs[i] += 1 & (num >> i)\n        result = 0\n        for i in range(32):\n            if occurs[i] % 3:\n                result |= 1 << i\n        return result if not occurs[-1] % 3 else result - (1 << 32)",
        "runtime": "107"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        bit_values = [0] * 32\n        for num in nums:\n            for i in range(32):\n                bit = num & 1\n                bit_values[i] += bit\n                num >>= 1\n\n        bit_values = [i % 3 for i in bit_values]\n\n        result = 0\n        for bit in bit_values[::-1]:\n            result <<= 1\n            result |= bit\n\n        if result >= (1<<31):\n            result = result - (1 << 32)\n\n        return result\n\n\n\n\n\n\n\n        ",
        "runtime": "107"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        x = [0]*64\n        for n in nums:\n            n+=(2**31)\n            nb = bin(n)[2:].zfill(64)\n            for i in range(64):\n                if nb[i]=='1':\n                    x[i]+=1\n                    x[i]%=3\n        answer = 0\n        i = 0\n        while i<64:\n            answer += x[63-i] * (2**i)\n            i+=1\n        return answer - (2**31)\n",
        "runtime": "116"
      },
      {
        "code": "class Solution:\n\n    def to_bit(self, n, a):\n        if n < 0:\n            a[31] = 1\n            n += 1<<31\n        else:\n            a[31] = 0\n        n, i = abs(n), 0\n        while i < 31:\n            a[i] = n % 2\n            n >>= 1\n            i += 1\n        return a\n\n    def add(self, a, b):\n        for i in range(32):\n            a[i] = (a[i]+b[i]) % 3\n\n    def to_num(self, a):\n        rt, n = 0, 1\n        for i in range(31):\n            rt += a[i] * n\n            n *= 2\n        if a[31] == 1:\n            rt += -1<<31\n        return rt\n\n    def singleNumber(self, nums) -> int:\n        a, b = [0]*32, [0]*32\n        for i in nums:\n            self.add(a, self.to_bit(i, b))\n        return self.to_num(a)",
        "runtime": "116"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        hm={}\n        d=[]\n        for i in nums:\n            if i in hm.keys():\n                d.append(i)\n                hm[i]+=1\n            else:\n                hm[i]=1\n        for i in nums:\n            if(i not in d):\n                return i\n        return 0",
        "runtime": "125"
      },
      {
        "code": "class Solution:\n\n    def to_bit(self, n, a):\n        if n < 0:\n            a[31] = 1\n            n += 2**31\n        else:\n            a[31] = 0\n        n, i = abs(n), 0\n        while i < 31:\n            a[i] = n % 2\n            n >>= 1\n            i += 1\n        return a\n\n    def add(self, a, b):\n        for i in range(32):\n            a[i] = (a[i]+b[i]) % 3\n\n    def to_num(self, a):\n        rt, n = 0, 1\n        for i in range(31):\n            rt += a[i] * n\n            n *= 2\n        if a[31] == 1:\n            rt += -2**31\n        return rt\n\n    def singleNumber(self, nums) -> int:\n        a, b = [0]*32, [0]*32\n        for i in nums:\n            self.add(a, self.to_bit(i, b))\n        return self.to_num(a)",
        "runtime": "125"
      },
      {
        "code": "class Solution:\n    def countNumber(self, num):\n        result = deque()\n        orig = num\n        num = num if num >= 0 else -num\n        while num != 0:\n            result.appendleft(num % 2)\n            num = num // 2\n        while len(result) < 32:\n            result.appendleft(0)\n        result.appendleft(1 if orig < 0 else 0)\n        return result\n    def addNum(self, left, right):\n        for i in range(len(left)):\n            left[i] += right[i]\n    def singleNumber(self, nums: List[int]) -> int:\n        tmp = self.countNumber(nums[0])\n        for i in range(1, len(nums)):\n            self.addNum(tmp, self.countNumber(nums[i]))\n        for i in range(len(tmp)):\n            tmp[i] = tmp[i] % 3\n        result = 0\n        for i in range(1, len(tmp)):\n            result = result * 2 + tmp[i]\n        return result if tmp[0] == 0 else -result\n\n",
        "runtime": "135"
      },
      {
        "code": "from collections import Counter\n\nclass Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        def bits_iter(num):\n            while num:\n                yield num & 1\n                num = num >> 1\n        bits = Counter()\n        minuses = 0\n        for num in nums:\n            if num < 0:\n                minuses += 1\n            for i, bit in enumerate(bits_iter(abs(num))):\n                bits[i] += bit\n        res = 0\n        for i, b in bits.items():\n            if b % 3 != 0:\n                res = res | (1 << i)\n        if minuses % 3 != 0:\n            res *= -1\n        return res\n",
        "runtime": "135"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        g = [0] * 32\n        for n in nums:\n            bits = [int(x) for x in bin(n + 2**31)[2:].zfill(32)]\n            for i in range(32):\n                g[i] = (g[i] + bits[i]) % 3\n        return int(''.join(str(x) for x in g), 2) - 2**31",
        "runtime": "144"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        def three_adic_xor(x: int, y: int) -> int:\n            z = 0\n            for i in range(21):\n                z += ((x // 3**i + y // 3**i) % 3) * 3**i\n            return z\n    \n        res = 0\n        for x in nums:\n            res = three_adic_xor(res, x)\n        if res > 3**20:\n            res -= 3**21\n        return res",
        "runtime": "154"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums) -> int:\n        def to_bin(num):\n            s = \"\"\n            a = False\n            if num < 0:\n                a = True\n            num = abs(num)\n            while num != 0:\n                if num % 2 == 1:\n                    s += \"1\"\n                else:\n                    s += \"0\"\n                num //= 2\n\n            while len(s) < 32:\n                s += \"0\"\n            if a:\n                s += \"1\"\n            else:\n                s += \"0\"\n            return s[::-1]\n\n        def xor(a, b):\n            s = \"\"\n            for i in range(33):\n                if a[i] == \"0\":\n                    if b[i] == \"0\":\n                        s += \"0\"\n                    else:\n                        s += \"1\"\n                elif a[i] == \"1\":\n                    if b[i] == \"0\":\n                        s += \"1\"\n                    else:\n                        s += \"2\"\n                else:\n                    if b[i] == \"0\":\n                        s += \"2\"\n                    else:\n                        s += \"0\"\n            return s\n\n        def to_int(s):\n            if s[0] == \"1\":\n                return -int(s[1:], 2)\n            else:\n                return int(s[1:], 2)\n\n        S = \"0\" * 33\n        c = [0 for _ in range(33)]\n        for i in nums:\n            s = to_bin(i)\n            S = xor(S, s)\n        return to_int(S)\n\n\n\n\n\n            \n        ",
        "runtime": "154"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums) -> int:\n        def to_bin(num):\n            s = \"\"\n            a = False\n            if num < 0:\n                a = True\n            num = abs(num)\n            while num != 0:\n                if num % 2 == 1:\n                    s += \"1\"\n                else:\n                    s += \"0\"\n                num //= 2\n\n            while len(s) < 32:\n                s += \"0\"\n            if a:\n                s += \"1\"\n            else:\n                s += \"0\"\n            return s[::-1]\n\n        def xor(a, b):\n            s = \"\"\n            for i in range(33):\n                if a[i] == \"0\":\n                    if b[i] == \"0\":\n                        s += \"0\"\n                    else:\n                        s += \"1\"\n                elif a[i] == \"1\":\n                    if b[i] == \"0\":\n                        s += \"1\"\n                    else:\n                        s += \"2\"\n                else:\n                    if b[i] == \"0\":\n                        s += \"2\"\n                    else:\n                        s += \"0\"\n            return s\n\n        def to_int(s):\n            if s[0] == \"1\":\n                return -int(s[1:], 2)\n            else:\n                return int(s[1:], 2)\n\n        S = \"0\" * 33\n        c = [0 for _ in range(33)]\n        for i in nums:\n            s = to_bin(i)\n            S = xor(S, s)\n        return to_int(S)\n\n\n\n\n\n            \n        ",
        "runtime": "163"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        L = 33\n        delta = 1 << 31\n        bits = {i: 0 for i in range(L)}\n        for n in nums:\n            for i in range(L):\n                bits[i] += int(((n + delta) & (1 << i)) != 0)\n        res = 0\n        for i in range(L):\n            if bits[i] % 3 != 0:\n                res += 1 << i\n        return res - delta",
        "runtime": "163"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        m=min(nums)\n        n=0\n        for i in range(len(nums)):\n            n=max(len(bin(nums[i]-m))-2,n)\n        ans=''\n        for i in range(n-1,-1,-1):\n            a=0\n            b=0\n            for j in range(len(nums)):\n                if bin(nums[j]-m)[2:].zfill(n)[i]=='1':\n                    a+=1\n                else:\n                    b+=1\n            if a%3==1:\n                ans='1'+ans\n            else:\n                ans='0'+ans\n        return int(ans,2)+m\n\n        # nums.sort()\n        # ans=0\n        # if len(nums)==1:\n        #     return nums[ans]\n        # else:\n        #     while ans<len(nums):\n        #         if ans+1<len(nums) and nums[ans]==nums[ans+1]:\n        #             ans=ans+3\n        #         else:\n        #             return nums[ans]\n        # The following solution does not use constant space and does not work.\n        # a=set()\n        # for item in nums:\n        #     a.add(item)\n        # return (3*sum(a)-sum(nums))//2\n        \n\n",
        "runtime": "182"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        m=min(nums)\n        n=0\n        for i in range(len(nums)):\n            n=max(len(bin(nums[i]-m))-2,n)\n        ans=''\n        for i in range(n-1,-1,-1):\n            a=0\n            b=0\n            for j in range(len(nums)):\n                if bin(nums[j]-m)[2:].zfill(n)[i]=='1':\n                    a+=1\n                else:\n                    b+=1\n            if a%3==1:\n                ans='1'+ans\n            else:\n                ans='0'+ans\n        return int(ans,2)+m\n\n        # nums.sort()\n        # ans=0\n        # if len(nums)==1:\n        #     return nums[ans]\n        # else:\n        #     while ans<len(nums):\n        #         if ans+1<len(nums) and nums[ans]==nums[ans+1]:\n        #             ans=ans+3\n        #         else:\n        #             return nums[ans]\n        # The following solution does not use constant space and does not work.\n        # a=set()\n        # for item in nums:\n        #     a.add(item)\n        # return (3*sum(a)-sum(nums))//2\n        \n\n",
        "runtime": "182"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        num_bits = int(35)\n        bit_sequence = [\"0\"] * num_bits\n        for i in range(num_bits):\n            bit_sum = 0\n            for n in nums:\n                bits = bin(n)[2:]\n                bits = (\"0\" * (num_bits - len(bits))) + bits\n                if bits[i] == \"1\":\n                    bit_sum += 1\n            if bit_sum % 3 != 0:\n                bit_sequence[i] = \"1\"\n\n\n        result = int(\"\".join(bit_sequence), 2)\n        # sign check\n        negative_count = 0\n        for n in nums:\n            bits = bin(n)\n            if bits[0] == \"-\":\n                negative_count += 1\n        \n        if negative_count % 3 != 0:\n            result *= -1\n\n        return result",
        "runtime": "191"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        ln=len(nums)\n        if ln>64:\n                \n                while(1):\n                    val = nums[0]\n                    nums.remove(val)\n                    if val in nums:\n                        nums.append(val)\n                    else:\n                        return val\n        else:\n            dicto={}\n            for i in nums:\n                if i in dicto.keys():\n                    dicto[i]+=1\n                else:\n                    dicto[i]=1\n            mini=min(dicto.values())\n            for i in dicto.items():\n                if i[1]==mini:\n                    return i[0] \n\ndef isin(value,arr):\n    left=0\n    right=len(arr)-1\n    mid=0\n    while(left<=right):\n            mid=(left+right)//2\n            if value==arr[mid]:\n                return True\n            elif value>arr[mid]:\n                left=mid+1\n            else:\n                right=mid-1\n    return False\n                \n    \n                \n            \n\n        ",
        "runtime": "210"
      }
    ],
    "memory_inefficient_codes": [
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        ones,twos=0,0\n        for num in nums:\n            ones=(ones^num)& ~twos\n            twos=(twos^num)& ~ones\n        return ones",
        "memory": "18700"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        d={}\n        for i in nums :\n            if i not in d :\n                d[i]=1\n            else:\n                if d[i]==1:\n                    d[i]+=1\n                else:\n                    del d[i]\n        return list(d.keys())[0]\n        ",
        "memory": "18700"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        d = dict()\n        for i in range(len(nums)):\n            if nums[i] not in d:\n                d[nums[i]]=1\n            else:\n                d[nums[i]]+=1\n        for k,v in d.items():\n            if v==1:\n                return k\n                \n        return 0\n        ",
        "memory": "18800"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        count = defaultdict(int)\n\n        for i in nums:\n            count[i] += 1\n        \n        for x, freq in count.items():\n            if freq == 1:\n                return x\n        \n        return -1\n",
        "memory": "18800"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        d= {}\n        for i in nums:\n            if i not in d:\n                d[i] = 1\n            else:\n                if d[i] ==1:\n                    d[i] += 1\n                else:\n                    del d[i]    \n\n        return list(d.keys())[0]  \n\n\n        ",
        "memory": "18900"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        counts = Counter(nums)\n        for n in counts:\n            if counts[n] == 1:\n                return n\n",
        "memory": "18900"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        return (3 * sum(set(nums)) - sum(nums)) // 2",
        "memory": "19000"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        return ((3*sum(set(nums)))-sum(nums))//2",
        "memory": "19000"
      }
    ],
    "memory_moderate_codes": [
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        for i in nums:\n            c=nums.count(i)\n            if c==1:\n                return i",
        "memory": "18400"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        for i in nums:\n            if nums.count(i) == 1:\n                return i\n        ",
        "memory": "18400"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        c=0\n        for i in nums:\n            c=nums.count(i)\n            if c==1:\n                return i",
        "memory": "18500"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        ones, twos = 0, 0\n    \n        for num in nums:\n            ones = (ones ^ num) & ~twos\n            twos = (twos ^ num) & ~ones\n    \n  \n        return ones  \n        ",
        "memory": "18500"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        nums.sort()\n        l = 0\n        while(l<len(nums)-1):\n            if nums[l] == nums[l+1]:\n                l += 3\n            else:\n                break\n        return nums[l]\n        ",
        "memory": "18600"
      },
      {
        "code": "class Solution:\n    def singleNumber(self, nums: list[int]) -> int:\n        result = 0\n\n        for i in range(32):\n            bit_count = 0\n            for num in nums:\n                if (num >> i) & 1:\n                    bit_count += 1\n\n            if bit_count % 3 != 0:\n                if i == 31:\n                    result -= 1 << i\n                else:\n                    result |= 1 << i\n\n        return result\n",
        "memory": "18600"
      }
    ],
    "memory_efficient_codes": [
      {
        "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        ans = 0\n        for i in range(32):  # loop through all 32 bits\n            s = 0\n            for j in nums:\n                t = (j >> i) & 1\n                s += t\n            s %= 3\n            if i == 31 and s:  # handle the sign bit separately\n                ans -= (1 << 31)\n            else:\n                ans |= (s << i)\n        return ans\n\n\n        ",
        "memory": "18100"
      }
    ],
    "import_code": "from typing import List",
    "setup_code": "# Define the necessary data structures and helper classes.\n\nclass Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        result = 0\n        for i in nums:\n            if nums.count(i) != 3:\n                return i\n\nclass TestCaseGenerator:\n    def generate(self) -> dict:\n        \"\"\"\n        Generate a sample test case input where elements \n        appear three times except one. This will return \n        a dictionary with one element `nums` containing \n        a list.\n        \"\"\"\n        nums = [2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]\n        return {'nums': nums}  # Random test case where the number `3` appears once.\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\"\n        Convert a test case input into a string.\n        This typically involves converting the list into a string format.\n        \"\"\"\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\"\n        Since the expected output is an integer, simply convert it to string.\n        This will help in returning a stringified version of the integer result.\n        \"\"\"\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\"\n        Given the input string, convert it back to a dictionary with key `nums`.\n        Warning: eval() is used here for simplicity; in production, safer alternatives\n        should be used to parse the input format to avoid code injection vulnerabilities.\n        \"\"\"\n        nums = eval(input_str)  # Careful with eval, consider safer methods if in doubt.\n        return {'nums': nums}",
    "libraries": ["from typing import List"],
    "entry_point": "singleNumber",
    "test_cases": [
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      },
      {
        "input": "[2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]",
        "output": "3"
      }
    ]
  },
  {
    "question_id": 138,
    "name": "copy-list-with-random-pointer",
    "prompt": "<p>A linked list of length <code>n</code> is given such that each node contains an additional random pointer, which could point to any node in the list, or <code>null</code>.</p>\n\n<p>Construct a <a href=\"https://en.wikipedia.org/wiki/Object_copying#Deep_copy\" target=\"_blank\"><strong>deep copy</strong></a> of the list. The deep copy should consist of exactly <code>n</code> <strong>brand new</strong> nodes, where each new node has its value set to the value of its corresponding original node. Both the <code>next</code> and <code>random</code> pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. <strong>None of the pointers in the new list should point to nodes in the original list</strong>.</p>\n\n<p>For example, if there are two nodes <code>X</code> and <code>Y</code> in the original list, where <code>X.random --&gt; Y</code>, then for the corresponding two nodes <code>x</code> and <code>y</code> in the copied list, <code>x.random --&gt; y</code>.</p>\n\n<p>Return <em>the head of the copied linked list</em>.</p>\n\n<p>The linked list is represented in the input/output as a list of <code>n</code> nodes. Each node is represented as a pair of <code>[val, random_index]</code> where:</p>\n\n<ul>\n\t<li><code>val</code>: an integer representing <code>Node.val</code></li>\n\t<li><code>random_index</code>: the index of the node (range from <code>0</code> to <code>n-1</code>) that the <code>random</code> pointer points to, or <code>null</code> if it does not point to any node.</li>\n</ul>\n\n<p>Your code will <strong>only</strong> be given the <code>head</code> of the original linked list.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/12/18/e1.png\" style=\"width: 700px; height: 142px;\" />\n<pre>\n<strong>Input:</strong> head = [[7,null],[13,0],[11,4],[10,2],[1,0]]\n<strong>Output:</strong> [[7,null],[13,0],[11,4],[10,2],[1,0]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/12/18/e2.png\" style=\"width: 700px; height: 114px;\" />\n<pre>\n<strong>Input:</strong> head = [[1,1],[2,1]]\n<strong>Output:</strong> [[1,1],[2,1]]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/12/18/e3.png\" style=\"width: 700px; height: 122px;\" /></strong></p>\n\n<pre>\n<strong>Input:</strong> head = [[3,null],[3,0],[3,null]]\n<strong>Output:</strong> [[3,null],[3,0],[3,null]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= n &lt;= 1000</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= Node.val &lt;= 10<sup>4</sup></code></li>\n\t<li><code>Node.random</code> is <code>null</code> or is pointing to some node in the linked list.</li>\n</ul>\n",
    "difficulty": "Medium",
    "topics": ["hash-table", "linked-list"],
    "runtime_inefficient_codes": [
      {
        "code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        old_to_new = {None:None}\n        \n        old = head\n        while old:\n            new = Node(old.val)\n            old_to_new[old] = new\n            old = old.next\n        \n        old = head\n        while old:\n            new = old_to_new[old]\n            new.next = old_to_new[old.next]\n            new.random = old_to_new[old.random]\n            old = old.next\n        \n        return old_to_new[head]",
        "runtime": "39"
      },
      {
        "code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        if not head:\n            return head\n        \n        old = head\n        while old:\n            new = Node(old.val)\n            \n            tmp = old.next\n            new.next = tmp\n            old.next = new\n            old = tmp\n        \n        old = head\n        \n        while old:\n            old.next.random = old.random.next if old.random else None\n            old = old.next.next\n        \n        old = head\n        new = head.next\n        new_head = head.next\n        while old:\n            old.next = old.next.next\n            new.next = new.next.next if old.next else None\n            old = old.next\n            new = new.next\n        \n        return new_head\n",
        "runtime": "39"
      },
      {
        "code": "class Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        if not head:\n            return None\n        old_to_new = {}\n\n        clone = head\n\n        while clone:\n            old_to_new[clone] = Node(clone.val)\n            clone = clone.next\n\n        clone = head\n        while clone:\n            old_to_new[clone].next = old_to_new.get(clone.next)\n            old_to_new[clone].random = old_to_new.get(clone.random)\n            clone = clone.next\n        return old_to_new[head]",
        "runtime": "40"
      },
      {
        "code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        if not head:\n            return None\n        old_to_new = {}\n        \n        curr = head\n        while curr:\n            old_to_new[curr] = Node(curr.val)\n            curr = curr.next\n        \n        curr = head\n        while curr:\n            old_to_new[curr].next = old_to_new.get(curr.next)\n            old_to_new[curr].random = old_to_new.get(curr.random)\n            curr = curr.next\n            \n        return old_to_new[head]\n        \n        ",
        "runtime": "40"
      },
      {
        "code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        if not head:\n            return None\n\n        # Step 1: Create a mapping from original nodes to new nodes\n        old_to_new = {}\n\n        current = head\n        while current:\n            old_to_new[current] = Node(current.val)  # Create a copy of the node\n            current = current.next\n\n        # Step 2: Assign next and random pointers to the new nodes\n        current = head\n        while current:\n            if current.next:\n                old_to_new[current].next = old_to_new[current.next]\n            if current.random:\n                old_to_new[current].random = old_to_new[current.random]\n            current = current.next\n\n        # Return the head of the copied list\n        return old_to_new[head]",
        "runtime": "41"
      },
      {
        "code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        old_to_copy = {None:None}\n        \n        old = head\n        while old:\n            new = Node(old.val)\n            old_to_copy[old] = new\n            old = old.next\n        \n        old = head\n        while old:\n            new = old_to_copy[old]\n            new.next = old_to_copy[old.next]\n            new.random = old_to_copy[old.random]\n            old = old.next\n        \n        return old_to_copy[head]\n",
        "runtime": "42"
      },
      {
        "code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        old_to_copy = {None:None}\n        \n        old = head\n        while old:\n            new = Node(old.val)\n            old_to_copy[old] = new\n            old = old.next\n        \n        old = head\n        while old:\n            new = old_to_copy[old]\n            new.next = old_to_copy[old.next]\n            new.random = old_to_copy[old.random]\n            old = old.next\n        \n        return old_to_copy[head]\n",
        "runtime": "42"
      },
      {
        "code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        if not head:\n            return None\n\n        # Fix: Correctly initialize the defaultdict to map old nodes to new ones\n        node_map = defaultdict(lambda: None)\n\n        # Create the new head node\n        res = Node(head.val)\n        node_map[head] = res\n        dummy = head\n\n        # First pass to create new nodes and link next pointers\n        while head:\n            # Create a new node for the current head if it does not exist in the map\n            if not node_map[head]:\n                node_map[head] = Node(head.val)\n            \n            # Handle the next node\n            if head.next and not node_map[head.next]:\n                node_map[head.next] = Node(head.next.val)\n\n            node_map[head].next = node_map[head.next]  # Link the next pointer\n            \n            # Move to the next node\n            head = head.next\n\n        # Second pass to link random pointers\n        while dummy:\n            if dummy.random:\n                node_map[dummy].random = node_map[dummy.random]  # Map random pointers\n            dummy = dummy.next\n\n\n        return res\n\n        ",
        "runtime": "43"
      },
      {
        "code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n\n        if not head:\n            return None\n            \n        copynodes={None:None}\n        curr=head\n        while curr:\n            copy=Node(curr.val)\n            copynodes[curr]=copy\n            curr=curr.next\n        \n        curr=head\n        while curr:\n            copy=copynodes[curr]\n            copy.next=copynodes[curr.next]\n            copy.random=copynodes[curr.random]\n            curr=curr.next\n        return copynodes[head]\n        ",
        "runtime": "43"
      },
      {
        "code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        oldToCopy = {None : None}\n\n        cur = head\n        while cur:\n            oldToCopy[cur] = Node(cur.val)\n            cur = cur.next\n        \n        cur = head\n        while cur:\n            oldToCopy[cur].next = oldToCopy[cur.next]\n            oldToCopy[cur].random = oldToCopy[cur.random]\n            cur = cur.next\n        \n        return oldToCopy[head]",
        "runtime": "44"
      },
      {
        "code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        old={None:None}\n        cur=head\n        while cur:\n            copy=Node(cur.val)\n            old[cur]=copy\n            cur=cur.next\n        cur= head\n        while cur:\n            copy=old[cur]\n            copy.next=old[cur.next]\n            copy.random=old[cur.random]\n            cur=cur.next\n        return old[head]    ",
        "runtime": "44"
      },
      {
        "code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        # time O(n)\n        # space O(n)\n        nodes = {} # key = curr nodes   \n        tmp = head\n\n        while tmp:\n            nodes[tmp] = Node(tmp.val)\n            tmp = tmp.next\n        \n        for node, newNode in nodes.items():\n            newNode.next = nodes[node.next] if node.next else None\n            newNode.random = nodes[node.random] if node.random else None\n        \n        return nodes[head] if head else None\n",
        "runtime": "45"
      },
      {
        "code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        oldToCopy = {None:None}             # for getting a NULL node or to refer to a NULL node\n        curr = head\n\n        while curr:\n            copy = Node(curr.val)\n            oldToCopy[curr] = copy\n            curr = curr.next\n\n        curr = head\n\n        while curr:\n            copy = oldToCopy[curr]\n            copy.next = oldToCopy[curr.next]\n            copy.random = oldToCopy[curr.random]\n            curr = curr.next\n        \n        return oldToCopy[head]\n",
        "runtime": "45"
      },
      {
        "code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        old_to_new = { None : None }\n\n        curr = head\n        while curr:\n            copy = Node(curr.val)\n            old_to_new[curr] = copy\n            curr = curr.next\n        \n        curr = head\n        while curr:\n            copy = old_to_new[curr]\n            copy.next = old_to_new[curr.next]\n            copy.random = old_to_new[curr.random]\n            curr = curr.next\n        \n        return old_to_new[head]",
        "runtime": "46"
      },
      {
        "code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        # using dictionary, we can copy the linked list, with O(N) space\n        # there is a way to use O(1) space, 3 passes of the list: first, generate copyed node, then, assign random, then assign next\n        if not head: return None\n        cur = head\n        # first pass\n        while cur:\n            new = Node(cur.val)\n            new.next = cur.next\n            cur.next = new\n            cur = new.next\n        # second pass\n        cur = head\n        while cur:\n            if cur.random:\n                cur.next.random = cur.random.next\n            else:\n                cur.next.random = None\n            cur = cur.next.next\n        # third pass\n        cur = head.next\n        while cur:\n            if cur.next:\n                cur.next = cur.next.next\n            else:\n                cur.next = None\n            cur = cur.next\n        return head.next\n\n\n",
        "runtime": "46"
      }
    ],
    "runtime_moderate_codes": [
      {
        "code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        old_copy = dict()\n        cur = head\n\n        while cur:\n            temp = Node(cur.val)\n            old_copy[cur] = temp\n            cur = cur.next\n\n        cur = head\n\n        while cur:\n            temp = old_copy.get(cur)\n            temp.next = old_copy.get(cur.next)\n            temp.random = old_copy.get(cur.random)\n            cur = cur.next\n\n        return old_copy.get(head)",
        "runtime": "24"
      },
      {
        "code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        if not head:\n            return None\n\n        copyToNode = { None : None}\n\n        # First pass\n        cur = head\n        while cur:\n            copy = Node(cur.val)\n            copyToNode[cur] = copy\n            cur = cur.next\n\n        # Second pass\n        cur = head\n        while cur:\n            copy = copyToNode[cur]\n            copy.next = copyToNode[cur.next]\n            copy.random = copyToNode[cur.random]\n            cur = cur.next\n\n        return copyToNode[head]    \n\n\n\n\n        # if not head:\n        #     return None\n        # visited = {}\n\n        # original = head\n\n\n        # # First pass\n        # original = head\n        # while original:\n        #     visited[original] = Node(original.val) \n        #     original = original.next\n\n        # # Second pass\n        # original = head\n        # while original:\n        #     copied = visited[original]\n        #     copied.random = visited.get(original.random)\n        #     copied.next = visited.get(original.next)\n        #     original = original.next\n\n        # return visited[head]      \n        ",
        "runtime": "25"
      },
      {
        "code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        if head is None: return None\n        randDict = {}\n        start = head\n        while start:\n            randDict[start] = Node(start.val)\n            start = start.next\n        start = head\n        while start:\n            if start.next:\n                randDict[start].next = randDict[start.next]\n            if start.random:\n                randDict[start].random = randDict[start.random]\n            start = start.next\n        return randDict[head]",
        "runtime": "26"
      },
      {
        "code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        if not head:\n            return None\n        curr = head\n        old_to_new = {}\n        while curr:\n            old_to_new[curr] = Node(curr.val)\n            curr = curr.next\n        \n        curr = head\n        while curr:\n            old_to_new[curr].next = old_to_new.get(curr.next)\n            old_to_new[curr].random = old_to_new.get(curr.random)\n            curr = curr.next\n        \n        return old_to_new[head]\n\n        ",
        "runtime": "26"
      },
      {
        "code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        oldToCopy = {None : None}\n\n        cur = head\n        while cur:\n            copy = Node(cur.val)\n            oldToCopy[cur] = copy\n            cur = cur.next\n        \n        cur = head\n        while cur:\n            copy = oldToCopy[cur]\n            copy.next = oldToCopy[cur.next]\n            copy.random = oldToCopy[cur.random]\n            cur = cur.next\n\n        return oldToCopy[head]\n\n        \n\n        ",
        "runtime": "27"
      },
      {
        "code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        if not head:\n            return head\n        \n        # handle node and next pointer\n        old = head\n        while old:\n            new = Node(old.val)\n            \n            tmp = old.next\n            new.next = tmp\n            old.next = new\n            old = tmp\n        \n        # handle random pointer\n        old = head\n        while old:\n            old.next.random = old.random.next if old.random else None\n            old = old.next.next\n        \n        # unweave lists\n        old = head\n        new = head.next\n        new_head = head.next\n        while old:\n            old.next = old.next.next\n            new.next = new.next.next if new.next else None\n            old = old.next\n            new = new.next\n        \n        return new_head\n",
        "runtime": "27"
      },
      {
        "code": "class Solution:\n  def copyRandomList(self, head: 'Node') -> 'Node':\n    if not head:\n      return None\n    if head in self.map:\n      return self.map[head]\n\n    newNode = Node(head.val)\n    self.map[head] = newNode\n    newNode.next = self.copyRandomList(head.next)\n    newNode.random = self.copyRandomList(head.random)\n    return newNode\n\n  map = {}",
        "runtime": "28"
      },
      {
        "code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        if not head:\n            return None\n        curr = head\n        new = Node(-1)\n        newcurr = new\n        rd = {}\n        while curr:\n            if curr in rd:\n                new_node = rd[curr]\n            else:\n                new_node = Node(curr.val)\n                rd[curr] = new_node\n            newcurr.next = new_node\n            if curr.random:\n                if curr.random in rd:\n                    new_node.random = rd[curr.random]\n                else:\n                    new_node.random = Node(curr.random.val)\n                    rd[curr.random] = new_node.random\n            newcurr = new_node\n            curr = curr.next\n        return new.next",
        "runtime": "28"
      },
      {
        "code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        apearDic = {}\n        if head is None:\n            return None\n\n        def copyRecusive(node):\n            if node.next is None:\n                nNode = Node(node.val, None, node.random)\n                apearDic[node] = nNode\n                return nNode\n            \n            nNext = copyRecusive(node.next)\n            nNode = Node(node.val, nNext, node.random)\n            apearDic[node] = nNode\n            return nNode\n        newNode = copyRecusive(head)\n        \n\n        def modifyRecusively(node):\n            if node is None:\n                return\n            if node.random in apearDic:\n                node.random = apearDic[node.random]\n            else:\n                node.random = None\n            modifyRecusively(node.next)\n        \n        modifyRecusively(newNode)\n        return newNode\n\n\n            \n        ",
        "runtime": "29"
      },
      {
        "code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n\n        if head==None: return None\n        #if head.next==None: return Node(head.val,None,None)\n\n        node1 = head\n        node2 = Node(node1.val,None,None)\n        visited1 = []\n        visited2 = []\n\n        new_head = node2\n        \n        while node1 != None:\n            if node1.next != None:\n                node2.next = Node(node1.next.val,None,None)\n\n            visited1.append(node1)\n            visited2.append(node2)\n\n            node1 = node1.next\n            node2 = node2.next\n        \n        node1 = head\n        node2 = new_head\n        while node1 != None:\n            if node1.random != None:\n                node2.random = visited2[visited1.index(node1.random)]\n\n            node1 = node1.next\n            node2 = node2.next\n\n        return new_head\n        ",
        "runtime": "29"
      },
      {
        "code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def __init__(self):\n        self.visited_nodes = {}\n\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        if head == None:\n            return None\n\n        if head in self.visited_nodes:\n            return self.visited_nodes[head]\n        \n        copy = Node(head.val)\n        self.visited_nodes[head] = copy\n\n        copy.next = self.copyRandomList(head.next)\n        copy.random = self.copyRandomList(head.random)\n        return copy\n        \n",
        "runtime": "30"
      },
      {
        "code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        apearDic = {}\n        if head is None:\n            return None\n\n        def copyRecusive(node):\n            if node.next is None:\n                nNode = Node(node.val, None, node.random)\n                apearDic[node] = nNode\n                return nNode\n            \n            nNext = copyRecusive(node.next)\n            apearDic[node.next] = nNext\n            \n            nNode = Node(node.val, nNext, node.random)\n            apearDic[node] = nNode\n            return nNode\n        newNode = copyRecusive(head)\n        \n\n        def modifyRecusively(node):\n            if node is None:\n                return\n            if node.random in apearDic:\n                node.random = apearDic[node.random]\n            else:\n                node.random = None\n            modifyRecusively(node.next)\n        \n        modifyRecusively(newNode)\n        return newNode\n\n\n            \n        ",
        "runtime": "30"
      },
      {
        "code": "class Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        if not head:\n            return None\n        old_to_new = {}\n\n        clone = head\n\n        while clone:\n            old_to_new[clone] = Node(clone.val)\n            clone = clone.next\n\n        clone = head\n        while clone:\n            old_to_new[clone].next = old_to_new.get(clone.next)\n            old_to_new[clone].random = old_to_new.get(clone.random)\n            clone = clone.next\n        return old_to_new[head]",
        "runtime": "31"
      },
      {
        "code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        if not head:\n            return None \n        hMap = {}\n        curr = head\n        while curr:\n            hMap[curr] = Node(curr.val)\n            curr = curr.next\n\n        curr = head\n        while curr:\n            if curr.next:\n                hMap[curr].next = hMap[curr.next]\n            if curr.random:\n                hMap[curr].random = hMap[curr.random]\n            curr = curr.next\n        return hMap[head]",
        "runtime": "31"
      },
      {
        "code": "class Solution:\n    def copyRandomList(self, head: \"Optional[Node]\") -> \"Optional[Node]\":\n        if not head:\n            return head\n\n        # Creating a new weaved list of original and copied nodes.\n        old = head\n        while old:\n\n            # Cloned node\n            new = Node(old.val)\n\n            # Inserting the cloned node just next to the original node.\n            # If A->B->C is the original linked list,\n            # Linked list after weaving cloned nodes would be A->A'->B->B'->C->C'\n            tmp = old.next\n            new.next = old.next\n            old.next = new\n            old = tmp\n\n        old = head\n\n        # Now link the random pointers of the new nodes created.\n        # Iterate the newly created list and use the original nodes random pointers,\n        # to assign references to random pointers for cloned nodes.\n        while old:\n            old.next.random = old.random.next if old.random else None\n            old = old.next.next\n\n        # Unweave the linked list to get back the original linked list and the cloned list.\n        # i.e. A->A'->B->B'->C->C' would be broken to A->B->C and A'->B'->C'\n        old = head  # A->B->C\n        new = head.next  # A'->B'->C'\n        new_head = head.next\n        while old:\n            old.next = old.next.next\n            new.next = new.next.next if old.next else None\n            old = old.next\n            new = new.next\n        return new_head\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    ",
        "runtime": "32"
      },
      {
        "code": "\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        if not head:\n            return None\n        hashM = {}\n        \n        currentNode = head\n        while currentNode:\n            hashM[currentNode] = Node(currentNode.val)\n            currentNode = currentNode.next\n        \n        currentNode = head\n        while currentNode:\n            hashM[currentNode].next = hashM.get(currentNode.next)\n            hashM[currentNode].random = hashM.get(currentNode.random)\n            currentNode = currentNode.next\n            \n        return hashM[head]\n        ",
        "runtime": "32"
      },
      {
        "code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        original_to_copy = {}\n        dummy_head = dummy = Node(0)\n        temp = head\n        while temp:\n            copy = Node(temp.val)\n            original_to_copy[temp] = copy\n            dummy.next = copy\n            dummy = dummy.next\n            temp = temp.next\n        temp = head\n        while temp:\n            copy = original_to_copy[temp]\n            copy.next = original_to_copy[temp.next] if temp.next else None\n            copy.random = original_to_copy[temp.random] if temp.random else None\n            temp = temp.next\n        return dummy_head.next",
        "runtime": "33"
      },
      {
        "code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        if not head:\n            return None\n\n        mapping={}\n        curr = head\n        while curr:\n            mapping[curr]=Node(curr.val)\n            curr=curr.next\n\n        curr=head\n        while curr:\n            if curr.next:\n                mapping[curr].next=mapping[curr.next]\n            if curr.random:\n                mapping[curr].random=mapping[curr.random]\n\n            curr=curr.next\n\n        return mapping[head]\n\n        \n\n        return new",
        "runtime": "34"
      },
      {
        "code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        if not head:\n            return head\n        \n        # creating new nodes in between the nodes.\n        # 1--> 2--> 3-->.\n        # 1--> 1'--> 2--> 2'--> 3--> 3'.\n        curr = head\n        while curr:\n            newnode = Node(curr.val,curr.next)\n            curr.next = newnode\n            curr = newnode.next\n        \n        # setting random pointers.\n        curr = head\n        while curr:\n            if curr.random:\n                curr.next.random = curr.random.next\n            curr = curr.next.next\n        \n        # separating old list and new list.\n        old_head = head\n        new_head = head.next\n        curr_old = old_head\n        curr_new = new_head\n        \n        while curr_old:\n            curr_old.next = curr_old.next.next\n            curr_new.next = curr_new.next.next if curr_new.next else None \n            curr_old = curr_old.next\n            curr_new = curr_new.next\n            \n        # return new list's head.\n        return new_head",
        "runtime": "34"
      },
      {
        "code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n\n        nodelist = {None: None}\n        curr = head\n        newList = Node(0)\n        \n        temp = newList\n        while curr:\n            newNode = Node(curr.val)\n            nodelist[curr] = newNode\n            temp.next = newNode\n            temp = temp.next\n            curr = curr.next\n        \n        temp.next = None\n\n\n        curr = head\n        temp = newList.next\n        while curr:\n            temp.random = nodelist[curr.random]\n            curr = curr.next\n            temp = temp.next\n        \n        return newList.next\n\n\n\n        \n        ",
        "runtime": "35"
      },
      {
        "code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        cur = dummy = Node(0)\n        old = head\n        old_to_new = {}\n        while old:\n            new_node = Node(old.val)\n            old_to_new[old] = new_node\n            cur.next = new_node\n            old = old.next\n            cur = cur.next\n\n        cur = dummy.next\n        old = head\n        while old:\n            if old.random:\n                cur.random = old_to_new[old.random]\n            old = old.next\n            cur = cur.next\n\n        return dummy.next",
        "runtime": "36"
      },
      {
        "code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        hm={None:None}\n\n        curr=head\n        while curr:\n            hm[curr]=Node(curr.val)\n            curr=curr.next\n        \n        curr=head\n        while curr:\n            hm[curr].next=hm[curr.next]\n            hm[curr].random=hm[curr.random]\n            curr=curr.next\n        \n        return hm[head]\n\n",
        "runtime": "36"
      },
      {
        "code": "class Solution:\n    def copyRandomList(self, head: \"Optional[Node]\") -> \"Optional[Node]\":\n        \"\"\"\n        The idea here is to intertwine the lists in the way\n        A -> A' -> B -> B' -> C -> C' ...\n        Then we can point the random pointers correctly\n        \"\"\"\n\n        if head is None:\n            return None\n\n        # Traverse the original list intertweaving it with a new list\n        node = head\n        while node is not None:\n            next = node.next\n            new_node = Node(node.val)\n            node.next = new_node\n            new_node.next = next\n            node = next\n\n        # Traverse the list again, for all the new nodes, the random value\n        # will be the next of the random of the previous if it makes sense\n        node = head\n        while node is not None:\n            copy = node.next\n            if node.random is not None:\n                copy.random = node.random.next\n\n            node = copy.next\n\n        # Separate the lists\n        node = head\n        new_head = node.next\n        while node is not None:\n            copy = node.next\n            node.next = copy.next\n            next = copy.next\n            if next is not None:\n                copy.next = next.next\n            else:\n                copy.next = None\n            node = next\n\n        return new_head",
        "runtime": "37"
      },
      {
        "code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        if not head: return head\n        start = head\n        mem = {}\n\n        while start:\n            mem[start] = Node(start.val)\n            start = start.next\n        start = head\n        while start:\n            if start.next:\n                mem[start].next = mem[start.next]\n            if start.random:\n                mem[start].random = mem[start.random]\n            start = start.next\n        \n        return mem[head]",
        "runtime": "37"
      },
      {
        "code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        dummy = new_tmp = Node(0)\n        temp = head\n        dic = {}\n        while temp:\n            if temp in dic.keys():\n                new_node = dic[temp]\n            else:\n                new_node = Node(temp.val)\n                dic[temp] = new_node\n            if temp.random:\n                if temp.random in dic.keys():\n                    new_node.random = dic[temp.random]\n                else:\n                    rand_node = Node(temp.random.val)\n                    dic[temp.random] = rand_node\n                    new_node.random = rand_node\n            \n            new_tmp.next = new_node\n            new_tmp = new_tmp.next\n            temp = temp.next\n        return dummy.next",
        "runtime": "38"
      },
      {
        "code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        # dummy = new_tmp = Node(0)\n        # temp = head\n        # dic = {}\n        # while temp:\n        #     if dic.get(temp, None):\n        #         new_node = dic[temp]\n        #     else:\n        #         new_node = Node(temp.val)\n        #         dic[temp] = new_node\n        #     if temp.random:\n        #         if dic.get(temp.random, None):\n        #             new_node.random = dic[temp.random]\n        #         else:\n        #             rand_node = Node(temp.random.val)\n        #             dic[temp.random] = rand_node\n        #             new_node.random = rand_node\n            \n        #     new_tmp.next = new_node\n        #     new_tmp = new_tmp.next\n        #     temp = temp.next\n        # return dummy.next\n        if not head: return head\n\n        temp = head\n        while temp:\n            next_node = temp.next\n            temp.next = Node(x=temp.val, next = next_node)\n            temp = next_node\n\n        temp = head\n        while temp and temp.next:\n            if temp.random:\n                temp.next.random = temp.random.next\n            temp = temp.next.next\n\n        new_head = new_temp = head.next\n        temp = head\n\n        while new_temp and new_temp.next:\n            temp.next = temp.next.next\n            temp = temp.next\n            new_temp.next = new_temp.next.next\n            new_temp = new_temp.next\n        return new_head",
        "runtime": "38"
      }
    ],
    "runtime_efficient_codes": [
      {
        "code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        arr = collections.defaultdict(Node)\n        cur = head\n        if not head:\n            return None\n\n        while cur:\n            arr[cur] = Node(cur.val, None, None)\n            cur = cur.next\n        \n        cur = head\n        while cur:\n            if cur.random:\n                arr[cur].random = arr[cur.random]\n            if cur.next:\n                arr[cur].next = arr[cur.next]\n            cur = cur.next\n        return arr[head]",
        "runtime": "12"
      },
      {
        "code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        if not head:\n            return head\n\n        seenNodes = {}\n        cur = head\n        while cur:\n            seenNodes[cur] = Node(cur.val)\n            cur = cur.next\n\n        cur = head\n        while cur:\n            copiedCur = seenNodes.get(cur, None)\n            if cur.next:\n                copiedCur.next = seenNodes.get(cur.next, None)\n            if cur.random:\n                copiedCur.random = seenNodes.get(cur.random, None)\n            cur = cur.next\n\n        return seenNodes.get(head, None)\n",
        "runtime": "17"
      },
      {
        "code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        temp = head\n        if not head:\n            return head\n        d = {}\n        while temp:\n            newNode = Node(temp.val)\n            d[temp] = newNode\n            temp = temp.next\n        \n        temp = head\n        while temp:\n            res = d[temp]\n            res.next = d.get(temp.next)\n            res.random = d.get(temp.random)\n            temp = temp.next\n\n        return d[head]\n",
        "runtime": "18"
      },
      {
        "code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        if not head :\n            return head\n        curr = head\n        s = {}\n        while curr :\n            s[curr] = Node(curr.val)\n            curr = curr.next\n\n        curr = head\n        while curr :\n            s[curr].next = s.get(curr.next)\n            s[curr].random = s.get(curr.random)\n            curr = curr.next\n        \n        return s[head]",
        "runtime": "19"
      },
      {
        "code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        if head is None: return None\n        mapping = {}\n        cur = head\n        while cur:\n            mapping[cur] = Node(cur.val,None,None)\n            cur = cur.next\n        cur = head\n        while cur:\n            if cur.next:\n                mapping[cur].next = mapping[cur.next]\n            if cur.random:\n                mapping[cur].random = mapping[cur.random]\n            cur = cur.next\n        return mapping[head]",
        "runtime": "20"
      },
      {
        "code": "from typing import Optional\n\n\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        # Take O(n) space to store node translation table\n        old2new = {None: None}\n\n        if not head:\n            return None\n        \n        def copy_helper(head: Optional[Node]) -> Optional[Node]:\n            nonlocal old2new\n            if head.next not in old2new:\n                old2new[head.next] = copy_helper(head.next)\n            # Cache new node in translation table\n            # N.B. translate .random later using old2new\n            old2new[head] = Node(head.val, old2new[head.next], head.random)  \n            return old2new[head]\n\n        head2 = copy_helper(head)\n\n        # Now set randoms.\n        for node in old2new.values():\n            if node:\n                node.random = old2new[node.random]\n\n        return head2\n\n\n        \n",
        "runtime": "22"
      },
      {
        "code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        new_head = current = Node(0)\n        seen = dict()\n\n        while head is not None:\n            current.next = Node(\n                x=head.val,\n                random=head.random\n            )\n            seen[head] = current.next\n\n            current = current.next\n            head = head.next\n        \n        current = new_head.next\n        while current is not None:\n            if current.random is not None:\n                current.random = seen[current.random]\n            current = current.next\n        \n        return new_head.next\n",
        "runtime": "23"
      }
    ],
    "memory_inefficient_codes": [
      {
        "code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        if not head:\n            return None\n        mem = {}\n        dummy = Node(0)\n        copy_curr, curr = dummy, head\n        pos = 0\n        while curr:\n            copy_curr.next = Node(curr.val, random=curr.random)\n            copy_curr = copy_curr.next\n            curr.random = copy_curr\n            curr = curr.next\n        \n        curr = dummy.next\n        while curr:\n            if curr.random:\n                curr.random = curr.random.random\n            curr = curr.next\n    \n        return dummy.next\n\n\n",
        "memory": "17400"
      },
      {
        "code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        self.map = {}\n        return self.recurse(head)\n\n\n    def recurse(self, node):\n        if node is None:\n            return None\n\n        if node in self.map:\n            return self.map[node]\n        \n        new_node = Node(node.val, None, None)\n\n        self.map[node] = new_node\n\n        new_node.next = self.recurse(node.next)\n        new_node.random = self.recurse(node.random)\n        \n             \n        return new_node\n",
        "memory": "17400"
      },
      {
        "code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        #how to also replicate the random node while also maintaining efficiency\n        #use a hashmap to store the random pointer\n\n        if not head: #edge case for empty list\n            return None\n        old_to_new = {} #stores old node as key, and new node as corresponding val\n\n        curr = head\n        while curr:\n            #filling the hashmap with each node and its new node with initialized values ONLY\n            old_to_new[curr] = Node(curr.val)\n            curr = curr.next\n\n        curr = head\n        while curr:\n            #now, replicating the connections by going thru the hashmap and ensuring new nodes have right random/next values\n            old_to_new[curr].next = old_to_new.get(curr.next)\n            #then you get the corresponding next new node, and make that the next of new node\n            old_to_new[curr].random = old_to_new.get(curr.random)\n            curr = curr.next\n        \n        return old_to_new[head]\n\n\n        \n\n        ",
        "memory": "17500"
      },
      {
        "code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        if not head:\n            return None\n        hmap = {}\n        curr = head\n        while curr:\n            hmap[curr] = ListNode(curr.val)\n            curr = curr.next\n        curr = head\n        res = hmap[head]\n        while curr:\n            hmap[curr].next = hmap[curr.next] if curr.next else None\n            hmap[curr].random = hmap[curr.random] if curr.random else None\n            curr = curr.next\n        return res\n\n",
        "memory": "17500"
      }
    ],
    "memory_moderate_codes": [
      {
        "code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n# 2024.09.14\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        nhead = head\n        while nhead != None :\n            nhead.next = Node(x=nhead.val, next=nhead.next, random=nhead.random)\n            nhead = nhead.next.next\n        \n        nhead = head\n        while nhead != None :\n            if nhead.random != None :\n                nhead.next.random = nhead.random.next\n            nhead = nhead.next.next\n        \n        fhead = Node(x=0)\n        nhead = fhead\n        while head != None :\n            nhead.next = head.next\n            head.next = head.next.next\n\n            nhead = nhead.next\n            head = head.next\n        \n        return fhead.next",
        "memory": "17100"
      },
      {
        "code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        # loop through the original list, for each node, make a copy and connect it to the next of the\n        # original node\n        # e.g., node1 -> node1_copy -> node2 -> node2_copy -> ...\n        # loop through again, connect the next pointer and random pointer\n        if not head:\n            return head\n        current = head\n        while current:\n            # make a copy\n            new_node = Node(current.val)\n            # connect it to the original node\n            next_node = current.next\n            current.next = new_node\n            current = next_node\n            new_node.next = next_node\n        # loop through again and make connections\n        current = head\n        new_head = current.next\n        while current:\n            new_node = current.next\n            next_node = new_node.next\n            # connect the random pointer\n            new_node.random = current.random.next if current.random else None\n            current = next_node\n        # connect the next pointer\n        current = head\n        while current:\n            new_node = current.next\n            current.next = new_node.next\n            new_node.next = new_node.next.next if new_node.next else None\n            current = current.next\n        return new_head\n            \n        \n        ",
        "memory": "17200"
      },
      {
        "code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        if not head:\n            return None\n        \n        copyDict = {}\n        cur = head\n        while cur:\n            copyDict[cur] = ListNode(cur.val)\n            cur = cur.next\n\n        cur = head\n        while cur:\n            copyDict[cur].next = copyDict.get(cur.next)\n            copyDict[cur].random = copyDict.get(cur.random)\n            cur = cur.next\n        \n        return copyDict[head]",
        "memory": "17200"
      },
      {
        "code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        if not head:\n            return None\n        cur = head\n        while cur:\n            node=Node(cur.val,cur.next)\n            cur.next=node\n            cur=cur.next.next\n        cur = head\n        while cur:\n            if cur.random:\n                cur.next.random=cur.random.next\n            else:\n                cur.next.random=None\n            cur= cur.next.next\n\n        cur = head\n        new_head = cur.next\n        copy_cur = new_head\n        while cur:\n            cur.next = copy_cur.next\n            if cur.next:\n                copy_cur.next = cur.next.next\n            else:\n                copy_cur.next = None\n            cur = cur.next\n            copy_cur = copy_cur.next\n\n        return new_head\n\n\n        ",
        "memory": "17300"
      },
      {
        "code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        if not head:\n            return head\n\n        hashmap = {}\n        node = head\n        while node:\n            hashmap[node] = Node(node.val, None, None)\n            node = node.next\n        \n        node = head\n        while node:\n            if node.next:\n                hashmap[node].next = hashmap[node.next]\n            if node.random:\n                hashmap[node].random = hashmap[node.random]\n\n            node = node.next\n        \n        return hashmap[head]\n",
        "memory": "17300"
      }
    ],
    "memory_efficient_codes": [],
    "import_code": "from typing import Optional",
    "setup_code": "# Definition for a Node class to represent each node in the LinkedList\nclass Node:\n    def __init__(self, x: int, next: 'Optional[Node]' = None, random: 'Optional[Node]' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\n# Helper class to generate and handle test cases\nclass TestCaseGenerator:\n    def generate(self) -> dict:\n        nodes = [\n            {'val': 7, 'random_index': None},\n            {'val': 13, 'random_index': 0},\n            {'val': 11, 'random_index': 4},\n            {'val': 10, 'random_index': 2},\n            {'val': 1, 'random_index': 0},\n        ]\n        head = self.build_linked_list(nodes)\n        return {'head': head}\n\n    def build_linked_list(self, node_info):\n        if not node_info:\n            return None\n        nodes = [Node(info['val']) for info in node_info]\n        for i in range(len(nodes) - 1):\n            nodes[i].next = nodes[i + 1]\n        for i, info in enumerate(node_info):\n            if info['random_index'] is not None:\n                nodes[i].random = nodes[info['random_index']]\n        return nodes[0]\n\n    def encode_input(self, input_obj) -> str:\n        return str(self.linked_list_to_array(input_obj['head']))\n\n    def encode_output(self, output_obj) -> str:\n        if not output_obj:\n            return str([])\n        return str(self.linked_list_to_array(output_obj))\n\n    def decode_input(self, input_str) -> dict:\n        data = eval(input_str)\n        return {'head': self.build_linked_list(data)}\n\n    def linked_list_to_array(self, head: 'Node') -> list:\n        if not head:\n            return []\n        nodes = []\n        current = head\n        while current:\n            random_index = None\n            if current.random is not None:\n                random_index = self.find_index(head, current.random)\n            nodes.append({'val': current.val, 'random_index': random_index})\n            current = current.next\n        return nodes\n\n    def find_index(self, head: 'Node', node: 'Node') -> int:\n        current, index = head, 0\n        while current:\n            if current == node:\n                return index\n            current = current.next\n            index += 1\n        return -1",
    "libraries": ["from typing import Optional"],
    "entry_point": "copyRandomList",
    "test_cases": [
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      },
      {
        "input": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]",
        "output": "[{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]"
      }
    ]
  }
]
