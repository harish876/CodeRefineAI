{
    "promt": "<p>There are <code>k</code> workers who want to move <code>n</code> boxes from the right (old) warehouse to the left (new) warehouse. You are given the two integers <code>n</code> and <code>k</code>, and a 2D integer array <code>time</code> of size <code>k x 4</code> where <code>time[i] = [right<sub>i</sub>, pick<sub>i</sub>, left<sub>i</sub>, put<sub>i</sub>]</code>.</p>\n\n<p>The warehouses are separated by a river and connected by a bridge. Initially, all <code>k</code> workers are waiting on the left side of the bridge. To move the boxes, the <code>i<sup>th</sup></code> worker can do the following:</p>\n\n<ul>\n\t<li>Cross the bridge to the right side in <code>right<sub>i</sub></code> minutes.</li>\n\t<li>Pick a box from the right warehouse in <code>pick<sub>i</sub></code> minutes.</li>\n\t<li>Cross the bridge to the left side in <code>left<sub>i</sub></code> minutes.</li>\n\t<li>Put the box into the left warehouse in <code>put<sub>i</sub></code> minutes.</li>\n</ul>\n\n<p>The <code>i<sup>th</sup></code> worker is <strong>less efficient</strong> than the j<code><sup>th</sup></code> worker if either condition is met:</p>\n\n<ul>\n\t<li><code>left<sub>i</sub> + right<sub>i</sub> &gt; left<sub>j</sub> + right<sub>j</sub></code></li>\n\t<li><code>left<sub>i</sub> + right<sub>i</sub> == left<sub>j</sub> + right<sub>j</sub></code> and <code>i &gt; j</code></li>\n</ul>\n\n<p>The following rules regulate the movement of the workers through the bridge:</p>\n\n<ul>\n\t<li>Only one worker can use the bridge at a time.</li>\n\t<li>When the bridge is unused prioritize the <strong>least efficient</strong> worker on the right side to cross. If there are no workers on the right side, prioritize the <strong>least efficient</strong> worker on the left side to cross.</li>\n\t<li>If enough workers have already been dispatched from the left side to pick up all the remaining boxes, <strong>no more</strong> workers will be sent from the left side.</li>\n</ul>\n\n<p>Return the <strong>elapsed minutes</strong> at which the last box reaches the <strong>left side of the bridge</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">n = 1, k = 3, time = [[1,1,2,1],[1,1,3,1],[1,1,4,1]]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">6</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<pre>\nFrom 0 to 1 minutes: worker 2 crosses the bridge to the right.\nFrom 1 to 2 minutes: worker 2 picks up a box from the right warehouse.\nFrom 2 to 6 minutes: worker 2 crosses the bridge to the left.\nFrom 6 to 7 minutes: worker 2 puts a box at the left warehouse.\nThe whole process ends after 7 minutes. We return 6 because the problem asks for the instance of time at which the last worker reaches the left side of the bridge.\n</pre>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">n = 3, k = 2, time = [[1,9,1,8],[10,10,10,10]]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">50</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<pre>\nFrom 0  to 10: worker 1 crosses the bridge to the right.\nFrom 10 to 20: worker 1 picks up a box from the right warehouse.\nFrom 10 to 11: worker 0 crosses the bridge to the right.\nFrom 11 to 20: worker 0 picks up a box from the right warehouse.\nFrom 20 to 30: worker 1 crosses the bridge to the left.\nFrom 30 to 40: worker 1 puts a box at the left warehouse.\nFrom 30 to 31: worker 0 crosses the bridge to the left.\nFrom 31 to 39: worker 0 puts a box at the left warehouse.\nFrom 39 to 40: worker 0 crosses the bridge to the right.\nFrom 40 to 49: worker 0 picks up a box from the right warehouse.\nFrom 49 to 50: worker 0 crosses the bridge to the left.\n</pre>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n, k &lt;= 10<sup>4</sup></code></li>\n\t<li><code>time.length == k</code></li>\n\t<li><code>time[i].length == 4</code></li>\n\t<li><code>1 &lt;= leftToRight<sub>i</sub>, pickOld<sub>i</sub>, rightToLeft<sub>i</sub>, putNew<sub>i</sub> &lt;= 1000</code></li>\n</ul>\n",
    "runtime_inefficient_codes": [
        {
            "code": "class Solution:\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n        curr = 0\n        avalible_worker = [(-time[i][0] - time[i][2], -i) for i in range(k)]\n        left_heap = []\n        right_heap = []\n        avalible_worker_picked = []\n        heapify(avalible_worker)\n\n        while n or right_heap or avalible_worker_picked:\n\n            while left_heap and left_heap[0][0] <= curr:\n                _, i = heappop(left_heap)\n                heappush(avalible_worker, (-time[i][0] - time[i][2], -i))\n\n            while right_heap and right_heap[0][0] <= curr:\n                _, i = heappop(right_heap)\n                heappush(avalible_worker_picked, (-time[i][0] - time[i][2], -i))\n\n            if avalible_worker_picked:\n                _, idx = heappop(avalible_worker_picked)\n                idx = -idx\n                # print(idx)\n                curr += time[idx][2]\n                heappush(left_heap, (curr + time[idx][3], idx))\n            elif avalible_worker and n:\n                _, idx = heappop(avalible_worker)\n                idx = -idx\n                curr += time[idx][0]\n                n -= 1\n                # print(idx)\n                heappush(right_heap, (curr + time[idx][1], idx))\n            else:\n                #curr += 1\n                curr = min(left_heap[0][0] if left_heap and n else inf, right_heap[0][0] if right_heap else inf)\n\n        return curr\n",
            "runtime": "374"
        },
        {
            "code": "class Solution:\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n        left_warehouse, left_bridge, right_warehouse, right_bridge = [], [], [], []\n        curr_time = 0\n        #initially everyone is in front of the left bridge\n        for i in range(k):\n            heapq.heappush(left_bridge,(-time[i][0]-time[i][2], -i))\n        #return the loop till we have boxes / there is someone on the right back of the river who needs to come back\n        while n or right_warehouse or right_bridge:\n            #we need to move the workers to the bridge edges before starting any movement\n            while left_warehouse and left_warehouse[0][0] <= curr_time:\n                _, i = heapq.heappop(left_warehouse)\n                heapq.heappush(left_bridge,(-time[i][0]-time[i][2], -i))\n            while right_warehouse and right_warehouse[0][0] <= curr_time:\n                _, i = heapq.heappop(right_warehouse)\n                heapq.heappush(right_bridge,(-time[i][0]-time[i][2], -i))\n            #workers on right end move to the left end\n            if right_bridge:\n                _, i = heapq.heappop(right_bridge)\n                l, po, r, pn = time[-i]\n                curr_time += r\n                heapq.heappush(left_warehouse,(curr_time+pn, -i))\n                n -= 1\n            #if there are more boxes in right and fewer workers, we need to move additional workers from the left\n            elif left_bridge and n > len(right_warehouse) + len(right_bridge):\n                _, i = heapq.heappop(left_bridge)\n                l, po, r, pn = time[-i]\n                curr_time += l\n                heapq.heappush(right_warehouse,(curr_time+po, -i))\n            #if there are no workers on the left end of the bridge and there are boxes \n            #OR\n            #if there are workers on the left end but no boxes \n            else:\n                left_time = left_warehouse[0][0] if left_warehouse and n > len(right_warehouse) + len(right_bridge) else math.inf\n                right_time = right_warehouse[0][0] if right_warehouse else math.inf\n                curr_time = min(left_time,right_time)\n        return curr_time                    ",
            "runtime": "375"
        },
        {
            "code": "class Solution:\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n        left_warehouse, left_bridge, right_warehouse, right_bridge = [], [], [], []\n        curr_time = 0\n        #initially everyone is in front of the left bridge\n        for i in range(k):\n            heapq.heappush(left_bridge,(-time[i][0]-time[i][2], -i))\n        #return the loop till we have boxes / there is someone on the right back of the river who needs to come back\n        while n or right_warehouse or right_bridge:\n            #we need to move the workers to the bridge edges before starting any movement\n            while left_warehouse and left_warehouse[0][0] <= curr_time:\n                _, i = heapq.heappop(left_warehouse)\n                heapq.heappush(left_bridge,(-time[i][0]-time[i][2], -i))\n            while right_warehouse and right_warehouse[0][0] <= curr_time:\n                _, i = heapq.heappop(right_warehouse)\n                heapq.heappush(right_bridge,(-time[i][0]-time[i][2], -i))\n            #workers on right end move to the left end\n            if right_bridge:\n                _, i = heapq.heappop(right_bridge)\n                l, po, r, pn = time[-i]\n                curr_time += r\n                heapq.heappush(left_warehouse,(curr_time+pn, -i))\n                n -= 1\n            #if there are more boxes in right and fewer workers, we need to move additional workers from the left\n            elif left_bridge and n > len(right_warehouse) + len(right_bridge):\n                _, i = heapq.heappop(left_bridge)\n                l, po, r, pn = time[-i]\n                curr_time += l\n                heapq.heappush(right_warehouse,(curr_time+po, -i))\n            #if there are no workers on the left end of the bridge and there are boxes \n            #OR\n            #if there are workers on the left end but no boxes \n            else:\n                left_time = left_warehouse[0][0] if left_warehouse and n > len(right_warehouse) + len(right_bridge) else math.inf\n                right_time = right_warehouse[0][0] if right_warehouse else math.inf\n                curr_time = min(left_time,right_time)\n        return curr_time                    ",
            "runtime": "378"
        },
        {
            "code": "class Solution:\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n        ans = free = 0 \n        l, ll = [], []\n        r, rr = [], []\n        for i, (x, _, y, _) in enumerate(time): heappush(ll, (-x-y, -i))\n        while n or r or rr: \n            if not rr and (not r or r[0][0] > free) and (not n or not ll and (not l or l[0][0] > free)): \n                cand = inf \n                if n and l: cand = min(cand, l[0][0])\n                if r: cand = min(cand, r[0][0])\n                free = cand\n                \n            while r and r[0][0] <= free: \n                _, i = heappop(r)\n                heappush(rr, (-time[i][0] - time[i][2], -i))\n\n            while l and l[0][0] <= free: \n                _, i = heappop(l)\n                heappush(ll, (-time[i][0] - time[i][2], -i))\n                \n            if rr: \n                _, i = heappop(rr)\n                free += time[-i][2]\n                if n: heappush(l, (free + time[-i][3], -i))\n                else: ans = max(ans, free)\n            else: \n                _, i = heappop(ll)\n                free += time[-i][0]\n                heappush(r, (free + time[-i][1], -i))\n                n -= 1\n        return ans ",
            "runtime": "380"
        },
        {
            "code": "class Solution:\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n        ans = free = 0 \n        l, ll, r, rr = [], [], [], []\n        for i, (x, _, y, _) in enumerate(time): heapq.heappush(ll, (-x-y, -i))\n        \n        while n or r or rr: \n            if not rr and (not r or r[0][0] > free) and (not n or not ll and (not l or l[0][0] > free)): \n                cand = math.inf \n                if n and l: cand = min(cand, l[0][0])\n                if r: cand = min(cand, r[0][0])\n                free = cand\n\n            while r and r[0][0] <= free: \n                _, i = heapq.heappop(r)\n                heapq.heappush(rr, (-time[i][0] - time[i][2], -i))\n\n            while l and l[0][0] <= free: \n                _, i = heapq.heappop(l)\n                heapq.heappush(ll, (-time[i][0] - time[i][2], -i))\n\n            if rr:\n                _, i = heapq.heappop(rr)\n                free += time[-i][2]\n                if n: heapq.heappush(l, (free + time[-i][3], -i))\n                else: ans = max(ans, free)\n            else: \n                _, i = heapq.heappop(ll)\n                free += time[-i][0]\n                heapq.heappush(r, (free + time[-i][1], -i))\n                n -= 1\n        return ans \n",
            "runtime": "381"
        },
        {
            "code": "class Solution:\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n        ans = free = 0 \n        l, ll = [], []\n        r, rr = [], []\n        for i, (x, _, y, _) in enumerate(time): heappush(ll, (-x-y, -i))\n        while n or r or rr: \n            if not rr and (not r or r[0][0] > free) and (not n or not ll and (not l or l[0][0] > free)): \n                cand = inf \n                if n and l: cand = min(cand, l[0][0])\n                if r: cand = min(cand, r[0][0])\n                free = cand\n                \n            while r and r[0][0] <= free: \n                _, i = heappop(r)\n                heappush(rr, (-time[i][0] - time[i][2], -i))\n\n            while l and l[0][0] <= free: \n                _, i = heappop(l)\n                heappush(ll, (-time[i][0] - time[i][2], -i))\n                \n            if rr: \n                _, i = heappop(rr)\n                free += time[-i][2]\n                if n: heappush(l, (free + time[-i][3], -i))\n                else: ans = max(ans, free)\n            else: \n                _, i = heappop(ll)\n                free += time[-i][0]\n                heappush(r, (free + time[-i][1], -i))\n                n -= 1\n        return ans         ",
            "runtime": "383"
        },
        {
            "code": "class Solution:\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n        ll, l, r, rr = list(), list(), list(), list()\n        for i, (a, _, c, _) in enumerate(time):\n            heapq.heappush(l, (-a - c, -i))\n\n        t = 0\n        while n:\n            while ll and ll[0][0] <= t:\n                _, i = heapq.heappop(ll)\n                heapq.heappush(l, (-time[i][0] - time[i][2], -i))\n            while rr and rr[0][0] <= t:\n                _, i = heapq.heappop(rr)\n                heapq.heappush(r, (-time[i][0] - time[i][2], -i))\n\n            if r:\n                _, i = heapq.heappop(r)\n                t += time[-i][2]\n                heapq.heappush(ll, (t + time[-i][3], -i))\n                n -= 1\n            elif l and n > len(r) + len(rr):\n                _, i = heapq.heappop(l)\n                t += time[-i][0]\n                heapq.heappush(rr, (t + time[-i][1], -i))\n            else:\n                x = ll[0][0] if ll and n > len(r) + len(rr) else float('inf')\n                y = rr[0][0] if rr else float('inf')\n                t = min(x, y)\n        return t",
            "runtime": "384"
        },
        {
            "code": "class Solution:\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n\n        left_warehouse = []\n        left_bridge = []\n        right_warehouse = []\n        right_bridge = []\n        curr_time = 0\n\n        for i in range(k):\n            heapq.heappush(left_bridge, (-time[i][0] - time[i][2], -i))\n\n        # loop until we have boxes/ there is someone on the right back of the river who needs to come back\n        while n or right_warehouse or right_bridge:\n            # move workers to the bridge edges before starting any movement\n            while left_warehouse and left_warehouse[0][0] <= curr_time:\n                _, i = heapq.heappop(left_warehouse)\n                heapq.heappush(left_bridge,(-time[i][0]-time[i][2], -i))\n            while right_warehouse and right_warehouse[0][0] <= curr_time:\n                _, i = heapq.heappop(right_warehouse)\n                heapq.heappush(right_bridge,(-time[i][0]-time[i][2], -i))\n            \n            #workers on the right end move to the left end\n            if right_bridge:\n                _, i = heapq.heappop(right_bridge)\n                l, po, r, pn = time[-i]\n                curr_time += r\n                heapq.heappush(left_warehouse,(curr_time+pn, -i))\n                n -= 1\n            #if there are more boxes in right and fewer workers, we need to move additional workers from the left\n            elif left_bridge and n > len(right_warehouse) + len(right_bridge):\n                _, i = heapq.heappop(left_bridge)\n                l, po, r, pn = time[-i]\n                curr_time += l\n                heapq.heappush(right_warehouse,(curr_time+po, -i))\n            # if there are no workers on the left end of the bridge and there are boxes\n            # OR if there are workers on the left but no boxes\n            else:\n                left_time = left_warehouse[0][0] if left_warehouse and  n > len(right_warehouse) + len(right_bridge) else math.inf\n                right_time = right_warehouse[0][0] if right_warehouse else math.inf\n                curr_time = min(left_time, right_time)\n        return curr_time\n            \n            \n\n        ",
            "runtime": "385"
        },
        {
            "code": "class Solution:\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n        left_warehouse, left_bridge, right_warehouse, right_bridge = [], [], [], []\n        curr_time = 0\n        #initially everyone is in front of the left bridge\n        for i in range(k):\n            heapq.heappush(left_bridge,(-time[i][0]-time[i][2], -i))\n        #return the loop till we have boxes / there is someone on the right back of the river who needs to come back\n        while n or right_warehouse or right_bridge:\n            #we need to move the workers to the bridge edges before starting any movement\n            while left_warehouse and left_warehouse[0][0] <= curr_time:\n                _, i = heapq.heappop(left_warehouse)\n                heapq.heappush(left_bridge,(-time[i][0]-time[i][2], -i))\n            while right_warehouse and right_warehouse[0][0] <= curr_time:\n                _, i = heapq.heappop(right_warehouse)\n                heapq.heappush(right_bridge,(-time[i][0]-time[i][2], -i))\n            #workers on right end move to the left end\n            if right_bridge:\n                _, i = heapq.heappop(right_bridge)\n                l, po, r, pn = time[-i]\n                curr_time += r\n                heapq.heappush(left_warehouse,(curr_time+pn, -i))\n                n -= 1\n            #if there are more boxes in right and fewer workers, we need to move additional workers from the left\n            elif left_bridge and n > len(right_warehouse) + len(right_bridge):\n                _, i = heapq.heappop(left_bridge)\n                l, po, r, pn = time[-i]\n                curr_time += l\n                heapq.heappush(right_warehouse,(curr_time+po, -i))\n            #if there are no workers on the left end of the bridge and there are boxes \n            #OR\n            #if there are workers on the left end but no boxes \n            else:\n                left_time = left_warehouse[0][0] if left_warehouse and n > len(right_warehouse) + len(right_bridge) else math.inf\n                right_time = right_warehouse[0][0] if right_warehouse else math.inf\n                curr_time = min(left_time,right_time)\n        return curr_time",
            "runtime": "386"
        },
        {
            "code": "class Solution:\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n        ans = free = 0 \n        l, ll = [], []\n        r, rr = [], []\n        for i, (x, _, y, _) in enumerate(time): heappush(ll, (-x-y, -i))\n        while n or r or rr: \n            if not rr and (not r or r[0][0] > free) and (not n or not ll and (not l or l[0][0] > free)): \n                cand = inf \n                if n and l: cand = min(cand, l[0][0])\n                if r: cand = min(cand, r[0][0])\n                free = cand\n                \n            while r and r[0][0] <= free: \n                _, i = heappop(r)\n                heappush(rr, (-time[i][0] - time[i][2], -i))\n\n            while l and l[0][0] <= free: \n                _, i = heappop(l)\n                heappush(ll, (-time[i][0] - time[i][2], -i))\n                \n            if rr: \n                _, i = heappop(rr)\n                free += time[-i][2]\n                if n: heappush(l, (free + time[-i][3], -i))\n                else: ans = max(ans, free)\n            else: \n                _, i = heappop(ll)\n                free += time[-i][0]\n                heappush(r, (free + time[-i][1], -i))\n                n -= 1\n        return ans",
            "runtime": "387"
        },
        {
            "code": "class Solution:\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n        ans = free = 0 \n        l, ll = [], []\n        r, rr = [], []\n        for i, (x, _, y, _) in enumerate(time): heappush(ll, (-x-y, -i))\n        while n or r or rr: \n            if not rr and (not r or r[0][0] > free) and (not n or not ll and (not l or l[0][0] > free)): \n                cand = inf \n                if n and l: cand = min(cand, l[0][0])\n                if r: cand = min(cand, r[0][0])\n                free = cand\n                \n            while r and r[0][0] <= free: \n                _, i = heappop(r)\n                heappush(rr, (-time[i][0] - time[i][2], -i))\n\n            while l and l[0][0] <= free: \n                _, i = heappop(l)\n                heappush(ll, (-time[i][0] - time[i][2], -i))\n                \n            if rr: \n                _, i = heappop(rr)\n                free += time[-i][2]\n                if n: heappush(l, (free + time[-i][3], -i))\n                else: ans = max(ans, free)\n            else: \n                _, i = heappop(ll)\n                free += time[-i][0]\n                heappush(r, (free + time[-i][1], -i))\n                n -= 1\n        return ans         ",
            "runtime": "388"
        },
        {
            "code": "class Solution:\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n        ans = free = 0 \n        l, ll = [], []\n        r, rr = [], []\n        for i, (x, _, y, _) in enumerate(time): heappush(ll, (-x-y, -i))\n        while n or r or rr: \n            if not rr and (not r or r[0][0] > free) and (not n or not ll and (not l or l[0][0] > free)): \n                cand = inf \n                if n and l: cand = min(cand, l[0][0])\n                if r: cand = min(cand, r[0][0])\n                free = cand\n                \n            while r and r[0][0] <= free: \n                _, i = heappop(r)\n                heappush(rr, (-time[i][0] - time[i][2], -i))\n            while l and l[0][0] <= free: \n                _, i = heappop(l)\n                heappush(ll, (-time[i][0] - time[i][2], -i))\n                \n            if rr: \n                _, i = heappop(rr)\n                free += time[-i][2]\n                if n: heappush(l, (free + time[-i][3], -i))\n                else: ans = max(ans, free)\n            else: \n                _, i = heappop(ll)\n                free += time[-i][0]\n                heappush(r, (free + time[-i][1], -i))\n                n -= 1\n        return ans",
            "runtime": "389"
        },
        {
            "code": "class Solution:\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n        left_warehouse, left_bridge, right_warehouse, right_bridge = [], [], [], []\n        curr_time = 0\n        \n        for i in range(k):\n            heapq.heappush(left_bridge,(-time[i][0]-time[i][2], -i))\n        while n or right_warehouse or right_bridge:\n            while left_warehouse and left_warehouse[0][0] <= curr_time:\n                _, i = heapq.heappop(left_warehouse)\n                heapq.heappush(left_bridge,(-time[i][0]-time[i][2], -i))\n            while right_warehouse and right_warehouse[0][0] <= curr_time:\n                _, i = heapq.heappop(right_warehouse)\n                heapq.heappush(right_bridge,(-time[i][0]-time[i][2], -i))\n            if right_bridge:\n                _, i = heapq.heappop(right_bridge)\n                l, po, r, pn = time[-i]\n                curr_time += r\n                heapq.heappush(left_warehouse,(curr_time+pn, -i))\n                n -= 1\n            elif left_bridge and n > len(right_warehouse) + len(right_bridge):\n                _, i = heapq.heappop(left_bridge)\n                l, po, r, pn = time[-i]\n                curr_time += l\n                heapq.heappush(right_warehouse,(curr_time+po, -i))\n            else:\n                left_time = left_warehouse[0][0] if left_warehouse and n > len(right_warehouse) + len(right_bridge) else math.inf\n                right_time = right_warehouse[0][0] if right_warehouse else math.inf\n                curr_time = min(left_time,right_time)\n        return curr_time                    ",
            "runtime": "391"
        },
        {
            "code": "class Solution:\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n        def totalCrossTime(i):\n            return time[i][0] + time[i][2]\n        \n        leftHouse = []\n        rightHouse = []\n        leftBridge = []\n        rightBridge = []\n        curTime = 0\n\n        for i in range(len(time)):\n            heapq.heappush(leftBridge, (-totalCrossTime(i), -i))\n\n        \n        while n or rightHouse or rightBridge:\n            while rightHouse and rightHouse[0][0] <= curTime:\n                _, i = heapq.heappop(rightHouse)\n                heapq.heappush(rightBridge, (-totalCrossTime(i), -i))\n            \n            while leftHouse and leftHouse[0][0] <= curTime:\n                _, i = heapq.heappop(leftHouse)\n                heapq.heappush(leftBridge, (-totalCrossTime(i), -i))\n\n            if rightBridge:\n                _, i = heapq.heappop(rightBridge)\n                i = -i\n                curTime += time[i][2]\n                heapq.heappush(leftHouse, (curTime + time[i][3], i))\n            elif leftBridge and n:\n                _, i = heapq.heappop(leftBridge)\n                i = -i\n                curTime += time[i][0]\n                n -= 1\n                heapq.heappush(rightHouse, (curTime + time[i][1], i))\n            else:\n                curTime = min(leftHouse[0][0] if leftHouse and n else float('inf'), rightHouse[0][0] if rightHouse else float('inf'))\n        return curTime",
            "runtime": "392"
        },
        {
            "code": "class Solution:\n    # l: (-(leftToRight + rightToLeft), -i), waiting on the left side, sort by efficiency\n    # r: (-(leftToRight + rightToLeft), -i), waiting on the right side, sort by efficiency\n    # ll: (time, i), on what time can move to l from new warehouse\n    # rr: (time, i), on what time can move to r from old warehouse\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n        ll, l, r, rr = list(), list(), list(), list()\n        for i, (a, _, c, _) in enumerate(time):\n            heapq.heappush(l, (-a - c, -i))\n\n        t = 0\n        while n:\n            while ll and ll[0][0] <= t:\n                _, i = heapq.heappop(ll)\n                heapq.heappush(l, (-time[i][0] - time[i][2], -i))\n            while rr and rr[0][0] <= t:\n                _, i = heapq.heappop(rr)\n                heapq.heappush(r, (-time[i][0] - time[i][2], -i))\n\n            if r:\n                _, i = heapq.heappop(r)\n                t += time[-i][2]\n                heapq.heappush(ll, (t + time[-i][3], -i))\n                n -= 1\n            elif l and n > len(r) + len(rr):\n                _, i = heapq.heappop(l)\n                t += time[-i][0]\n                heapq.heappush(rr, (t + time[-i][1], -i))\n            else:\n                x = ll[0][0] if ll and n > len(r) + len(rr) else float('inf')\n                y = rr[0][0] if rr else float('inf')\n                t = min(x, y)\n        return t",
            "runtime": "394"
        },
        {
            "code": "class Solution:\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n        left_warehouse, left_bridge, right_warehouse, right_bridge = [], [], [], []\n        curr_time = 0\n        #initially everyone is in front of the left bridge\n        for i in range(k):\n            heapq.heappush(left_bridge,(-time[i][0]-time[i][2], -i))\n        #return the loop till we have boxes / there is someone on the right back of the river who needs to come back\n        while n > 0 or right_warehouse or right_bridge:\n            #we need to move the workers to the bridge edges before starting any movement\n            while left_warehouse and left_warehouse[0][0] <= curr_time:\n                _, i = heapq.heappop(left_warehouse)\n                heapq.heappush(left_bridge,(-time[i][0]-time[i][2], -i))\n            while right_warehouse and right_warehouse[0][0] <= curr_time:\n                _, i = heapq.heappop(right_warehouse)\n                heapq.heappush(right_bridge,(-time[i][0]-time[i][2], -i))\n            #workers on right end move to the left end\n            if right_bridge:\n                _, i = heapq.heappop(right_bridge)\n                r, pk, l, pt = time[-i]\n                curr_time += l\n                heapq.heappush(left_warehouse,(curr_time+pt, -i))\n                n -= 1\n            #if there are more boxes in right and fewer workers, we need to move additional workers from the left\n            elif left_bridge and n > len(right_warehouse) + len(right_bridge):\n                _, i = heapq.heappop(left_bridge)\n                r, pk, l, pt = time[-i]\n                curr_time += r\n                heapq.heappush(right_warehouse,(curr_time+pk, -i))\n            #if there are no workers on the left end of the bridge and there are boxes \n            #OR\n            #if there are workers on the left end but no boxes \n            else:\n                left_time = left_warehouse[0][0] if left_warehouse and n > len(right_warehouse) + len(right_bridge) else math.inf\n                right_time = right_warehouse[0][0] if right_warehouse else math.inf\n                curr_time = min(left_time,right_time)\n        return curr_time                    \n\n        \n\n'''\n    n       : 3\n                i\n                a              b\n    time    : [[10,10,10,10], [1,9,1,8]]\n\n    hq      : <>\n                   e   p   x  lr    n\n        poped   : (0, -20, a, left, 3), \n                : (0, -02, b, left, 3),\n                : (20, -20, a, right, 3), \n                : (20, -02, b, right, 3), \n                : (40, -20, a, left, 2),  => skip cause n is 0\n                : (49, -02, b, right, 2), \n    \n    ttime   : 0 > 10 > 11 > 20 > 30 > 31 > 39 > 40 > 49 \n        put : 8\n        n   : 0\n        \n\n\n1. Problem\n    - k workers who want to move n boxes from the right to left \n    - two integers n and k\n    - time of size k*4 where time[i] = [right, pick, left, put]\n    - river and connected by a bridge\n    - k workers are waiting on the left side of the bridge\n    - cross the bridge to the right side in right mins\n    - pick a box from the right warehouse in pick mins\n    - \n\n2. TC\n    tc1)\n    n       : 3\n                a              b\n    time    : [[10,10,10,10], [1,9,1,8]]\n\n    left    : <>\n        poped   : a0l, \n                : b0l, \n                : a20r, \n                : b20r, \n                : b39l, \n                : a40l, <= skip cause box is 0\n                : b49r\n    box     : 0\n    time    : 0 > 10 > 11 > 30 > 31 > 40 > 50\n\n\n3. Brain Storming\n    1) use queue\n        => (endtime, -(left+right), i)\n\n\n    1) first initialize with \n        for loop:\n            heappush !! (endtime, -(left+right), -i, l or r)\n        \n    2) handle it with pop ??\n        while botx > 0:\n            endtime, , idx, lr = lheappop\n            idx = -idx\n            update time ?? !!\n                time = max(time, endtime)\n                if lr == left:\n                    time += left time\n                    push to heap time + pick\n                else:\n                    time += right time\n                    push to heap time + working\n                \n\n    \n\n'''",
            "runtime": "395"
        },
        {
            "code": "class Solution:\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n\n        right = []\n        picking = []\n        putting = []\n        left = []\n        # each worker will be separated by their efficiency\n        for i,j in enumerate(time):\n            heapq.heappush(left, [-(j[0] + j[2]), -i])\n        \n        t = 0\n        while n or right or putting or picking:\n            if right: # right to left passing\n                worker = heapq.heappop(right)\n                t += time[-worker[1]][2]\n                heapq.heappush(putting, [t + time[-worker[1]][3], worker])\n            elif n and left:\n                worker = heapq.heappop(left)\n                t += time[-worker[1]][0]\n                n -= 1\n                heapq.heappush(picking, [t + time[-worker[1]][1], worker])\n\n            else:\n                if not n and not picking:\n                    return t\n                nextTime = []\n                if putting:\n                    nextTime.append(putting[0][0])\n                if picking:\n                    nextTime.append(picking[0][0])\n                t = min(nextTime)\n            while putting and putting[0][0] <= t:\n                _,worker = heapq.heappop(putting)\n                heapq.heappush(left, worker)\n            while picking and picking[0][0] <= t:\n                _,worker = heapq.heappop(picking)\n                heapq.heappush(right, worker)\n        return t\n\n                \n            \n\n\n\n                \n\n\n\n\n\n        ",
            "runtime": "397"
        },
        {
            "code": "from heapq import heappush, heappop\nfrom typing import List\n\nclass Solution:\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n        ans = free = 0 \n        l, ll = [], []\n        r, rr = [], []\n        \n        # Initialize the priority queue for workers on the left side\n        for i, (righti, picki, lefti, puti) in enumerate(time):\n            heappush(ll, (-righti - lefti, -i))\n        \n        # Simulate the process\n        while n > 0 or r or rr:\n            # Advance time if no workers are ready to cross\n            if not rr and (not r or r[0][0] > free) and (not n or not ll and (not l or l[0][0] > free)):\n                cand = float('inf')\n                if n and l:\n                    cand = min(cand, l[0][0])\n                if r:\n                    cand = min(cand, r[0][0])\n                free = cand\n            \n            # Move workers to ready queues\n            while r and r[0][0] <= free:\n                _, i = heappop(r)\n                heappush(rr, (-time[i][0] - time[i][2], -i))\n            \n            while l and l[0][0] <= free:\n                _, i = heappop(l)\n                heappush(ll, (-time[i][0] - time[i][2], -i))\n            \n            # Cross the bridge\n            if rr:\n                _, i = heappop(rr)\n                free += time[-i][2]\n                if n:\n                    heappush(l, (free + time[-i][3], -i))\n                else:\n                    ans = max(ans, free)\n            else:\n                _, i = heappop(ll)\n                free += time[-i][0]\n                heappush(r, (free + time[-i][1], -i))\n                n -= 1\n        \n        return ans",
            "runtime": "398"
        },
        {
            "code": "class Solution:\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n        ans = 0\n        left = [[-t[0]-t[2], -i] for i, t in enumerate(time)]\n        right = []\n        save = []\n        heapify(left)\n        cnt = note = tmstamp = 0\n        while cnt < n:\n            if len(left) == len(right) == 0 and save[0][0] > tmstamp:\n                tmstamp = save[0][0]\n            while save and save[0][0] <= tmstamp:\n                t, eff, idx, direction = heappop(save)\n                if direction == 1:\n                    heappush(left, [eff, idx])\n                else:\n                    heappush(right, [eff, idx])\n            flag = True\n            if note == n:\n                while len(right) == 0:\n                    t, eff, idx, direction = heappop(save)\n                    tmstamp = t\n                    if direction == 0: heappush(right, [eff, idx])\n            elif len(right) == 0: flag = False\n            cnt += flag\n            if flag:\n                eff, idx = heappop(right)\n                tmstamp += time[-idx][2]\n                heappush(save, [tmstamp + time[-idx][3], eff, idx, 1])\n            else:\n                eff, idx = heappop(left)\n                tmstamp += time[-idx][0]\n                heappush(save, [tmstamp + time[-idx][1], eff, idx, 0])\n                note += 1\n        return tmstamp\n        \n        ",
            "runtime": "401"
        },
        {
            "code": "class Solution:\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n        ef = []\n        left_q = [] # queue waiting on the left side\n        for i in range(k):\n            ef.append(-(time[i][0] + time[i][2]))\n            heapq.heappush(left_q, (ef[i], -i))\n        workers_to_send = n # boxes to care minus workers in progress\n        current_time = 0\n        right_q = [] # queue waiting on the right side\n        left_box_q = [] # queue for taking boxes\n        right_box_q = [] # queue for putting boxes\n        # box queues are sorted by the time when worker will be ready with picking boxes\n        # waiting queues are sorted by efficiency\n        while len(right_q) > 0 or len(right_box_q) > 0 or workers_to_send > 0:\n            while len(right_box_q) > 0 and right_box_q[0][0] <= current_time: # check if smbd's picked a box\n                _, with_box = heapq.heappop(right_box_q)\n                # move him to the right queue\n                heapq.heappush(right_q, (ef[with_box], -with_box))\n            while len(left_box_q) and left_box_q[0][0] <= current_time: # check if smbd's put a box\n                _, without_box = heapq.heappop(left_box_q)\n                # move him to the right queue\n                heapq.heappush(left_q, (ef[without_box], -without_box))\n            if len(right_q) > 0: # the 1st from right to left go first\n                _, next_to_left = heapq.heappop(right_q) # get with the lowest efficient\n                next_to_left = -next_to_left\n                current_time += time[next_to_left][2] # he crosses the bridge and putting a box\n                heapq.heappush(left_box_q, (current_time + time[next_to_left][3], next_to_left))\n            # when right queue is empty 1 from left queue can cross if some boxes left\n            elif len(left_q) > 0 and workers_to_send > 0:\n                _, next_to_right = heapq.heappop(left_q) # get with the lowest efficient\n                next_to_right = -next_to_right\n                current_time += time[next_to_right][0] # he crosses the bridge and picking a box\n                heapq.heappush(right_box_q, (current_time + time[next_to_right][1], next_to_right))\n                workers_to_send -= 1 # decrease a count of workers to send\n            else: # both queues are empty (left queue we consider as empty if we dont need more workers)\n                if len(right_box_q) == 0 and workers_to_send == 0: # nobody in a new warehouse and nobody to send\n                    return current_time # we've done\n                # take the smallest value from left_box_q and right_box_q and shift time\n                right_box_time = sys.maxsize if len(right_box_q) == 0 else right_box_q[0][0]\n                left_box_time = sys.maxsize if len(left_box_q) == 0 else left_box_q[0][0]\n                # worker will get to a queue on the next iteration\n                current_time = min(right_box_time, left_box_time)\n        return current_time",
            "runtime": "402"
        },
        {
            "code": "class Solution:\n    def cross(self, wait, cpu, time, tick, is_left_to_right) -> int:\n        cur = heapq.heappop(wait)\n        i = 0 if is_left_to_right else 2\n        tick += time[-cur[2]][i]\n        cur[0] = tick + time[-cur[2]][i + 1]\n        heapq.heappush(cpu, cur)\n        return tick\n\n    def check_cpu(self, cpu, wait, tick) -> None:\n        while cpu and cpu[0][0] <= tick:\n            cur = heapq.heappop(cpu)\n            cur[0] = 0\n            heapq.heappush(wait, cur)\n\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n        l_wait, l_cpu, r_wait, r_cpu = [], [], [], []\n        for i in range(k):\n            heapq.heappush(l_wait, [0, -time[i][0] - time[i][2], -i])\n        tick = 0\n        while n:\n            self.check_cpu(l_cpu, l_wait, tick)\n            self.check_cpu(r_cpu, r_wait, tick)\n            if l_wait and not r_wait:\n                tick = self.cross(l_wait, r_cpu, time, tick, True)\n                n -= 1\n            elif r_wait:\n                tick = self.cross(r_wait, l_cpu, time, tick, False)\n            else: \n                tick = min(l_cpu[0][0] if l_cpu else math.inf, r_cpu[0][0] if r_cpu else math.inf)\n\n        while r_cpu or r_wait:\n            self.check_cpu(r_cpu, r_wait, tick)\n            tick = self.cross(r_wait, l_cpu, time, tick, False) if r_wait else r_cpu[0][0]\n        return tick",
            "runtime": "404"
        },
        {
            "code": "class Solution:\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n        ans = 0\n        left = [[-t[0]-t[2], -i] for i, t in enumerate(time)]\n        right = []\n        save = []\n        heapify(left)\n        cnt = note = tmstamp = 0\n        while cnt < n:\n            if len(left) == len(right) == 0 and save[0][0] > tmstamp:\n                tmstamp = save[0][0]\n            while save and save[0][0] <= tmstamp:\n                t, eff, idx, direction = heappop(save)\n                if direction == 1:\n                    heappush(left, [eff, idx])\n                else:\n                    heappush(right, [eff, idx])\n            flag = True\n            if note == n:\n                while len(right) == 0:\n                    t, eff, idx, direction = heappop(save)\n                    tmstamp = t\n                    if direction == 0: heappush(right, [eff, idx])\n            elif len(right) == 0: flag = False\n            cnt += flag\n            if flag:\n                eff, idx = heappop(right)\n                tmstamp += time[-idx][2]\n                heappush(save, [tmstamp + time[-idx][3], eff, idx, 1])\n            else:\n                eff, idx = heappop(left)\n                tmstamp += time[-idx][0]\n                heappush(save, [tmstamp + time[-idx][1], eff, idx, 0])\n                note += 1\n        return tmstamp",
            "runtime": "405"
        },
        {
            "code": "class Solution:\n    def findCrossingTime(self, n: int, k: int, work: List[List[int]]) -> int:\n        l2r, r2l = [], []\n        events = []\n        for i in range(k):\n            heappush(l2r, (- work[i][0] - work[i][2], - i))\n        heappush(events, (0, 2, 0))\n        bridge_free = False\n        res = 0\n        while events:\n            time, etype, i = heappop(events)\n            if etype == 0:\n                heappush(l2r, (- work[i][0] - work[i][2], - i))\n                # print(time, i, \"->l\")\n                if bridge_free:\n                    heappush(events, (time, 2, 0))\n                    bridge_free = False\n                if n == 0:\n                    res = max(res, time - work[i][3])\n            elif etype == 1:\n                heappush(r2l, (- work[i][0] - work[i][2], - i))\n                # print(time, i, \"->r\")\n                if bridge_free:\n                    heappush(events, (time, 2, 0))\n                    bridge_free = False\n            else:\n                if r2l:\n                    _, i = heappop(r2l)\n                    i = - i\n                    heappush(events, (time + work[i][2] + work[i][3], 0, i))\n                    heappush(events, (time + work[i][2], 2, i))\n                    # print(time, i, \"r->l\")\n                elif l2r and n > 0:\n                    n -= 1\n                    _, i = heappop(l2r)\n                    i = - i\n                    heappush(events, (time + work[i][0] + work[i][1], 1, i))\n                    heappush(events, (time + work[i][0], 2, i))\n                    # print(time, i, \"l->r\")\n                else:\n                    bridge_free = True\n        return res\n        ",
            "runtime": "406"
        },
        {
            "code": "class Solution:\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n        def totalCrossTime(i):\n            return time[i][0] + time[i][2]\n        \n        leftHouse = []\n        rightHouse = []\n        leftBridge = []\n        rightBridge = []\n        curTime = 0\n\n        leftBridge = [(-totalCrossTime(i), -i) for i in range(len(time))]\n        heapq.heapify(leftBridge)\n\n        \n        while n or rightHouse or rightBridge:\n            while rightHouse and rightHouse[0][0] <= curTime:\n                _, i = heapq.heappop(rightHouse)\n                heapq.heappush(rightBridge, (-totalCrossTime(i), -i))\n            \n            while leftHouse and leftHouse[0][0] <= curTime:\n                _, i = heapq.heappop(leftHouse)\n                heapq.heappush(leftBridge, (-totalCrossTime(i), -i))\n\n            if rightBridge:\n                _, i = heapq.heappop(rightBridge)\n                i = -i\n                curTime += time[i][2]\n                heapq.heappush(leftHouse, (curTime + time[i][3], i))\n            elif leftBridge and n:\n                _, i = heapq.heappop(leftBridge)\n                i = -i\n                curTime += time[i][0]\n                n -= 1\n                heapq.heappush(rightHouse, (curTime + time[i][1], i))\n            else:\n                curTime = min(leftHouse[0][0] if leftHouse and n else float('inf'), rightHouse[0][0] if rightHouse else float('inf'))\n        return curTime",
            "runtime": "407"
        },
        {
            "code": "class Solution:\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n        ll, l, r, rr = list(), list(), list(), list()\n        for i, (a, _, c, _) in enumerate(time):\n            heapq.heappush(l, (-a - c, -i))\n\n        t = 0\n        while n:\n            while ll and ll[0][0] <= t:\n                _, i = heapq.heappop(ll)\n                heapq.heappush(l, (-time[i][0] - time[i][2], -i))\n            while rr and rr[0][0] <= t:\n                _, i = heapq.heappop(rr)\n                heapq.heappush(r, (-time[i][0] - time[i][2], -i))\n\n            if r:\n                _, i = heapq.heappop(r)\n                t += time[-i][2]\n                heapq.heappush(ll, (t + time[-i][3], -i))\n                n -= 1\n            elif l and n > len(r) + len(rr):\n                _, i = heapq.heappop(l)\n                t += time[-i][0]\n                heapq.heappush(rr, (t + time[-i][1], -i))\n            else:\n                x = ll[0][0] if ll and n > len(r) + len(rr) else float('inf')\n                y = rr[0][0] if rr else float('inf')\n                t = min(x, y)\n        return t",
            "runtime": "417"
        },
        {
            "code": "class Solution:\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n        right = []\n        left = []\n        rightReady = []\n        leftReady = [(-t[0] - t[2], -i) for i, t in enumerate(time)]\n        heapify(leftReady)\n        currTime = 0\n\n        def getWorkersReady(t):\n            def transfer(heap, readyHeap):\n                while heap and heap[0][0] <= t:\n                    _, speed, neg_i = heappop(heap)\n                    heappush(readyHeap, (speed, neg_i))\n            transfer(left, leftReady)\n            transfer(right, rightReady)\n\n        while n:\n            getWorkersReady(currTime)\n            if rightReady:\n                # worker from right are ready to cross\n                speed, neg_i = heappop(rightReady)\n                currTime += time[abs(neg_i)][2]\n                n -= 1\n                heappush(left, (currTime + time[abs(neg_i)][3], speed, neg_i))\n            elif len(right) == n:\n                currTime = right[0][0]\n            elif leftReady:\n                speed, neg_i = heappop(leftReady)\n                currTime += time[abs(neg_i)][0]\n                heappush(right, (currTime + time[abs(neg_i)][1], speed, neg_i))\n            else:\n                currTime = min(\n                    right[0][0] if right else float(\"inf\"),\n                    left[0][0] if left else float(\"inf\")\n                )\n        return currTime\n",
            "runtime": "438"
        },
        {
            "code": "class Solution:\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n        right, rightReady, left = [], [], []\n        leftReady = [(-t[0] - t[2], -i) for i, t in enumerate(time)]\n        heapify(leftReady)\n        currTime = 0\n\n        def getWorkersReady(t):\n            def transfer(heap, readyHeap):\n                while heap and heap[0][0] <= t:\n                    _, speed, neg_i = heappop(heap)\n                    heappush(readyHeap, (speed, neg_i))\n            transfer(left, leftReady)\n            transfer(right, rightReady)\n\n        while n:\n            getWorkersReady(currTime)\n            if rightReady:\n                # worker from right are ready to cross\n                speed, neg_i = heappop(rightReady)\n                currTime += time[abs(neg_i)][2]\n                n -= 1\n                heappush(left, (currTime + time[abs(neg_i)][3], speed, neg_i))\n            elif len(right) == n:\n                # don't need to send any workers over to right, fast forward\n                currTime = right[0][0]\n            elif leftReady:\n                # send a worker over to right\n                speed, neg_i = heappop(leftReady)\n                currTime += time[abs(neg_i)][0]\n                heappush(right, (currTime + time[abs(neg_i)][1], speed, neg_i))\n            else:\n                # fast forward to next actionable time\n                currTime = min(\n                    right[0][0] if right else float(\"inf\"),\n                    left[0][0] if left else float(\"inf\")\n                )\n        return currTime",
            "runtime": "454"
        },
        {
            "code": "class Solution:\n    def findCrossingTime(self, n, k, time):\n        left,right = [],[] # (-efficiency,-index,availableTime)\n        for i in range(k):\n            heapq.heappush(left,(-time[i][0]-time[i][2],-i,0))\n        left0,right0 = [],[] # (availableTime,-index)\n        timing = 0\n        while n>0:\n            while left and n>0 and (not right0 or timing<right0[0][0]):\n                _,i,avail = heapq.heappop(left)\n                timing = max(avail,timing)+time[-i][0]\n                heapq.heappush(right0,(timing+time[-i][1],i))\n                n -= 1\n                self.updateLeft(timing,left,right,left0,right0,time,n)\n            self.updateRight(timing,left,right,left0,right0,time,n)\n            while right:\n                _,i,avail = heapq.heappop(right)\n                timing = max(avail,timing)+time[-i][2]\n                heapq.heappush(left0,(timing+time[-i][3],i))\n                self.updateLeft(timing,left,right,left0,right0,time,n)\n                self.updateRight(timing,left,right,left0,right0,time,n)\n        return timing\n\n    def updateLeft(self,timing,left,right,left0,right0,time,n):\n        while left0 and (left0[0][0]<=timing or (not left and not right and right0 and left0[0][0]<right0[0][0]) or (not left and not right and not right0)):\n            avail,i = heapq.heappop(left0)\n            heapq.heappush(left,(-time[-i][0]-time[-i][2],i,max(avail,timing)))\n\n    def updateRight(self,timing,left,right,left0,right0,time,n):\n        while right0 and (right0[0][0]<=timing or (not right and (n==0 or not left))):\n            avail,i = heapq.heappop(right0)\n            heapq.heappush(right,(-time[-i][0]-time[-i][2],i,max(avail,timing)))",
            "runtime": "457"
        },
        {
            "code": "class Solution:\n    def updateLeft(self,timing,left,right,left0,right0,time,n):\n        while left0 and (left0[0][0]<=timing or (not left and not right and right0 and left0[0][0]<right0[0][0]) or (not left and not right and not right0)):\n            avail,i = heapq.heappop(left0)\n            heapq.heappush(left,(-time[-i][0]-time[-i][2],i,max(avail,timing)))\n\n    def updateRight(self,timing,left,right,left0,right0,time,n):\n        while right0 and (right0[0][0]<=timing or (not right and (n==0 or not left))):\n            avail,i = heapq.heappop(right0)\n            heapq.heappush(right,(-time[-i][0]-time[-i][2],i,max(avail,timing)))\n\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n        l,r=[],[]\n        ll,rr=[],[]\n        for i in range(k):\n            heapq.heappush(l,(-time[i][0]-time[i][2],-i,0))\n        timing=0\n        while n>0:\n            while l and n>0 and (not rr or timing<rr[0][0]):\n                _,i,avail = heapq.heappop(l)\n                timing = max(avail,timing) + time[-i][0]\n                heapq.heappush(rr,(timing+time[-i][1],i))\n                n-=1\n                self.updateLeft(timing,l,r,ll,rr,time,n)\n            self.updateRight(timing,l,r,ll,rr,time,n)\n            while r:\n                _,i,avail = heapq.heappop(r)\n                timing=max(timing,avail)+time[-i][2]\n                heapq.heappush(ll,(timing+time[-i][3],i))\n                self.updateLeft(timing,l,r,ll,rr,time,n)\n                self.updateRight(timing,l,r,ll,rr,time,n)\n        return timing \n\n\n\n        ",
            "runtime": "463"
        },
        {
            "code": "class Solution:\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n        # workers putting new boxes\n        put_new = [(0, i) for i in range(k)] # [(available_at, i)] waiting to put new\n        heapq.heapify(put_new)\n        # workers waiting on left bank of bridge\n        bridge_left = [] # [(eff, i)] ready to cross river left to right\n        # workers picking old boxes\n        pick_old = [] # [(available_at, i)] waiting to pick old\n        # workers waiting on right bank of bridge\n        bridge_right = [] # [(eff, i)] ready to cross river right to left\n        box_left = 0\n        box_right = n\n        \n        def eff(i):\n            return (-time[i][0]-time[i][2], -i)\n            \n        t = 0    \n        while box_left < n:\n            while put_new and put_new[0][0] <= t:\n                _, i = heapq.heappop(put_new)\n                heapq.heappush(bridge_left, (eff(i), i))\n            while pick_old and pick_old[0][0] <= t:\n                _, i = heapq.heappop(pick_old)\n                heapq.heappush(bridge_right, (eff(i), i))\n            \n            if bridge_right:\n                _, i = heapq.heappop(bridge_right)\n                t += time[i][2]\n                box_left += 1\n                heapq.heappush(put_new, (t+time[i][3], i))\n            elif bridge_left and box_right > 0:\n                _, i = heapq.heappop(bridge_left)\n                t += time[i][0]\n                box_right -= 1\n                heapq.heappush(pick_old, (t+time[i][1], i))\n            elif put_new or pick_old:\n                t = 2**31\n                if put_new:\n                    t = min(t, put_new[0][0])\n                if pick_old:\n                    t = min(t, pick_old[0][0])    \n        return t\n        ",
            "runtime": "465"
        },
        {
            "code": "class Solution:\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n        put_new = [(0, i) for i in range(k)]\n        bridge_left = [] \n        pick_old = []\n        bridge_right = [] \n        box_left = 0\n        box_right = n\n        def eff(i):\n            return (-time[i][0]-time[i][2], -i)\n        t = 0    \n        while box_left < n:\n            while put_new and put_new[0][0] <= t:\n                _, i = heapq.heappop(put_new)\n                heapq.heappush(bridge_left, (eff(i), i))\n            while pick_old and pick_old[0][0] <= t:\n                _, i = heapq.heappop(pick_old)\n                heapq.heappush(bridge_right, (eff(i), i))\n            \n            if bridge_right:\n                _, i = heapq.heappop(bridge_right)\n                t += time[i][2]\n                box_left += 1\n                heapq.heappush(put_new, (t+time[i][3], i))\n            elif bridge_left and box_right > 0:\n                _, i = heapq.heappop(bridge_left)\n                t += time[i][0]\n                box_right -= 1\n                heapq.heappush(pick_old, (t+time[i][1], i))\n            elif put_new or pick_old:\n                t = 2**31\n                if put_new:\n                    t = min(t, put_new[0][0])\n                if pick_old:\n                    t = min(t, pick_old[0][0])    \n        return t\n        ",
            "runtime": "466"
        },
        {
            "code": "class Solution:\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n        right, rightReady, left = [], [], []\n        leftReady = [(-t[0] - t[2], -i) for i, t in enumerate(time)]\n        heapify(leftReady)\n        currTime = 0\n\n        def getWorkersReady(t):\n            def transfer(heap, readyHeap):\n                while heap and heap[0][0] <= t:\n                    _, i = heappop(heap)\n                    heappush(readyHeap, (-time[i][0] - time[i][2], -i))\n            transfer(left, leftReady)\n            transfer(right, rightReady)\n\n        while n:\n            getWorkersReady(currTime)\n            if rightReady:\n                # worker from right are ready to cross\n                _, neg_i = heappop(rightReady)\n                currTime += time[abs(neg_i)][2]\n                n -= 1\n                heappush(left, (currTime + time[abs(neg_i)][3], -neg_i))\n            elif len(right) == n:\n                # don't need to send any workers over to right, fast forward\n                currTime = right[0][0]\n            elif leftReady:\n                # send a worker over to right\n                _, neg_i = heappop(leftReady)\n                currTime += time[abs(neg_i)][0]\n                heappush(right, (currTime + time[abs(neg_i)][1], -neg_i))\n            else:\n                # fast forward to next actionable time\n                currTime = min(\n                    right[0][0] if right else float(\"inf\"),\n                    left[0][0] if left else float(\"inf\")\n                )\n        return currTime",
            "runtime": "469"
        },
        {
            "code": "class Solution:\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n        # workers putting new boxes\n        put_new = [(0, i) for i in range(k)] # [(available_at, i)] waiting to put new\n        heapq.heapify(put_new)\n        bridge_left = [] \n        pick_old = []\n        bridge_right = [] \n        box_left = 0\n        box_right = n\n        def eff(i):\n            return (-time[i][0]-time[i][2], -i)\n        t = 0    \n        while box_left < n:\n            while put_new and put_new[0][0] <= t:\n                _, i = heapq.heappop(put_new)\n                heapq.heappush(bridge_left, (eff(i), i))\n            while pick_old and pick_old[0][0] <= t:\n                _, i = heapq.heappop(pick_old)\n                heapq.heappush(bridge_right, (eff(i), i))\n            \n            if bridge_right:\n                _, i = heapq.heappop(bridge_right)\n                t += time[i][2]\n                box_left += 1\n                heapq.heappush(put_new, (t+time[i][3], i))\n            elif bridge_left and box_right > 0:\n                _, i = heapq.heappop(bridge_left)\n                t += time[i][0]\n                box_right -= 1\n                heapq.heappush(pick_old, (t+time[i][1], i))\n            elif put_new or pick_old:\n                t = 2**31\n                if put_new:\n                    t = min(t, put_new[0][0])\n                if pick_old:\n                    t = min(t, pick_old[0][0])    \n        return t\n        ",
            "runtime": "475"
        },
        {
            "code": "class Solution:\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n        # workers putting new boxes\n        put_new = [(0, i) for i in range(k)] # [(available_at, i)] waiting to put new\n        heapq.heapify(put_new)\n        # workers waiting on left bank of bridge\n        bridge_left = [] # [(eff, i)] ready to cross river left to right\n        # workers picking old boxes\n        pick_old = [] # [(available_at, i)] waiting to pick old\n        # workers waiting on right bank of bridge\n        bridge_right = [] # [(eff, i)] ready to cross river right to left\n        box_left = 0\n        box_right = n\n        \n        def eff(i):\n            return (-time[i][0]-time[i][2], -i)\n            \n        t = 0    \n        while box_left < n:\n            while put_new and put_new[0][0] <= t:\n                _, i = heapq.heappop(put_new)\n                heapq.heappush(bridge_left, (eff(i), i))\n            while pick_old and pick_old[0][0] <= t:\n                _, i = heapq.heappop(pick_old)\n                heapq.heappush(bridge_right, (eff(i), i))\n            \n            if bridge_right:\n                _, i = heapq.heappop(bridge_right)\n                t += time[i][2]\n                box_left += 1\n                heapq.heappush(put_new, (t+time[i][3], i))\n            elif bridge_left and box_right > 0:\n                _, i = heapq.heappop(bridge_left)\n                t += time[i][0]\n                box_right -= 1\n                heapq.heappush(pick_old, (t+time[i][1], i))\n            elif put_new or pick_old:\n                t = 2**31\n                if put_new:\n                    t = min(t, put_new[0][0])\n                if pick_old:\n                    t = min(t, pick_old[0][0])    \n        return t",
            "runtime": "486"
        },
        {
            "code": "RIGHT, PICK, LEFT, PUT = 0, 1, 2, 3 \n\n\nclass Solution:\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n        left_q = [(-(r + l), -i) for i, (r, _, l, _) in enumerate(time)]\n        heapq.heapify(left_q)\n        put_q = []\n        bridge, head_right = None, False\n        right_q = []\n        pick_q = []\n        ts, next_ts = 0, 0\n        while n or bridge or pick_q:\n            ts = next_ts\n            if bridge and bridge[1] <= ts:\n                i, _ = bridge\n                if head_right:\n                    heapq.heappush(pick_q, (ts + time[i][PICK], i))\n                else:\n                    heapq.heappush(put_q, (ts + time[i][PUT], i))\n                bridge = None\n            while pick_q and pick_q[0][0] <= ts:\n                _, i = heapq.heappop(pick_q)\n                heapq.heappush(right_q, (-(time[i][LEFT] + time[i][RIGHT]), -i))\n            while put_q and put_q[0][0] <= ts:\n                _, i = heapq.heappop(put_q)\n                heapq.heappush(left_q, (-(time[i][LEFT] + time[i][RIGHT]), -i))\n            if bridge is None:\n                if right_q:\n                    i = -heapq.heappop(right_q)[1]\n                    bridge = (i, ts + time[i][LEFT])\n                    head_right = False\n                elif left_q and n:\n                    i = -heapq.heappop(left_q)[1]\n                    bridge = (i, ts + time[i][RIGHT])\n                    head_right = True\n                    n -= 1\n            next_ts = sys.maxsize\n            if bridge:\n                next_ts = bridge[1]\n            if pick_q:\n                next_ts = min(next_ts, pick_q[0][0])\n            if put_q:\n                next_ts = min(next_ts, put_q[0][0])\n        return ts",
            "runtime": "488"
        },
        {
            "code": "class Solution:\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n        priority = [(time[i][0] + time[i][2], i) for i in range(k)]\n        priority.sort()\n        efficiency = [0] * k\n        for i in range(k):\n            efficiency[priority[i][1]] = -i\n        \n        left_queue, right_queue = [], []\n        for i in range(k):\n            heappush(left_queue, (efficiency[i], i))\n        \n        # Events: \"waitL, waitR, reachL, reachR\"\n        time_series = []\n        collected_box = [0, 0] # pending_box, total_box counts\n        occupied = False\n        timing = 0\n                \n        def process_bridge(timing):\n            occupied = True\n            if right_queue:\n                _, worker = heappop(right_queue)\n                heappush(time_series, (timing + time[worker][2], 2, worker))\n            elif left_queue and collected_box[0] < n:\n                collected_box[0] += 1\n                _, worker = heappop(left_queue)\n                heappush(time_series, (timing + time[worker][0], 3, worker))\n            else:\n                occupied = False\n            return occupied\n                \n        def process_time_series(timing, events, worker, occupied):\n            # print(timing, \"waitL, waitR, reachL, reachR\".split(', ')[events], worker)\n            if events == 0:\n                heappush(left_queue, (efficiency[worker], worker))\n            elif events == 1:\n                heappush(right_queue, (efficiency[worker], worker))\n            elif events == 2:\n                collected_box[1] += 1\n                if collected_box[1] == n:\n                    return True, occupied\n                heappush(time_series, (timing + time[worker][3], 0, worker))\n            else:\n                heappush(time_series, (timing + time[worker][1], 1, worker))\n            if events >= 2:\n                occupied = process_bridge(timing)\n            return False, occupied\n        \n        while True:\n            if not occupied:\n                occupied = process_bridge(timing)\n\n            if time_series:\n                timing, events, worker = heappop(time_series)\n                complete, occupied = process_time_series(timing, events, worker, occupied)\n                if complete:\n                    return timing\n                while time_series:\n                    ctiming, events, worker = heappop(time_series)\n                    if ctiming == timing:\n                        complete, occupied = process_time_series(timing, events, worker, occupied)\n                        if complete:\n                            return timing\n                    else:\n                        heappush(time_series, (ctiming, events, worker))\n                        break\n            \n        return -1\n                    \n                    \n                    ",
            "runtime": "518"
        },
        {
            "code": "class Solution:\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n        priority = [(time[i][0] + time[i][2], i) for i in range(k)]\n        priority.sort()\n        efficiency = [0] * k\n        for i in range(k):\n            efficiency[priority[i][1]] = -i\n        \n        left_queue, right_queue = [], []\n        for i in range(k):\n            heappush(left_queue, (efficiency[i], i))\n        \n        # Events: \"waitL, waitR, reachL, reachR\"\n        time_series = []\n        collected_box = [0, 0] # pending_box, total_box counts\n        occupied = False\n        timing = 0\n                \n        def process_bridge(timing):\n            occupied = True\n            if right_queue:\n                _, worker = heappop(right_queue)\n                heappush(time_series, (timing + time[worker][2], 2, worker))\n            elif left_queue and collected_box[0] < n:\n                collected_box[0] += 1\n                _, worker = heappop(left_queue)\n                heappush(time_series, (timing + time[worker][0], 3, worker))\n            else:\n                occupied = False\n            return occupied\n                \n        def process_time_series(timing, events, worker, occupied):\n            # print(timing, \"waitL, waitR, reachL, reachR\".split(', ')[events], worker)\n            if events == 0:\n                heappush(left_queue, (efficiency[worker], worker))\n            elif events == 1:\n                heappush(right_queue, (efficiency[worker], worker))\n            elif events == 2:\n                collected_box[1] += 1\n                if collected_box[1] == n:\n                    return True, occupied\n                heappush(time_series, (timing + time[worker][3], 0, worker))\n            else:\n                heappush(time_series, (timing + time[worker][1], 1, worker))\n            if events >= 2:\n                occupied = process_bridge(timing)\n            return False, occupied\n        \n        while True:\n            if not occupied:\n                occupied = process_bridge(timing)\n\n            if time_series:\n                timing, events, worker = heappop(time_series)\n                complete, occupied = process_time_series(timing, events, worker, occupied)\n                if complete:\n                    return timing\n                while time_series:\n                    ctiming, events, worker = heappop(time_series)\n                    if ctiming == timing:\n                        complete, occupied = process_time_series(timing, events, worker, occupied)\n                        if complete:\n                            return timing\n                    else:\n                        heappush(time_series, (ctiming, events, worker))\n                        break\n            \n        return -1",
            "runtime": "529"
        },
        {
            "code": "from dataclasses import dataclass, field\nfrom heapq import heappush, heappop\n\nclass WorkerStates:\n    RIGHT = \"right\"\n    PICK = \"pick\"\n    LEFT = \"left\"\n    PUT = \"put\"\n    NONE = \"\"\n\n@dataclass(order=True, unsafe_hash=True)\nclass Worker:\n    priority: int = field(hash=True)\n    index: int= field(hash=True)\n    right: int = field(compare=False, hash=True)\n    pick: int = field(compare=False, hash=True)\n    left: int = field(compare=False, hash=True)\n    put: int = field(compare=False, hash=True)\n    task: str = field(default=WorkerStates.NONE, compare=False)\n    task_finish_time: int = field(default=0, compare=False)\n\n    def start_right(self, time):\n        self.task_finish_time = time + self.right\n        self.task = WorkerStates.RIGHT\n\n    def start_pick(self, time):\n        self.task_finish_time = time + self.pick\n        self.task = WorkerStates.PICK\n\n    def start_left(self, time):\n        self.task_finish_time = time + self.left\n        self.task = WorkerStates.LEFT\n        return TaskedWorker(self.task_finish_time, self)\n\n    def start_put(self, time):\n        self.task_finish_time = time + self.put\n        self.task = WorkerStates.PUT\n\n    def tasked_worker(self):\n        return TaskedWorker(self.task_finish_time, self)\n\n    @classmethod\n    def get_worker_queue(cls, time_stats):\n        q = []\n        for i, w in enumerate(time_stats):\n            heappush(q, cls(-1 * (w[0] + w[2]), i, *w))\n        return q\n\n@dataclass(order=True, unsafe_hash=True)\nclass TaskedWorker:\n    task_finish_time: int = field(hash=True)\n    worker: Worker = field(compare=False)\n\nclass WorkStatus:\n    def __init__(self, n, time_stats):\n        self.left_queue = Worker.get_worker_queue(time_stats)\n        self.right_queue = []\n        self.picking_queue = []\n        self.putting_queue = []\n        self.bridge = None\n        self.time = 0\n        self.remaining_workers = n\n        self.boxes_needed = n\n\n    def update_workers(self):\n        # update workers that are done with their current task\n        if self.bridge and self.bridge.task_finish_time == self.time:\n            if self.bridge.task == WorkerStates.RIGHT:\n                self.bridge.start_pick(self.time)\n                debug(f\"worker {self.bridge.index} arrived right, starting pick\")\n                heappush(self.picking_queue, self.bridge.tasked_worker())\n            else:\n                self.bridge.start_put(self.time)\n                debug(f\"worker {self.bridge.index} arrived left, starting put\")\n                heappush(self.putting_queue, self.bridge.tasked_worker())\n                self.boxes_needed -= 1\n            self.bridge = None\n\n        while len(self.picking_queue) > 0 and self.picking_queue[0].task_finish_time == self.time:\n            debug(f\"worker {self.picking_queue[0].worker.index} finished pick\")\n            heappush(self.right_queue, heappop(self.picking_queue).worker)\n\n        while len(self.putting_queue) > 0 and self.putting_queue[0].task_finish_time == self.time:\n            debug(f\"worker {self.putting_queue[0].worker.index} finished put\")\n            heappush(self.left_queue, heappop(self.putting_queue).worker)\n\n        if not self.bridge:\n            if len(self.right_queue) > 0:\n                self.bridge = heappop(self.right_queue)\n                self.bridge.start_left(self.time)\n                debug(f\"worker {self.bridge.index} starting left across bridge\")\n            elif len(self.left_queue) > 0 and self.remaining_workers > 0:\n                self.bridge = heappop(self.left_queue)\n                self.bridge.start_right(self.time)\n                self.remaining_workers -= 1\n                debug(f\"worker {self.bridge.index} starting right across bridge\")\n\n    def update_time(self):\n        next_time = 10 ** 8\n        if self.bridge:\n            next_time = min(self.bridge.task_finish_time, next_time)\n        if self.picking_queue:\n            next_time = min(self.picking_queue[0].task_finish_time, next_time)\n        if self.putting_queue:\n            next_time = min(self.putting_queue[0].task_finish_time, next_time)\n        if next_time < 10 ** 8:\n            self.time = next_time\n        debug(f\"time={self.time}\")\n\n    def done(self):\n        if self.boxes_needed == 0:\n            return True\n        else:\n            return False\n        if self.remaining_workers:\n            return False\n        if self.bridge:\n            return False\n        if self.picking_queue:\n            return False\n        if self.right_queue:\n            return False\n        return True\n\n    def print_status(self):\n        put = [\" \"] * (6 - len(self.putting_queue))\n        put.extend(reversed([str(abs(w.worker.index)) for w in self.putting_queue]))\n        put = \" \".join(put)\n\n        left = [\" \"] * (6 - len(self.left_queue))\n        left.extend(reversed([str(abs(w.index)) for w in self.left_queue]))\n        left = \" \".join(left)\n\n        pick = [str(abs(w.worker.index)) for w in self.picking_queue]\n        pick.extend([\" \"] * (6 - len(self.picking_queue)))\n        pick = \" \".join(pick)\n\n        right = [str(abs(w.index)) for w in self.right_queue]\n        right.extend([\" \"] * (6 - len(self.right_queue)))\n        right = \" \".join(right)\n\n        if self.bridge and self.bridge.task == WorkerStates.RIGHT:\n            bridge = \">--{}-->\".format(abs(self.bridge.index))\n        elif self.bridge and self.bridge.task == WorkerStates.LEFT:\n            bridge = \"<--{}--<\".format(abs(self.bridge.index))\n        else:\n            bridge = \"-------\"\n        print(f\"[{put}] {left}  ##  {bridge}  ##  {right} [{pick}]\")\n\ndef debug(s):\n    pass\n    #print(s)\n\n\nclass Solution:\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n        workers = []\n        for i, w in enumerate(time):\n            workers.append((w[0] + w[2], i, w))\n        workers.sort(reverse=True)\n        time = [w[2] for w in workers]\n        status = WorkStatus(n, time)\n\n        while not status.done():\n            status.update_time()\n            status.update_workers()\n\n        return status.time",
            "runtime": "1156"
        }
    ],
    "runtime_efficient_codes": [
        {
            "code": "class Solution:\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n        time.sort(key=lambda x: x[0] + x[2])\n        cur = 0\n        wait_in_left, wait_in_right = [], []\n        work_in_left, work_in_right = [], []\n        for i in range(k):\n            heappush(wait_in_left, -i)\n        while 1:\n            while work_in_left:\n                t, i = work_in_left[0]\n                if t > cur:\n                    break\n                heappop(work_in_left)\n                heappush(wait_in_left, -i)\n            while work_in_right:\n                t, i = work_in_right[0]\n                if t > cur:\n                    break\n                heappop(work_in_right)\n                heappush(wait_in_right, -i)\n            left_to_go = n > 0 and wait_in_left\n            right_to_go = bool(wait_in_right)\n            if not left_to_go and not right_to_go:\n                nxt = inf\n                if work_in_left:\n                    nxt = min(nxt, work_in_left[0][0])\n                if work_in_right:\n                    nxt = min(nxt, work_in_right[0][0])\n                cur = nxt\n                continue\n            if right_to_go:\n                i = -heappop(wait_in_right)\n                cur += time[i][2]\n                if n == 0 and not wait_in_right and not work_in_right:\n                    return cur\n                heappush(work_in_left, (cur + time[i][3], i))\n            else:\n                i = -heappop(wait_in_left)\n                cur += time[i][0]\n                n -= 1\n                heappush(work_in_right, (cur + time[i][1], i))",
            "runtime": "323"
        },
        {
            "code": "import heapq\nclass Solution:\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n        time.sort(key=lambda x: x[0] + x[2])     \n        current_time = 0\n        wait_left, wait_right, work_left, work_right = [], [], [], []\n        for i in range(k): heappush(wait_left, -i)\n        while True:\n            while work_left:\n                crossing_time, person_idx = work_left[0]\n                if crossing_time > current_time: break\n                heappop(work_left)\n                heappush(wait_left, -person_idx)\n            while work_right:\n                crossing_time, person_idx = work_right[0]\n                if crossing_time > current_time: break\n                heappop(work_right)\n                heappush(wait_right, -person_idx)\n            left_to_cross = n > 0 and wait_left\n            right_to_cross = bool(wait_right)\n            if not left_to_cross and not right_to_cross:\n                next_event = float('inf')\n                if work_left: next_event = min(next_event, work_left[0][0])\n                if work_right: next_event = min(next_event, work_right[0][0])\n                current_time = next_event\n                continue\n            if right_to_cross:\n                person_idx = -heappop(wait_right)\n                current_time += time[person_idx][2]\n                if n == 0 and not wait_right and not work_right: return current_time\n                heappush(work_left, (current_time + time[person_idx][3], person_idx))\n            else:\n                person_idx = -heappop(wait_left)\n                current_time += time[person_idx][0]\n                n -= 1\n                heappush(work_right, (current_time + time[person_idx][1], person_idx))\n        return current_time\n",
            "runtime": "325"
        },
        {
            "code": "class Solution:\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n        time.sort(key=lambda x: x[0] + x[2])\n        cur = 0\n        wait_in_left, wait_in_right = [], []\n        work_in_left, work_in_right = [], []\n        for i in range(k):\n            heappush(wait_in_left, -i)\n        while 1:\n            while work_in_left:\n                t, i = work_in_left[0]\n                if t > cur:\n                    break\n                heappop(work_in_left)\n                heappush(wait_in_left, -i)\n            while work_in_right:\n                t, i = work_in_right[0]\n                if t > cur:\n                    break\n                heappop(work_in_right)\n                heappush(wait_in_right, -i)\n            left_to_go = n > 0 and wait_in_left\n            right_to_go = bool(wait_in_right)\n            if not left_to_go and not right_to_go:\n                nxt = inf\n                if work_in_left:\n                    nxt = min(nxt, work_in_left[0][0])\n                if work_in_right:\n                    nxt = min(nxt, work_in_right[0][0])\n                cur = nxt\n                continue\n            if right_to_go:\n                i = -heappop(wait_in_right)\n                cur += time[i][2]\n                if n == 0 and not wait_in_right and not work_in_right:\n                    return cur\n                heappush(work_in_left, (cur + time[i][3], i))\n            else:\n                i = -heappop(wait_in_left)\n                cur += time[i][0]\n                n -= 1\n                heappush(work_in_right, (cur + time[i][1], i))",
            "runtime": "328"
        },
        {
            "code": "class Solution:\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n        # left = new, right = old\n        #            0            1        2            3\n        # time[i] = [leftToRight, pickOld, rightToLeft, putNew]\n\n        # if only one worker answer can be found in constant time\n        # (simulation would still work for k==1, this is just faster)\n        if k==1:\n            # Don't count the last put by subtracting it\n            return sum(time[0]) * n - time[0][3]\n\n        # start with everyone on left side of bridge, trying to cross to old factory\n        # left and right are max heaps based on efficiency\n        left = [(-(time[i][0] + time[i][2]), -i) for i in range(k)]\n        heapify(left)\n        right = []\n        # picking and putting are min heaps based on the timestamp that the worker will finish picking up/putting down a box\n        picking = []\n        putting = []\n\n        total_time = 0\n\n        # Since we are not counting the time to put down the last box(es), don't check if putting is non-empty\n        # To adjust this so it counts the final put time, add \"or putting\" to while condition\n        while n or right or picking:\n            # try to have someone cross bridge, update total_time to the when they will finish crossing\n            # add worker to corresponding picking/putting heap with the time they will be done at\n            if right:\n                efficiency, i = heappop(right)\n                i *= -1\n                total_time += time[i][2]\n                heappush(putting, (total_time + time[i][3], i))\n            elif left and n:\n                efficiency, i = heappop(left)\n                i *= -1\n                total_time += time[i][0]\n                heappush(picking, (total_time + time[i][1], i))\n                n -= 1\n            # If no one is trying to cross, update time to the first person to finish their current task\n            else:\n                total_time = min(putting[0][0] if putting else inf, picking[0][0] if picking else inf)\n            # Now move anyone done picking or putting boxes back in corresponding heaps to cross the bridge\n            while putting and putting[0][0] <= total_time:\n                t, i = heappop(putting)\n                heappush(left, (-(time[i][0] + time[i][2]), -i))\n            while picking and picking[0][0] <= total_time:\n                t, i = heappop(picking)\n                heappush(right, (-(time[i][0] + time[i][2]), -i))\n\n        return total_time",
            "runtime": "336"
        },
        {
            "code": "class Solution:\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n        # After sorting, the order of the indexes is the order of selection\n        time = sorted(time[::-1], key=lambda x: -x[0]-x[2])\n        lwait, rwait, lwork, rwork = [i for i in range(k)], [], [], []\n        heapify(lwait)\n        t = 0\n        while n or len(rwait) or len(rwork):\n            # Before t, these workers have finished their work\n            # Collect them and insert into waitlist\n            while len(lwork) and lwork[0][0] <= t:\n                heappush(lwait, heappop(lwork)[1])\n            while len(rwork) and rwork[0][0] <= t:\n                heappush(rwait, heappop(rwork)[1])\n            if len(rwait):\n                # Choose the rightside workers at first\n                c = heappop(rwait)\n                # Restart to wait after cross and work\n                heappush(lwork, (t + time[c][2] + time[c][3], c))\n                # Bridge return to idle after worker crossed\n                t += time[c][2]\n            else:\n                # Nobody waiting in rightside, choose leftside workers\n                if n == 0: \n                    # No need to schedule leftside worker\n                    # Advance directly to the next worker to complete\n                    t = rwork[0][0]\n                else:\n                    if len(lwait):\n                        # There are workers waiting in leftside \n                        c = heappop(lwait)\n                        # Restart to wait after cross and work\n                        heappush(rwork, (t + time[c][0] + time[c][1], c))\n                        # Bridge return to idle after worker crossed\n                        t += time[c][0]\n                        n -= 1\n                    else:\n                        # Choose the earlier complete time\n                        u = lwork[0][0] if len(lwork) else 1e9\n                        v = rwork[0][0] if len(rwork) else 1e9\n                        t = min(u, v)\n        return t",
            "runtime": "338"
        },
        {
            "code": "class Solution:\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n#         \u5efa\u7acb 4 \u4e2a\u5806\uff0c\u6bcf\u4e2a\u5806\u90fd\u8bb0\u5f55\u5de5\u4eba\u4e0b\u6807 i \u548c\u5b8c\u6210\u65f6\u95f4 t\uff08\u5230\u8fbe\u6865\u7684\u65f6\u95f4\uff09\uff0c\u8fd9 4 \u4e2a\u5806\u4ece\u5de6\u5230\u53f3\u5206\u522b\u8868\u793a:\n\n#         workL\uff1a\u65b0\u4ed3\u5e93\u6b63\u5728\u653e\u7bb1\u7684\u5de5\u4eba\uff1b\n#         waitL\uff1a\u5de6\u8fb9\u7b49\u5f85\u8fc7\u6865\u7684\u5de5\u4eba\uff1b\n#         waitR\uff1a\u53f3\u8fb9\u7b49\u5f85\u8fc7\u6865\u7684\u5de5\u4eba\uff1b\n#         workR\uff1a\u65e7\u4ed3\u5e93\u6b63\u5728\u642c\u7bb1\u7684\u5de5\u4eba\u3002\n#         \u8bb0\u5f55\u5f53\u524d\u65f6\u95f4 cur\uff0c\u4e0d\u65ad\u5faa\u73af\u76f4\u5230\u6240\u6709\u7bb1\u5b50\u88ab\u642c\u5b8c\uff0c\u6bcf\u6b21\u5faa\u73af\uff1a\n\n#         \u628a\u5b8c\u6210\u65f6\u95f4\u4e0d\u8d85\u8fc7 cur \u7684 workL \u5f39\u51fa\uff0c\u653e\u5165 waitL \u4e2d\uff1b\n#         \u628a\u5b8c\u6210\u65f6\u95f4\u4e0d\u8d85\u8fc7 cur \u7684 workR \u5f39\u51fa\uff0c\u653e\u5165 waitR \u4e2d\uff1b\n#         \u5982\u679c waitR \u4e0d\u4e3a\u7a7a\uff0c\u51fa\u5806\uff0c\u8fc7\u6865\uff0c\u66f4\u65b0 cur \u4e3a\u8fc7\u5b8c\u6865\u7684\u65f6\u95f4\uff0c\u7136\u540e\u628a\u8fd9\u4e2a\u5de5\u4eba\u653e\u5165 workL \u4e2d\uff08\u8bb0\u5f55\u5b8c\u6210\u65f6\u95f4\uff09\uff1b\n#         \u5426\u5219\u5982\u679c waitL \u4e0d\u4e3a\u7a7a\uff0c\u51fa\u5806\uff0c\u8fc7\u6865\uff0c\u66f4\u65b0 cur \u4e3a\u8fc7\u5b8c\u6865\u7684\u65f6\u95f4\uff0c\u7136\u540e\u628a\u8fd9\u4e2a\u5de5\u4eba\u653e\u5165 workR \u4e2d\uff08\u8bb0\u5f55\u5b8c\u6210\u65f6\u95f4\uff09\uff0c\u540c\u65f6\u628a n \u51cf\u4e00\uff1b\n#         \u5426\u5219\u8bf4\u660e cur \u8fc7\u5c0f\uff0c\u627e\u4e2a\u6700\u5c0f\u7684\u653e\u7bb1/\u642c\u7bb1\u5b8c\u6210\u65f6\u95f4\u6765\u66f4\u65b0 cur\u3002\n#         \u5faa\u73af\u7ed3\u675f\u540e\uff0c\u4e0d\u65ad\u5f39\u51fa workR\uff0c\u8fc7\u6865\uff0c\u6700\u540e\u4e00\u4e2a\u5de5\u4eba\u8fc7\u5b8c\u6865\u7684\u65f6\u95f4\u5373\u4e3a\u7b54\u6848\u3002\n\n#         \u4ee3\u7801\u5b9e\u73b0\u65f6\uff0c\u53ef\u4ee5\u5148\u628a time \u4ece\u5c0f\u5230\u5927\u7a33\u5b9a\u6392\u5e8f\uff0c\u8fd9\u6837\u4e0b\u6807\u8d8a\u5927\u7684\u5de5\u4eba\u6548\u7387\u8d8a\u4f4e\uff0c\u53ea\u770b\u4e0b\u6807\u5c31\u80fd\u6bd4\u8f83\u5de5\u4eba\u7684\u6548\u7387\u3002\n\n\n        time.sort(key=lambda t: t[0] + t[2])  # \u7a33\u5b9a\u6392\u5e8f\n        cur = 0\n        workL, waitL, waitR, workR = [], [[-i, 0] for i in range(k - 1, -1, -1)], [], []  # \u4e0b\u6807\u8d8a\u5927\u6548\u7387\u8d8a\u4f4e\n        while n:\n            while workL and workL[0][0] <= cur:\n                p = heappop(workL)\n                p[0], p[1] = p[1], p[0]\n                heappush(waitL, p)  # \u5de6\u8fb9\u5b8c\u6210\u653e\u7bb1\n            while workR and workR[0][0] <= cur:\n                p = heappop(workR)\n                p[0], p[1] = p[1], p[0]\n                heappush(waitR, p)  # \u53f3\u8fb9\u5b8c\u6210\u642c\u7bb1\n            if waitR:  # \u53f3\u8fb9\u8fc7\u6865\uff0c\u6ce8\u610f\u52a0\u5230 waitR \u4e2d\u7684\u90fd\u662f <= cur \u7684\uff08\u4e0b\u540c\uff09\n                p = heappop(waitR)\n                cur += time[-p[0]][2]\n                p[1] = p[0]\n                p[0] = cur + time[-p[0]][3]\n                heappush(workL, p)  # \u653e\u7bb1\n            elif waitL:  # \u5de6\u8fb9\u8fc7\u6865\n                p = heappop(waitL)\n                cur += time[-p[0]][0]\n                p[1] = p[0]\n                p[0] = cur + time[-p[0]][1]\n                heappush(workR, p)  # \u642c\u7bb1\n                n -= 1\n            elif len(workL) == 0: cur = workR[0][0]  # cur \u8fc7\u5c0f\uff0c\u627e\u4e2a\u6700\u5c0f\u7684\u653e\u7bb1/\u642c\u7bb1\u5b8c\u6210\u65f6\u95f4\u6765\u66f4\u65b0 cur\n            elif len(workR) == 0: cur = workL[0][0]\n            else: cur = min(workL[0][0], workR[0][0])\n        while workR:\n            t, i = heappop(workR)  # \u53f3\u8fb9\u5b8c\u6210\u642c\u7bb1\n            # \u5982\u679c\u6ca1\u6709\u6392\u961f\uff0c\u76f4\u63a5\u8fc7\u6865\uff1b\u5426\u5219\u7531\u4e8e\u65e0\u8bba\u8c01\u5148\u8fc7\u6865\uff0c\u6700\u7ec8\u5b8c\u6210\u65f6\u95f4\u90fd\u4e00\u6837\uff0c\u6240\u4ee5\u4e5f\u53ef\u4ee5\u76f4\u63a5\u8ba1\u7b97\n            cur = max(t, cur) + time[-i][2]\n        return cur  # \u6700\u540e\u4e00\u4e2a\u8fc7\u6865\u7684\u65f6\u95f4\n\n",
            "runtime": "355"
        },
        {
            "code": "class Solution:\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n\n        right = []\n        picking = []\n        putting = []\n        left = []\n        # each worker will be separated by their efficiency\n        for i,j in enumerate(time):\n            heapq.heappush(left, [-(j[0] + j[2]), -i])\n        \n        t = 0\n        while n or right or putting or picking:\n            if right: # right to left passing\n                worker = heapq.heappop(right)\n                t += time[-worker[1]][2]\n                heapq.heappush(putting, [t + time[-worker[1]][3], worker])\n            elif n and left:\n                worker = heapq.heappop(left)\n                t += time[-worker[1]][0]\n                n -= 1\n                heapq.heappush(picking, [t + time[-worker[1]][1], worker])\n            else:\n                if not n and not picking:\n                    return t\n                nextTime = []\n                if putting:\n                    nextTime.append(putting[0][0])\n                if picking:\n                    nextTime.append(picking[0][0])\n                t = min(nextTime)\n            while putting and putting[0][0] <= t:\n                _,worker = heapq.heappop(putting)\n                heapq.heappush(left, worker)\n            while picking and picking[0][0] <= t:\n                _,worker = heapq.heappop(picking)\n                heapq.heappush(right, worker)\n        return t\n\n                \n            \n\n\n\n                \n\n\n\n\n\n        ",
            "runtime": "360"
        },
        {
            "code": "class Solution:\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n\n        # have a left bridge\n        # the left bridge will have elements that will be put towards picking\n        # the right bridge will have elements that will be put towards putting\n\n        left = []\n        right = []\n        putting = []\n        picking = []\n        t = 0\n        for i,worker in enumerate(time):\n            heapq.heappush(left, [-(worker[0] + worker[2]), -i])\n        \n\n        while n or right or putting or picking:\n            if right: # right to left passing\n                worker = heapq.heappop(right)\n                t += time[-worker[1]][2]\n                heapq.heappush(putting, [t + time[-worker[1]][3], worker])\n            elif n and left:\n                worker = heapq.heappop(left)\n                t += time[-worker[1]][0]\n                n -= 1\n                heapq.heappush(picking, [t + time[-worker[1]][1], worker])\n            else:\n                if not n and not picking:\n                    return t\n                nextTime = []\n                if picking:\n                    nextTime.append(picking[0][0])\n                if putting:\n                    nextTime.append(putting[0][0])\n                t = min(nextTime)\n\n            while putting and putting[0][0] <= t:\n                _,worker = heapq.heappop(putting)\n                heapq.heappush(left, worker)\n            while picking and picking[0][0] <= t:\n                _, worker = heapq.heappop(picking)\n                heapq.heappush(right, worker)\n        return t\n            \n\n\n\n            \n\n        ",
            "runtime": "365"
        },
        {
            "code": "class Solution:\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n        res = 0\n\n        heap = []\n        available_workers = [(-time[i][0] - time[i][2], -i) for i in range(len(time))]\n        heapify(available_workers)\n\n        right_heap = []\n        right_available_workers = []\n\n        while n or right_heap or right_available_workers:\n            did = True\n\n            while right_heap and right_heap[0][0] <= res:\n                heappush(right_available_workers, heappop(right_heap)[1:])\n\n            while heap and heap[0][0] <= res and n:\n                heappush(available_workers, heappop(heap)[1:])\n\n            if right_available_workers:\n                weight, worker = heappop(right_available_workers)\n\n                # cross\n                res += time[-worker][2]\n                heappush(heap, (res + time[-worker][3], weight, worker))\n                did = False\n\n            elif available_workers and n:\n                weight, worker = heappop(available_workers)\n\n                # cross\n                res += time[-worker][0]\n                heappush(right_heap, (res + time[-worker][1], weight, worker))\n                n -= 1\n                did = False\n\n            if did:\n                res = min(heap[0][0] if heap and n else inf, right_heap[0][0] if right_heap else inf)\n\n        return res",
            "runtime": "366"
        },
        {
            "code": "class Solution:\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n\n        leftSide = []\n        rightSide = []\n        picking = []\n        putting = []\n\n        for i, worker in enumerate(time):\n            heapq.heappush(leftSide, [-(worker[0] + worker[2]), -i])\n        t = 0\n\n        while n or rightSide or picking or putting:\n            if rightSide: # right to left passing\n                worker = heapq.heappop(rightSide)\n                t += time[-worker[1]][2]\n                heapq.heappush(putting, [t + time[-worker[1]][3], worker])\n            elif n and leftSide:\n                worker = heapq.heappop(leftSide)\n                t += time[-worker[1]][0]\n                n -= 1\n                heapq.heappush(picking, [t + time[-worker[1]][1], worker])\n            else:\n                if not n and not picking:\n                    return t\n                nextTime = []\n                if picking:\n                    nextTime.append(picking[0][0])\n                if putting:\n                    nextTime.append(putting[0][0])\n                t = min(nextTime)\n            \n\n            #put all the workers back to the bridge queue if they finish\n            while putting and putting[0][0] <= t:\n                _, worker = heapq.heappop(putting)\n                heapq.heappush(leftSide, worker)\n            while picking and picking[0][0] <= t:\n                _, worker = heapq.heappop(picking)\n                heapq.heappush(rightSide, worker)\n        return t\n\n            \n\n        ",
            "runtime": "369"
        },
        {
            "code": "class Solution:\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n        res = 0\n\n        heap = []\n        available_workers = [(-time[i][0] - time[i][2], -i) for i in range(len(time))]\n        heapify(available_workers)\n\n        right_heap = []\n        right_available_workers = []\n\n        while n or right_heap or right_available_workers:\n            did = True\n\n            while right_heap and right_heap[0][0] <= res:\n                heappush(right_available_workers, heappop(right_heap)[1:])\n\n            while heap and heap[0][0] <= res and n:\n                heappush(available_workers, heappop(heap)[1:])\n\n            if right_available_workers:\n                weight, worker = heappop(right_available_workers)\n\n                # cross\n                res += time[-worker][2]\n                heappush(heap, (res + time[-worker][3], weight, worker))\n                did = False\n\n            elif available_workers and n:\n                weight, worker = heappop(available_workers)\n\n                # cross\n                res += time[-worker][0]\n                heappush(right_heap, (res + time[-worker][1], weight, worker))\n                n -= 1\n                did = False\n\n            if did:\n                res = min(heap[0][0] if heap and n else inf, right_heap[0][0] if right_heap else inf)\n\n        return res",
            "runtime": "370"
        },
        {
            "code": "class Solution:\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n        leftSide = []\n        rightSide = []\n        picking = []\n        putting = []\n        for i, worker in enumerate(time):\n            heapq.heappush(leftSide, [-(worker[0] + worker[2]), -i])\n        t = 0\n        while n or rightSide or picking or putting:\n            if rightSide:\n                worker = heapq.heappop(rightSide)\n                t += time[-worker[1]][2]\n                heapq.heappush(putting, [t + time[-worker[1]][3], worker])\n            elif n and leftSide:\n                worker = heapq.heappop(leftSide)\n                t += time[-worker[1]][0]\n                n -= 1\n                heapq.heappush(picking, [t + time[-worker[1]][1], worker])\n            else:\n                if not n and not picking:\n                    return t\n                nextTime = []\n                if picking:\n                    nextTime.append(picking[0][0])\n                if putting:\n                    nextTime.append(putting[0][0])\n                t = min(nextTime)\n            while putting and putting[0][0] <= t:\n                _, worker = heapq.heappop(putting)\n                heapq.heappush(leftSide, worker)\n            while picking and picking[0][0] <= t:\n                _, worker = heapq.heappop(picking)\n                heapq.heappush(rightSide, worker)\n        return t",
            "runtime": "371"
        },
        {
            "code": "class Solution:\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n        curr = 0\n        avalible_worker = [(-time[i][0] - time[i][2], -i) for i in range(k)]\n        left_heap = []\n        right_heap = []\n        avalible_worker_picked = []\n        heapify(avalible_worker)\n\n        while n or right_heap or avalible_worker_picked:\n\n            while left_heap and left_heap[0][0] <= curr:\n                _, i = heappop(left_heap)\n                heappush(avalible_worker, (-time[i][0] - time[i][2], -i))\n\n            while right_heap and right_heap[0][0] <= curr:\n                _, i = heappop(right_heap)\n                heappush(avalible_worker_picked, (-time[i][0] - time[i][2], -i))\n\n            if avalible_worker_picked:\n                _, idx = heappop(avalible_worker_picked)\n                idx = -idx\n                # print(idx)\n                curr += time[idx][2]\n                heappush(left_heap, (curr + time[idx][3], idx))\n            elif avalible_worker and n:\n                _, idx = heappop(avalible_worker)\n                idx = -idx\n                curr += time[idx][0]\n                n -= 1\n                # print(idx)\n                heappush(right_heap, (curr + time[idx][1], idx))\n            else:\n                #curr += 1\n                curr = min(left_heap[0][0] if left_heap and n else 1000000000, right_heap[0][0] if right_heap else 1000000000)\n\n        return curr\n",
            "runtime": "372"
        },
        {
            "code": "class Solution:\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n        left_warehouse, left_bridge, right_warehouse, right_bridge = [], [], [], []\n        curr_time = 0\n        #initially everyone is in front of the left bridge\n        for i in range(k):\n            heapq.heappush(left_bridge,(-time[i][0]-time[i][2], -i))\n        #return the loop till we have boxes / there is someone on the right back of the river who needs to come back\n        while n or right_warehouse or right_bridge:\n            #we need to move the workers to the bridge edges before starting any movement\n            while left_warehouse and left_warehouse[0][0] <= curr_time:\n                _, i = heapq.heappop(left_warehouse)\n                heapq.heappush(left_bridge,(-time[i][0]-time[i][2], -i))\n            while right_warehouse and right_warehouse[0][0] <= curr_time:\n                _, i = heapq.heappop(right_warehouse)\n                heapq.heappush(right_bridge,(-time[i][0]-time[i][2], -i))\n            #workers on right end move to the left end\n            if right_bridge:\n                _, i = heapq.heappop(right_bridge)\n                l, po, r, pn = time[-i]\n                curr_time += r\n                heapq.heappush(left_warehouse,(curr_time+pn, -i))\n                n -= 1\n            #if there are more boxes in right and fewer workers, we need to move additional workers from the left\n            elif left_bridge and n > len(right_warehouse) + len(right_bridge):\n                _, i = heapq.heappop(left_bridge)\n                l, po, r, pn = time[-i]\n                curr_time += l\n                heapq.heappush(right_warehouse,(curr_time+po, -i))\n            #if there are no workers on the left end of the bridge and there are boxes \n            #OR\n            #if there are workers on the left end but no boxes \n            else:\n                left_time = left_warehouse[0][0] if left_warehouse and n > len(right_warehouse) + len(right_bridge) else math.inf\n                right_time = right_warehouse[0][0] if right_warehouse else math.inf\n                curr_time = min(left_time,right_time)\n        return curr_time                    ",
            "runtime": "373"
        }
    ],
    "memory_inefficient_codes": [
        {
            "code": "class Solution:\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n\n        right = []\n        picking = []\n        putting = []\n        left = []\n        # each worker will be separated by their efficiency\n        for i,j in enumerate(time):\n            heapq.heappush(left, [-(j[0] + j[2]), -i])\n        \n        t = 0\n        while n or right or putting or picking:\n            if right: # right to left passing\n                worker = heapq.heappop(right)\n                t += time[-worker[1]][2]\n                heapq.heappush(putting, [t + time[-worker[1]][3], worker])\n            elif n and left:\n                worker = heapq.heappop(left)\n                t += time[-worker[1]][0]\n                n -= 1\n                heapq.heappush(picking, [t + time[-worker[1]][1], worker])\n\n            else:\n                if not n and not picking:\n                    return t\n                nextTime = []\n                if putting:\n                    nextTime.append(putting[0][0])\n                if picking:\n                    nextTime.append(picking[0][0])\n                t = min(nextTime)\n            while putting and putting[0][0] <= t:\n                _,worker = heapq.heappop(putting)\n                heapq.heappush(left, worker)\n            while picking and picking[0][0] <= t:\n                _,worker = heapq.heappop(picking)\n                heapq.heappush(right, worker)\n        return t\n\n                \n            \n\n\n\n                \n\n\n\n\n\n        ",
            "memory": "23300"
        },
        {
            "code": "class Solution:\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n        ll, l, r, rr = list(), list(), list(), list()\n        for i, (a, _, c, _) in enumerate(time):\n            heapq.heappush(l, (-a - c, -i))\n\n        t = 0\n        while n:\n            while ll and ll[0][0] <= t:\n                _, i = heapq.heappop(ll)\n                heapq.heappush(l, (-time[i][0] - time[i][2], -i))\n            while rr and rr[0][0] <= t:\n                _, i = heapq.heappop(rr)\n                heapq.heappush(r, (-time[i][0] - time[i][2], -i))\n\n            if r:\n                _, i = heapq.heappop(r)\n                t += time[-i][2]\n                heapq.heappush(ll, (t + time[-i][3], -i))\n                n -= 1\n            elif l and n > len(r) + len(rr):\n                _, i = heapq.heappop(l)\n                t += time[-i][0]\n                heapq.heappush(rr, (t + time[-i][1], -i))\n            else:\n                x = ll[0][0] if ll and n > len(r) + len(rr) else float('inf')\n                y = rr[0][0] if rr else float('inf')\n                t = min(x, y)\n        return t",
            "memory": "23400"
        },
        {
            "code": "class Solution:\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n        time.sort(key=lambda x: x[0] + x[2])\n        cur = 0\n        wait_in_left, wait_in_right = [], []\n        work_in_left, work_in_right = [], []\n        for i in range(k):\n            heappush(wait_in_left, -i)\n        while 1:\n            while work_in_left:\n                t, i = work_in_left[0]\n                if t > cur:\n                    break\n                heappop(work_in_left)\n                heappush(wait_in_left, -i)\n            while work_in_right:\n                t, i = work_in_right[0]\n                if t > cur:\n                    break\n                heappop(work_in_right)\n                heappush(wait_in_right, -i)\n            left_to_go = n > 0 and wait_in_left\n            right_to_go = bool(wait_in_right)\n            if not left_to_go and not right_to_go:\n                nxt = inf\n                if work_in_left:\n                    nxt = min(nxt, work_in_left[0][0])\n                if work_in_right:\n                    nxt = min(nxt, work_in_right[0][0])\n                cur = nxt\n                continue\n            if right_to_go:\n                i = -heappop(wait_in_right)\n                cur += time[i][2]\n                if n == 0 and not wait_in_right and not work_in_right:\n                    return cur\n                heappush(work_in_left, (cur + time[i][3], i))\n            else:\n                i = -heappop(wait_in_left)\n                cur += time[i][0]\n                n -= 1\n                heappush(work_in_right, (cur + time[i][1], i))",
            "memory": "23500"
        },
        {
            "code": "class Solution:\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n        priority = [(time[i][0] + time[i][2], i) for i in range(k)]\n        priority.sort()\n        efficiency = [0] * k\n        for i in range(k):\n            efficiency[priority[i][1]] = -i\n        \n        left_queue, right_queue = [], []\n        for i in range(k):\n            heappush(left_queue, (efficiency[i], i))\n        \n        # Events: \"waitL, waitR, reachL, reachR\"\n        time_series = []\n        collected_box = [0, 0] # pending_box, total_box counts\n        occupied = False\n        timing = 0\n                \n        def process_bridge(timing):\n            occupied = True\n            if right_queue:\n                _, worker = heappop(right_queue)\n                heappush(time_series, (timing + time[worker][2], 2, worker))\n            elif left_queue and collected_box[0] < n:\n                collected_box[0] += 1\n                _, worker = heappop(left_queue)\n                heappush(time_series, (timing + time[worker][0], 3, worker))\n            else:\n                occupied = False\n            return occupied\n                \n        def process_time_series(timing, events, worker, occupied):\n            # print(timing, \"waitL, waitR, reachL, reachR\".split(', ')[events], worker)\n            if events == 0:\n                heappush(left_queue, (efficiency[worker], worker))\n            elif events == 1:\n                heappush(right_queue, (efficiency[worker], worker))\n            elif events == 2:\n                collected_box[1] += 1\n                if collected_box[1] == n:\n                    return True, occupied\n                heappush(time_series, (timing + time[worker][3], 0, worker))\n            else:\n                heappush(time_series, (timing + time[worker][1], 1, worker))\n            if events >= 2:\n                occupied = process_bridge(timing)\n            return False, occupied\n        \n        while True:\n            if not occupied:\n                occupied = process_bridge(timing)\n\n            if time_series:\n                timing, events, worker = heappop(time_series)\n                complete, occupied = process_time_series(timing, events, worker, occupied)\n                if complete:\n                    return timing\n                while time_series:\n                    ctiming, events, worker = heappop(time_series)\n                    if ctiming == timing:\n                        complete, occupied = process_time_series(timing, events, worker, occupied)\n                        if complete:\n                            return timing\n                    else:\n                        heappush(time_series, (ctiming, events, worker))\n                        break\n            \n        return -1",
            "memory": "23700"
        },
        {
            "code": "class Solution:\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n        # workers putting new boxes\n        put_new = [(0, i) for i in range(k)] # [(available_at, i)] waiting to put new\n        heapq.heapify(put_new)\n        bridge_left = [] \n        pick_old = []\n        bridge_right = [] \n        box_left = 0\n        box_right = n\n        def eff(i):\n            return (-time[i][0]-time[i][2], -i)\n        t = 0    \n        while box_left < n:\n            while put_new and put_new[0][0] <= t:\n                _, i = heapq.heappop(put_new)\n                heapq.heappush(bridge_left, (eff(i), i))\n            while pick_old and pick_old[0][0] <= t:\n                _, i = heapq.heappop(pick_old)\n                heapq.heappush(bridge_right, (eff(i), i))\n            \n            if bridge_right:\n                _, i = heapq.heappop(bridge_right)\n                t += time[i][2]\n                box_left += 1\n                heapq.heappush(put_new, (t+time[i][3], i))\n            elif bridge_left and box_right > 0:\n                _, i = heapq.heappop(bridge_left)\n                t += time[i][0]\n                box_right -= 1\n                heapq.heappush(pick_old, (t+time[i][1], i))\n            elif put_new or pick_old:\n                t = 2**31\n                if put_new:\n                    t = min(t, put_new[0][0])\n                if pick_old:\n                    t = min(t, pick_old[0][0])    \n        return t\n        ",
            "memory": "23800"
        }
    ],
    "memory_efficient_codes": [
        {
            "code": "class Solution:\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n\n        right = []\n        picking = []\n        putting = []\n        left = []\n        # each worker will be separated by their efficiency\n        for i,j in enumerate(time):\n            heapq.heappush(left, [-(j[0] + j[2]), -i])\n        \n        t = 0\n        while n or right or putting or picking:\n            if right: # right to left passing\n                worker = heapq.heappop(right)\n                t += time[-worker[1]][2]\n                heapq.heappush(putting, [t + time[-worker[1]][3], worker])\n            elif n and left:\n                worker = heapq.heappop(left)\n                t += time[-worker[1]][0]\n                n -= 1\n                heapq.heappush(picking, [t + time[-worker[1]][1], worker])\n            else:\n                if not n and not picking:\n                    return t\n                nextTime = []\n                if putting:\n                    nextTime.append(putting[0][0])\n                if picking:\n                    nextTime.append(picking[0][0])\n                t = min(nextTime)\n            while putting and putting[0][0] <= t:\n                _,worker = heapq.heappop(putting)\n                heapq.heappush(left, worker)\n            while picking and picking[0][0] <= t:\n                _,worker = heapq.heappop(picking)\n                heapq.heappush(right, worker)\n        return t\n\n                \n            \n\n\n\n                \n\n\n\n\n\n        ",
            "memory": "23100"
        },
        {
            "code": "RIGHT, PICK, LEFT, PUT = 0, 1, 2, 3 \n\n\nclass Solution:\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n        left_q = [(-(r + l), -i) for i, (r, _, l, _) in enumerate(time)]\n        heapq.heapify(left_q)\n        put_q = []\n        bridge, head_right = None, False\n        right_q = []\n        pick_q = []\n        ts, next_ts = 0, 0\n        while n or bridge or pick_q:\n            ts = next_ts\n            if bridge and bridge[1] <= ts:\n                i, _ = bridge\n                if head_right:\n                    heapq.heappush(pick_q, (ts + time[i][PICK], i))\n                else:\n                    heapq.heappush(put_q, (ts + time[i][PUT], i))\n                bridge = None\n            while pick_q and pick_q[0][0] <= ts:\n                _, i = heapq.heappop(pick_q)\n                heapq.heappush(right_q, (-(time[i][LEFT] + time[i][RIGHT]), -i))\n            while put_q and put_q[0][0] <= ts:\n                _, i = heapq.heappop(put_q)\n                heapq.heappush(left_q, (-(time[i][LEFT] + time[i][RIGHT]), -i))\n            if bridge is None:\n                if right_q:\n                    i = -heapq.heappop(right_q)[1]\n                    bridge = (i, ts + time[i][LEFT])\n                    head_right = False\n                elif left_q and n:\n                    i = -heapq.heappop(left_q)[1]\n                    bridge = (i, ts + time[i][RIGHT])\n                    head_right = True\n                    n -= 1\n            next_ts = sys.maxsize\n            if bridge:\n                next_ts = bridge[1]\n            if pick_q:\n                next_ts = min(next_ts, pick_q[0][0])\n            if put_q:\n                next_ts = min(next_ts, put_q[0][0])\n        return ts",
            "memory": "23200"
        }
    ]
}