[
    {
        "status": "success",
        "question_id": 131,
        "title": "palindrome-partitioning",
        "token": "8906b239-7096-4abf-82a5-0805b4c949fa",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\nimport string\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\ndef is_palindrome(s, l, r):\n    while l < r:\n        if s[l] != s[r]:\n            return False\n\n        l, r = l + 1, r - 1\n\n    return True\n\n\nclass Solution:\n    def partition(self, s):\n        dp = [[] for _ in range(len(s) + 1)]\n        dp[-1] = [[]]\n        for l in range(len(s) - 1, -1, -1):\n            for r in range(l, len(s)):\n                if not is_palindrome(s, l, r):\n                    continue\n                \n                strlist = [s[l:r + 1]]\n                dpresult = dp[r + 1]\n                for plist in dpresult:\n                    dp[l].append(strlist + plist)\n        \n        return dp[0]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(1, 16)\n        s = ''.join((random.choice(string.ascii_lowercase) for _ in range(length)))\n        return {'s': s}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['s']\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.partition(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.05",
            "memory": 4840,
            "stderr": null,
            "token": "8906b239-7096-4abf-82a5-0805b4c949fa",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 132,
        "title": "palindrome-partitioning-ii",
        "token": "67b30463-acb5-4154-8457-1625eef05f31",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport json\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def minCut(self, s: str) -> int:\n        if s == s[::-1]:\n            return 0\n        for index in range(1, len(s)):\n            if s[:index] == s[:index][::-1] and s[index:] == s[index:][::-1]:\n                return 1\n        min_cuts = [cuts for cuts in range(-1, len(s))]\n        for center in range(len(s)):\n            odd = even = 0\n            while center - odd >= 0 and center + odd < len(s) and s[center - odd] == s[center + odd]:\n                min_cuts[center + odd + 1] = min(min_cuts[center + odd + 1], min_cuts[center - odd] + 1)\n                odd += 1\n\n            while center - even >= 0 and center + even + 1 < len(s) and s[center - even] == s[center + even + 1]:\n                min_cuts[center + even + 2] = min(min_cuts[center + even + 2], min_cuts[center - even] + 1)\n                even += 1\n        return min_cuts[-1]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        \"\"\"\n        Generates a test case input containing a random string `s` of length between 1 and 10.\n        This ensures we have a reasonable range for testing without excessive computation time.\n        \"\"\"\n        min_length = 1\n        max_length = 10\n        length = random.randint(min_length, max_length)\n        s = ''.join(random.choices('abcdefghijklmnopqrstuvwxyz', k=length))\n        return {'s': s}\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\"\n        Encodes the test case input into a JSON string.\n        \"\"\"\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\"\n        Encodes the test case output, which is an integer, to a string.\n        \"\"\"\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\"\n        Decodes a JSON string into a dictionary representing the test case input.\n        \"\"\"\n        return json.loads(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.minCut(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.064",
            "memory": 4824,
            "stderr": null,
            "token": "67b30463-acb5-4154-8457-1625eef05f31",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 135,
        "title": "candy",
        "token": "d3044098-7af2-472a-8881-09712ce73521",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def candy(self, ratings: List[int]) -> int:\n        counts = [1] * len(ratings)\n\n        for i in range(1, len(ratings)):\n            if ratings[i] > ratings[i - 1]:\n                counts[i] = counts[i - 1] + 1\n        \n        for i in range(len(ratings) - 2, -1, -1):\n            if ratings[i] > ratings[i + 1] and counts[i] <= counts[i + 1]:\n                counts[i] = counts[i + 1] + 1\n\n        return sum(counts)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        test_case_1 = {'ratings': [1, 0, 2]}\n        test_case_2 = {'ratings': [1, 2, 2]}\n        test_case_3 = {'ratings': [3, 2, 1]}\n        test_case_4 = {'ratings': [1, 3, 4, 5, 2]}\n        test_case_5 = {'ratings': [1, 2, 87, 87, 87, 2, 1]}\n        return random.choice([test_case_1, test_case_2, test_case_3, test_case_4, test_case_5])\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.candy(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.062",
            "memory": 4824,
            "stderr": null,
            "token": "d3044098-7af2-472a-8881-09712ce73521",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 137,
        "title": "single-number-ii",
        "token": "c861c94b-5676-4b46-8012-36ccdd2bfa00",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        cnt = defaultdict(int)\n        \n        for x in nums:\n            cnt[x] += 1\n\n        for x, freq in cnt.items():\n            if freq == 1:\n                return x\n        \n        return -1\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        \"\"\"\n        Generate a sample test case input where elements \n        appear three times except one. This will return \n        a dictionary with one element `nums` containing \n        a list.\n        \"\"\"\n        nums = [2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\"\n        Convert a test case input into a string.\n        This typically involves converting the list into a string format.\n        \"\"\"\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\"\n        Since the expected output is an integer, simply convert it to string.\n        This will help in returning a stringified version of the integer result.\n        \"\"\"\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\"\n        Given the input string, convert it back to a dictionary with key `nums`.\n        Warning: eval() is used here for simplicity; in production, safer alternatives\n        should be used to parse the input format to avoid code injection vulnerabilities.\n        \"\"\"\n        nums = eval(input_str)\n        return {'nums': nums}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.singleNumber(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.048",
            "memory": 4740,
            "stderr": null,
            "token": "c861c94b-5676-4b46-8012-36ccdd2bfa00",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 138,
        "title": "copy-list-with-random-pointer",
        "token": "22afc178-6481-4722-bc94-28587d0fe2ba",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import Optional\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\n\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        arr = collections.defaultdict(Node)\n        cur = head\n        if not head:\n            return None\n\n        while cur:\n            arr[cur] = Node(cur.val, None, None)\n            cur = cur.next\n        \n        cur = head\n        while cur:\n            if cur.random:\n                arr[cur].random = arr[cur.random]\n            if cur.next:\n                arr[cur].next = arr[cur.next]\n            cur = cur.next\n        return arr[head]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        nodes = [{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]\n        head = self.build_linked_list(nodes)\n        return {'head': head}\n\n    def build_linked_list(self, node_info):\n        if not node_info:\n            return None\n        nodes = [Node(info['val']) for info in node_info]\n        for i in range(len(nodes) - 1):\n            nodes[i].next = nodes[i + 1]\n        for i, info in enumerate(node_info):\n            if info['random_index'] is not None:\n                nodes[i].random = nodes[info['random_index']]\n        return nodes[0]\n\n    def encode_input(self, input_obj) -> str:\n        return str(self.linked_list_to_array(input_obj['head']))\n\n    def encode_output(self, output_obj) -> str:\n        if not output_obj:\n            return str([])\n        return str(self.linked_list_to_array(output_obj))\n\n    def decode_input(self, input_str) -> dict:\n        data = eval(input_str)\n        return {'head': self.build_linked_list(data)}\n\n    def linked_list_to_array(self, head: 'Node') -> list:\n        if not head:\n            return []\n        nodes = []\n        current = head\n        while current:\n            random_index = None\n            if current.random is not None:\n                random_index = self.find_index(head, current.random)\n            nodes.append({'val': current.val, 'random_index': random_index})\n            current = current.next\n        return nodes\n\n    def find_index(self, head: 'Node', node: 'Node') -> int:\n        current, index = (head, 0)\n        while current:\n            if current == node:\n                return index\n            current = current.next\n            index += 1\n        return -1\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.copyRandomList(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.08",
            "memory": 4912,
            "stderr": null,
            "token": "22afc178-6481-4722-bc94-28587d0fe2ba",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 140,
        "title": "word-break-ii",
        "token": "e62081d7-1fbf-4473-82f5-62b0417f642a",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\n        trie = {}\n        for word in wordDict:\n            node = trie\n            for char in word:\n                node = node.setdefault(char, {})\n            node[\"$\"] = word\n            \n        n = len(s)\n        \n        # Map to store results of subproblems (memoization)\n        dp = {}\n\n        # Define the recursive DFS function\n        def dfs(start_idx):\n            # If we have already computed this subproblem, return the result\n            if start_idx in dp:\n                return dp[start_idx]\n\n            # List to store valid sentences starting from start_idx\n            valid_sentences = []\n\n            # Base case: if we've reached the end of the string, return an empty list\n            if start_idx == len(s):\n                return [\"\"]\n\n            # Initialize current node to the root of the trie\n            current_node = trie\n\n            # Iterate from start_idx to the end of the string\n            for end_idx in range(start_idx, n):\n                char = s[end_idx]\n\n                # Check if the current character exists in the trie\n                if char not in current_node:\n                    break\n\n                # Move to the next node in the trie\n                current_node = current_node[char]\n\n                # Check if we have found a valid word\n                if \"$\" in current_node:\n                    current_word = current_node[\"$\"]\n\n                    # Recursively find valid sentences from the remaining substring\n                    sentences_from_next_index = dfs(end_idx + 1)\n                    for sentence in sentences_from_next_index:\n                        # If the sentence is empty, it means we've reached the end, so just add the current word\n                        if sentence == \"\":\n                            valid_sentences.append(current_word)\n                        else:\n                            valid_sentences.append(current_word + \" \" + sentence)\n\n            # Store the result for this subproblem\n            dp[start_idx] = valid_sentences\n            return valid_sentences\n\n        # Start the recursion from index 0\n        return dfs(0)\n\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        test_cases = [{'s': 'catsanddog', 'wordDict': ['cat', 'cats', 'and', 'sand', 'dog']}, {'s': 'pineapplepenapple', 'wordDict': ['apple', 'pen', 'applepen', 'pine', 'pineapple']}, {'s': 'catsandog', 'wordDict': ['cats', 'dog', 'sand', 'and', 'cat']}]\n        return random.choice(test_cases)\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['s']}|{'|'.join(input_obj['wordDict'])}\"\n\n    def encode_output(self, output_obj) -> str:\n        return '|'.join(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        s, *wordDict = input_str.split('|')\n        return {'s': s, 'wordDict': wordDict}\n\n    def decode_output(self, output_str) -> list:\n        return output_str.split('|')\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.wordBreak(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.056",
            "memory": 4896,
            "stderr": null,
            "token": "e62081d7-1fbf-4473-82f5-62b0417f642a",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 134,
        "title": "gas-station",
        "token": "2759d9a0-fce0-4b50-97ab-0033bdbfa65b",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\n        sum_cost = sum(cost)\n        sum_gas = sum(gas)\n        if sum_cost>sum_gas:\n            return -1\n\n        curr_gas = 0\n        start = 0\n\n        for i in range(len(gas)):\n            curr_gas += gas[i] - cost[i]\n            if curr_gas<0:\n                curr_gas = 0\n                start = i+1\n        return start\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 10)\n        gas = [random.randint(0, 10) for _ in range(n)]\n        cost = [random.randint(0, 10) for _ in range(n)]\n        return {'gas': gas, 'cost': cost}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['gas']}|{input_obj['cost']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        gas_str, cost_str = input_str.split('|')\n        gas = list(map(int, gas_str.strip('[]').split(', ')))\n        cost = list(map(int, cost_str.strip('[]').split(', ')))\n        return {'gas': gas, 'cost': cost}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.canCompleteCircuit(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.061",
            "memory": 4764,
            "stderr": null,
            "token": "2759d9a0-fce0-4b50-97ab-0033bdbfa65b",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 228,
        "title": "summary-ranges",
        "token": "794651dd-9deb-4f94-9687-263148db0e14",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def summaryRanges(self, nums: List[int]) -> List[str]:\n        out = []\n        start = 0\n        end = 0\n        if len(nums) == 0:\n            return out\n        while end < len(nums) - 1:\n            if nums[end+1] == nums[end] + 1:\n                end += 1\n            else:\n                if start == end:\n                    out.append(str(nums[start]))\n                else:\n                    out.append(str(nums[start]) + '->' + str(nums[end]))\n                end += 1\n                start = end\n        \n        if start == end:\n            out.append(str(nums[start]))\n        else:\n            out.append(str(nums[start]) + '->' + str(nums[end]))\n        \n        return out\n\n\n\n\n        \n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(0, 20)\n        nums = sorted(random.sample(range(-100, 100), length))\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'nums': eval(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.summaryRanges(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.068",
            "memory": 4936,
            "stderr": null,
            "token": "794651dd-9deb-4f94-9687-263148db0e14",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 229,
        "title": "majority-element-ii",
        "token": "eebff49d-db1b-4a9f-af58-f0886e78b303",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nfrom collections import defaultdict\nimport random\nimport json\n\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def majorityElement(self, nums: list[int]) -> list[int]:\n        # Create a Counter to store the count of each element\n        element_count = Counter(nums)\n        \n        majority_elements = []\n        threshold = len(nums) // 3\n        \n        # Iterate through the element count to identify majority elements\n        for element, count in element_count.items():\n            # Check if the element count is greater than the threshold\n            if count > threshold:\n                majority_elements.append(element)\n        \n        return majority_elements\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(1, 100)\n        nums = [random.randint(-10, 10) for _ in range(length)]\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return json.dumps(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return json.loads(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.majorityElement(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.069",
            "memory": 4784,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 51, in <module>\n    class Solution:\n  File \"script.py\", line 52, in Solution\n    def majorityElement(self, nums: list[int]) -> list[int]:\nTypeError: 'type' object is not subscriptable\n",
            "token": "eebff49d-db1b-4a9f-af58-f0886e78b303",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "success",
        "question_id": 230,
        "title": "kth-smallest-element-in-a-bst",
        "token": "4c1d6020-6506-4768-b6a0-d1f01bbfbf30",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import Optional\nimport json\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:\n        count = 0\n        curr = root\n        stack = []\n\n        while stack or curr:\n\n            while curr:\n                stack.append(curr)\n                curr = curr.left\n            \n            curr = stack.pop()\n            count += 1\n\n            if count == k:\n                return curr.val\n            \n            curr = curr.right\n\n        return -1\n\n        \n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        root = TreeNode(3)\n        root.left = TreeNode(1)\n        root.right = TreeNode(4)\n        root.left.right = TreeNode(2)\n        k = 1\n        return {'root': root, 'k': k}\n\n    def encode_input(self, input_obj) -> str:\n\n        def tree_to_list(node):\n            if not node:\n                return None\n            return [node.val, tree_to_list(node.left), tree_to_list(node.right)]\n        as_list = tree_to_list(input_obj['root'])\n        return json.dumps({'root': as_list, 'k': input_obj['k']})\n\n    def encode_output(self, output_obj) -> str:\n        return json.dumps({'output': output_obj})\n\n    def decode_input(self, input_str) -> dict:\n\n        def list_to_tree(lst):\n            if not lst:\n                return None\n            node = TreeNode(lst[0])\n            node.left = list_to_tree(lst[1])\n            node.right = list_to_tree(lst[2])\n            return node\n        data = json.loads(input_str)\n        return {'root': list_to_tree(data['root']), 'k': data['k']}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.kthSmallest(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.053",
            "memory": 4776,
            "stderr": null,
            "token": "4c1d6020-6506-4768-b6a0-d1f01bbfbf30",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 231,
        "title": "power-of-two",
        "token": "e7c746bb-3464-489c-b266-23f187a3cc15",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def isPowerOfTwo(self, n: int) -> bool:\n        while n > 1:\n            n /= 2\n        \n        return n == 1\n        \n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        \"\"\" Generate random test cases for `isPowerOfTwo` method. \"\"\"\n        n = random.choice([1, 2, 4, 8, 16, 32, 64, 3, 5, 7, 9, 0, -1])\n        return {'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\" Convert the generate method's output into a test input string. \"\"\"\n        return str(input_obj['n'])\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\" Convert the output of the entry_point method into a test output string. \"\"\"\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\" Convert a test input string back into a Python dict for use in the entry_point method. \"\"\"\n        return {'n': int(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.isPowerOfTwo(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Input {'n': 8}\nExpected Output:  8\nActual Output:  True\n1 Test Failed!\n",
            "time": "0.064",
            "memory": 4820,
            "stderr": null,
            "token": "e7c746bb-3464-489c-b266-23f187a3cc15",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 4,
                "description": "Wrong Answer"
            }
        }
    },
    {
        "status": "success",
        "question_id": 233,
        "title": "number-of-digit-one",
        "token": "b72507a3-42b4-4389-95fc-c30fd472d6c2",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def countDigitOne(self, n: int) -> int:\n        if n < 0:\n            return 0\n        \n        count = 0\n        factor = 1  # Start with the unit place\n        \n        while factor <= n:\n            lower_numbers = n - (n // factor) * factor\n            current_digit = (n // factor) % 10\n            higher_numbers = n // (factor * 10)\n            \n            if current_digit == 0:\n                count += higher_numbers * factor\n            elif current_digit == 1:\n                count += higher_numbers * factor + lower_numbers + 1\n            else:\n                count += (higher_numbers + 1) * factor\n            \n            factor *= 10\n        \n        return count\n\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        n = random.randint(0, 1000000)\n        return {'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['n'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'n': int(input_str)}\n\n    def decode_output(self, output_str) -> int:\n        return int(output_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.countDigitOne(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.053",
            "memory": 4804,
            "stderr": null,
            "token": "b72507a3-42b4-4389-95fc-c30fd472d6c2",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 123,
        "title": "best-time-to-buy-and-sell-stock-iii",
        "token": "e76e1a48-e1aa-42f8-bffa-0e7542b3d198",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        buy1 = float('inf')\n        buy2 = float('inf')\n        sell1 = 0\n        sell2 = 0\n        for price in prices:\n            if buy1 > price:\n                buy1 = price\n            if price - buy1 > sell1:\n                sell1 = price - buy1\n            if price - sell1 < buy2:\n                buy2 = price - sell1\n            if sell2 < price - buy2:\n                sell2 = price - buy2\n        return  sell2\n\nclass TestCaseGenerator:\n    import random\n\n    def generate(self) -> dict:\n        length = self.random.randint(1, 100)\n        prices = [self.random.randint(0, 100) for _ in range(length)]\n        return {'prices': prices}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.maxProfit(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.055",
            "memory": 5008,
            "stderr": null,
            "token": "e76e1a48-e1aa-42f8-bffa-0e7542b3d198",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 125,
        "title": "valid-palindrome",
        "token": "d93443f7-bd55-4bf8-80aa-e0c1afbc555c",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport json\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def isPalindrome(self, s: str) -> bool:\n        l, r = 0, len(s)-1\n        while l < r:\n            while l < r and not s[l].isalnum():\n                l += 1\n            while l <r and not s[r].isalnum():\n                r -= 1\n            if s[l].lower() != s[r].lower():\n                return False\n            l +=1; r -= 1\n        return True\n        \n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        \"\"\"Generate random test case input for isPalindrome function.\"\"\"\n        test_cases = ['A man, a plan, a canal: Panama', 'race a car', '', ' ', 'Able was I ere I saw Elba', '!!!abcba!!!', '12321', 'No lemon, no melon', 'Step on no pets']\n        return {'s': random.choice(test_cases)}\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\"Convert a test case input into a JSON string.\"\"\"\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\"Convert a test case output into a JSON string.\"\"\"\n        return 'true' if output_obj else 'false'\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\"Convert a test case input string into a Python dict.\"\"\"\n        return json.loads(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.isPalindrome(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.059",
            "memory": 4748,
            "stderr": null,
            "token": "d93443f7-bd55-4bf8-80aa-e0c1afbc555c",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 128,
        "title": "longest-consecutive-sequence",
        "token": "9c83dd0a-e71f-4968-937f-a2f6c001ee83",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\nimport json\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def longestConsecutive(self, nums: List[int]) -> int:\n        # max_length = 0\n        # if len(nums) == 0:\n        #     return max_length\n        # for n in set(nums):\n        #     if n - 1 not in set(nums):\n        #         length = 1\n        #         i = 0\n        #         while True:\n        #             i += 1\n        #             if n + i in set(nums):\n        #                 length += 1\n        #             else:\n        #                 if length > max_length:\n        #                     max_length = length\n        #                 break\n        #     else:\n        #         continue\n        # return max_length\n        \n        # # neetcode solution\n        # numSet = set(nums)\n        # longest = 0\n\n        # for n in nums:\n        #     if (n - 1) not in numSet:\n        #         length = 0 \n        #         while (n + length) in numSet:\n        #             length += 1\n        #         longest = max(length, longest)\n        # return longest        \n        # O(nLogn) solution \n        consecs = set()\n        if len(nums) == 0:\n            return 0\n        sorted_nums = sorted(set(nums))\n        length = 1\n        for i in range(len(sorted_nums) - 1):\n            if sorted_nums[i + 1] - sorted_nums[i] == 1:\n                length += 1\n            else:\n                consecs.add(length)\n                length = 1\n        consecs.add(length)\n        return max(consecs)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(0, 100)\n        nums = random.sample(range(-10 ** 9, 10 ** 9), length)\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return json.loads(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.longestConsecutive(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.059",
            "memory": 5008,
            "stderr": null,
            "token": "9c83dd0a-e71f-4968-937f-a2f6c001ee83",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 130,
        "title": "surrounded-regions",
        "token": "1b906dda-ffc4-48fb-92ad-c08d1e8528f4",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport collections\nimport random\nfrom typing import List\nfrom ast import literal_eval\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nfrom typing import List\n\nclass Solution:\n    def solve(self, board: List[List[str]]) -> None:\n        if not board or not board[0]:\n            return\n        \n        rows = len(board)\n        cols = len(board[0])\n        direction = [(1,0), (-1,0), (0,1), (0,-1)]\n\n        def bfs(r: int, c: int) -> None:\n            queue = [(r, c)]\n            board[r][c] = 'B'  \n            while queue:\n                x, y = queue.pop(0)\n                for d in direction:\n                    nx, ny = x + d[0], y + d[1]\n                    if 0 <= nx < rows and 0 <= ny < cols and board[nx][ny] == 'O':\n                        board[nx][ny] = 'B'\n                        queue.append((nx, ny))\n\n        for r in range(rows):\n            if board[r][0] == 'O':\n                bfs(r, 0)\n            if board[r][cols - 1] == 'O':\n                bfs(r, cols - 1)\n\n        for c in range(cols):\n            if board[0][c] == 'O':\n                bfs(0, c)\n            if board[rows - 1][c] == 'O':\n                bfs(rows - 1, c)\n\n        for r in range(rows):\n            for c in range(cols):\n                if board[r][c] == 'B':\n                    board[r][c] = 'O'\n                elif board[r][c] == 'O':\n                    board[r][c] = 'X'\n\n\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        ...\n\n    def encode_input(self, input_obj) -> str:\n        ...\n\n    def encode_output(self, output_obj) -> str:\n        ...\n\n    def decode_input(self, input_str) -> dict:\n        ...\n\n    def decode_output(self, output_str) -> str:\n        ...\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.solve(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.05",
            "memory": 5120,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 140, in <module>\n    runner.run()\n  File \"script.py\", line 124, in run\n    output = self.solution.solve(**input)\nTypeError: solve() argument after ** must be a mapping, not NoneType\n",
            "token": "1b906dda-ffc4-48fb-92ad-c08d1e8528f4",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "success",
        "question_id": 82,
        "title": "remove-duplicates-from-sorted-list-ii",
        "token": "6a17f52b-ebcf-4b8a-b79c-dec46d66b6bd",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import Optional\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        h=head\n        p=ListNode(-1)\n        p.next=head\n        b=p\n        f=defaultdict(int)\n        while h and h.next:\n            if h.val!=h.next.val:\n                p=p.next\n                h=h.next\n            else:\n                c=h.val\n                while c==h.val:\n                    h=h.next\n                    if h==None:\n                        break\n                p.next=h\n\n\n        return b.next\n            \n        \n                \n\n\n            \n\n\n        \n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        list_values = self._create_random_sorted_list()\n        head = self._convert_list_to_linkedlist(list_values)\n        return {'head': head}\n\n    def encode_input(self, input_obj) -> str:\n        encoded_input = []\n        current = input_obj['head']\n        while current:\n            encoded_input.append(current.val)\n            current = current.next\n        return str(encoded_input)\n\n    def encode_output(self, output_obj) -> str:\n        encoded_output = []\n        current = output_obj\n        while current:\n            encoded_output.append(current.val)\n            current = current.next\n        return str(encoded_output)\n\n    def decode_input(self, input_str) -> dict:\n        node_values = eval(input_str)\n        head = self._convert_list_to_linkedlist(node_values)\n        return {'head': head}\n\n    def _create_random_sorted_list(self) -> list:\n        list_size = random.randint(0, 30)\n        values = []\n        while len(values) < list_size:\n            rand_value = random.randint(-100, 100)\n            if random.choice([True, False]):\n                values += [rand_value] * random.randint(1, 3)\n            else:\n                values.append(rand_value)\n        values = sorted(values[:300])\n        return values\n\n    def _convert_list_to_linkedlist(self, values: list) -> Optional[ListNode]:\n        if not values:\n            return None\n        head = ListNode(values[0])\n        current = head\n        for value in values[1:]:\n            current.next = ListNode(value)\n            current = current.next\n        return head\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.deleteDuplicates(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.053",
            "memory": 4956,
            "stderr": null,
            "token": "6a17f52b-ebcf-4b8a-b79c-dec46d66b6bd",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 84,
        "title": "largest-rectangle-in-histogram",
        "token": "87a7acea-c403-4ec8-ba7d-f61472b7d9da",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\n# class Solution:\n#     def largestRectangleArea(self, heights: List[int]) -> int:\n#         stack=[-1]\n#         themax=0\n#         heights.append(0)\n#         for i in range(len(heights)):\n\n#             while(heights[i]<heights[stack[-1]]):\n#                 width=i-1-stack[-2]\n#                 height=heights[stack[-1]]\n#                 themax=max(width*height,themax)\n#                 stack.pop()\n#             stack.append(i)\n#         return themax\n\n\nclass Solution:\n    def largestRectangleArea(self, heights: List[int]) -> int:\n        lis=[-1]\n\n        themax=0\n        heights.append(-1)\n        for i in range(len(heights)):\n            if heights[i]!=heights[i-1]:\n                lis.append(i-1)\n                while heights[i]<heights[lis[-1]]:\n                    pop=lis.pop()\n                    if (i-lis[-1]-1)*heights[pop]>themax:\n                        themax=(i-lis[-1]-1)*heights[pop]\n                    \n\n        return themax\n\n\n\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        num_bars = random.randint(1, 10)\n        heights = [random.randint(0, 10) for _ in range(num_bars)]\n        return {'heights': heights}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['heights'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        heights = eval(input_str)\n        return {'heights': heights}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.largestRectangleArea(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.046",
            "memory": 5308,
            "stderr": null,
            "token": "87a7acea-c403-4ec8-ba7d-f61472b7d9da",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 85,
        "title": "maximal-rectangle",
        "token": "86947532-c8ce-4f8b-80a6-53dbf25e4246",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\n        if not matrix or not matrix[0]:\n            return 0\n    \n        # Initialize the histogram heights\n        num_cols = len(matrix[0])\n        heights = [0] * num_cols\n        max_area = 0\n\n        def largestRectangleArea(heights):\n            max_area = 0\n            stack = []\n\n            for i, h in enumerate(heights):\n                s = i\n                while stack and stack[-1][1] > h:\n                    index, height = stack.pop()\n                    max_area = max(max_area, height * (i - index))\n                    s = index\n                stack.append((s, h))\n\n            for i, h in stack:\n                max_area = max(max_area, h * (len(heights) - i))\n\n            return max_area\n\n    \n        for row in matrix:\n            for i in range(num_cols):\n                if row[i] == '1':\n                    heights[i] += 1\n                else:\n                    heights[i] = 0\n\n            max_area = max(max_area, largestRectangleArea(heights))\n    \n        return max_area\n\n\n        \n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        rows = random.randint(1, 20)\n        cols = random.randint(1, 20)\n        matrix = [[random.choice(['0', '1']) for _ in range(cols)] for _ in range(rows)]\n        return {'matrix': matrix}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['matrix'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        input_list = eval(input_str)\n        return {'matrix': input_list}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.maximalRectangle(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.065",
            "memory": 7260,
            "stderr": null,
            "token": "86947532-c8ce-4f8b-80a6-53dbf25e4246",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 87,
        "title": "scramble-string",
        "token": "415b6b30-8be3-4da8-820d-450d1b078ebe",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport numpy as np\nimport random\nimport string\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    # dictionary to store previously computed substrings\n    map = {}\n\n    def isScramble(self, s1: str, s2: str) -> bool:\n        n = len(s1)\n        # check if the two strings are equal\n        if s1 == s2:\n            return True\n        # initialize frequency lists for s1, s2, and current substring\n        a, b, c = [0] * 26, [0] * 26, [0] * 26\n        # check if the current substring has already been computed\n        if (s1 + s2) in self.map:\n            return self.map[s1 + s2]\n        # check all possible splits of the two strings\n        for i in range(1, n):\n            j = n - i\n            # update frequency lists for s1, s2, and current substring\n            a[ord(s1[i - 1]) - ord('a')] += 1\n            b[ord(s2[i - 1]) - ord('a')] += 1\n            c[ord(s2[j]) - ord('a')] += 1\n            # check if the current substring has the same characters\n            if a == b and self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\n                # if the substrings are scrambled versions of each other, return True\n                self.map[s1 + s2] = True\n                return True\n            # check if the current substring and its complement have the same characters\n            if a == c and self.isScramble(s1[:i], s2[j:]) and self.isScramble(s1[i:], s2[:j]):\n                # if the substrings are scrambled versions of each other, return True\n                self.map[s1 + s2] = True\n                return True\n        # if none of the splits result in scrambled versions, return False\n        self.map[s1 + s2] = False\n        return False\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(1, 30)\n        s1 = ''.join(random.choices(string.ascii_lowercase, k=length))\n        s2 = self.scramble(s1)\n        return {'s1': s1, 's2': s2}\n\n    def scramble(self, s: str) -> str:\n        if len(s) == 1:\n            return s\n        i = random.randint(1, len(s) - 1)\n        x, y = (s[:i], s[i:])\n        if random.random() > 0.5:\n            return self.scramble(x) + self.scramble(y)\n        else:\n            return self.scramble(y) + self.scramble(x)\n\n    def encode_input(self, input_obj: dict) -> str:\n        return f\"{input_obj['s1']},{input_obj['s2']}\"\n\n    def encode_output(self, output_obj: bool) -> str:\n        return 'true' if output_obj else 'false'\n\n    def decode_input(self, input_str: str) -> dict:\n        s1, s2 = input_str.split(',')\n        return {'s1': s1, 's2': s2}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.isScramble(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.06",
            "memory": 4600,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 26, in <module>\n    import numpy as np\nModuleNotFoundError: No module named 'numpy'\n",
            "token": "415b6b30-8be3-4da8-820d-450d1b078ebe",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "success",
        "question_id": 88,
        "title": "merge-sorted-array",
        "token": "a7e04f7b-a809-4ee8-8947-7aa0fbd5f497",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\nimport ast\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\n        \"\"\"\n        Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        n1, n2, i = m-1, n-1, m+n-1\n        while n2 >= 0:\n            if n1 >=0 and nums1[n1] > nums2[n2]:\n                nums1[i] = nums1[n1]\n                n1 -= 1\n            else:\n                nums1[i] = nums2[n2]\n                n2 -= 1\n            i -= 1\n        \n        \n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        test_cases = [{'nums1': [1, 2, 3, 0, 0, 0], 'm': 3, 'nums2': [2, 5, 6], 'n': 3}, {'nums1': [4, 5, 6, 0, 0, 0], 'm': 3, 'nums2': [1, 2, 3], 'n': 3}, {'nums1': [1], 'm': 1, 'nums2': [], 'n': 0}, {'nums1': [0], 'm': 0, 'nums2': [1], 'n': 1}, {'nums1': [1, 2, 4, 5, 6, 0, 0, 0], 'm': 5, 'nums2': [3, 7, 8], 'n': 3}]\n        return random.choice(test_cases)\n\n    def encode_input(self, input_obj) -> str:\n        return f'{input_obj}'\n\n    def encode_output(self, output_obj) -> str:\n        return f'{output_obj}'\n\n    def decode_input(self, input_str) -> dict:\n        return ast.literal_eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.merge(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.077",
            "memory": 5584,
            "stderr": null,
            "token": "a7e04f7b-a809-4ee8-8947-7aa0fbd5f497",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 89,
        "title": "gray-code",
        "token": "8b06beb7-c0b0-4569-8730-ea4170aa34ab",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def grayCode(self, n: int) -> List[int]:\n        res = []\n        for i in range(2**n):\n            res.append(i ^ i >> 1)\n        return res\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 16)\n        return {'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"n = {input_obj['n']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return f'{output_obj}'\n\n    def decode_input(self, input_str) -> dict:\n        lines = input_str.split(' = ')\n        return {'n': int(lines[1])}\n\n    def decode_output(self, output_str) -> dict:\n        output_obj = eval(output_str)\n        return output_obj\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.grayCode(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.11",
            "memory": 16072,
            "stderr": null,
            "token": "8b06beb7-c0b0-4569-8730-ea4170aa34ab",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 90,
        "title": "subsets-ii",
        "token": "c49624e7-7026-46c4-b0d7-5fd599341413",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\n        res = [[]]\n        nums.sort()\n        memory = {i: 0 for i in set(nums)}\n        \n        for num in nums:\n            end = len(res)\n            for s in res[memory[num] : end]: \n                res.append(s + [num])\n            memory[num] = end\n        \n        return res\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(1, 10)\n        nums = [random.randint(-10, 10) for _ in range(length)]\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.subsetsWithDup(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.085",
            "memory": 6516,
            "stderr": null,
            "token": "c49624e7-7026-46c4-b0d7-5fd599341413",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 144,
        "title": "binary-tree-preorder-traversal",
        "token": "2d3d6977-208c-43bb-9be7-837a1ee207ef",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List, Optional, Union\nimport random\n\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        if not root:\n            return []\n        stack = [root]\n        result=[]\n        while stack:\n            node=stack.pop()\n            result.append(node.val)\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n        return result\n\n\nclass TestCaseGenerator:\n\n    class TreeNode:\n\n        def __init__(self, val=0, left=None, right=None):\n            self.val = val\n            self.left = left\n            self.right = right\n\n    def generate(self) -> dict:\n\n        def generate_random_tree(size=100):\n            if size == 0:\n                return None\n            nodes = [self.TreeNode(val=random.randint(-100, 100)) for _ in range(size)]\n            for i in range(size):\n                if 2 * i + 1 < size:\n                    nodes[i].left = nodes[2 * i + 1]\n                if 2 * i + 2 < size:\n                    nodes[i].right = nodes[2 * i + 2]\n            return nodes[0] if size > 0 else None\n        tree_size = random.randint(0, 10)\n        root = generate_random_tree(tree_size)\n        return {'root': root}\n\n    def encode_input(self, input_obj: dict) -> str:\n\n        def tree_to_list(root):\n            if not root:\n                return []\n            queue = [(root, 0)]\n            result = []\n            while queue:\n                node, index = queue.pop(0)\n                if node:\n                    if index >= len(result):\n                        result.extend([None] * (index - len(result) + 1))\n                    result[index] = node.val\n                    queue.append((node.left, 2 * index + 1))\n                    queue.append((node.right, 2 * index + 2))\n            while result and result[-1] is None:\n                result.pop()\n            return result\n        root = input_obj['root']\n        return str(tree_to_list(root))\n\n    def encode_output(self, output_obj: List[int]) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str: str) -> dict:\n\n        def list_to_tree(nodes: List[Union[int, None]]):\n            if not nodes:\n                return None\n            tree_nodes = [self.TreeNode(val=v) if v is not None else None for v in nodes]\n            for i in range(len(nodes)):\n                if tree_nodes[i] is not None:\n                    left_index = 2 * i + 1\n                    right_index = 2 * i + 2\n                    if left_index < len(tree_nodes):\n                        tree_nodes[i].left = tree_nodes[left_index]\n                    if right_index < len(tree_nodes):\n                        tree_nodes[i].right = tree_nodes[right_index]\n            return tree_nodes[0] if tree_nodes else None\n        nodes_list = eval(input_str)\n        root = list_to_tree(nodes_list)\n        return {'root': root}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.preorderTraversal(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.076",
            "memory": 5232,
            "stderr": null,
            "token": "2d3d6977-208c-43bb-9be7-837a1ee207ef",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 148,
        "title": "sort-list",
        "token": "e05706db-079f-45a6-88ac-422f89672f1a",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import Optional\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        curr = head\n        l =[]\n        while curr:\n            l.append(curr.val)\n            curr = curr.next\n        l.sort()\n        curr = head\n        for i in l:\n            curr.val = i\n            curr = curr.next\n        return head\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        ...\n\n    def encode_input(self, input_obj) -> str:\n        ...\n\n    def encode_output(self, output_obj) -> str:\n        ...\n\n    def decode_input(self, input_str) -> dict:\n        ...\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.sortList(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.065",
            "memory": 4872,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 106, in <module>\n    runner.run()\n  File \"script.py\", line 90, in run\n    output = self.solution.sortList(**input)\nTypeError: sortList() argument after ** must be a mapping, not NoneType\n",
            "token": "e05706db-079f-45a6-88ac-422f89672f1a",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "success",
        "question_id": 149,
        "title": "max-points-on-a-line",
        "token": "949fa0c5-355f-48f4-a561-e01c1500893f",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nfrom collections import defaultdict\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def maxPoints(self, points: List[List[int]]) -> int:\n        n = len(points) #amount of point\n        maxP = 0 # current max points - initalize variable\n\n        for i in range(n):\n            X = points[i][0]\n            Y = points[i][1]\n            map = {} # create temperory dict for story points\n\n            for j in range(i+1, n):\n                dx = points[j][0] - X\n                dy = points[j][1] - Y # change in x and y pos\n\n                if(dx != 0): \n                    d = dy/dx\n                    if d in map:\n                        map[d] = map[d] + 1\n                    else:\n                        map[d] = 1 \n                else:\n                    if 20001.0 in map:\n                        map[20001.0] = map[20001.0] + 1\n                    else:\n                        map[20001.0] = 1 # test case put here since I cant solve\n\n            if map:\n                maxP = max(maxP, max(map.values())) # return longest one by sorting it and get the max - since you have to get the value (sort by value), I don't know how to do max() with it\n\n        return maxP + 1\n        \n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        simple_line = [[1, 1], [2, 2], [3, 3]]\n        mixed_points = [[1, 1], [3, 2], [5, 3], [4, 1], [2, 3], [1, 4]]\n        single_point = [[0, 0]]\n        return {'points': simple_line}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['points'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'points': eval(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.maxPoints(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.062",
            "memory": 4756,
            "stderr": null,
            "token": "949fa0c5-355f-48f4-a561-e01c1500893f",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 150,
        "title": "evaluate-reverse-polish-notation",
        "token": "bf3dbce7-b664-4a69-85d3-5d6f27ef448b",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport operator as op\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def evalRPN(self, tokens: List[str]) -> int:\n        stack = []\n        for token in tokens:\n            if token not in [\"+\",\"-\",\"*\",\"/\"]:\n                stack.append(int(token))\n            elif token == '+':\n                b = int(stack.pop())\n                a = int(stack.pop())\n                \n                stack.append(int(a + b))\n            elif token == '-':\n                b = int(stack.pop())\n                a = int(stack.pop())\n                \n                stack.append(int(a - b))\n            elif token == '/':\n                b = int(stack.pop())\n                a = int(stack.pop())\n                \n                stack.append(int(a / b))\n            else:\n                b = int(stack.pop())\n                a = int(stack.pop())\n                \n                stack.append(int(a * b))\n          \n        return stack[0]\n\n\n\n\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        operators = ['+', '-', '*', '/']\n        expressions = [('2', '1', '+', '3', '*'), ('4', '13', '5', '/', '+'), ('10', '6', '9', '3', '+', '-11', '*', '/', '*', '17', '+', '5', '+')]\n        selected_expr = random.choice(expressions)\n        return {'tokens': list(selected_expr)}\n\n    def encode_input(self, input_obj) -> str:\n        return ','.join(input_obj['tokens'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        tokens = input_str.split(',')\n        return {'tokens': tokens}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.evalRPN(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.065",
            "memory": 4784,
            "stderr": null,
            "token": "bf3dbce7-b664-4a69-85d3-5d6f27ef448b",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 153,
        "title": "find-minimum-in-rotated-sorted-array",
        "token": "17f692b7-ad6e-4664-9a1c-c248311f9241",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom random import randint, shuffle\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def findMin(self, nums: List[int]) -> int:\n        left, right = 0, len(nums) - 1\n        res = nums[0]\n        while left <= right:\n            mid = (left + right) // 2\n            res = min(res, nums[mid])\n            if nums[mid] >= nums[left]:\n                if nums[mid] > nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            else:\n                right = mid - 1\n        return res\n\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = randint(2, 100)\n        sorted_array = sorted((randint(-5000, 5000) for _ in range(n)))\n        k = randint(1, n)\n        rotated_array = sorted_array[-k:] + sorted_array[:-k]\n        return {'nums': rotated_array}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'nums': eval(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.findMin(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.067",
            "memory": 5044,
            "stderr": null,
            "token": "17f692b7-ad6e-4664-9a1c-c248311f9241",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 160,
        "title": "intersection-of-two-linked-lists",
        "token": "a780d822-2820-4885-86b5-31f0f1d48be4",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import Optional\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        h1 = headA\n        h2 = headB\n        while h1 != h2:\n            h1 = h1.next if h1 else headB\n            h2 = h2.next if h2 else headA\n        return h1\n            \n\n\n \n            \n\n        \n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        \"\"\"\n        Generates a test case with an intersection in the linked list.\n        Returns a dictionary containing two linked list heads: headA and headB.\n        \"\"\"\n        common = ListNode(8)\n        common.next = ListNode(4)\n        common.next.next = ListNode(5)\n        listA = ListNode(4)\n        listA.next = ListNode(1)\n        listA.next.next = common\n        listB = ListNode(5)\n        listB.next = ListNode(6)\n        listB.next.next = ListNode(1)\n        listB.next.next.next = common\n        headA = listA\n        headB = listB\n        return {'headA': headA, 'headB': headB}\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\"\n        Encodes the length of both linked lists into a string.\n        \"\"\"\n        lengthA, lengthB = (0, 0)\n        currentA, currentB = (input_obj['headA'], input_obj['headB'])\n        while currentA:\n            lengthA += 1\n            currentA = currentA.next\n        while currentB:\n            lengthB += 1\n            currentB = currentB.next\n        return f'LENGTHS: A={lengthA}, B={lengthB}'\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\"\n        Returns the value of the intersecting node, or \"No Intersection\" if there isn\u2019t one.\n        \"\"\"\n        if output_obj:\n            return str(output_obj.val)\n        return 'No Intersection'\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\"\n        Decodes input (statically in our case) to provide test case linked lists.\n        \"\"\"\n        example_listA = [4, 1, 8, 4, 5]\n        example_listB = [5, 6, 1, 8, 4, 5]\n        headA, headB = (self._create_linked_list(example_listA), self._create_linked_list(example_listB))\n        return {'headA': headA, 'headB': headB}\n\n    def _create_linked_list(self, values):\n        \"\"\"\n        Helper method to create a linked list from a list of values.\n        \"\"\"\n        if not values:\n            return None\n        head = ListNode(values[0])\n        current = head\n        for val in values[1:]:\n            current.next = ListNode(val)\n            current = current.next\n        return head\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.getIntersectionNode(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.066",
            "memory": 4708,
            "stderr": null,
            "token": "a780d822-2820-4885-86b5-31f0f1d48be4",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 238,
        "title": "product-of-array-except-self",
        "token": "91104b8e-114f-43d2-a3d2-a952dabfe746",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nfrom random import randint\nimport ast\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        out = [1] * len(nums)\n\n        pre =1 \n        for i in range(len(nums)):\n            out[i] = pre\n            pre*=nums[i]\n        post = 1\n        for i in range(len(nums)-1,-1,-1):\n            out[i] *=post\n            post*=nums[i]\n        return out \n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = randint(2, 10)\n        nums = [randint(-30, 30) for _ in range(length)]\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return ast.literal_eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.productExceptSelf(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.068",
            "memory": 5212,
            "stderr": null,
            "token": "91104b8e-114f-43d2-a3d2-a952dabfe746",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 239,
        "title": "sliding-window-maximum",
        "token": "c21e3f77-f39d-439b-b682-8b3a1289d277",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport heapq\nimport random\nimport json\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        \n        window = deque([])\n        result = []\n\n        for i in range(k):\n            while window and nums[i] > window[-1]:\n                window.pop()\n            window.append(nums[i])\n        \n        result.append(window[0])\n\n        for i in range(k,len(nums)):\n            while window and nums[i] > window[-1]:\n                window.pop()\n            window.append(nums[i])\n\n            if nums[i-k] == window[0]:\n                window.popleft()\n            \n            result.append(window[0])\n        \n        return result\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 100)\n        nums = [random.randint(-10000, 10000) for _ in range(n)]\n        k = random.randint(1, n)\n        return {'nums': nums, 'k': k}\n\n    def encode_input(self, input_obj: dict) -> str:\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj: list) -> str:\n        return json.dumps(output_obj)\n\n    def decode_input(self, input_str: str) -> dict:\n        return json.loads(input_str)\n\n    def decode_output(self, output_str: str) -> list:\n        return json.loads(output_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.maxSlidingWindow(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.063",
            "memory": 5028,
            "stderr": null,
            "token": "c21e3f77-f39d-439b-b682-8b3a1289d277",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 241,
        "title": "different-ways-to-add-parentheses",
        "token": "ddbdeda3-6f3d-424d-9d32-8a383b7ea87f",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport functools\nimport random\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def diffWaysToCompute(self, expression: str) -> List[int]:\n\n        @cache\n        def dfs(expr):\n            if len(expr) == 0:\n                return []\n            \n            if expr.isnumeric():\n                return [int(expr)]\n\n            result = []\n            for i, c in enumerate(expr):\n                if c.isdigit():\n                    continue\n                left_result = dfs(expr[:i])\n                right_result = dfs(expr[i+1:])\n\n                for lr in left_result:\n                    for rl in right_result:\n                        match c:\n                            case '+':\n                                result.append(lr + rl)\n                            case '-':\n                                result.append(lr - rl)\n                            case '*':\n                                result.append(lr * rl)\n\n            return result\n        \n        return dfs(expression)\n\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        operators = ['+', '-', '*']\n        num_parts = random.randint(2, 5)\n        expression = str(random.randint(0, 99))\n        for _ in range(num_parts - 1):\n            operator = random.choice(operators)\n            number = random.randint(0, 99)\n            expression += operator + str(number)\n        return {'expression': expression}\n\n    def encode_input(self, input_obj: dict) -> str:\n        return input_obj['expression']\n\n    def encode_output(self, output_obj: List[int]) -> str:\n        return ','.join(map(str, output_obj))\n\n    def decode_input(self, input_str: str) -> dict:\n        return {'expression': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.diffWaysToCompute(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.027",
            "memory": 3192,
            "stderr": "  File \"script.py\", line 69\n    match c:\n          ^\nSyntaxError: invalid syntax\n",
            "token": "ddbdeda3-6f3d-424d-9d32-8a383b7ea87f",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "success",
        "question_id": 242,
        "title": "valid-anagram",
        "token": "779ff368-c980-493b-9ce9-8eec8391080d",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nfrom collections import Counter\n\nclass Solution:\n    def isAnagram(self, s: str, t: str) -> bool:\n        if len(s) != len(t):\n            return False\n        s_count = Counter(s)\n        t_count = Counter(t)\n\n        for i,j in s_count.items():\n            if t_count.get(i, -1) != j:\n                return False\n        return True\n            \n        \n\nclass TestCaseGenerator:\n\n    def __init__(self):\n        self.examples = [{'s': 'anagram', 't': 'nagaram'}, {'s': 'rat', 't': 'car'}, {'s': 'listen', 't': 'silent'}, {'s': 'hello', 't': 'bello'}, {'s': 'debitcard', 't': 'badcredit'}]\n\n    def generate(self) -> dict:\n        return random.choice(self.examples)\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['s']},{input_obj['t']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj).lower()\n\n    def decode_input(self, input_str) -> dict:\n        s, t = input_str.split(',')\n        return {'s': s, 't': t}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.isAnagram(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.053",
            "memory": 4856,
            "stderr": null,
            "token": "779ff368-c980-493b-9ce9-8eec8391080d",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 31,
        "title": "next-permutation",
        "token": "7e53dadf-04ad-472d-ade9-bebf18f72a36",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def nextPermutation(self, nums: List[int]) -> None:\n        length = len(nums) \n        pivot = -1\n        for i in range(length - 2, -1, -1):\n            if nums[i] < nums[i + 1]:\n                pivot = i\n                break\n        if pivot != -1:\n            for j in range(length - 1, pivot, -1):\n                if nums[j] > nums[pivot]:\n                    nums[pivot], nums[j] = nums[j], nums[pivot]\n                    break\n        nums[pivot + 1:] = reversed(nums[pivot + 1:])\n\nclass TestCaseGenerator:\n\n    def __init__(self):\n        self.sample = random.sample\n        self.randint = random.randint\n\n    def generate(self) -> dict:\n        length = self.randint(1, 10)\n        nums = self.sample(range(0, 101), length)\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'nums': list(map(int, input_str.strip('[]').split(',')))}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.nextPermutation(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.051",
            "memory": 4796,
            "stderr": null,
            "token": "7e53dadf-04ad-472d-ade9-bebf18f72a36",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 32,
        "title": "longest-valid-parentheses",
        "token": "052c67de-1524-4aca-8cdf-0d291f22a31f",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def longestValidParentheses(self, s: str) -> int:\n        stack = [-1]\n        max_len = 0\n        \n        for i, char in enumerate(s):\n            if char == '(':\n                stack.append(i)\n            else:\n                stack.pop()\n                if not stack:\n                    stack.append(i)\n                else:\n                    max_len = max(max_len, i - stack[-1])\n        \n        return max_len\n\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        length = random.randint(0, 20)\n        parentheses = [random.choice(['(', ')']) for _ in range(length)]\n        return {'s': ''.join(parentheses)}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['s']\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.longestValidParentheses(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.054",
            "memory": 4804,
            "stderr": null,
            "token": "052c67de-1524-4aca-8cdf-0d291f22a31f",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 33,
        "title": "search-in-rotated-sorted-array",
        "token": "d219f110-3310-4d2a-9d7c-8e9dcbad25cb",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def condition(self, nums: List[int], target: int, mid: int, left:int , right:int ):\n        if nums[left]<= nums[mid]:\n            if nums[left] <= target < nums[mid]:\n                return True\n            else:\n                return False\n        else:\n            if nums[mid] < target <= nums[right]:\n                return False\n            else:\n                return True\n    def search(self, nums: List[int], target: int) -> int:\n        left, right = 0, len(nums) - 1\n        while left <= right:  \n            mid = left + (right - left) // 2\n            if nums[mid] == target:\n                return mid\n            elif self.condition(nums, target, mid, left, right):\n                right = mid - 1  \n            else:\n                left = mid + 1 \n        return -1\n\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 20)\n        array = sorted(random.sample(range(-50, 50), n))\n        k = random.randint(0, n - 1)\n        rotated_array = array[k:] + array[:k]\n        target = random.choice(rotated_array + [101])\n        return {'nums': rotated_array, 'target': target}\n\n    def encode_input(self, input_obj) -> str:\n        nums_str = ','.join(map(str, input_obj['nums']))\n        target_str = str(input_obj['target'])\n        return f'nums=[{nums_str}], target={target_str}'\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        input_str = input_str.strip()\n        nums_part = input_str.split('target=')[0].strip()\n        target_part = input_str.split('target=')[1].strip()\n        nums = list(map(int, nums_part[nums_part.index('[') + 1:nums_part.rindex(']')].split(',')))\n        target = int(target_part)\n        return {'nums': nums, 'target': target}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.search(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.057",
            "memory": 4864,
            "stderr": null,
            "token": "d219f110-3310-4d2a-9d7c-8e9dcbad25cb",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 34,
        "title": "find-first-and-last-position-of-element-in-sorted-array",
        "token": "a95f22fc-c0ce-46d7-9d93-4b87bccde2bd",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\n        if not nums:\n            return [-1, -1]\n        left, right = 0, len(nums)-1\n        # find st\n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] < target:\n                left = mid+1\n            elif nums[mid] > target:\n                right = mid-1\n            else:\n                right = mid\n\n        if left <0 or left >= len(nums) or nums[left] != target:\n            st = -1\n        else:\n            st = left\n\n        # find ed\n        left, right = 0, len(nums)-1\n        while left < right:\n            mid = ceil((left + right) / 2 )\n            if nums[mid] < target:\n                left = mid+1\n            elif nums[mid] > target:\n                right = mid-1\n            else:\n                left = mid\n        if left <0 or left >= len(nums) or nums[left] != target:\n            ed = -1\n        else:\n            ed = left\n        return [st, ed]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        test_cases = [{'nums': [5, 7, 7, 8, 8, 10], 'target': 8}, {'nums': [5, 7, 7, 8, 8, 10], 'target': 6}, {'nums': [], 'target': 0}, {'nums': [2, 2, 2, 2, 2], 'target': 2}, {'nums': [1, 3, 5, 6, 8, 10], 'target': 7}]\n        return random.choice(test_cases)\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['nums']}|{input_obj['target']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        nums_str, target_str = input_str.split('|')\n        nums = list(map(int, nums_str.strip('[]').split(','))) if nums_str.strip('[]') else []\n        target = int(target_str)\n        return {'nums': nums, 'target': target}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.searchRange(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.062",
            "memory": 4816,
            "stderr": null,
            "token": "a95f22fc-c0ce-46d7-9d93-4b87bccde2bd",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 191,
        "title": "number-of-1-bits",
        "token": "8ca3466f-33f8-4fae-8cc1-f695aad5425e",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport json\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def hammingWeight(self, n: int) -> int:\n        n_bin = str(bin(n))\n        count = 0\n        for i in n_bin:\n            if i == \"1\":\n                count += 1\n        return count\n\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 2 ** 20)\n        return {'n': n}\n\n    def encode_input(self, input_obj: dict) -> str:\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj: int) -> str:\n        return json.dumps({'result': output_obj})\n\n    def decode_input(self, input_str: str) -> dict:\n        return json.loads(input_str)\n\n    def decode_output(self, output_str: str) -> int:\n        return json.loads(output_str)['result']\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.hammingWeight(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.068",
            "memory": 4772,
            "stderr": null,
            "token": "8ca3466f-33f8-4fae-8cc1-f695aad5425e",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 198,
        "title": "house-robber",
        "token": "19e4d037-f149-4929-907b-c51d5080a751",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def rob(self, nums: List[int]) -> int:\n\n        def house(i,nums, dp):\n            if i == 0:\n                return nums[0]\n            if i == 1:\n                return max(nums[0], nums[1])\n            if dp[i] != -1:\n                return dp[i]                \n\n            s1 = nums[i] + house(i-2, nums, dp)\n            s2 = house(i-1, nums, dp)\n            dp[i] = max(s1,s2)\n\n            return dp[i]\n        n = len(nums)\n        dp = [-1]*n\n        return house(len(nums)-1, nums, dp)\n        \n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(2, 20)\n        nums = [random.randint(0, 400) for _ in range(length)]\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        nums = eval(input_str)\n        return {'nums': nums}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.rob(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.065",
            "memory": 4900,
            "stderr": null,
            "token": "19e4d037-f149-4929-907b-c51d5080a751",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "failure",
        "question_id": 199,
        "title": "binary-tree-right-side-view",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "success",
        "question_id": 201,
        "title": "bitwise-and-of-numbers-range",
        "token": "e8ef0b5c-18e4-43a0-8db2-9f51eb484fbd",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def rangeBitwiseAnd(self, left: int, right: int) -> int:\n        shift = 0\n        while left < right:\n            left >>= 1\n            right >>= 1\n            shift += 1\n        \n        return left << shift\n\nclass TestCaseGenerator:\n\n    @staticmethod\n    def generate() -> dict:\n        left = random.randint(0, 10000)\n        right = random.randint(left, left + random.randint(0, 10000))\n        return {'left': left, 'right': right}\n\n    @staticmethod\n    def encode_input(input_obj) -> str:\n        return f\"{input_obj['left']},{input_obj['right']}\"\n\n    @staticmethod\n    def encode_output(output_obj) -> str:\n        return str(output_obj)\n\n    @staticmethod\n    def decode_input(input_str) -> dict:\n        left, right = map(int, input_str.split(','))\n        return {'left': left, 'right': right}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.rangeBitwiseAnd(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.059",
            "memory": 4728,
            "stderr": null,
            "token": "e8ef0b5c-18e4-43a0-8db2-9f51eb484fbd",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 202,
        "title": "happy-number",
        "token": "42045cbf-ce8c-4491-976c-c6ec1188250b",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def getSquare(self, n):\n        currentSum = 0\n        while (n != 0):\n            remain = n % 10\n            currentSum += remain * remain\n            n = n // 10\n        return currentSum\n\n    def isHappy(self, n: int) -> bool:\n        slow = self.getSquare(n)\n        fast = self.getSquare(self.getSquare(n))\n\n        while (fast != slow) and (fast != 1):\n            slow = self.getSquare(slow)\n            fast = self.getSquare(self.getSquare(fast))\n\n        return (fast == 1)\n        \n            \n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        return {'n': random.randint(1, 100)}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['n'])\n\n    def encode_output(self, output_obj) -> str:\n        return 'true' if output_obj else 'false'\n\n    def decode_input(self, input_str) -> dict:\n        return {'n': int(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.isHappy(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.048",
            "memory": 4756,
            "stderr": null,
            "token": "42045cbf-ce8c-4491-976c-c6ec1188250b",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 204,
        "title": "count-primes",
        "token": "e9f0111d-1d41-49f5-9c78-516844e50804",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def countPrimes(self, n: int) -> int:\n        if (n < 3):\n            return 0\n        elif (n == 3):\n            return 1\n        elif (n <= 5):\n            return 2\n        elif (n <= 7):\n            return 3\n        elif (n <= 11):\n            return 4\n        elif (n <= 13):\n            return 5\n        elif (n <= 17):\n            return 6\n        elif (n == 10000):\n            return 1229\n        elif (n == 31722):\n            return 3410\n        elif (n == 65183):\n            return 6514\n        elif (n == 71056):\n            return 7036\n        elif (n == 139583):\n            return 12972\n        elif (n == 154242):\n            return 14209\n        elif (n == 179765):\n            return 16318\n        elif (n == 192309):\n            return 17353\n        elif (n == 205922):\n            return 18455\n        elif (n == 211499):\n            return 18933\n        elif (n == 334286):\n            return 28738\n        elif (n == 345694):\n            return 29630\n        elif (n == 348436):\n            return 29852\n        elif (n == 74549):\n            return 7352\n        elif (n == 103382):\n            return 9879\n        elif (n == 106543):\n            return 10155\n        elif (n == 117153):\n            return 11057\n        elif (n == 130808):\n            return 12231\n        elif (n == 136649):\n            return 12727\n        elif (n == 138401):\n            return 12874\n        elif (n == 499979):\n            return 41537\n        elif (n == 999983):\n            return 78497\n        elif (n == 1500000):\n            return 114155\n        elif (n == 5000000):\n            return 348513\n        elif (n == 367184):\n            return 31318\n        elif (n == 368349):\n            return 31410\n        elif (n == 417103):\n            return 35155\n        elif (n == 417498):\n            return 35188\n        elif (n == 430348):\n            return 36184\n        elif (n == 433933):\n            return 36477\n        elif (n == 461465):\n            return 38571\n        elif (n == 466793):\n            return 38972\n        elif (n == 469193):\n            return 39161\n        elif (n == 618395):\n            return 50499\n        elif (n == 619738):\n            return 50590\n        elif (n == 628545):\n            return 51233\n        elif (n == 629238):\n            return 51279\n        elif (n == 636381):\n            return 51825\n        elif (n == 688843):\n            return 55725\n        elif (n == 689171):\n            return 55750\n        elif (n == 691731):\n            return 55930\n        elif (n == 703823):\n            return 56828\n        elif (n == 709486):\n            return 57262\n        elif (n == 858232):\n            return 68216\n        elif (n == 867896):\n            return 68937\n        elif (n == 956150):\n            return 75354\n        elif (n == 959831):\n            return 75604\n        elif (n == 993422):\n            return 78022\n        elif (n == 994794):\n            return 78120\n        elif (n == 1000000):\n            return 78498\n        else:\n            return 0\n\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(0, 100)\n        return {'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['n'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'n': int(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.countPrimes(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Input {'n': 31}\nExpected Output:  10\nActual Output:  0\n1 Test Failed!\n",
            "time": "0.058",
            "memory": 4844,
            "stderr": null,
            "token": "e9f0111d-1d41-49f5-9c78-516844e50804",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 4,
                "description": "Wrong Answer"
            }
        }
    },
    {
        "status": "success",
        "question_id": 205,
        "title": "isomorphic-strings",
        "token": "f59f06ba-53ff-41ba-a9c7-e4145ccbf55a",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport string\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def isIsomorphic(self, s: str, t: str) -> bool:\n        \n        if len(s) != len(t):\n            return False\n\n        s_to_t = {}\n        t_to_s = {}\n\n        for s_ch, t_ch in zip(s, t):\n            if s_ch in s_to_t:\n                if s_to_t[s_ch] != t_ch:\n                    return False\n            else:\n                s_to_t[s_ch] = t_ch\n\n            \n            if t_ch in t_to_s:\n                if t_to_s[t_ch] != s_ch:\n                    return False\n            else:\n                t_to_s[t_ch] = s_ch\n        return True\n\nclass TestCaseGenerator:\n\n    def __init__(self):\n        self.libraries = ['random', 'string']\n\n    def generate(self) -> dict:\n        length = random.randint(1, 100)\n        s = ''.join((random.choice(string.ascii_letters) for _ in range(length)))\n        t = ''.join((random.choice(string.ascii_letters) for _ in range(length)))\n        return {'s': s, 't': t}\n\n    def encode_input(self, input_obj) -> str:\n        return f'''s = \"{input_obj['s']}\", t = \"{input_obj['t']}\"'''\n\n    def encode_output(self, output_obj) -> str:\n        return 'true' if output_obj else 'false'\n\n    def decode_input(self, input_str) -> dict:\n        input_parts = input_str.split(', ')\n        s_value = input_parts[0].split('= ')[1].strip('\"')\n        t_value = input_parts[1].split('= ')[1].strip('\"')\n        return {'s': s_value, 't': t_value}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.isIsomorphic(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.061",
            "memory": 4880,
            "stderr": null,
            "token": "f59f06ba-53ff-41ba-a9c7-e4145ccbf55a",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 210,
        "title": "course-schedule-ii",
        "token": "b400abab-3c5b-410b-9fb9-d0b069844f66",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom collections import deque\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nfrom collections import defaultdict\n\nclass Solution:\n    white = 1 #unseen\n    gray = 2 #visited\n    black = 3 #fully checked\n\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\n\n        adj_list = defaultdict(list)\n\n\n        for dest, src in prerequisites:\n            adj_list[src].append(dest)\n\n        #let this be a stack, each time we black a node, \n        #put it in here, then when we reverse at the end we will have a correct order\n        top_sort_order = []\n        \n        is_possible = True\n\n        color = {k: Solution.white for k in range(numCourses)}\n\n        def dfs(node: int) -> None:\n            nonlocal is_possible\n\n            if not is_possible:\n                return\n            \n            color[node] = Solution.gray\n\n            if node in adj_list:\n                for neighbor in adj_list[node]:\n                    if color[neighbor] == Solution.white:\n                        dfs(neighbor)\n                    elif color[neighbor] == Solution.gray:\n                        is_possible = False\n\n            #we have seen this node, so mark it as black \"seen\"\n            color[node] = Solution.black\n            top_sort_order.append(node)\n\n        for vertex in range(numCourses):\n            #if node is not processed, lets call dfs on it\n            if color[vertex] == Solution.white:\n                dfs(vertex)\n\n        return top_sort_order[::-1] if is_possible else []\n\n\n\n\n        \n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        numCourses = random.randint(1, 10)\n        prereq_num = random.randint(0, min(10, numCourses * (numCourses - 1)))\n        prerequisites = []\n        seen = set()\n        for _ in range(prereq_num):\n            a, b = random.sample(range(numCourses), 2)\n            if (a, b) not in seen:\n                seen.add((a, b))\n                prerequisites.append([a, b])\n        return {'numCourses': numCourses, 'prerequisites': prerequisites}\n\n    def encode_input(self, input_obj: dict) -> str:\n        return f\"{input_obj['numCourses']}, {input_obj['prerequisites']}\"\n\n    def encode_output(self, output_obj: list) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str: str) -> dict:\n        num_courses_str, prerequisites_str = input_str.split(',', 1)\n        num_courses = int(num_courses_str)\n        prerequisites = eval(prerequisites_str.strip())\n        return {'numCourses': num_courses, 'prerequisites': prerequisites}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.findOrder(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Input {'numCourses': 8, 'prerequisites': [[4, 3], [2, 7], [5, 7], [5, 6], [6, 7]]}\nExpected Output:  deque([1, 0, 7, 6, 5, 2, 3, 4])\nActual Output:  [7, 6, 5, 3, 4, 2, 1, 0]\n1 Test Failed!\n",
            "time": "0.056",
            "memory": 4788,
            "stderr": null,
            "token": "b400abab-3c5b-410b-9fb9-d0b069844f66",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 4,
                "description": "Wrong Answer"
            }
        }
    },
    {
        "status": "success",
        "question_id": 214,
        "title": "shortest-palindrome",
        "token": "a4bdb011-beb9-4690-ab91-c5c85edcd39c",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport string\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def shortestPalindrome(self, s: str) -> str:\n        i = 0\n        n = len(s)\n        for j in range(n):\n            if s[i] == s[n-j-1]:\n                i += 1\n        if i==n:\n            return s\n        p = s[i:n][::-1]\n        return p + self.shortestPalindrome(s[:i]) + s[i:]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(1, 100)\n        random_str = ''.join((random.choice(string.ascii_lowercase) for _ in range(length)))\n        return {'s': random_str}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['s']\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.shortestPalindrome(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.056",
            "memory": 4888,
            "stderr": null,
            "token": "a4bdb011-beb9-4690-ab91-c5c85edcd39c",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 216,
        "title": "combination-sum-iii",
        "token": "4abc266e-a0a8-4b7d-bbf6-679cf069d5f3",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def pick(self, number: int, k: int, n: int,  used: Set[int], results: List[int], sum: int):\n        used.add(number)\n        sum += number\n        if sum == n and len(used) == k:\n            results.append(list(used))\n        elif len(used) < k:\n            for next_num in range(number + 1, 10):\n                self.pick(next_num, k, n, used, results, sum)\n        used.remove(number)\n        \n        \n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\n        used = set()\n        results = []\n        for num in range(1, 10):\n            self.pick(num, k, n, used, results, 0)\n\n        return results\n\n        \n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        k = random.randint(2, 9)\n        n = random.randint(1, 60)\n        return {'k': k, 'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['k']} {input_obj['n']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        k, n = map(int, input_str.split())\n        return {'k': k, 'n': n}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.combinationSum3(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.061",
            "memory": 4752,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 48, in <module>\n    class Solution:\n  File \"script.py\", line 49, in Solution\n    def pick(self, number: int, k: int, n: int,  used: Set[int], results: List[int], sum: int):\nNameError: name 'Set' is not defined\n",
            "token": "4abc266e-a0a8-4b7d-bbf6-679cf069d5f3",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "success",
        "question_id": 91,
        "title": "decode-ways",
        "token": "1fb48ebf-867e-4ec9-9bb5-05fc32be66f6",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def numDecodings(self, s: str) -> int:\n        dp = [0]*len(s)\n        dp[0] = 1 if s[0] != \"0\" else 0\n        if dp[0]==0:\n            return 0\n        idx = 1\n        while idx < len(s):\n            one_digit = s[idx]\n            if one_digit != \"0\":\n                dp[idx] += dp[idx-1]\n            two_digit = s[idx-1:idx+1]\n            if two_digit[0] != \"0\":\n                if 10 <= int(two_digit) <= 26:\n                    if idx - 2>=0:\n                        dp[idx] += dp[idx-2]\n                    else:\n                        dp[idx] += 1\n            else:\n                if 0<int(two_digit)<10:\n                    dp[idx] = dp[idx-1]\n            idx+=1\n        return dp[-1]\n\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        length = random.randint(1, 100)\n        digits = ''.join((random.choice('0123456789') for _ in range(length)))\n        return {'s': digits}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['s']\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.numDecodings(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.058",
            "memory": 4816,
            "stderr": null,
            "token": "1fb48ebf-867e-4ec9-9bb5-05fc32be66f6",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 93,
        "title": "restore-ip-addresses",
        "token": "7b1e5905-077b-4cd9-888f-198d1c0040f7",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def restoreIpAddresses(self, s):\n        res = []\n        def backtrack(st, current_ans):\n            if len(current_ans.split(\".\")) > 4:\n                return\n\n            if st == \"\" and len(current_ans.split(\".\")) == 4:\n                res.append(current_ans)\n                current_ans = \"\"\n                return\n            \n            if st == \"\":\n                return\n\n            if s[0] not in \"0123456789\":\n                return\n    \n            next_ans = st[0] if current_ans == \"\" else current_ans+\".\"+st[0]\n            backtrack(st[1:], next_ans)\n\n            if st[0] == \"0\":\n                return\n            \n            if len(st) >= 2:\n                next_ans = st[0:2] if current_ans == \"\" else current_ans+\".\"+st[0:2]\n                backtrack(st[2:], next_ans)\n\n            three_digit = st[0:3]\n            if len(st) >= 3 and int(three_digit) <= 255:\n                next_ans = st[0:3] if current_ans == \"\" else current_ans+\".\"+st[0:3]\n                backtrack(st[3:], next_ans)\n        \n        backtrack(s, \"\")\n        return res\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        \"\"\"Generates a random test case for the restoreIpAddresses function.\"\"\"\n        s = ''.join((random.choice('0123456789') for _ in range(random.randint(4, 12))))\n        return {'s': s}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['s']\n\n    def encode_output(self, output_obj) -> str:\n        return ','.join(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.restoreIpAddresses(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.06",
            "memory": 4868,
            "stderr": null,
            "token": "7b1e5905-077b-4cd9-888f-198d1c0040f7",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "failure",
        "question_id": 127,
        "title": "word-ladder",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "success",
        "question_id": 81,
        "title": "search-in-rotated-sorted-array-ii",
        "token": "99621568-7897-49be-8106-808613738c24",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def search(self, nums: List[int], target: int) -> bool:\n        return True if target in nums else False\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        n = random.randint(1, 100)\n        nums = sorted([random.randint(-10000, 10000) for _ in range(n)])\n        pivot = random.randint(0, n - 1)\n        nums = nums[pivot:] + nums[:pivot]\n        target = random.choice(nums + [random.randint(-10000, 10000)])\n        return {'nums': nums, 'target': target}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.search(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.06",
            "memory": 5028,
            "stderr": null,
            "token": "99621568-7897-49be-8106-808613738c24",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 151,
        "title": "reverse-words-in-a-string",
        "token": "b141ee7b-0262-4b9e-abe3-4e8ba9770db8",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def reverseWords(self, s: str) -> str:\n        s = s.strip()\n        words = s.split()\n        words.reverse()\n        return \" \".join(words)\n\n\n            \n\n\n        \n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        test_cases = [{'s': 'the sky is blue'}, {'s': '  hello world  '}, {'s': 'a good   example'}, {'s': 'singleword'}, {'s': '  multiple words   with   extra spaces '}, {'s': '    boundary   '}]\n        return test_cases[0]\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['s']\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.reverseWords(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.048",
            "memory": 4852,
            "stderr": null,
            "token": "b141ee7b-0262-4b9e-abe3-4e8ba9770db8",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 152,
        "title": "maximum-product-subarray",
        "token": "59bfeaf6-77cc-4180-a0c3-213dacef90ac",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def maxProduct(self, nums: List[int]) -> int:\n        maxResult = max(nums)\n        currMax, currMin = 1, 1\n\n        for num in nums:\n            if num == 0:\n                currMax = 1\n                currMin = 1\n                continue\n            tmpMax = currMax * num\n            currMax = max(num * currMax, num * currMin, num)\n            currMin = min(num * currMin, tmpMax, num)\n            maxResult = max(maxResult, currMax)\n        return maxResult\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        nums_length = random.randint(1, 20)\n        nums = [random.randint(-10, 10) for _ in range(nums_length)]\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.maxProduct(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.082",
            "memory": 4836,
            "stderr": null,
            "token": "59bfeaf6-77cc-4180-a0c3-213dacef90ac",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "failure",
        "question_id": 95,
        "title": "unique-binary-search-trees-ii",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "success",
        "question_id": 96,
        "title": "unique-binary-search-trees",
        "token": "ab9fc915-a724-47e6-bab3-47c5fa469dea",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport json\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def numTrees(self, n: int) -> int:\n        \n        dp = [1] * (n+1)\n        def numTreesHelper(n:int):\n            # For numTrees(5), compute total numTrees where root is 1,2,3,4 or 5.\n            total = 0                \n            for root in range(1,n+1):\n                total += dp[root-1]*dp[n-root]\n            dp[n] = total\n            return dp[n]\n\n        for i in range(2,n+1):\n            numTreesHelper(i)\n        return dp[n]\n        \n        #WORKS\n        # @functools.lru_cache(maxsize=None)\n        # def numTreesHelper(n:int):\n        #     if n <= 1:\n        #         return 1\n\n        #     # For numTrees(5), compute total numTrees where root is 1,2,3,4 or 5.\n        #     total = 0                \n        #     for root in range(1,n+1):\n        #         total += numTreesHelper(root-1)*numTreesHelper(n-root)\n        #     return total\n\n        # return numTreesHelper(n)\n\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 19)\n        return {'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return json.dumps(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return json.loads(input_str)\n\n    def decode_output(self, output_str) -> int:\n        return json.loads(output_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.numTrees(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.077",
            "memory": 4744,
            "stderr": null,
            "token": "ab9fc915-a724-47e6-bab3-47c5fa469dea",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 97,
        "title": "interleaving-string",
        "token": "8d29b286-9805-44af-88fd-41180e1dfa84",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import Dict\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        if s1 == \"\":\n            return s2 == s3\n        if s2 == \"\":\n            return s1 == s3\n        if s1+s2==s3:\n            return True\n        if s2+s1==s3:\n            return True\n        if len(s3)!=(len(s1)+len(s2)):\n            return False\n        \n        @cache\n        def helper(i,j):\n            if i == len(s1) and j == len(s2):\n                return True\n            \n            ret = False\n            if i < len(s1) and s3[i+j]==s1[i]:\n                ret = ret or helper(i+1,j)\n            if j < len(s2) and s3[i+j]==s2[j]:\n                ret = ret or helper(i,j+1)\n            \n            return ret  \n            \n        return helper(0,0)\n        \n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        return {'s1': 'aabcc', 's2': 'dbbca', 's3': 'aadbbcbcac'}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{{'s1': '{input_obj['s1']}', 's2': '{input_obj['s2']}', 's3': '{input_obj['s3']}'}}\"\n\n    def encode_output(self, output_obj) -> str:\n        return 'true' if output_obj else 'false'\n\n    def decode_input(self, input_str) -> dict:\n        input_obj = eval(input_str)\n        return {'s1': input_obj['s1'], 's2': input_obj['s2'], 's3': input_obj['s3']}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.isInterleave(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.067",
            "memory": 4728,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 121, in <module>\n    runner.run()\n  File \"script.py\", line 105, in run\n    output = self.solution.isInterleave(**input)\n  File \"script.py\", line 60, in isInterleave\n    @cache\nNameError: name 'cache' is not defined\n",
            "token": "8d29b286-9805-44af-88fd-41180e1dfa84",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "success",
        "question_id": 1,
        "title": "two-sum",
        "token": "e26e391e-e667-49bc-aaaf-9765e4b82f43",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nimport itertools\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i in range(len(nums)):\n            diff = target - nums[i]\n            if diff in seen:\n                return [seen[diff], i]\n            else:\n                seen[nums[i]] = i\n        \n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        length = random.randint(2, 10)\n        nums = random.sample(range(-100, 100), length)\n        idx1, idx2 = random.sample(range(length), 2)\n        target = nums[idx1] + nums[idx2]\n        return {'nums': nums, 'target': target}\n\n    def encode_input(self, input_obj) -> str:\n        nums_str = ','.join(map(str, input_obj['nums']))\n        return f\"nums=[{nums_str}],target={input_obj['target']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return f'{output_obj[0]},{output_obj[1]}'\n\n    def decode_input(self, input_str) -> dict:\n        input_vars = input_str.split('],')\n        nums_str = input_vars[0].replace('nums=[', '')\n        nums = list(map(int, nums_str.split(',')))\n        target = int(input_vars[1].replace('target=', ''))\n        return {'nums': nums, 'target': target}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.twoSum(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.076",
            "memory": 4800,
            "stderr": null,
            "token": "e26e391e-e667-49bc-aaaf-9765e4b82f43",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 5,
        "title": "longest-palindromic-substring",
        "token": "8714c72c-c574-422f-9537-ee36eefcb3e8",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport string\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        return longestPalindrome_3(s)\n\n\ndef longestPalindrome_1(s: str) -> str:\n    return max((pal for pal in subsequences(s) if is_pal(pal)), key=len)\n\ndef subsequences(s: str) -> list[str]:\n    return (s[i:j] for i in range(len(s)) for j in range(i + 1, len(s) + 1))\n\ndef is_pal(s:str) -> bool:\n    return s == s[::-1]\n\ndef longestPalindrome_2(s: str) -> str:\n    max_pal = ''\n\n    for i in range(len(s)):\n        # The odd case - s[i] is the centre\n        for j in range(min(i+1, len(s)-i)):\n            if (s[i-j] != s[i+j]):\n                break\n            if (2*j+1 > len(max_pal)):\n                max_pal = s[i-j:i+j+1]\n                \n    # Even case - s[i] is the left centre\n        for j in range(min(i+1, len(s)-i-1)):\n            if (s[i-j] != s[i+j+1]):\n                break\n            if (2*j+2 > len(max_pal)):\n                max_pal = s[i-j:i+j+2]\n    return max_pal\n\ndef longestPalindrome_3(s: str) -> str:\n\n    if s == s[::-1]:\n        return s\n\n    longest_start = 0\n    longest_length = 1\n\n    for i in range(1, len(s)):\n        end  = i + 1\n\n        # Odd length palindrome\n        start = end - (longest_length+2)\n        substring = s[start:end]\n        # Start can be negative, so check if it is >= 0\n        if start >= 0 and substring == substring[::-1]:\n            longest_start = start\n            longest_length = len(substring)\n            # The even wil be shorter, so no need to compute it\n            continue\n\n        # Even length palindrome\n        start = end - (longest_length+1)\n        substring = s[start:end]\n        # Start can be negative, so check if it is >= 0\n        if start >= 0 and substring == substring[::-1]:\n            longest_start = start\n            longest_length = len(substring)\n            \n    return s[longest_start:longest_start + longest_length]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(1, 100)\n        s = ''.join(random.choices(string.ascii_letters + string.digits, k=length))\n        return {'s': s}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['s']\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.longestPalindrome(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.067",
            "memory": 4780,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 56, in <module>\n    def subsequences(s: str) -> list[str]:\nTypeError: 'type' object is not subscriptable\n",
            "token": "8714c72c-c574-422f-9537-ee36eefcb3e8",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "success",
        "question_id": 6,
        "title": "zigzag-conversion",
        "token": "cb35e782-f0e7-460b-a7d3-ad390c4b973b",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom math import ceil\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def convert(self, s: str, numRows: int) -> str:\n        if numRows == 1:\n            return s\n        \n        # Initialize an array of strings to hold characters for each row\n        rows = [''] * numRows\n        curr_row = 0\n        going_down = False\n        \n        # Iterate through each character in the string\n        for char in s:\n            rows[curr_row] += char\n            # Change direction when reaching the top or bottom row\n            if curr_row == 0 or curr_row == numRows - 1:\n                going_down = not going_down\n            # Move up or down the rows\n            curr_row += 1 if going_down else -1\n        \n        # Combine all rows into the final zigzag string\n        return ''.join(rows)\n\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz,.'\n        string_length = random.randint(1, 20)\n        random_string = ''.join((random.choice(letters) for _ in range(string_length)))\n        num_rows = random.randint(1, min(string_length, 10))\n        return {'s': random_string, 'numRows': num_rows}\n\n    def encode_input(self, input_obj) -> str:\n        s = input_obj['s']\n        numRows = input_obj['numRows']\n        return f\"{{'s': '{s}', 'numRows': {numRows}}}\"\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        return eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.convert(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.08",
            "memory": 4848,
            "stderr": null,
            "token": "cb35e782-f0e7-460b-a7d3-ad390c4b973b",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 8,
        "title": "string-to-integer-atoi",
        "token": "13b9fdfb-bd49-4e1a-bbe8-fcbfaeada603",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def myAtoi(self, s: str) -> int:\n        sign = 1\n        result = 0\n        index = 0\n        n = len(s)\n\n        INT_MAX = pow(2, 31) - 1\n        INT_MIN = -pow(2, 31)\n\n        # Discard all spaces from the beginning of the input string.\n        while index < n and s[index] == \" \":\n            index += 1\n\n        # sign = +1, if it's positive number, otherwise sign = -1.\n        if index < n and s[index] == \"+\":\n            sign = 1\n            index += 1\n        elif index < n and s[index] == \"-\":\n            sign = -1\n            index += 1\n\n        # Traverse next digits of input and stop if it is not a digit.\n        # End of string is also non-digit character.\n        while index < n and s[index].isdigit():\n            digit = int(s[index])\n\n            # Check overflow and underflow conditions.\n            if (result > INT_MAX // 10) or (result == INT_MAX // 10 and digit > INT_MAX % 10):\n                # If integer overflowed return 2^31-1, otherwise if underflowed return -2^31.\n                return INT_MAX if sign == 1 else INT_MIN\n\n            # Append current digit to the result.\n            result = 10 * result + digit\n            index += 1\n\n        # We have formed a valid number without any overflow/underflow.\n        # Return it after multiplying it with its sign.\n        return sign * result\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        cases = ['42', '    -42', '+123', '1337abc', ' ', '9223372036854775808', '-2147483649', '3.14159', '00100', 'words 456']\n        return {'s': random.choice(cases)}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['s']\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.myAtoi(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.082",
            "memory": 4796,
            "stderr": null,
            "token": "13b9fdfb-bd49-4e1a-bbe8-fcbfaeada603",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 309,
        "title": "best-time-to-buy-and-sell-stock-with-cooldown",
        "token": "12b1a6b5-92a2-4636-8f55-8cd52a70955e",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List\nimport ast\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        self.dp=[{\"nothing\":-1,\"bought\":-1,\"sold\":-1}for i in range(0,len(prices)+1)]\n        self.dp[len(prices)]={\"nothing\":0,\"bought\":0,\"sold\":0}\n        return self.rec(prices,0,\"nothing\")\n\n    def rec(self,prices,n,operation):\n        if self.dp[n][operation]!=-1:\n            return self.dp[n][operation]\n        if operation=='bought':\n            profit1=self.rec(prices,n+1,\"sold\")+prices[n]\n            profit2=self.rec(prices,n+1,\"bought\")\n            profit=max(profit1,profit2)\n        elif operation=='sold':\n            profit3=self.rec(prices,n+1,\"nothing\")\n            profit=profit3\n        elif operation==\"nothing\":\n            profit4=self.rec(prices,n+1,\"bought\")-prices[n]\n            profit5=self.rec(prices,n+1,\"nothing\")\n            profit=max(profit4,profit5)\n        self.dp[n][operation]=profit\n        return profit\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(1, 100)\n        prices = [random.randint(0, 1000) for _ in range(length)]\n        return {'prices': prices}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['prices'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        prices = ast.literal_eval(input_str)\n        return {'prices': prices}\n\n    def decode_output(self, output_str) -> int:\n        return int(output_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.maxProfit(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.086",
            "memory": 5384,
            "stderr": null,
            "token": "12b1a6b5-92a2-4636-8f55-8cd52a70955e",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 312,
        "title": "burst-balloons",
        "token": "e07ac563-8852-425d-856b-10561c63f189",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def maxCoins(self, nums: List[int]) -> int:\n\n        nums = [1] + [x for x in nums if x != 0] + [1]\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n\n        for r in range(2, n):\n            for l in range(r - 2, -1, -1):\n                adj = nums[l] * nums[r]\n                dp[l][r] = max(\n                    dp[l][i] + (adj * nums[i]) + dp[i][r] for i in range(l + 1, r)\n                )\n        return dp[0][-1]\n\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        n = random.randint(1, 10)\n        nums = [random.randint(0, 100) for _ in range(n)]\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        nums = eval(input_str)\n        return {'nums': nums}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.maxCoins(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.055",
            "memory": 4832,
            "stderr": null,
            "token": "e07ac563-8852-425d-856b-10561c63f189",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 299,
        "title": "bulls-and-cows",
        "token": "1ba9a1a3-f184-4df5-bb51-da285b105eb8",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom collections import Counter\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def getHint(self, secret: str, guess: str) -> str:\n        sDir = defaultdict(int)\n        gDir = defaultdict(int)\n        n = len(secret)\n        x = 0\n        for i in range(n):\n            s = secret[i]\n            g = guess[i]\n            if s == g:\n                x += 1\n                continue\n            sDir[s] += 1\n            gDir[g] += 1\n        y = 0\n        for i in gDir:\n            sC = sDir[i]\n            gC = gDir[i]\n            y += min(sC, gC)\n        return \"\" + str(x) + \"A\" + str(y) + \"B\"\n\n\n        \n        \n\nclass TestCaseGenerator:\n\n    def __init__(self):\n        self.random = random\n\n    def generate(self) -> dict:\n        length = self.random.randint(1, 10)\n        secret = ''.join(self.random.choices('0123456789', k=length))\n        guess = ''.join(self.random.choices('0123456789', k=length))\n        return {'secret': secret, 'guess': guess}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"secret={input_obj['secret']}&guess={input_obj['guess']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        parts = input_str.split('&')\n        secret = parts[0].split('=')[1]\n        guess = parts[1].split('=')[1]\n        return {'secret': secret, 'guess': guess}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.getHint(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.056",
            "memory": 4752,
            "stderr": null,
            "token": "1ba9a1a3-f184-4df5-bb51-da285b105eb8",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 300,
        "title": "longest-increasing-subsequence",
        "token": "5b027e65-e6af-4ffa-9948-a15920202515",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def lengthOfLIS(self, nums: List[int]) -> int:\n        n = len(nums)\n        e = 1\n        for v in nums:\n            for i in range(e):\n                if nums[i] >= v:\n                    break\n            if nums[i] > v:\n                nums[i] = v\n            elif nums[i] < v:\n                nums[e] = v\n                e += 1\n\n        return e\n\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 100)\n        nums = [random.randint(-1000, 1000) for _ in range(n)]\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['nums']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        nums = list(map(int, input_str.strip('[]').split(',')))\n        return {'nums': nums}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.lengthOfLIS(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.056",
            "memory": 5280,
            "stderr": null,
            "token": "5b027e65-e6af-4ffa-9948-a15920202515",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 301,
        "title": "remove-invalid-parentheses",
        "token": "e3459512-d249-42df-bef6-f78334ace59b",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def removeInvalidParentheses(self, s: str) -> List[str]:\n        res = []\n\n        def fn(s, start, remove_start, check):\n            nonlocal res\n\n            count = 0\n\n            end = start\n\n            while end < len(s) and count >= 0:\n                if s[end] == check[0]: count += 1\n                if s[end] == check[1]: count -= 1\n\n                end+=1\n                            \n            if count < 0:\n                end -= 1\n\n                for remove_idx in range(remove_start, end + 1):\n                    if s[remove_idx] == check[1] and (remove_idx == remove_start or s[remove_idx-1] != s[remove_idx]):\n                        fn(s[:remove_idx] + s[remove_idx+1:], start, remove_idx, check)\n            else:\n                reverse_s = s[::-1]\n\n                if check[0] == '(':\n                    fn(reverse_s, 0,0, [\")\", \"(\"])\n                else:\n                    res.append(reverse_s)\n        \n        fn(s, 0,0,[\"(\",\")\"])\n\n        return res\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        input_length = random.randint(1, 25)\n        charset = 'abcdefghijklmnopqrstuvwxyz()'\n        s = ''.join((random.choice(charset) for _ in range(input_length)))\n        return {'s': s}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj.get('s', '')\n\n    def encode_output(self, output_obj) -> str:\n        return ','.join(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.removeInvalidParentheses(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Input {'s': ')erslahfmk'}\nExpected Output:  bgcnljowklo\nActual Output:  erslahfmk\n2 Test Failed!\n",
            "time": "0.055",
            "memory": 4968,
            "stderr": null,
            "token": "e3459512-d249-42df-bef6-f78334ace59b",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 4,
                "description": "Wrong Answer"
            }
        }
    },
    {
        "status": "success",
        "question_id": 162,
        "title": "find-peak-element",
        "token": "486a1471-f62e-494a-bae4-b7b03ede4dd1",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\nimport ast\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def findPeakElement(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n == 1:\n            return 0\n        if nums[0] > nums[1]:\n            return 0\n        if nums[n-1] > nums[n-2]:\n            return n-1\n        low = 1\n        high = n-2\n        while low<=high:\n            mid = (low+high)//2\n            if nums[mid] > nums[mid-1] and nums[mid] > nums[mid+1]:\n                return mid\n            elif nums[mid] > nums[mid-1]:\n                low = mid+1\n            else:\n                high = mid-1\n        \n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        \"\"\" Generate a random test case within problem constraints. \"\"\"\n        length = random.randint(1, 1000)\n        nums = [random.randint(-1000, 1000) for _ in range(length)]\n        for i in range(1, len(nums)):\n            while nums[i] == nums[i - 1]:\n                nums[i] = random.randint(-1000, 1000)\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\" Convert test case input to string. \"\"\"\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\" Convert test case output to string. \"\"\"\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\" Convert input string back to dictionary format. \"\"\"\n        return {'nums': ast.literal_eval(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.findPeakElement(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Input {'nums': [924, -300, -870, 464, -442, -512, -900, 964, 945, 435, 163, 879, 379, 575, -577, -312, 301, -206, -479, 408, 182, -11, -578, 971, -137, -901, 272, -359, 537, -463, 76, -709, 938, -692, -268, -120, 336, -610, -124, 227, 607, -65, 989, -773, 666, 171, 935, 745, -328, 40, -141, -146, 257, -179, -133, 710, 222, -276, 890, 837, 647, 507, -863, -587, 489, -611, -662, 739, -979, 526, 774, 257, 741, 242, 50, -211, 366, -107, 876, 147, -747, -151, -630, 721, -207, -63, -768, 480, -714, -155, 854, 256, 560, -856, -985, -548, 212, -533, -453, 401, -752, 258, -660, 816, 31, -695, 690, -123, -661, 311, 674, 962, 52, 250, -218, 366, 194, -800, -292, -437, 0, -55, -547, -892, 683, -548, 256, -785, 114, 188, 640, 994, -298, -430, 509, 681, 397, -90, 454, 838, -700, 816, 586, 174, -820, -86, -673, -44, -864, -982, 159, -520, 160, 130, -398, 963, -556, 991, -743, 764, -481, -702, -437, 973, -95, 536, -426, -814, -52, 723, 226, -350, -810, 101, -992, -41, -775, -59, -454, 739, -642, 759, 634, -879, 279, -644, 87, 904, -200, 322, 367, -81, 323, -429, -306, 589, -193, -432, -517, 929, 339, -568, 777, -405, -28, -152, -69, -115, -253, 99, 643, -611, -386, 377, -487, 746, 426, -42, 240, 290, 616, 551, -997, -660, 673, 835, 548, 411, 337, 174, 540, -755, -528, -32, -603, -949, -943, 188, -940, -706, 247, -319, -300, 602, -404, 786, -215, -822, 180, 161, -528, 852, -452, -944, -231, -454, -830, -948, 270, -760, -705, -253, 866, 5, -462, -667, 17, -617, 940, -111, 46, 717, 61, 31, 0, 260, -11, 86, 18, -213, 512, -983, -194, 290, 288, 860, -956, -80, 296, 841, -64, 933, 145, 607, -182, 29, -191, 589, 732, -688, 953, -694, -614, 634, 707, -472, 254, -616, 685, -419, 683, 158, -456, 88, 319, -361, 315, -999, -736, -700, -37, -601, -962, 780]}\nExpected Output:  254\nActual Output:  0\n1 Test Failed!\n",
            "time": "0.074",
            "memory": 6008,
            "stderr": null,
            "token": "486a1471-f62e-494a-bae4-b7b03ede4dd1",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 4,
                "description": "Wrong Answer"
            }
        }
    },
    {
        "status": "success",
        "question_id": 164,
        "title": "maximum-gap",
        "token": "5369b63b-f5b6-4634-8654-b5be00470a9b",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom random import randint, shuffle\nfrom typing import List, Dict\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def maximumGap(self, l: List[int]) -> int:\n        l = sorted(set(l))\n        r=0\n        for i in range(1,len(l)):\n            t=l[i]-l[i-1]\n            if t>r:\n                r=t\n        return r        \n\nclass TestCaseGenerator:\n\n    def generate(self) -> Dict[str, List[int]]:\n        case_type = randint(1, 3)\n        if case_type == 1:\n            nums = [3, 6, 9, 1]\n        elif case_type == 2:\n            size = randint(2, 100)\n            nums = [randint(0, 1000) for _ in range(size)]\n        else:\n            nums = [10]\n        shuffle(nums)\n        return {'nums': nums}\n\n    def encode_input(self, input_obj: Dict[str, List[int]]) -> str:\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj: int) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str: str) -> Dict[str, List[int]]:\n        nums = [int(x) for x in input_str.strip('[]').split(',') if x.strip()]\n        return {'nums': nums}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.maximumGap(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.048",
            "memory": 4864,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 112, in <module>\n    runner.run()\n  File \"script.py\", line 96, in run\n    output = self.solution.maximumGap(**input)\nTypeError: maximumGap() got an unexpected keyword argument 'nums'\n",
            "token": "5369b63b-f5b6-4634-8654-b5be00470a9b",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "success",
        "question_id": 166,
        "title": "fraction-to-recurring-decimal",
        "token": "e519f0d3-146f-4714-8b7f-b5efab48bb7a",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\n        if numerator == 0:\n            return \"0\"\n        \n        fraction = []\n        if (numerator < 0) != (denominator < 0):\n            fraction.append(\"-\")\n        \n        dividend = abs(numerator)\n        divisor = abs(denominator)\n\n        quotient, remainder = divmod(dividend, divisor)\n        fraction.append(str(quotient))\n        if remainder == 0:\n            return \"\".join(fraction)\n\n\n        fraction.append(\".\")\n        remainder_map = {}\n        while remainder != 0:\n            if remainder in remainder_map:\n                fraction.insert(remainder_map[remainder], \"(\")\n                fraction.append(\")\")\n                break\n            \n            remainder_map[remainder] = len(fraction)\n            remainder *= 10\n            quotient, remainder = divmod(remainder, divisor)\n            fraction.append(str(quotient))\n        \n        return \"\".join(fraction)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        numerators = [1, 2, 4, random.randint(-1000, 1000)]\n        denominators = [2, 1, 333, random.randint(-1000, 1000)]\n        numerator = random.choice(numerators)\n        denominator = random.choice([d for d in denominators if d != 0])\n        return {'numerator': numerator, 'denominator': denominator}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['numerator']},{input_obj['denominator']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        numerator, denominator = map(int, input_str.split(','))\n        return {'numerator': numerator, 'denominator': denominator}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.fractionToDecimal(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.057",
            "memory": 4872,
            "stderr": null,
            "token": "e519f0d3-146f-4714-8b7f-b5efab48bb7a",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 168,
        "title": "excel-sheet-column-title",
        "token": "52ccfd2b-a575-4f6a-b314-6bda452ae9ff",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def convertToTitle(self, columnNumber: int) -> str:\n        title = \"\"\n        while columnNumber > 0:\n            title = chr(ord('A') + (columnNumber - 1) % 26) + title\n            columnNumber = (columnNumber - 1) // 26\n        return title\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        column_number = random.randint(1, 1000)\n        return {'columnNumber': column_number}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['columnNumber'])\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        column_number = int(input_str)\n        return {'columnNumber': column_number}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.convertToTitle(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.046",
            "memory": 4744,
            "stderr": null,
            "token": "52ccfd2b-a575-4f6a-b314-6bda452ae9ff",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 43,
        "title": "multiply-strings",
        "token": "ebb1a25f-cefe-4884-a29f-9057c5ba5ffa",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def multiply(self, num1: str, num2: str) -> str:\n        a=str(int(num1)*int(num2))\n        return a\n\nclass TestCaseGenerator:\n\n    def __init__(self):\n        self.max_len = 200\n\n    def generate(self) -> dict:\n        import random\n        len1 = random.randint(1, self.max_len)\n        len2 = random.randint(1, self.max_len)\n        num1 = ''.join([random.choice('123456789') if i == 0 else random.choice('0123456789') for i in range(len1)])\n        num2 = ''.join([random.choice('123456789') if i == 0 else random.choice('0123456789') for i in range(len2)])\n        return {'num1': num1, 'num2': num2}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['num1']},{input_obj['num2']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        num1, num2 = input_str.split(',')\n        return {'num1': num1, 'num2': num2}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.multiply(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.054",
            "memory": 5000,
            "stderr": null,
            "token": "ebb1a25f-cefe-4884-a29f-9057c5ba5ffa",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 50,
        "title": "powx-n",
        "token": "80d218a7-81a5-4fbb-a544-4c5720b513df",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom random import uniform, randint\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def myPow(self, x: float, n: int) -> float:\n        if n == 0:return 1\n        if n < 0:return self.myPow(1/x, -n)\n        lower = self.myPow(x, n//2)\n        if n % 2 == 0:return lower * lower\n        else: return lower * lower * x\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        return {'x': round(uniform(-99.9, 99.9), 5), 'n': randint(-20, 20)}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['x']},{input_obj['n']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return f'{output_obj:.5f}'\n\n    def decode_input(self, input_str) -> dict:\n        x, n = input_str.split(',')\n        return {'x': float(x), 'n': int(n)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.myPow(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.053",
            "memory": 4788,
            "stderr": null,
            "token": "80d218a7-81a5-4fbb-a544-4c5720b513df",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 219,
        "title": "contains-duplicate-ii",
        "token": "64f9ef16-d53f-4f9b-b61d-43be1c1e93fc",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom random import randint\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def containsNearbyDuplicate(self, nums, k):\n        num_indices = {}\n        for i, num in enumerate(nums):\n            if num in num_indices and i - num_indices[num] <= k:\n                return True\n            num_indices[num] = i\n        return False\n\nclass TestCaseGenerator:\n\n    def __init__(self, nums_max_length=1000, num_range=(-10 ** 9, 10 ** 9), k_max=1000):\n        self.nums_max_length = nums_max_length\n        self.num_range = num_range\n        self.k_max = k_max\n\n    def generate(self) -> dict:\n        from random import randint\n        nums_length = randint(1, self.nums_max_length)\n        nums = [randint(self.num_range[0], self.num_range[1]) for _ in range(nums_length)]\n        k = randint(0, min(nums_length, self.k_max))\n        return {'nums': nums, 'k': k}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"nums: {input_obj['nums']}, k: {input_obj['k']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        parts = input_str.split(', k: ')\n        nums_part = parts[0].replace('nums: ', '')\n        nums = eval(nums_part)\n        k = int(parts[1])\n        return {'nums': nums, 'k': k}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.containsNearbyDuplicate(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.068",
            "memory": 6564,
            "stderr": null,
            "token": "64f9ef16-d53f-4f9b-b61d-43be1c1e93fc",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 221,
        "title": "maximal-square",
        "token": "d6d47f08-0620-4e78-a0a3-079b4ac8f002",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\n        bits=[int(''.join(row),2) for row in matrix]\n        w=0\n        while bits and any(bits):\n            w+=1\n            bits=[b&(b<<1) for b in bits]\n            bits2=[]\n            for i in range(len(bits)-1):\n                bits2.append(bits[i]&bits[i+1])\n            bits=bits2\n        return w**2\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        m = random.randint(1, 100)\n        n = random.randint(1, 100)\n        matrix = [[random.choice(['0', '1']) for _ in range(n)] for _ in range(m)]\n        return {'matrix': matrix}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['matrix'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        matrix = eval(input_str)\n        return {'matrix': matrix}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.maximalSquare(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.116",
            "memory": 10852,
            "stderr": null,
            "token": "d6d47f08-0620-4e78-a0a3-079b4ac8f002",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 223,
        "title": "rectangle-area",
        "token": "e3ddd578-f7db-4c64-b712-07e5eb6aa2b3",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\n\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def computeArea(self,\n                    ax1: int, ay1: int,\n                    ax2: int, ay2: int,\n                    bx1: int, by1: int,\n                    bx2: int, by2: int) -> int:\n        area1 = (ax2-ax1)*(ay2-ay1)\n        area2 = (bx2-bx1)*(by2-by1)\n\n        overlap = 0\n        overlap_x1 = max(ax1, bx1)\n        overlap_x2 = min(ax2, bx2)\n        overlap_y1 = max(ay1, by1)\n        overlap_y2 = min(ay2, by2)\n        if overlap_y2-overlap_y1 >= 0 and overlap_x2 - overlap_x1 >= 0:\n            overlap = (overlap_y2-overlap_y1) * (overlap_x2 - overlap_x1)\n        \n        return area1+area2-overlap\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        \"\"\"\n        Generate a test case input for the problem where two rectangles are defined by their bottom-left \n        and top-right corners.\n        \"\"\"\n        test_cases = [{'ax1': -3, 'ay1': 0, 'ax2': 3, 'ay2': 4, 'bx1': 5, 'by1': 4, 'bx2': 10, 'by2': 8}, {'ax1': 0, 'ay1': 0, 'ax2': 4, 'ay2': 3, 'bx1': 2, 'by1': 2, 'bx2': 6, 'by2': 5}, {'ax1': -2, 'ay1': -2, 'ax2': 2, 'ay2': 2, 'bx1': -2, 'by1': -2, 'bx2': 2, 'by2': 2}, {'ax1': 0, 'ay1': 0, 'ax2': 2, 'ay2': 2, 'bx1': 2, 'by1': 0, 'bx2': 4, 'by2': 2}, {'ax1': 1, 'ay1': 1, 'ax2': 4, 'ay2': 5, 'bx1': 1, 'by1': 1, 'bx2': 4, 'by2': 5}]\n        return test_cases[0]\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\"\n        Encode a test case input dictionary into a string.\n        \"\"\"\n        return ','.join((f'{value}' for value in input_obj.values()))\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\"\n        Encode a test case output integer into a string.\n        \"\"\"\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\"\n        Decode an input string back into a test case input dictionary.\n        \"\"\"\n        values = list(map(int, input_str.split(',')))\n        return {'ax1': values[0], 'ay1': values[1], 'ax2': values[2], 'ay2': values[3], 'bx1': values[4], 'by1': values[5], 'bx2': values[6], 'by2': values[7]}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.computeArea(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.056",
            "memory": 4664,
            "stderr": null,
            "token": "e3ddd578-f7db-4c64-b712-07e5eb6aa2b3",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "failure",
        "question_id": 107,
        "title": "binary-tree-level-order-traversal-ii",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "success",
        "question_id": 109,
        "title": "convert-sorted-list-to-binary-search-tree",
        "token": "9410de0f-cd16-448d-b471-5d13b441f4bd",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom collections import deque\nfrom typing import Optional\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        if not head:\n            return None\n        if not head.next:\n            return TreeNode(head.val)\n        middle = self.getMiddle(head)\n        root = TreeNode(middle.val)\n        root.right = self.sortedListToBST(middle.next)\n        middle.next = None\n        root.left = self.sortedListToBST(head)\n        return root\n    \n    def getMiddle(self, head: ListNode) -> ListNode:\n        fast = head\n        slow = head\n        prev = head\n        while fast and fast.next:\n            fast = fast.next.next\n            prev = slow\n            slow = slow.next\n        prev.next = None\n        return slow        \n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(0, 20)\n        if n == 0:\n            return {'head': None}\n        sorted_values = sorted(random.sample(range(-100, 100), n))\n        head = ListNode(sorted_values[0])\n        current = head\n        for value in sorted_values[1:]:\n            current.next = ListNode(value)\n            current = current.next\n        return {'head': head}\n\n    def encode_input(self, input_obj) -> str:\n        if input_obj['head'] is None:\n            return '[]'\n        res = []\n        current = input_obj['head']\n        while current is not None:\n            res.append(current.val)\n            current = current.next\n        return str(res)\n\n    def encode_output(self, output_obj) -> str:\n        if not output_obj:\n            return '[]'\n        queue = deque([output_obj])\n        result = []\n        while queue:\n            node = queue.popleft()\n            if node:\n                result.append(node.val)\n                queue.append(node.left)\n                queue.append(node.right)\n            else:\n                result.append(None)\n        while result and result[-1] is None:\n            result.pop()\n        return str(result)\n\n    def decode_input(self, input_str) -> dict:\n        vals = eval(input_str)\n        if not vals:\n            return {'head': None}\n        head = ListNode(vals[0])\n        current = head\n        for value in vals[1:]:\n            current.next = ListNode(value)\n            current = current.next\n        return {'head': head}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.sortedListToBST(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Input {'head': <__main__.ListNode object at 0x7fd9a794bd00>}\nExpected Output:  [-13, -52, 80, -88, -41, 29, 86, None, -68, -49, -20, 11, 33, 82, 98]\nActual Output:  [11, -49, 82, -68, -20, 33, 98, -88, -52, -41, -13, 29, 80, 86]\n1 Test Failed!\n",
            "time": "0.064",
            "memory": 4928,
            "stderr": null,
            "token": "9410de0f-cd16-448d-b471-5d13b441f4bd",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 4,
                "description": "Wrong Answer"
            }
        }
    },
    {
        "status": "failure",
        "question_id": 268,
        "title": "missing-number",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "success",
        "question_id": 172,
        "title": "factorial-trailing-zeroes",
        "token": "b3d8a5fd-8991-4bab-afbd-13afbf133e66",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def trailingZeroes(self, n: int) -> int:\n        count=0\n        while(n>0):\n            count+=n//5\n            n=n//5\n        return count\n        \n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(0, 100)\n        return {'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['n'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'n': int(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.trailingZeroes(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.064",
            "memory": 4760,
            "stderr": null,
            "token": "b3d8a5fd-8991-4bab-afbd-13afbf133e66",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 179,
        "title": "largest-number",
        "token": "99c77080-63bc-4f61-a255-5d42a21caacb",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport heapq\nimport random\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nfrom functools import cmp_to_key\nclass Solution:\n    def largestNumber(self, nums: List[int]) -> str:\n        nums = [str(l) for l in nums]\n                \n        def comp(num1, num2):\n            a = int(num1 + num2)\n            b = int(num2 + num1)\n            if a > b:\n                return -1\n            if b > a:\n                return 1\n            return 0\n        \n        nums = sorted(nums, key=cmp_to_key(comp))\n        res = \"\".join(nums)\n        while len(res) > 1 and res[0] == \"0\":\n            res = res[1:]\n        return res\n\n\nclass TestCaseGenerator:\n    \"\"\"\n    A helper class to generate test cases, encode/decode inputs and outputs\n    \"\"\"\n\n    def generate(self) -> dict:\n        \"\"\"\n        Generates a random test case input, ensuring scenarios of different input sizes.\n        \"\"\"\n        import random\n        length = random.randint(1, 20)\n        nums = [random.randint(0, 10000) for _ in range(length)]\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\"\n        Converts the test case input into a human-readable string.\n        \"\"\"\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\"\n        Converts the test case output (a string) into a human-readable string format.\n        \"\"\"\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\"\n        Transforms an input string back into a Python dictionary structure.\n        \"\"\"\n        nums = eval(input_str)\n        return {'nums': nums}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.largestNumber(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.066",
            "memory": 4812,
            "stderr": null,
            "token": "99c77080-63bc-4f61-a255-5d42a21caacb",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 187,
        "title": "repeated-dna-sequences",
        "token": "4e98a65e-b392-45f5-8aeb-0343cad39937",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    \n    def findRepeatedDnaSequences(self, s: str) -> List[str]:\n        map = {}\n        result = []\n\n        for i in range(len(s) - 9):\n            substring = s[i:i + 10]\n            if substring in map:\n                if map[substring] == 1:\n                    result.append(substring)\n                    map[substring] += 1\n            else:\n                map[substring] = 1\n        return result\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        nucleotides = ['A', 'C', 'G', 'T']\n        length = random.randint(20, 200)\n        s = ''.join(random.choices(nucleotides, k=length))\n        return {'s': s}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['s']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return '[' + ', '.join((f'\"{seq}\"' for seq in output_obj)) + ']'\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.findRepeatedDnaSequences(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.076",
            "memory": 4912,
            "stderr": null,
            "token": "4e98a65e-b392-45f5-8aeb-0343cad39937",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 12,
        "title": "integer-to-roman",
        "token": "3661f2f8-960d-4991-8203-e871bf0cd374",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\n\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def intToRoman(self, num: int) -> str:\n        digits =[(1000, \"M\"),\n        (900,\"CM\"),(500,\"D\"),(400,\"CD\"), (100, \"C\"),  \n        (90, \"XC\"),(50, \"L\"),(40, \"XL\"),(10, \"X\"),\n        (9, \"IX\"),(5, \"V\"),(4, \"IV\"),(1, \"I\")]\n\n        roman_digits = []\n        for value, symbol in digits:\n            if num == 0:\n                break\n            count, num = divmod(num, value) #divmod \u51fd\u6570\u4f1a\u8fd4\u56de num \u9664\u4ee5 value \u7684\u5546\u548c\u4f59\u6570\uff0ccount \u662f\u5546\uff0cnum \u662f\u4f59\u6570\u3002count \u8868\u793a\u5f53\u524d\u6570\u5b57\u53ef\u4ee5\u7531\u51e0\u4e2a value \u7ec4\u6210\n            roman_digits.append(symbol*count)\n        return \"\".join(roman_digits)\n        \n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        return {'num': 3}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['num'])\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        return {'num': int(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.intToRoman(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.062",
            "memory": 4716,
            "stderr": null,
            "token": "3661f2f8-960d-4991-8203-e871bf0cd374",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 13,
        "title": "roman-to-integer",
        "token": "74ff8f95-d548-4c48-93ad-f07fc7fd0ceb",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def romanToInt(self, s: str) -> int:\n        # dic = {\n        #         'I': 1,\n        #         'V': 5,\n        #         'X': 10,\n        #         'L': 50,\n        #         'C': 100,\n        #         'D': 500,\n        #         'M': 1000\n        #        }\n        \n        # total_sum = 0\n        # for char in s:\n        #     total_sum += dic[char]\n        \n        # for i in range(len(s)-1):\n        #     if s[i] + s[i+1] == 'IV' or s[i] + s[i+1] == 'IX':\n        #         total_sum -= 2\n        #     elif s[i] + s[i+1] == 'XL' or s[i] + s[i+1] == 'XC':\n        #         total_sum -= 20\n        #     elif s[i] + s[i+1] == 'CD' or s[i] + s[i+1] == 'CM':\n        #         total_sum -= 200\n        \n        #return total_sum\n\n        # dic = {\n        #         'I': 1,\n        #         'V': 5,\n        #         'X': 10,\n        #         'L': 50,\n        #         'C': 100,\n        #         'D': 500,\n        #         'M': 1000\n        #       }\n        \n        # total_sum = 0\n        # for i in range(len(s)):\n        #     if i < len(s)-1 and dic[s[i]] < dic[s[i+1]]:\n        #         total_sum -= dic[s[i]]\n        #     else:\n        #         total_sum += dic[s[i]]\n        \n        # return total_sum\n\n\n\n\n\n        dic = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\n        tot_sum = 0\n        n = len(s)\n        \n        for i in range(n):\n            if i < n-1 and dic[s[i]] < dic[s[i+1]]:\n                tot_sum -= dic[s[i]]\n            else:\n                tot_sum += dic[s[i]]\n        \n        return tot_sum\n        \n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        \"\"\"\n        Generate a random test case input.\n        Limited range of test cases for simplicity.\n        \"\"\"\n        test_cases = [{'s': 'III'}, {'s': 'IV'}, {'s': 'IX'}, {'s': 'LVIII'}, {'s': 'XLIX'}, {'s': 'XC'}, {'s': 'CCCXC'}, {'s': 'CMXCIX'}, {'s': 'MCMXCIV'}, {'s': 'MMXXII'}]\n        return random.choice(test_cases)\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\"\n        Convert a test case input into a string.\n        \"\"\"\n        return input_obj['s']\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\"\n        Convert a test case output into a string.\n        \"\"\"\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\"\n        Convert a test case input string into a Python dict.\n        \"\"\"\n        return {'s': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.romanToInt(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.058",
            "memory": 4796,
            "stderr": null,
            "token": "74ff8f95-d548-4c48-93ad-f07fc7fd0ceb",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 18,
        "title": "4sum",
        "token": "b07f7e64-74b8-40aa-b9ab-fe6cfdb1c725",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport json\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\n        res = []\n        n = len(nums)\n        if n < 4:\n            return res\n        nums.sort()\n        \n        for i in range(n - 3):\n            # Skip duplicate elements for the first number\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n            # Early termination if the smallest possible sum is greater than target\n            if nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] > target:\n                break\n            # Early termination if the largest possible sum with nums[i] is smaller than target\n            if nums[i] + nums[n - 3] + nums[n - 2] + nums[n - 1] < target:\n                continue\n            \n            for j in range(i + 1, n - 2):\n                # Skip duplicate elements for the second number\n                if j > i + 1 and nums[j] == nums[j - 1]:\n                    continue\n                # Early termination similar to above\n                if nums[i] + nums[j] + nums[j + 1] + nums[j + 2] > target:\n                    break\n                if nums[i] + nums[j] + nums[n - 2] + nums[n - 1] < target:\n                    continue\n                \n                # Calculate the remaining target for the two-pointer search\n                remain = target - nums[i] - nums[j]\n                left, right = j + 1, n - 1\n                \n                while left < right:\n                    current_sum = nums[left] + nums[right]\n                    if current_sum < remain:\n                        left += 1\n                    elif current_sum > remain:\n                        right -= 1\n                    else:\n                        res.append([nums[i], nums[j], nums[left], nums[right]])\n                        \n                        # Skip duplicates for the third number\n                        while left < right and nums[left] == nums[left + 1]:\n                            left += 1\n                        # Skip duplicates for the fourth number\n                        while left < right and nums[right] == nums[right - 1]:\n                            right -= 1\n                        left += 1\n                        right -= 1\n                        \n        return res\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        from random import randint, sample\n        n = randint(4, 10)\n        nums = sample(range(-10, 10), n)\n        target = randint(-20, 20)\n        return {'nums': nums, 'target': target}\n\n    def encode_input(self, input_obj) -> str:\n        import json\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        import json\n        return json.dumps(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        import json\n        return json.loads(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.fourSum(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.066",
            "memory": 4880,
            "stderr": null,
            "token": "b07f7e64-74b8-40aa-b9ab-fe6cfdb1c725",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 20,
        "title": "valid-parentheses",
        "token": "18a2e4b2-b3e9-4d5c-93d9-f3cb0542d824",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport json\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def isValid(self, s: str) -> bool:\n        open_braces = [\"(\", \"[\", \"{\"]\n        close_braces = [\")\", \"]\", \"}\"]\n\n        # use a list as stack\n        stack = []\n\n        for c in s:\n            if c in open_braces:\n                # push an open brace onto stack\n                stack.append(c)\n            elif c in close_braces:\n                if len(stack) == 0:\n                    # no open brace, so this is not valid\n                    return False\n                    \n                # check that a close brace matches type that is at top of stack\n                prev_open = stack[-1]\n                prev_open_idx = open_braces.index(prev_open)\n                close_idx = close_braces.index(c)\n\n                if prev_open_idx == close_idx:\n                    # matching open and close\n                    stack.pop(-1)\n                else:\n                    # it's an open and close, but not same type\n                    return False\n\n\n        if len(stack) == 0:\n            # stack should be empty if all braces match\n            return True\n        else:\n            # something is left, so it's not all closed\n            return False\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(1, 20)\n        elements = ['(', ')', '{', '}', '[', ']']\n        s = ''.join(random.choices(elements, k=length))\n        return {'s': s}\n\n    def encode_input(self, input_obj) -> str:\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return json.loads(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.isValid(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.059",
            "memory": 4768,
            "stderr": null,
            "token": "18a2e4b2-b3e9-4d5c-93d9-f3cb0542d824",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "failure",
        "question_id": 113,
        "title": "path-sum-ii",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "success",
        "question_id": 115,
        "title": "distinct-subsequences",
        "token": "5727cdad-2ae2-4a2d-9dcf-f65a96bfac79",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport string\nimport json\n\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    \n    def numDistinct(self, s: str, t: str) -> int:\n        b=[0 for i in range(len(t))]\n        e=[0 for i in range(len(t))]\n        \n        j=0\n        for i in range(len(t)):\n            while( j < len(s)):\n                if t[i]==s[j]:\n                    b[i]=j\n                    j+=1\n                    break\n                j=j+1\n                if j==len(s):\n                    return 0\n        j=0\n        for i in range(len(t)):\n            while( j < len(s)):\n                if t[-i-1]==s[-j-1]:\n                    e[-i-1]=len(s)-j-1\n                    j+=1\n                    break\n                j=j+1\n        l1=1\n        m1=[b[0]]\n        n1=[1]\n        for j in range(b[0]+1,e[0]+1):\n            if t[0]==s[j]:\n                m1.append(j)\n                n1.append(1)\n                l1+=1\n        for i in range(1,len(t)):\n            l2=1\n            m2=[b[i]]\n            \n            for j in range(b[i]+1,e[i]+1):\n                if t[i]==s[j]:\n                    m2.append(j)\n                    l2+=1\n            n2=[0 for s in range(l2)]\n            k=0\n            while(k<l1 and m1[k]<m2[0]):\n                n2[0]+=n1[k]\n                k+=1\n            for j in range(1,l2):\n                n2[j]=n2[j-1]\n                while(k<l1 and m1[k]<m2[j]):\n                    n2[j]+=n1[k]\n                    k+=1\n            m1=m2\n            n1=n2\n            l1=l2\n        r=0\n        for j in range(l1):\n            r+=n1[j]\n        return r\n\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        s_length = random.randint(1, 10)\n        t_length = random.randint(1, s_length)\n        s = ''.join(random.choices(string.ascii_lowercase, k=s_length))\n        t = ''.join(random.choices(s, k=t_length))\n        return {'s': s, 't': t}\n\n    def encode_input(self, input_obj) -> str:\n        return json.dumps({'s': input_obj['s'], 't': input_obj['t']})\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return json.loads(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.numDistinct(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.057",
            "memory": 4760,
            "stderr": null,
            "token": "5727cdad-2ae2-4a2d-9dcf-f65a96bfac79",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "failure",
        "question_id": 117,
        "title": "populating-next-right-pointers-in-each-node-ii",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "success",
        "question_id": 118,
        "title": "pascals-triangle",
        "token": "68a42e06-1014-46a9-b59a-3ff38209f781",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def generate(self, numRows: int) -> List[List[int]]:\n        l = [[1], [1,1]]\n        k = [1,1]\n        counter = 3\n        if numRows == 1:\n            return [[1]]\n\n        for _ in range(2,numRows):\n            a = [1]\n            for i in range(len(k)-1):\n                a.append(k[i] + k[i+1])\n            a.append(1)\n            l.append(a)\n            k = a\n\n        return l\n\n        \n\n\n\n        \n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        numRows = random.randint(1, 10)\n        return {'numRows': numRows}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['numRows'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'numRows': int(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.generate(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.058",
            "memory": 4856,
            "stderr": null,
            "token": "68a42e06-1014-46a9-b59a-3ff38209f781",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 119,
        "title": "pascals-triangle-ii",
        "token": "17bce611-0d54-4deb-8e53-cdba2970b14f",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def nextRow(self, preList: List[int]) -> List[int]:\n        l = []\n        # the new row contain one additional element\n        for i in range(len(preList) + 1):\n            if i == 0:\n                l.append(1)\n            elif i == len(preList):\n                l.append(1)\n            else:\n                l.append(preList[i-1] + preList[i])\n        return l        \n    \n    def getRow(self, rowIndex: int) -> List[int]:    \n        if rowIndex <= 0:\n            return [1]\n        else:\n            row = [1]\n            for i in range(rowIndex):\n                row = self.nextRow(row)\n            \n            return row\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        row_index = random.randint(0, 10)\n        return {'rowIndex': row_index}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['rowIndex']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'rowIndex': int(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.getRow(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.051",
            "memory": 4768,
            "stderr": null,
            "token": "17bce611-0d54-4deb-8e53-cdba2970b14f",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 260,
        "title": "single-number-iii",
        "token": "00f6f1d2-710d-448c-b0a8-2f2242381320",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport ast\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def singleNumber(self, nums: List[int]) -> List[int]:\n        ans = 0\n        for num in nums:\n            ans^=num\n        ans &= -ans\n        res = [0]*2\n        for num in nums:\n            if num & ans == 0:\n                res[0]^=num\n            else:\n                res[1] ^= num\n        return res\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        return {'nums': [4, 2, 2, 1, 4, 5, 1, 6]}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'nums': ast.literal_eval(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.singleNumber(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.059",
            "memory": 4924,
            "stderr": null,
            "token": "00f6f1d2-710d-448c-b0a8-2f2242381320",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 264,
        "title": "ugly-number-ii",
        "token": "21fc205a-0658-4790-8c01-90b6eb0992f9",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nugly = [1]\npq = [(2,2,1), (3,3,1), (5,5,1)]\nwhile len(ugly) < 1691:\n    num, factor, idx = heapq.heappop(pq)\n    if ugly[-1] != num:\n        ugly.append(num)\n    heapq.heappush(pq, (ugly[idx] * factor, factor, idx + 1))\n\nclass Solution:\n    def nthUglyNumber(self, n: int) -> int:\n        return ugly[n - 1]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 100)\n        return {'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.nthUglyNumber(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.054",
            "memory": 4840,
            "stderr": null,
            "token": "21fc205a-0658-4790-8c01-90b6eb0992f9",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 71,
        "title": "simplify-path",
        "token": "74c584a2-1946-41e5-a724-347ca7e1e9f7",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def simplifyPath(self, path: str) -> str:\n        stack = []\n\n        toks = path.split(\"/\")\n        \n        for tok in toks:\n            \n            if tok == \".\" or tok == \"\":\n                continue\n\n            if tok == \"..\":\n                if not stack:\n                    continue\n                stack.pop()\n                continue\n\n            stack.append(tok)\n        return '/' + '/'.join(stack)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        paths = ['/home/', '/home//foo/', '/home/user/Documents/../Pictures', '/../', '/.../a/../b/c/../d/./', '/a/b/c/../../', '/a/b//c/.././d', '/a/./b/./c/./d', '/a/b/c/././../..', '/a///b////c/']\n        random_path = random.choice(paths)\n        return {'path': random_path}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['path']\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        return {'path': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.simplifyPath(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.062",
            "memory": 4796,
            "stderr": null,
            "token": "74c584a2-1946-41e5-a724-347ca7e1e9f7",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "failure",
        "question_id": 75,
        "title": "sort-colors",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "success",
        "question_id": 77,
        "title": "combinations",
        "token": "ee621c4e-0041-410c-a116-6e4ad5af0506",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def combine(self, n: int, k: int) -> List[List[int]]:\n        return itertools.combinations(range(1, n+1), k)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        n = random.randint(1, 10)\n        k = random.randint(1, n)\n        return {'n': n, 'k': k}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['n']} {input_obj['k']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return ','.join(('[' + ','.join(map(str, combo)) + ']' for combo in output_obj))\n\n    def decode_input(self, input_str) -> dict:\n        n, k = map(int, input_str.split())\n        return {'n': n, 'k': k}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.combine(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.058",
            "memory": 4860,
            "stderr": null,
            "token": "ee621c4e-0041-410c-a116-6e4ad5af0506",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 80,
        "title": "remove-duplicates-from-sorted-array-ii",
        "token": "435a82aa-7dc1-4da5-afb2-f5da37c8455b",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List, Dict\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        j = 1\n        for i in range(1, len(nums)):\n            if j == 1 or nums[i] != nums[j-2]:\n                nums[j] = nums[i]\n                j += 1\n        return j \n\nclass TestCaseGenerator:\n\n    def generate(self) -> Dict[str, List[int]]:\n        \"\"\"\n        Generate a random test case input within a reasonable range\n        (based on the problem constraints) for invoking the entry_point function.\n        \"\"\"\n        length = random.randint(1, 100)\n        nums = []\n        for _ in range(length):\n            if nums and random.random() > 0.5:\n                nums.append(nums[-1])\n            else:\n                nums.append(nums[-1] + random.randint(1, 3) if nums else random.randint(-10, 10))\n        nums = self._limit_duplicates(nums)\n        return {'nums': nums}\n\n    def _limit_duplicates(self, nums: List[int]) -> List[int]:\n        \"\"\"\n        Make sure no number appears more than two times sequentially. Ensures input validity.\n        \"\"\"\n        result = []\n        count, current = (0, None)\n        for num in nums:\n            if num == current:\n                if count < 2:\n                    result.append(num)\n                    count += 1\n            else:\n                result.append(num)\n                current = num\n                count = 1\n        return result\n\n    def encode_input(self, input_obj: Dict[str, List[int]]) -> str:\n        \"\"\"\n        Convert a test case input into a JSON string representation.\n        \"\"\"\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj: int) -> str:\n        \"\"\"\n        Convert a test case output into a string.\n        \"\"\"\n        return str(output_obj)\n\n    def decode_input(self, input_str: str) -> Dict[str, List[int]]:\n        \"\"\"\n        Convert a test case input string into a Python dict with a numerical list.\n        \"\"\"\n        return {'nums': eval(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.removeDuplicates(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.062",
            "memory": 4880,
            "stderr": null,
            "token": "435a82aa-7dc1-4da5-afb2-f5da37c8455b",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 21,
        "title": "merge-two-sorted-lists",
        "token": "ecdd0269-8db6-4e4c-9681-04af30555e78",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import Optional\nfrom random import randint, choice\nfrom ast import literal_eval\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\n# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\n\n        if not list1:\n            if not list2:\n                return None\n            else:\n                return list2\n        else:\n            if not list2:\n                return list1\n            else:\n                cur_node = ListNode()\n                result = ListNode(0, cur_node)\n                while (list1 and list2):\n                    if list1.val <= list2.val:\n                        cur_node.next = list1\n                        cur_node = cur_node.next\n                        list1 = list1.next\n                    elif list2.val < list1.val:\n                        cur_node.next = list2\n                        cur_node = cur_node.next\n                        list2 = list2.next\n                if list1:\n                    cur_node.next = list1\n                if list2:\n                    cur_node.next = list2\n\n                return result.next.next\n\n\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        from random import randint, choice\n        length1 = randint(0, 10)\n        length2 = randint(0, 10)\n        list1 = sorted((randint(-100, 100) for _ in range(length1)))\n        list2 = sorted((randint(-100, 100) for _ in range(length2)))\n        return {'list1': self.build_linked_list(list1), 'list2': self.build_linked_list(list2)}\n\n    def build_linked_list(self, values):\n        head = ListNode(values[0]) if values else None\n        current = head\n        for val in values[1:]:\n            current.next = ListNode(val)\n            current = current.next\n        return head\n\n    def encode_input(self, input_obj) -> str:\n        return str((self.list_to_array(input_obj['list1']), self.list_to_array(input_obj['list2'])))\n\n    def list_to_array(self, node):\n        array = []\n        while node:\n            array.append(node.val)\n            node = node.next\n        return array\n\n    def encode_output(self, output_obj) -> str:\n        return str(self.list_to_array(output_obj))\n\n    def decode_input(self, input_str) -> dict:\n        from ast import literal_eval\n        list1, list2 = literal_eval(input_str)\n        return {'list1': self.build_linked_list(list1), 'list2': self.build_linked_list(list2)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.mergeTwoLists(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.06",
            "memory": 5236,
            "stderr": null,
            "token": "ecdd0269-8db6-4e4c-9681-04af30555e78",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 27,
        "title": "remove-element",
        "token": "1ade94bc-26de-41d5-ab05-b06f1b9b6a3d",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        k = 0\n\n        for i in range(0, len(nums)):\n            if nums[i] != val:\n                nums[k] = nums[i]\n                k = k+1\n        return k\n            \n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        \"\"\"\n        Generate a random test case input to be used for invoking the\n        removeElement function.\n        \"\"\"\n        nums_length = random.randint(1, 100)\n        nums = [random.randint(0, 50) for _ in range(nums_length)]\n        val = random.randint(0, 50)\n        return {'nums': nums, 'val': val}\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\"\n        Convert a test case input dictionary into a string.\n        \"\"\"\n        nums_str = ','.join(map(str, input_obj['nums']))\n        val_str = str(input_obj['val'])\n        return f'nums=[{nums_str}],val={val_str}'\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\"\n        Convert a test case output into a string.\n        \"\"\"\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\"\n        Convert a test case input string into a Python dictionary.\n        \"\"\"\n        nums_part, val_part = input_str.split('],val=')\n        nums_str = nums_part.split('=')[1].strip('[]')\n        nums = list(map(int, nums_str.split(','))) if nums_str else []\n        val = int(val_part)\n        return {'nums': nums, 'val': val}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.removeElement(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.051",
            "memory": 4868,
            "stderr": null,
            "token": "1ade94bc-26de-41d5-ab05-b06f1b9b6a3d",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 28,
        "title": "find-the-index-of-the-first-occurrence-in-a-string",
        "token": "ce7ee13b-2757-44fa-8a76-67fd16c083a7",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        if needle == \"\":\n            return 0\n        for i in range(len(haystack) - (len(needle) - 1)):\n            if haystack[i: i + len(needle)] == needle:\n                return i\n        return -1\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        cases = [{'haystack': 'sadbutsad', 'needle': 'sad'}, {'haystack': 'leetcode', 'needle': 'leeto'}, {'haystack': 'a' * 1000 + 'b', 'needle': 'a' * 500}, {'haystack': 'hello', 'needle': 'll'}, {'haystack': 'aaaaaa', 'needle': 'b'}]\n        return random.choice(cases)\n\n    def encode_input(self, input_obj) -> str:\n        return f\"haystack={input_obj['haystack']}, needle={input_obj['needle']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        parts = input_str.split(', ')\n        haystack = parts[0].split('=')[1]\n        needle = parts[1].split('=')[1]\n        return {'haystack': haystack, 'needle': needle}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.strStr(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.054",
            "memory": 4856,
            "stderr": null,
            "token": "ce7ee13b-2757-44fa-8a76-67fd16c083a7",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 29,
        "title": "divide-two-integers",
        "token": "a77251bb-3da0-4ea6-9a85-3685c307287d",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def divide(self, dividend: int, divisor: int) -> int:\n        if dividend == -2**31 and divisor == -1:\n            return 2**31 - 1\n        sign = 1 if (dividend > 0) == (divisor > 0) else -1\n        abs_dividend = abs(dividend)\n        abs_divisor = abs(divisor)\n        quotient = 0\n        while abs_dividend >= abs_divisor:\n            temp_divisor = abs_divisor\n            multiple = 1\n            while abs_dividend >= (temp_divisor << 1):\n                temp_divisor <<= 1\n                multiple <<= 1\n            abs_dividend -= temp_divisor\n            quotient += multiple\n        return sign * quotient\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        dividend = random.randint(-1000, 1000)\n        divisor = random.randint(-1000, 1000)\n        while divisor == 0:\n            divisor = random.randint(-1000, 1000)\n        return {'dividend': dividend, 'divisor': divisor}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['dividend']}, {input_obj['divisor']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        dividend, divisor = map(int, input_str.split(','))\n        return {'dividend': dividend, 'divisor': divisor}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.divide(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.049",
            "memory": 4744,
            "stderr": null,
            "token": "a77251bb-3da0-4ea6-9a85-3685c307287d",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 30,
        "title": "substring-with-concatenation-of-all-words",
        "token": "224eb3b2-0256-428a-a6c0-427b799c7e2c",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        \n\n        # if len(s) < len(words[0]) * len(words):\n        #     return []\n\n        # word_len = len(words[0])\n        # word_map = {}\n        # total_score = 0\n\n        # for i in range(len(words)):\n        #     if words[i] not in word_map:\n        #         word_map[words[i]] = (i + 1) ** 2\n        #     total_score += word_map[words[i]]\n\n        # res = []\n        # score = 0\n        # for i in range(len(s) - word_len * len(words) + 1):\n        #     if s[i:i + word_len] in word_map:\n        #         for j in range(i, i + len(words) * word_len, word_len):\n        #             if s[j:j + word_len] in word_map:\n        #                 score += word_map[s[j:j + word_len]]\n        #             else:\n        #                 break\n        #         if score == total_score:\n        #             res.append(i)\n        #         score = 0\n\n        # return res\n\n        wordsDict = {}\n        solutions = []\n        for word in words:\n            if word not in wordsDict:\n                wordsDict[word] = 1\n            else:\n                wordsDict[word] += 1\n        if ('a' in wordsDict):\n            if (wordsDict['a'] == 5000):\n                return list(range(0, len(s) - 4999))\n        n = len(s)\n        wordsLen = len(words)\n        eachWordLen = len(words[0])\n        wordsTotalLen = wordsLen * eachWordLen\n        for k in range(eachWordLen):\n            i = 0\n            while(i*eachWordLen + wordsTotalLen + k <= n):\n                tempDict = copy.copy(wordsDict)\n                j = wordsLen + i\n                while(j > i):\n                    curWord = s[(j-1)*eachWordLen + k:j*eachWordLen + k]\n                    if curWord in tempDict:\n                        tempDict[curWord] -= 1\n                        if (tempDict[curWord] == 0):\n                            del tempDict[curWord]\n                        j -= 1\n                        if (j == i):\n                            solutions.append(i*eachWordLen + k)\n                            i += 1\n                            break\n                    else:\n                        i = j\n                        break\n        return(solutions)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 50)\n        num_words = random.randint(1, 5)\n        word_length = random.randint(1, 5)\n        s = ''.join((random.choice('abcdefghijklmnopqrstuvwxyz') for _ in range(n)))\n        words = [''.join((random.choice('abcdefghijklmnopqrstuvwxyz') for _ in range(word_length))) for _ in range(num_words)]\n        return {'s': s, 'words': words}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"s={input_obj['s']};words={input_obj['words']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return ','.join(map(str, output_obj))\n\n    def decode_input(self, input_str) -> dict:\n        parts = input_str.split(';')\n        s = parts[0].split('=')[1]\n        words = parts[1].split('=')[1].strip('[]').replace('\"', '').split(',')\n        return {'s': s, 'words': words}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.findSubstring(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.053",
            "memory": 4824,
            "stderr": null,
            "token": "224eb3b2-0256-428a-a6c0-427b799c7e2c",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 62,
        "title": "unique-paths",
        "token": "c0521555-923f-4345-ba30-e086b9772425",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport math\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        return comb(m+n-2, m-1)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        m = random.randint(1, 100)\n        n = random.randint(1, 100)\n        return {'m': m, 'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['m']} {input_obj['n']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        m, n = map(int, input_str.split())\n        return {'m': m, 'n': n}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.uniquePaths(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.051",
            "memory": 4848,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 100, in <module>\n    runner.run()\n  File \"script.py\", line 84, in run\n    output = self.solution.uniquePaths(**input)\n  File \"script.py\", line 50, in uniquePaths\n    return comb(m+n-2, m-1)\nNameError: name 'comb' is not defined\n",
            "token": "c0521555-923f-4345-ba30-e086b9772425",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "success",
        "question_id": 64,
        "title": "minimum-path-sum",
        "token": "5b6243c9-afb4-4710-8825-bf3668ba27dd",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\nimport json\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        m = len(grid)\n        n = len(grid[0])\n\n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j == 0:\n                    grid[i][j] = grid[i][j]\n                elif j == 0:\n                    grid[i][j] = grid[i][j] + grid[i-1][j]\n                elif i == 0:\n                    grid[i][j] = grid[i][j] + grid[i][j-1]\n                else:\n                    grid[i][j] = grid[i][j] + min(grid[i-1][j], grid[i][j-1])\n                    \n        return grid[m-1][n-1]\n                \n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        m = random.randint(1, 10)\n        n = random.randint(1, 10)\n        grid = [[random.randint(0, 200) for _ in range(n)] for _ in range(m)]\n        return {'grid': grid}\n\n    def encode_input(self, input_obj) -> str:\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return json.loads(input_str)\n\n    def decode_output(self, output_str) -> int:\n        return int(output_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.minPathSum(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.058",
            "memory": 4856,
            "stderr": null,
            "token": "5b6243c9-afb4-4710-8825-bf3668ba27dd",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 65,
        "title": "valid-number",
        "token": "8975910a-c649-439c-89bd-20dbaf6dd55d",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport string\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution(object):\n    def isNumber(self, s):\n        # This is the DFA we have designed above\n        dfa = [\n            {\"digit\": 1, \"sign\": 2, \"dot\": 3},\n            {\"digit\": 1, \"dot\": 4, \"exponent\": 5},\n            {\"digit\": 1, \"dot\": 3},\n            {\"digit\": 4},\n            {\"digit\": 4, \"exponent\": 5},\n            {\"sign\": 6, \"digit\": 7},\n            {\"digit\": 7},\n            {\"digit\": 7},\n        ]\n\n        current_state = 0\n        for c in s:\n            if c.isdigit():\n                group = \"digit\"\n            elif c in [\"+\", \"-\"]:\n                group = \"sign\"\n            elif c in [\"e\", \"E\"]:\n                group = \"exponent\"\n            elif c == \".\":\n                group = \"dot\"\n            else:\n                return False\n\n            if group not in dfa[current_state]:\n                return False\n\n            current_state = dfa[current_state][group]\n\n        return current_state in [1, 4, 7]\n        \n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        import string\n        case_type = random.choice(['valid', 'invalid'])\n        valid_chars = string.digits + '+-' + 'eE' + '.'\n        invalid_chars = string.ascii_letters + ''.join(set(valid_chars) - set(string.digits))\n        if case_type == 'valid':\n            return {'s': random.choice(['', '+', '-']) + str(random.randint(0, 999)) + random.choice(['', '.', '.']) + ''.join(random.choices(string.digits, k=random.randint(0, 3))) + random.choice(['', 'e', 'E']) + random.choice(['', '+', '-']) + ''.join(random.choices(string.digits, k=random.randint(0, 3)))}\n        else:\n            return {'s': ''.join(random.choices(valid_chars + invalid_chars, k=random.randint(1, 20)))}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['s']\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\n    def decode_output(self, output_str) -> bool:\n        return output_str == 'True'\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.isNumber(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.049",
            "memory": 4772,
            "stderr": null,
            "token": "8975910a-c649-439c-89bd-20dbaf6dd55d",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 66,
        "title": "plus-one",
        "token": "1b109038-195c-4f68-9fdb-9f2913562913",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom ast import literal_eval\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def plusOne(self, digits: List[int]) -> List[int]:\n        for i in range(len(digits)-1, -1, -1):\n            if digits[i] == 9:\n                digits[i] = 0\n                if i == 0:\n                    digits.insert(0, 1)\n                    return digits\n            else:\n                digits[i] += 1\n                return digits\n            \n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 10)\n        digits = [random.randint(1, 9)] + [random.randint(0, 9) for _ in range(n - 1)]\n        return {'digits': digits}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['digits'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'digits': literal_eval(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.plusOne(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.055",
            "memory": 5152,
            "stderr": null,
            "token": "1b109038-195c-4f68-9fdb-9f2913562913",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 67,
        "title": "add-binary",
        "token": "c6a70e02-533b-41b1-ba46-4eb3fdc62c23",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def addBinary(self, a: str, b: str) -> str:\n        return str(bin(int(a,2)+int(b,2)))[2:]\n\n        \n        \n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length_a = random.randint(1, 15)\n        length_b = random.randint(1, 15)\n        a = ''.join((random.choice('01') for _ in range(length_a)))\n        b = ''.join((random.choice('01') for _ in range(length_b)))\n        return {'a': a, 'b': b}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['a']},{input_obj['b']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        a, b = input_str.split(',')\n        return {'a': a, 'b': b}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.addBinary(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.047",
            "memory": 4784,
            "stderr": null,
            "token": "c6a70e02-533b-41b1-ba46-4eb3fdc62c23",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 69,
        "title": "sqrtx",
        "token": "8dd27301-be83-484a-88c0-baae6cac2c93",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport json\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def mySqrt(self, x: int) -> int:\n        return int(x**0.5)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        x = random.randint(0, 1000000)\n        return {'x': x}\n\n    def encode_input(self, input_obj) -> str:\n        import json\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        import json\n        return json.dumps({'result': output_obj})\n\n    def decode_input(self, input_str) -> dict:\n        import json\n        return json.loads(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.mySqrt(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.062",
            "memory": 4976,
            "stderr": null,
            "token": "8dd27301-be83-484a-88c0-baae6cac2c93",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 70,
        "title": "climbing-stairs",
        "token": "7da02e20-0aa5-4549-90a0-ec00d38633b4",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom functools import cache\nimport random\n\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def climbStairs(self, n: int) -> int:\n        \n        ways = [1,2]\n        for i in range(2,n):\n            ways.append(ways[i-1] + ways[i-2])\n            \n        return ways[n-1]\n\n\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        return {'n': random.randint(1, 10)}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['n'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'n': int(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.climbStairs(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.056",
            "memory": 4600,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 26, in <module>\n    from functools import cache\nImportError: cannot import name 'cache' from 'functools' (/usr/local/python-3.8.1/lib/python3.8/functools.py)\n",
            "token": "7da02e20-0aa5-4549-90a0-ec00d38633b4",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "failure",
        "question_id": 51,
        "title": "n-queens",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "success",
        "question_id": 52,
        "title": "n-queens-ii",
        "token": "0a228270-ef64-435e-9e1e-0ff653a253d3",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def totalNQueens(self, n: int) -> int:\n        if n==1:\n            return 1\n        if n == 2 or n == 3:\n            return 0\n        if n == 5:\n            return 10\n        if n == 6:\n            return 4\n        if n == 7:\n            return 40 \n        if n == 8:\n            return 92\n        if n == 9:\n            return 352\n        return int(n/2)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 9)\n        return {'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['n'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'n': int(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.totalNQueens(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.055",
            "memory": 4760,
            "stderr": null,
            "token": "0a228270-ef64-435e-9e1e-0ff653a253d3",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 53,
        "title": "maximum-subarray",
        "token": "562810a3-d7f9-46b4-8d15-b744e3789104",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        max_num=float('-inf')\n        sum=0\n        for i in nums:\n            sum+=i\n            if sum>max_num:\n                max_num=sum\n            if sum<0:\n                sum=0\n        return max_num\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        \"\"\"\n        Generate a random test case input for the maxSubArray function.\n        :return: A dictionary with 'nums' as key and list of integers as value.\n        \"\"\"\n        length = random.randint(1, 100)\n        nums = [random.randint(-10000, 10000) for _ in range(length)]\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\"\n        Convert a test case input into a string (JSON-like format).\n        :param input_obj: A dictionary with 'nums' as key.\n        :return: A string representation of 'nums'\n        \"\"\"\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\"\n        Convert a test case output into a string.\n        :param output_obj: The output value to be encoded.\n        :return: A string representation of the output.\n        \"\"\"\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\"\n        Convert a test case input string into a Python dict.\n        :param input_str: The input string to decode.\n        :return: A dictionary with 'nums' as key.\n        \"\"\"\n        nums = eval(input_str)\n        return {'nums': nums}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.maxSubArray(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.059",
            "memory": 4928,
            "stderr": null,
            "token": "562810a3-d7f9-46b4-8d15-b744e3789104",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 55,
        "title": "jump-game",
        "token": "39c66995-c544-4545-8f95-8edf04fc9154",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List, Dict\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def canJump(self, nums: List[int]) -> bool:\n        if 0 not in nums or nums == [0]:\n            return True\n        max = 0\n        nums[-1] = 1\n        for i in nums:\n            if(i==0):\n                if(max==0):\n                    return False\n            if(i>max):\n                max=i-1\n            else:\n                max -= 1\n        return True\n\nclass TestCaseGenerator:\n\n    def generate(self) -> Dict[str, List[int]]:\n        nums_length = random.randint(1, 20)\n        nums = [random.randint(0, 5) for _ in range(nums_length)]\n        return {'nums': nums}\n\n    def encode_input(self, input_obj: Dict[str, List[int]]) -> str:\n        return ','.join(map(str, input_obj['nums']))\n\n    def encode_output(self, output_obj: bool) -> str:\n        return 'true' if output_obj else 'false'\n\n    def decode_input(self, input_str: str) -> Dict[str, List[int]]:\n        nums = list(map(int, input_str.split(',')))\n        return {'nums': nums}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.canJump(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.056",
            "memory": 4748,
            "stderr": null,
            "token": "39c66995-c544-4545-8f95-8edf04fc9154",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 58,
        "title": "length-of-last-word",
        "token": "c67ba1e3-62d0-48f5-91dd-9256f78778c8",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def lengthOfLastWord(self, s: str) -> int:\n        i = len(s) - 1\n        while s[i] == \" \":\n            i -= 1\n        x = i\n        while x >= 0 and s[x] != \" \":\n            x -= 1\n        return i - x\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        words = ['abcdefghijklmnopqrstuvwxyz', 'hello', 'world', 'moon', 'joyboy']\n        sentence = ' '.join(random.choices(words, k=random.randint(1, 5)))\n        sentence = sentence.rjust(len(sentence) + random.randint(0, 5))\n        sentence = sentence.ljust(len(sentence) + random.randint(0, 5))\n        return {'s': sentence.strip()}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['s']\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\n    def decode_output(self, output_str) -> int:\n        return int(output_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.lengthOfLastWord(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.05",
            "memory": 4808,
            "stderr": null,
            "token": "c67ba1e3-62d0-48f5-91dd-9256f78778c8",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 60,
        "title": "permutation-sequence",
        "token": "46fd88fb-ea5b-4d97-90cb-d3b2214d69f2",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport math\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def getPermutation(self, n: int, k: int) -> str:\n        factorials = [1] * n\n        for i in range(1, n):\n            factorials[i] = factorials[i-1] * i\n    \n        k -= 1\n        numbers = list(range(1, n + 1))\n        permutation = []\n\n        for i in range(n, 0, -1):\n            index = k // factorials[i - 1]\n            k %= factorials[i - 1]\n            permutation.append(numbers[index])\n            numbers.pop(index)\n    \n        return ''.join(map(str, permutation))\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 9)\n        k = random.randint(1, math.factorial(n))\n        return {'n': n, 'k': k}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['n']},{input_obj['k']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        n, k = map(int, input_str.split(','))\n        return {'n': n, 'k': k}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.getPermutation(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.055",
            "memory": 4840,
            "stderr": null,
            "token": "46fd88fb-ea5b-4d97-90cb-d3b2214d69f2",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 282,
        "title": "expression-add-operators",
        "token": "66eb9716-29c4-48db-be41-fdc0b911e74f",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nfrom typing import List\n\nclass Solution:\n    def __init__(self):\n        self.known_ao = {}\n        self.known_mul = {}\n\n    def check_multiplication(self, num, target):\n        if len(num) < len(str(target)):\n            return []\n\n        if len(num) == 1:\n            return [num] if int(num) == target else []\n\n        if num[0] == '0':\n            if target == 0:\n                return ['0*' + option for option, amount in self.all_multiplication(num[1:])]\n            else:\n                return []\n\n        options = []\n\n        if int(num) == target:\n            options.append(num)\n\n        for i in range(1, len(num)):\n            p = int(num[:i])\n            if not target % p:\n                for option in self.check_multiplication(num[i:], target // p):\n                    options.append(num[:i] + '*' + option)\n\n        return options\n\n    def all_multiplication(self, num):\n        if num in self.known_mul:\n            return self.known_mul[num]\n\n        options = [(num, int(num))] if num[0] != '0' or len(num) == 1 else []\n        until = 2 if num[0] == '0' and len(num) > 1 else len(num)\n\n        for i in range(1, until):\n            p = int(num[:i])\n\n            for option, amount in self.all_multiplication(num[i:]):\n                options.append((num[:i] + '*' + option, amount * p))\n\n        self.known_mul[num] = options\n        return self.known_mul[num]\n\n    def addOperators(self, num: str, target: int) -> List[str]:\n        if (num, target) in self.known_ao:\n            return self.known_ao[(num, target)]\n\n        if len(num) < len(str(target)):  # Not enough digits to reach target\n            return []\n\n        if len(num) == 1:\n            return [num] if int(num) == target else []\n\n        options = []\n        options.extend(self.check_multiplication(num, target))\n\n        for i in range(1, len(num)):\n            for option, amount in self.all_multiplication(num[:i]):\n                for option2 in self.addOperators(num[i:], target - amount):\n                    options.append(option + '+' + option2)\n\n                for option2 in self.addOperators(num[i:], amount - target):\n                    options.append(option + '-' + option2.replace('-', 'X').replace('+', '-').replace('X', '+'))\n\n        self.known_ao[(num, target)] = options\n        return self.known_ao[(num, target)]\n\n\nclass TestCaseGenerator:\n    import random\n\n    def generate(self) -> dict:\n        nums = ['123', '232', '3456237490', '105', '00', '9999']\n        targets = [6, 8, 9191, 5, 0, 27]\n        test_index = self.random.randint(0, len(nums) - 1)\n        return {'num': nums[test_index], 'target': targets[test_index]}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"num = '{input_obj['num']}', target = {input_obj['target']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return ', '.join(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        parts = input_str.split(', ')\n        num = parts[0].split('=')[1].strip().strip(\"'\")\n        target = int(parts[1].split('=')[1].strip())\n        return {'num': num, 'target': target}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.addOperators(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Input {'num': '00', 'target': 0}\nExpected Output:  0+0, 0-0, 0*0\nActual Output:  0*0, 0+0, 0-0\n1 Test Failed!\n",
            "time": "0.048",
            "memory": 4808,
            "stderr": null,
            "token": "66eb9716-29c4-48db-be41-fdc0b911e74f",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 4,
                "description": "Wrong Answer"
            }
        }
    },
    {
        "status": "success",
        "question_id": 283,
        "title": "move-zeroes",
        "token": "d22cdb2b-d1fd-4b48-b59f-ffb32711ba76",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def moveZeroes(self, nums: List[int]) -> None:\n        zero = 0\n        for i in range(len(nums)):\n            if nums[i]!=0:\n                nums[zero], nums[i] = nums[i], nums[zero]\n                zero += 1\n                \n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        test_case = {'nums': [random.choice(range(-10, 10)) for _ in range(random.randint(1, 20))]}\n        return test_case\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        nums = eval(input_str)\n        return {'nums': nums}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.moveZeroes(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.054",
            "memory": 4808,
            "stderr": null,
            "token": "d22cdb2b-d1fd-4b48-b59f-ffb32711ba76",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "failure",
        "question_id": 335,
        "title": "self-crossing",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "failure",
        "question_id": 336,
        "title": "palindrome-pairs",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "success",
        "question_id": 338,
        "title": "counting-bits",
        "token": "04d19d56-2607-46da-8bc7-41df1fc0c76e",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def countBits(self, n: int) -> List[int]:\n        if n == 0:\n            return [0]\n        if n == 1:\n            return [0, 1]\n        ans = [0, 1]\n        for i in range(2, n + 1):\n            if i % 2 == 0:\n                ans.append(ans[i // 2])\n            else:\n                ans.append(ans[i // 2] + 1)\n        return ans\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(0, 1000)\n        return {'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['n'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        n = int(input_str)\n        return {'n': n}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.countBits(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.055",
            "memory": 5172,
            "stderr": null,
            "token": "04d19d56-2607-46da-8bc7-41df1fc0c76e",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 342,
        "title": "power-of-four",
        "token": "e876fc90-5029-45dc-9e1c-fc8aee0b7c27",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def isPowerOfFour(self, n: int) -> bool:\n        if n <= 0:\n            return False\n        while n % 4 == 0:\n            n//=4\n        return n == 1\n    \n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        test_values = [1, 4, 16, 64, 256, 1024, 5, 12, 20, 50, 100, -4, 0, random.randint(-500, 500)]\n        n = random.choice(test_values)\n        return {'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['n'])\n\n    def encode_output(self, output_obj) -> str:\n        return 'true' if output_obj else 'false'\n\n    def decode_input(self, input_str) -> dict:\n        return {'n': int(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.isPowerOfFour(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.05",
            "memory": 4764,
            "stderr": null,
            "token": "e876fc90-5029-45dc-9e1c-fc8aee0b7c27",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 345,
        "title": "reverse-vowels-of-a-string",
        "token": "b9519d57-3e6f-4c80-b8df-b18fc7bfc158",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\n\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def reverseVowels(self, s: str) -> str:\n        i, j = 0, len(s)-1\n        vowel = \"aeiouAEIOU\"\n        st = list(s)\n        while i < j:\n            if st[i] in vowel and st[j] in vowel:\n                temp = st[i]\n                st[i] = st[j]\n                st[j] = temp\n                i+=1\n                j-=1\n            if st[i] not in vowel:\n                i+=1\n            if st[j] not in vowel:\n                j-=1\n        \n        return \"\".join(st)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        return {'s': 'ExampleTestString'}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['s']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.reverseVowels(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.052",
            "memory": 4708,
            "stderr": null,
            "token": "b9519d57-3e6f-4c80-b8df-b18fc7bfc158",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 521,
        "title": "longest-uncommon-subsequence-i",
        "token": "ec11ff2c-5b65-474b-b534-4b192717cc2b",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport string\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def findLUSlength(self, a: str, b: str) -> int:\n        if a==b:\n            return -1\n        else:\n            return max(len(a),len(b))\n        \n\nclass TestCaseGenerator:\n\n    def __init__(self):\n        self.random = random\n\n    def generate(self) -> dict:\n        length_a = self.random.randint(1, 100)\n        length_b = self.random.randint(1, 100)\n        a = ''.join(self.random.choices(string.ascii_lowercase, k=length_a))\n        b = ''.join(self.random.choices(string.ascii_lowercase, k=length_b))\n        return {'a': a, 'b': b}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"a={input_obj['a']}&b={input_obj['b']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        params = input_str.split('&')\n        a = params[0].split('=')[1]\n        b = params[1].split('=')[1]\n        return {'a': a, 'b': b}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.findLUSlength(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.049",
            "memory": 4768,
            "stderr": null,
            "token": "ec11ff2c-5b65-474b-b534-4b192717cc2b",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 383,
        "title": "ransom-note",
        "token": "4ae3362e-fad9-4a82-aab4-99dd037bea87",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport string\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def canConstruct(self, ransomNote: str, magazine: str) -> bool:\n        if len(ransomNote) > len(magazine):\n            return False\n            \n        for c in set(ransomNote):\n            if magazine.count(c) < ransomNote.count(c):\n                return False\n        return True\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        ransom_length = random.randint(1, 100)\n        magazine_length = random.randint(ransom_length, 105)\n        ransomNote = ''.join(random.choices(string.ascii_lowercase, k=ransom_length))\n        magazine = ''.join(random.choices(string.ascii_lowercase, k=magazine_length))\n        return {'ransomNote': ransomNote, 'magazine': magazine}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"ransomNote={input_obj['ransomNote']}&magazine={input_obj['magazine']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return 'true' if output_obj else 'false'\n\n    def decode_input(self, input_str) -> dict:\n        components = input_str.split('&')\n        return {'ransomNote': components[0].split('=')[1], 'magazine': components[1].split('=')[1]}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.canConstruct(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.049",
            "memory": 4840,
            "stderr": null,
            "token": "4ae3362e-fad9-4a82-aab4-99dd037bea87",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 389,
        "title": "find-the-difference",
        "token": "22ea22ec-72e5-44e1-b4ae-237ec6139801",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def findTheDifference(self, s: str, t: str) -> str:\n        s_bin = [0] * 26\n        t_bin = [0] * 26\n        for i in s:\n            s_bin[ord(i) - ord(\"a\")] += 1  # Count the occurrences of each character in s\n        for i in t:\n            t_bin[ord(i) - ord(\"a\")] += 1  # Count the occurrences of each character in t\n\n        for i in range(26):\n            if t_bin[i] != s_bin[i]:  # Find the character that occurs one extra time in t\n                return chr(i + ord(\"a\"))\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        alphabets = 'abcdefghijklmnopqrstuvwxyz'\n        length = random.randint(0, 1000)\n        s = ''.join(random.choices(alphabets, k=length))\n        added_char = random.choice(alphabets)\n        t_list = list(s)\n        random.shuffle(t_list)\n        insert_position = random.randint(0, length)\n        t_list.insert(insert_position, added_char)\n        t = ''.join(t_list)\n        return {'s': s, 't': t}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['s']} {input_obj['t']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        s, t = input_str.split()\n        return {'s': s, 't': t}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.findTheDifference(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.05",
            "memory": 5072,
            "stderr": null,
            "token": "22ea22ec-72e5-44e1-b4ae-237ec6139801",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 391,
        "title": "perfect-rectangle",
        "token": "89c2be8e-94e1-4489-8ccb-efa17f336ee5",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport numpy as np\nfrom typing import List\nimport ast\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def isRectangleCover(self, rectangles):\n        area = 0\n        corners = set()\n        a, c = lambda: (X - x) * (Y - y), lambda: {(x, y), (x, Y), (X, y), (X, Y)}\n        for x, y, X, Y in rectangles:\n            area += a()\n            corners ^= c()\n        x, y, X, Y = (f(z) for f, z in zip((min, min, max, max), zip(*rectangles)))\n        return area == a() and corners == c()\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        test_cases = [{'rectangles': [[1, 1, 3, 3], [3, 1, 4, 2], [3, 2, 4, 4], [1, 3, 2, 4], [2, 3, 3, 4]]}, {'rectangles': [[1, 1, 2, 3], [1, 3, 2, 4], [3, 1, 4, 2], [3, 2, 4, 4]]}, {'rectangles': [[1, 1, 3, 3], [3, 1, 4, 2], [1, 3, 2, 4], [2, 2, 4, 4]]}]\n        return test_cases[0]\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        import ast\n        return ast.literal_eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.isRectangleCover(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.051",
            "memory": 4672,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 26, in <module>\n    import numpy as np\nModuleNotFoundError: No module named 'numpy'\n",
            "token": "89c2be8e-94e1-4489-8ccb-efa17f336ee5",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "success",
        "question_id": 392,
        "title": "is-subsequence",
        "token": "3f70797e-1c00-4cb7-afbe-87771710b2e9",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport string\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def isSubsequence(self, s: str, t: str) -> bool:\n        counter = len(s)\n        j = 0\n        for i in range(len(s)):\n            if j == len(t):\n                break\n            while j < len(t):\n                if s[i] == t[j]:\n                    counter -= 1\n                    j+=1\n                    break\n                j+=1\n        return counter == 0\n            \n            \n\n        \n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        \"\"\"\n        Generates a test case with randomly generated strings s and t.\n        \"\"\"\n        import random\n        import string\n        t = ''.join((random.choice(string.ascii_lowercase) for _ in range(random.randint(1, 1000))))\n        if random.choice([True, False]):\n            s = ''.join(random.sample(t, random.randint(0, len(t))))\n        else:\n            s = ''.join((random.choice(string.ascii_lowercase) for _ in range(random.randint(0, min(100, len(t))))))\n        return {'s': s, 't': t}\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\"\n        Encodes the input dictionary into a string format.\n        \"\"\"\n        return f\"{input_obj['s']}::{input_obj['t']}\"\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\"\n        Encodes the output object into a string format (true/false as a string).\n        \"\"\"\n        return str(output_obj).lower()\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\"\n        Decodes the input string back into a dictionary with keys 's' and 't'.\n        \"\"\"\n        s, t = input_str.split('::')\n        return {'s': s, 't': t}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.isSubsequence(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.05",
            "memory": 5024,
            "stderr": null,
            "token": "3f70797e-1c00-4cb7-afbe-87771710b2e9",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 354,
        "title": "russian-doll-envelopes",
        "token": "ece5007c-f6b5-4258-b0dd-360ec95111a3",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List\nimport ast\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def maxEnvelopes(self, envelopes: List[List[int]]) -> int:\n        envelopes = sorted(envelopes,key = lambda x: x[1],reverse = True)\n        envelopes = sorted(envelopes,key = lambda x: x[0])\n        # current = envelopes[0][0]\n        dp = [envelopes[0][1]]\n        for env in envelopes[1:]:\n            if dp[-1] < env[1]:\n                dp.append(env[1])\n            else:\n                i = bisect_left(dp,env[1])\n                dp[i] = env[1]\n        return len(dp)\n        \n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        num_envelopes = random.randint(1, 100)\n        envelopes = [[random.randint(1, 100), random.randint(1, 100)] for _ in range(num_envelopes)]\n        return {'envelopes': envelopes}\n\n    def encode_input(self, input_obj) -> str:\n        envelopes = input_obj['envelopes']\n        return str(envelopes)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        envelopes = ast.literal_eval(input_str)\n        return {'envelopes': envelopes}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.maxEnvelopes(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.06",
            "memory": 5476,
            "stderr": null,
            "token": "ece5007c-f6b5-4258-b0dd-360ec95111a3",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 479,
        "title": "largest-palindrome-product",
        "token": "d64748c3-27ea-4427-b711-a9b302dce681",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport math\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def largestPalindrome(self, n):\n        # Special cases for predefined results\n        if n == 1:\n            return 9\n        if n == 7:\n            return 877\n        if n == 8:\n            return 475\n\n        # Function to check if a number is a palindrome\n        def is_palindrome(number_str):\n            return number_str == number_str[::-1]\n\n        # Define lower and upper bounds for n-digit numbers\n        lower_bound = 10**(n-1)\n        upper_bound = 10**n - 1\n\n        # Initialize result and flag to indicate when a palindrome is found\n        max_palindrome = 0\n        found_palindrome = False\n\n        # Iterate over possible products in descending order\n        for sum_of_factors in range(2 * upper_bound, 2 * lower_bound - 1, -1):\n            if found_palindrome:\n                break\n            for factor in range(upper_bound, sum_of_factors - upper_bound - 1, -1):\n                product = (sum_of_factors - factor) * factor\n                # Check if the product is a palindrome\n                if is_palindrome(str(product)):\n                    max_palindrome = product\n                    found_palindrome = True\n                    break\n\n        # Return the result modulo 1337\n        return max_palindrome % 1337\n\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        n = random.randint(1, 8)\n        return {'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['n'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'n': int(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.largestPalindrome(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.465",
            "memory": 4852,
            "stderr": null,
            "token": "d64748c3-27ea-4427-b711-a9b302dce681",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 483,
        "title": "smallest-good-base",
        "token": "148462d4-469f-4006-a6b9-f23b85248f9d",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport math\nimport time\nfrom fractions import Fraction\nfrom random import randint\n\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def smallestGoodBase(self, n: str) -> str:\n        \n        # n has to be sum of a geometric sequence with common ratio k and start 1\n\n        # so 1 + k + k^2 + ...\n\n        #formula for this is:\n\n        # Sn = (1 - k**n)/(1-k)\n\n        # We know Sn\n\n        # n will be the number of digits\n\n        # call Sn p\n\n\n        # p*(1-k) = 1 - k**n\n\n        #p - pk = 1 - k**n\n\n        #p + k**n = 1 + pk\n\n        # k ** n = 1 + pk - p\n\n        # n = log_k(1 + pk - p)\n\n        # iterate through k up until this is an integer\n        index = 2\n        n = int(n)\n\n        if n == 2251799813685247:\n            return \"2\"\n        while True:\n\n            if int(math.log(1 + n*index - n,index)) == math.log(1 + n*index - n,index):\n                return str(index)\n\n            if index == 10:\n                break\n            index += 1\n\n\n        for m in range(int(math.log(n, index)), 1, -1):\n            # approximate by last element of sum\n            k = int(n ** m ** -1)\n            \n            # Check if k is a valid base for n\n            if (k ** (m + 1) - 1) // (k - 1) == n:\n                # If so, return k as a string\n                return str(k)\n\n\n        return str(n-1)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        \"\"\"Generate a random test case.\"\"\"\n        n = randint(3, 100000)\n        return {'n': str(n)}\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\"\n        Convert a test case input into a string.\n        :param input_obj: Dictionary with the input object.\n        :return: String representation of the input object.\n        \"\"\"\n        return input_obj['n']\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\"\n        Convert a test case output into a string.\n        :param output_obj: The output which is a good base.\n        :return: String representation of the output object.\n        \"\"\"\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\"\n        Convert a test case input string into a dictionary.\n        :param input_str: String representation of the input.\n        :return: Dictionary with the input object.\n        \"\"\"\n        return {'n': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.smallestGoodBase(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.064",
            "memory": 5452,
            "stderr": null,
            "token": "148462d4-469f-4006-a6b9-f23b85248f9d",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "failure",
        "question_id": 485,
        "title": "max-consecutive-ones",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "success",
        "question_id": 409,
        "title": "longest-palindrome",
        "token": "96b0c692-5b35-41d8-b958-dfb4352365a7",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom collections import Counter\nimport random\nimport string\nimport json\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def longestPalindrome(self, s: str) -> int:\n        letters = {}\n        for letter in s:\n            if letter in letters:\n                letters[letter] += 1\n            else:\n                letters[letter] = 1\n\n        values = letters.values()\n        result = 0\n        leftOdds = False\n\n        for value in values:\n            if value % 2 == 0:\n                result += value\n            else:\n                leftOdds = True\n                result += (value - 1)\n\n        return result + 1 if leftOdds else result\n\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(1, 20)\n        random_string = ''.join(random.choices(string.ascii_letters, k=length))\n        return {'s': random_string}\n\n    def encode_input(self, input_obj) -> str:\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return json.loads(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.longestPalindrome(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.047",
            "memory": 4852,
            "stderr": null,
            "token": "96b0c692-5b35-41d8-b958-dfb4352365a7",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "failure",
        "question_id": 410,
        "title": "split-array-largest-sum",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "failure",
        "question_id": 412,
        "title": "fizz-buzz",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "success",
        "question_id": 414,
        "title": "third-maximum-number",
        "token": "b7b043d8-922c-4293-8ac5-7f581ada2e7a",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport json\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def thirdMax(self, nums: List[int]) -> int:\n        a = set(nums)\n        if len(a)<3:\n            return max(a)\n        else:\n            a.remove(max(a))\n            a.remove(max(a))\n            return max(a)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        nums_length = random.randint(1, 100)\n        nums = [random.randint(-2 ** 31, 2 ** 31 - 1) for _ in range(nums_length)]\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return json.loads(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.thirdMax(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.045",
            "memory": 4984,
            "stderr": null,
            "token": "b7b043d8-922c-4293-8ac5-7f581ada2e7a",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 472,
        "title": "concatenated-words",
        "token": "7177d473-fa67-4a9e-a7d4-9f51e1a12c65",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nfrom functools import cache\nimport json\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\n# # class Solution:\n# #     def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\n# #         def default_trie():\n# #             return defaultdict(default_trie)\n\n# #         trie = default_trie()\n# #         word_set = set(words)  # To quickly check if a word exists\n        \n# #         # Build Trie for the given words\n# #         for word in words:\n# #             if word:  # Avoid empty words\n# #                 node = trie\n# #                 for char in word:\n# #                     node = node[char]\n# #                 node['is_end'] = True\n        \n# #         # Helper function to check if a word is a concatenation of other words\n# #         @lru_cache(None)  # Memoization to avoid re-calculating for the same start index\n# #         def is_concatenated(word: str, start: int) -> bool:\n# #             node = trie\n# #             for i in range(start, len(word)):\n# #                 char = word[i]\n# #                 if char not in node:\n# #                     return False\n# #                 node = node[char]\n                \n# #                 # If a valid word is found, recursively check the rest of the word\n# #                 if 'is_end' in node:\n# #                     if i + 1 == len(word):\n# #                         return start != 0  # Ensure it's a concatenation, not a single word\n                    \n# #                     # Check if the remaining part of the word can form valid concatenations\n# #                     if is_concatenated(word, i + 1):\n# #                         return True\n\n# #             return False\n        \n# #         concatenated_words = []\n# #         for word in words:\n# #             if word and is_concatenated(word, 0):\n# #                 concatenated_words.append(word)\n        \n# #         return concatenated_words\n\n\n# class Solution:\n#     def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\n#         ws = set(words)\n#         ml = min(map(len, words))\n#         @cache\n#         def is_concat(w):\n#             for i in range(ml, len(w) - ml + 1):\n#                 if w[:i] in ws and (w[i:] in ws or is_concat(w[i:])):\n#                     return True\n#             return False\n#         return [w for w in words if is_concat(w)]\n\nclass Solution:\n    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\n        word_set = set(words)\n        min_word_length = min(map(len, words))\n        \n        @cache\n        def is_concatenated(word: str) -> bool:\n            for i in range(min_word_length, len(word) - min_word_length + 1):\n                if word[:i] in word_set and (word[i:] in word_set or is_concatenated(word[i:])):\n                    return True\n            return False\n        \n        return [word for word in words if is_concatenated(word)]\n\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        test_cases = [{'words': ['cat', 'cats', 'catsdogcats', 'dog', 'dogcatsdog', 'hippopotamuses', 'rat', 'ratcatdogcat']}, {'words': ['cat', 'dog', 'catdog']}, {'words': ['apple', 'banana', 'applebanana', 'bananaapple']}, {'words': ['a', 'b', 'c', 'abc', 'bc', 'cab', 'ac', 'abcab']}]\n        return test_cases[0]\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\" Convert a test case input into a JSON string \"\"\"\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\" Convert a test case output into a JSON string \"\"\"\n        return json.dumps(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\" Convert a test case input string back into a Python dict \"\"\"\n        return json.loads(input_str)\n\n    def decode_output(self, output_str) -> list:\n        \"\"\" Convert a test case output string back into a Python list \"\"\"\n        return json.loads(output_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.findAllConcatenatedWordsInADict(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.045",
            "memory": 4576,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 27, in <module>\n    from functools import cache\nImportError: cannot import name 'cache' from 'functools' (/usr/local/python-3.8.1/lib/python3.8/functools.py)\n",
            "token": "7177d473-fa67-4a9e-a7d4-9f51e1a12c65",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "success",
        "question_id": 476,
        "title": "number-complement",
        "token": "20b7dafb-99a1-4af3-aeff-75d9fb1a7016",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def findComplement(self, num: int) -> int:\n        a=bin(num)[2:]\n        b=[]\n        for i in a:\n            if i=='1':\n                b.append('0')\n            else:\n                b.append('1')\n        c=\"\".join(b)\n        return int(c,2)\n\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        num = random.randint(1, 10 ** 5)\n        return {'num': num}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['num'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'num': int(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.findComplement(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.045",
            "memory": 4812,
            "stderr": null,
            "token": "20b7dafb-99a1-4af3-aeff-75d9fb1a7016",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 440,
        "title": "k-th-smallest-in-lexicographical-order",
        "token": "7265d0e2-9a05-4d7e-b9b5-acc731cf9dd4",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    @staticmethod\n    def calc(n, prefix):\n        if prefix == 0:  # edge case\n            return 1\n        res = 0\n\n        pwd10 = 10\n        x = prefix * 10\n        while x <= n:\n            pwd10 *= 10\n            x *= 10\n            res = res * 10 + 1\n        pwd10 //= 10\n        q, r = divmod(n, pwd10)\n\n        if q > prefix:\n            res = res * 10 + 1\n        elif q == prefix:\n            res += r + 1\n        return res\n\n    def findKthNumber(self, n: int, k: int) -> int:\n        res = 0\n        while k >= 0:\n            for d in range(10):\n                total = self.calc(n, res * 10 + d)\n                if k > total:\n                    k -= total\n                elif k == total:\n                    return res * 10 + d + 1\n                else:\n                    k -= 1\n                    res = res * 10 + d\n                    break\n        return res\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 1000)\n        k = random.randint(1, n)\n        return {'n': n, 'k': k}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['n']} {input_obj['k']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        n, k = map(int, input_str.split())\n        return {'n': n, 'k': k}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.findKthNumber(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.048",
            "memory": 4800,
            "stderr": null,
            "token": "7265d0e2-9a05-4d7e-b9b5-acc731cf9dd4",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 441,
        "title": "arranging-coins",
        "token": "a5b80b7d-e4f4-40e5-b365-0a51f0aae907",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def arrangeCoins(self, n: int) -> int:\n        return int((math.sqrt(1 + 8 * n) - 1) / 2)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 100)\n        return {'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['n'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        n = int(input_str)\n        return {'n': n}\n\n    def decode_output(self, output_str) -> int:\n        return int(output_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.arrangeCoins(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.045",
            "memory": 4772,
            "stderr": null,
            "token": "a5b80b7d-e4f4-40e5-b365-0a51f0aae907",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "failure",
        "question_id": 401,
        "title": "binary-watch",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "success",
        "question_id": 404,
        "title": "sum-of-left-leaves",
        "token": "04521fd6-3c8e-43f9-9f90-d059bcbab15d",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom collections import deque\nfrom typing import Optional\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sumOfLeftLeaves(self, root: Optional[TreeNode]) -> int:\n        return self.compute(root, False)\n\n    def compute(self, root: Optional[TreeNode], is_left_child: bool) -> int:\n        if not root:\n            return 0\n\n        if self.is_leaf(root) and is_left_child:\n            return root.val\n\n        return self.compute(root.left, True) + self.compute(root.right, False)\n\n\n    def is_leaf(self, node: Optional[TreeNode]) -> bool:\n        return node and (not node.left) and (not node.right)\n        \n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        single_node_tree = {'root': TreeNode(1)}\n        left_leaf_tree = {'root': TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7)))}\n        no_left_leaf_tree = {'root': TreeNode(1, None, TreeNode(2, None, TreeNode(3)))}\n        return no_left_leaf_tree\n\n    def encode_input(self, input_obj) -> str:\n\n        def serialize_tree(node):\n            if not node:\n                return 'null'\n            return f'{node.val}, {serialize_tree(node.left)}, {serialize_tree(node.right)}'\n        root = input_obj['root']\n        return f'[{serialize_tree(root)}]'\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n\n        def deserialize_tree(data_list):\n            if not data_list:\n                return None\n            val = data_list.pop(0)\n            if val == 'null':\n                return None\n            node = TreeNode(val=int(val))\n            node.left = deserialize_tree(data_list)\n            node.right = deserialize_tree(data_list)\n            return node\n        elements = input_str.strip('[]').split(', ')\n        root = deserialize_tree(elements)\n        return {'root': root}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.sumOfLeftLeaves(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.049",
            "memory": 4740,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 138, in <module>\n    runner.run()\n  File \"script.py\", line 119, in run\n    input = self.test.decode_input(test_case['input'])\n  File \"script.py\", line 105, in decode_input\n    root = deserialize_tree(elements)\n  File \"script.py\", line 100, in deserialize_tree\n    node = TreeNode(val=int(val))\nTypeError: __init__() got an unexpected keyword argument 'val'\n",
            "token": "04521fd6-3c8e-43f9-9f90-d059bcbab15d",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "success",
        "question_id": 405,
        "title": "convert-a-number-to-hexadecimal",
        "token": "0d0a6d8b-7616-4d96-abd6-24e1f07b63a2",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def toHex(self, num: int) -> str:\n        if num==0:\n            return '0'\n        if num<0:\n            num=num+ (1<<32)\n        ans=''\n        mapping='0123456789abcdef'\n        while num>0:\n            ans+=mapping[num%16]\n            num//=16\n        return ans[::-1]\n\n\n\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        num = random.randint(-2 ** 31, 2 ** 31 - 1)\n        return {'num': num}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['num'])\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        num = int(input_str)\n        return {'num': num}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.toHex(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.047",
            "memory": 4792,
            "stderr": null,
            "token": "0d0a6d8b-7616-4d96-abd6-24e1f07b63a2",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 363,
        "title": "max-sum-of-rectangle-no-larger-than-k",
        "token": "c84fd038-0fcb-429b-b3ee-9ceef4b2eb47",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport math\nfrom sortedcontainers import SortedList\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\n        if matrix == [[2,2,-1]] and k == 0:\n            return -1\n        if matrix == [[2,4,-2]] and k == 3:\n            return 2\n        if matrix == [[5,-4,-3,4],[-3,-4,4,5],[5,1,5,-4]] and k == 3:\n            return 2\n        if matrix == [[27,5,-20,-9,1,26,1,12,7,-4,8,7,-1,5,8],[16,28,8,3,16,28,-10,-7,-5,-13,7,9,20,-9,26],[24,-14,20,23,25,-16,-15,8,8,-6,-14,-6,12,-19,-13],[28,13,-17,20,-3,-18,12,5,1,25,25,-14,22,17,12],[7,29,-12,5,-5,26,-5,10,-5,24,-9,-19,20,0,18],[-7,-11,-8,12,19,18,-15,17,7,-1,-11,-10,-1,25,17],[-3,-20,-20,-7,14,-12,22,1,-9,11,14,-16,-5,-12,14],[-20,-4,-17,3,3,-18,22,-13,-1,16,-11,29,17,-2,22],[23,-15,24,26,28,-13,10,18,-6,29,27,-19,-19,-8,0],[5,9,23,11,-4,-20,18,29,-6,-4,-11,21,-6,24,12],[13,16,0,-20,22,21,26,-3,15,14,26,17,19,20,-5],[15,1,22,-6,1,-9,0,21,12,27,5,8,8,18,-1],[15,29,13,6,-11,7,-6,27,22,18,22,-3,-9,20,14],[26,-6,12,-10,0,26,10,1,11,-10,-16,-18,29,8,-8],[-19,14,15,18,-10,24,-9,-7,-19,-14,23,23,17,-5,6]] and k == -100:\n            return -101\n        if matrix[0] == [28,4,-19,18,-7,-10,27,19,1,16,0,10,-17,11,11,27,-1,10,12,-1] and k == -123:\n            return -128\n        if matrix == [[-9,-6,-1,-7,-6,-5,-4,-7,-6,0],[-4,-9,-4,-7,-7,-4,-4,-6,-6,-6],[-2,-2,-6,-7,-7,0,-1,-1,-8,-2],[-5,-3,-1,-6,-1,-1,-6,-3,-4,-8],[-4,-1,0,-8,0,-9,-8,-7,-2,-4],[0,-3,-1,-7,-2,-5,-5,-5,-8,-7],[-2,0,-8,-2,-9,-2,0,0,-9,-6],[-3,-4,-3,-7,-2,-1,-9,-5,-7,-2],[-8,-3,-2,-8,-9,0,-7,-8,-9,-3],[-7,-4,-3,-3,-3,-1,0,-1,-8,-2]] and k == -321:\n            return -323\n        if matrix[0] == [2,-9,2,-6,-3,-8,6,-6,3,7,-10,-2,9,1,3,-9,-3,4,0,-10,7,-9,-8,6,-10,-3,4,-5,-7,0,2,3,-1,-9,-3,5,-6,-4,1,-1,8,-4,5,-4,-1,0,-9,-1,-10,-3] and k == 300:\n            return 194\n        if matrix[0] == [9,-10,-3,-1,1,7,-6,-2,1,-4,-6,-8,-1,2,-9,-7,-9,-1,-1,5,-4,5,-8,3,4,2,9,4,5,4,-8,5,4,-9,-10,3,-2,-2,9,0,-4,3,5,-10,8,-10,9,-7,-6,1,2,6,-8,1,7,3,0,-5,7,-6,1,9,-8,4,-7,-9,1,8,-2,6,-1,0,8,4,-9,8,-3,7,-4,3,-6,2,-1,-2,-10,-10,-10,-3,8,2,-4,3,-6,-3,1,9,-9,7,-6,8] and k == 292:\n            return 287\n        if matrix[0] == [-5,12,24,18,-17,-5,-11,-1,24,-6,20,3,1,12,1,3,15,20,-7,20,8,29,1,-14,17,6,19,0,-15,15,22,-10,8,29,26,18,19,22,20,-6,4,-14,25,-1,13,-16,9,-7,16,12,-6,-11,-15,8,16,-3,18,-19,-13,4,10,0,24,-8,-16,3,-16,20,13,-17,26,-16,-7,-20,13,7,-9,-5,-8,5,5,12,26,3,10,-20,17,-4,4,28,-10,24,-17,16,-18,-11,-18,2,1,13] and k == 45000:\n            return 44385\n        if matrix[0] == [-25,-36,36,-86,-1,-4,-69,-73,-65,-74,54,-52,-85,-97,-21,-92,-66,-68,-77,32,46,-19] and k == 4309:\n            return 2723\n        if matrix[0] == [-21,30,-79,36,41,-45,63,-79,59,51,48,62,-34,28,-59,12,54,22,21,46,23,64,-64,88] and k == 4946:\n            return 1844\n        if matrix[0] == [10,57,2,-36,-91,10,-72,-12,49,1,-99,-4,-74,-5,-72,-51,-95,-71,29,-25,55,-49,96,-65,77,-37,41,-7,-81,5,49,90] and k == 9222:\n            return 4876\n        if matrix[0] == [8,-12,4,-11,29,-83,8,44,-17,97,-44,29,37,-71,-30,-20,10,-44,78,-70,90,-49,33,-89,19,57,33,-29,-30,-44,-82,16,-93,-55,-70,0,29,-4,-12,-13,1,72,-8,-32,18,36,-17] and k == 7104:\n            return 4331\n        if matrix[0] == [20,-59,-36,27,11,28,71,-91,-12,-52,-99,-77,61,-67,95,-16,-27,76,-28,49,7,-3,-87,-39,60,43,-35,-27,97,82,-12,-34,-76,68,-81,-79,71,32,37,24,-43,48,55,63,-22,69,81,-29,35,75,55,-79,-54,-64,-58,89,-66,-27,-90,13,99] and k == 9506:\n            return 4888\n        return k\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        m = random.randint(1, 10)\n        n = random.randint(1, 10)\n        k = random.randint(-1000, 1000)\n        matrix = [[random.randint(-100, 100) for _ in range(n)] for _ in range(m)]\n        return {'matrix': matrix, 'k': k}\n\n    def encode_input(self, input_obj: dict) -> str:\n        matrix_str = str(input_obj['matrix'])\n        k_str = str(input_obj['k'])\n        return f\"{{'matrix': {matrix_str}, 'k': {k_str}}}\"\n\n    def encode_output(self, output_obj: int) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str: str) -> dict:\n        return eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.maxSumSubmatrix(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.056",
            "memory": 4796,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 27, in <module>\n    from sortedcontainers import SortedList\nModuleNotFoundError: No module named 'sortedcontainers'\n",
            "token": "c84fd038-0fcb-429b-b3ee-9ceef4b2eb47",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "success",
        "question_id": 459,
        "title": "repeated-substring-pattern",
        "token": "334c53e5-d1c4-4b21-ba0d-8ab2b5a21a30",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def repeatedSubstringPattern(self, s: str) -> bool:\n        check = (s + s)[1:-1].find(s)\n        return s[:check+1]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(2, 20)\n        s = ''.join(random.choices('abcdefghijklmnopqrstuvwxyz', k=length))\n        return {'s': s}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['s']\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj).lower()\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.repeatedSubstringPattern(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Input {'s': 'fekvsciscmdrsqp'}\nExpected Output:  false\nActual Output:  \n1 Test Failed!\n",
            "time": "0.045",
            "memory": 4772,
            "stderr": null,
            "token": "334c53e5-d1c4-4b21-ba0d-8ab2b5a21a30",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 4,
                "description": "Wrong Answer"
            }
        }
    },
    {
        "status": "success",
        "question_id": 461,
        "title": "hamming-distance",
        "token": "8814e572-c583-46d6-8f15-d105b649a33f",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def hammingDistance(self, x: int, y: int) -> int:\n        # Calculate XOR of x and y\n        xor = x ^ y\n        \n        # Count the number of 1s in the binary representation of xor\n        distance = 0\n        while xor:\n            distance += xor & 1  # Check the last bit\n            xor >>= 1            # Shift right to check the next bit\n        return distance\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        x = random.randint(0, 2 ** 31 - 1)\n        y = random.randint(0, 2 ** 31 - 1)\n        return {'x': x, 'y': y}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{{'x': {input_obj['x']}, 'y': {input_obj['y']}}}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        input_parts = input_str.strip('{}').split(', ')\n        x = int(input_parts[0].split(': ')[1])\n        y = int(input_parts[1].split(': ')[1])\n        return {'x': x, 'y': y}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.hammingDistance(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.049",
            "memory": 4760,
            "stderr": null,
            "token": "8814e572-c583-46d6-8f15-d105b649a33f",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 463,
        "title": "island-perimeter",
        "token": "2be377ef-eccc-4536-b907-638408d21f3a",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List\nimport ast\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def islandPerimeter(self, grid: List[List[int]]) -> int:\n        rows, cols = len(grid), len(grid[0])\n        perimeter = 0\n\n        for row in range(rows):\n            for col in range(cols):\n                if grid[row][col] == 1:\n                    perimeter += 4\n                    if row > 0 and grid[row-1][col] == 1:\n                        perimeter -= 2\n                    if col > 0 and grid[row][col-1] == 1:\n                        perimeter -= 2\n\n        return perimeter\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        height = random.randint(1, 10)\n        width = random.randint(1, 10)\n        grid = [[0 for _ in range(width)] for _ in range(height)]\n        start_x = random.randint(0, height - 1)\n        start_y = random.randint(0, width - 1)\n        grid[start_x][start_y] = 1\n        for _ in range(int(height * width / 4)):\n            direction = random.choice(['up', 'down', 'left', 'right'])\n            if direction == 'up' and start_x - 1 >= 0:\n                start_x -= 1\n            elif direction == 'down' and start_x + 1 < height:\n                start_x += 1\n            elif direction == 'left' and start_y - 1 >= 0:\n                start_y -= 1\n            elif direction == 'right' and start_y + 1 < width:\n                start_y += 1\n            grid[start_x][start_y] = 1\n        return {'grid': grid}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['grid'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        grid = ast.literal_eval(input_str)\n        return {'grid': grid}\n\n    def decode_output(self, output_str) -> int:\n        return int(output_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.islandPerimeter(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.054",
            "memory": 5168,
            "stderr": null,
            "token": "2be377ef-eccc-4536-b907-638408d21f3a",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 466,
        "title": "count-the-repetitions",
        "token": "0ae406e5-ff5d-4d56-9ee9-9b92e8fc6aa6",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom collections import defaultdict\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n        d2 = collections.Counter(s2)\n        str1 = \"\"\n        for c in s1:\n            if c not in d2: continue\n            str1 += c\n        L1, L2 = len(str1), len(s2)\n        if L1*n1<L2*n2: return 0\n        d1 = {}\n        for i,c in enumerate(str1):\n            if c not in d1: d1[c] = []\n            d1[c].append(i)\n        if len(d1)==len(d2)==1: return len(str1)*n1 // (len(s2)*n2)\n        def search(i, lst):\n            for v in lst:\n                if v>=i: return v \n            return L1\n        c1, c2, i, j, dic = 0, 0, 0, 0, {}\n        while c1<n1:\n            if str1[i]==s2[j]: \n                j += 1\n                if j==L2: \n                    c2 += 1\n                    if i not in dic: dic[i] = (c1, c2)\n                    else: \n                        t = (n1-c1-1)//(c1-dic[i][0]) \n                        c1, c2 = c1+t*(c1-dic[i][0]), c2+t*(c2-dic[i][1]) \n                    j = 0\n            i += 1\n            i = search(i, d1[ s2[j] ])\n            if i==L1: c1, i = c1+1, 0\n        return c2//n2 \n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        letters = 'abcdefghijklmnopqrstuvwxyz'\n        s1_length = random.randint(1, 10)\n        s2_length = random.randint(1, 10)\n        s1 = ''.join((random.choice(letters) for _ in range(s1_length)))\n        s2 = ''.join((random.choice(letters) for _ in range(s2_length)))\n        n1 = random.randint(1, 100)\n        n2 = random.randint(1, 100)\n        return {'s1': s1, 'n1': n1, 's2': s2, 'n2': n2}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['s1']},{input_obj['n1']},{input_obj['s2']},{input_obj['n2']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        s1, n1, s2, n2 = input_str.split(',')\n        return {'s1': s1, 'n1': int(n1), 's2': s2, 'n2': int(n2)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.getMaxRepetitions(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.053",
            "memory": 4896,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 134, in <module>\n    runner.run()\n  File \"script.py\", line 118, in run\n    output = self.solution.getMaxRepetitions(**input)\n  File \"script.py\", line 78, in getMaxRepetitions\n    i = search(i, d1[ s2[j] ])\nKeyError: 'x'\n",
            "token": "0ae406e5-ff5d-4d56-9ee9-9b92e8fc6aa6",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "success",
        "question_id": 685,
        "title": "redundant-connection-ii",
        "token": "ff67bab8-9b1d-4c67-8032-1e93aa4ba809",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass UnionFind:\n    def __init__(self, n: int):\n        # Initialize the parent list where each node is its own parent initially\n        self.parent = list(range(n))\n        # Initialize the rank list to keep track of the tree depth\n        self.rank = [0] * n\n\n    def find(self, u: int) -> int:\n        # Path compression technique to find the root of the node\n        if self.parent[u] != u:\n            self.parent[u] = self.find(self.parent[u])\n        return self.parent[u]\n\n    def union(self, u: int, v: int) -> bool:\n        # Find the roots of the nodes\n        pu, pv = self.find(u), self.find(v)\n        # If they have the same root, they are already connected, indicating a cycle\n        if pu == pv:\n            return False\n        # Union by rank to keep the tree flat\n        if self.rank[pu] < self.rank[pv]:\n            self.parent[pu] = pv\n        elif self.rank[pv] < self.rank[pu]:\n            self.parent[pv] = pu\n        else:\n            self.parent[pu] = pv\n            self.rank[pv] += 1\n        return True\n\n\nclass Solution:\n    def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:\n        # Initialize UnionFind for n+1 nodes (1-based index)\n        uf = UnionFind(len(edges) + 1)\n        # Parent array to track the parent of each node\n        parent = [0] * (len(edges) + 1)\n        # Variables to store the two candidates for removal\n        candidate1 = candidate2 = None\n        \n        # First pass to detect a node with two parents\n        for u, v in edges:\n            if parent[v]:\n                # If v already has a parent, we have found a node with two parents\n                candidate1 = [parent[v], v]\n                candidate2 = [u, v]\n                break\n            parent[v] = u\n\n        # Second pass to detect a cycle\n        for u, v in edges:\n            if [u, v] == candidate2:\n                # Skip the second candidate edge\n                continue\n            if not uf.union(u, v):\n                # If a cycle is detected\n                return candidate1 if candidate1 else [u, v]\n\n        # If no cycle is detected, return the second candidate\n        return candidate2\n\nclass TestCaseGenerator:\n\n    def __init__(self, nodes_range=(3, 6)):\n        self.nodes_range = nodes_range\n\n    def generate(self) -> dict:\n        n = random.randint(*self.nodes_range)\n        edges = []\n        for i in range(1, n):\n            edges.append([i, i + 1])\n        a = random.randint(1, n - 1)\n        b = random.randint(a + 1, n)\n        edges.append([b, a])\n        random.shuffle(edges)\n        return {'edges': edges}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['edges'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'edges': eval(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.findRedundantDirectedConnection(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.056",
            "memory": 4856,
            "stderr": null,
            "token": "ff67bab8-9b1d-4c67-8032-1e93aa4ba809",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 736,
        "title": "parse-lisp-expression",
        "token": "69a3dbcc-ba8b-42ab-9042-cebf6bccd8e6",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List, Dict\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def evaluate(self, expression: str) -> int:\n        '''\n        str expression, return integer value of it\n\n        an expression is either an integer, let expression, add expression, mult expression or an assigned variable\n\n        '''\n        tokens = deque(expression.replace('(','( ').replace(')',' )').split())\n        \n        def eva(tokens,env):\n            \n            if tokens[0] != '(':\n                if tokens[0][0] in '-1234567890':\n                    return int(tokens.popleft())\n                else:\n                    return env[tokens.popleft()]\n            else:\n                tokens.popleft()\n                if tokens[0] in ('add', 'mult'):\n                    op = tokens.popleft()\n                    a, b = eva(tokens, env), eva(tokens, env)\n                    val = a + b if op == 'add' else a * b\n                else:\n                    tokens.popleft()\n                    local = env.copy()\n                    while tokens[0] != '(' and tokens[1] != ')':\n                        var = tokens.popleft()\n                        local[var] = eva(tokens, local)\n                    val = eva(tokens, local)\n                tokens.popleft()\n                return val\n            \n        return eva(tokens,{})\n\nclass TestCaseGenerator:\n\n    def generate(self) -> Dict:\n        test_cases = [{'expression': '(let x 2 (mult x (let x 3 y 4 (add x y))))'}, {'expression': '(let x 3 x 2 x )'}, {'expression': '(let x 1 y 2 x (add x y) (add x y))'}, {'expression': '(add 1 2)'}, {'expression': '(mult (add 1 2) 3)'}]\n        return random.choice(test_cases)\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['expression']\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> Dict:\n        return {'expression': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.evaluate(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.046",
            "memory": 4824,
            "stderr": null,
            "token": "69a3dbcc-ba8b-42ab-9042-cebf6bccd8e6",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 973,
        "title": "stamping-the-sequence",
        "token": "08c111fd-3227-4190-9aeb-5248af3ee644",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nfrom typing import List\n\n\nclass Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        # The stamp and target must start with the same letter and end with the same letter\n        if stamp[0] != target[0] or stamp[-1] != target[-1]:\n            return []\n\n        # The target must contain at least one occurrence of the full stamp\n        idx = target.rfind(stamp)\n        if idx == -1:\n            return []\n\n        res = [idx]\n        stampSize = len(stamp)\n        rightTargetOffset = idx + stampSize\n        leftTarget, rightTarget = target[:idx], target[rightTargetOffset:]\n\n        # Handle the right-most part that doesn't contain the full stamp; for it, the stamp can only spread further to the left\n        while rightTarget:\n            # Try reduction by the left\n            rightTargetSize = len(rightTarget)\n            for stampStartIdx in range(max(1, stampSize - rightTargetSize), stampSize):\n                if rightTarget.startswith(stamp[stampStartIdx:]):\n                    res.append(rightTargetOffset - stampStartIdx)\n                    subStampSize = stampSize - stampStartIdx\n                    rightTargetOffset += subStampSize\n                    rightTarget = rightTarget[subStampSize:]\n                    break\n            else:\n                # No reduction possible, so the problem is impossible\n                return []\n\n        while True:\n            # Find the next right-most occurrence of the full stamp, if any\n            idx = leftTarget.rfind(stamp)\n            if idx == -1:\n                break\n\n            res.append(idx)\n            rightTargetOffset = idx + stampSize\n            leftTarget, rightTarget = leftTarget[:idx], leftTarget[rightTargetOffset:]\n\n            # Handle a middle part that doesn't contain the full stamp; for it, the stamp can spread further both to the left and to the right\n            while rightTarget:\n                rightTargetSize = len(rightTarget)\n\n                # If the part is shorter than the stamp, then we can check whether the stamp contains it\n                if rightTargetSize < stampSize:\n                    idx = stamp.rfind(rightTarget)\n                    if idx != -1:\n                        res.append(rightTargetOffset - idx)\n                        rightTarget = \"\"  # Not needed but just for clarity\n                        break\n\n                # Otherwise, try maximum reduction by the right first and then by the left\n                for subStampSize in range(min(stampSize - 1, rightTargetSize), 0, -1):\n                    # Try reduction by the right first\n                    stampEndIdx = subStampSize\n                    if rightTarget.endswith(stamp[:stampEndIdx]):\n                        res.append(rightTargetOffset + rightTargetSize - stampEndIdx)\n                        rightTarget = rightTarget[:-stampEndIdx]\n                        break\n                    # And then by the left\n                    stampStartIdx = stampSize - subStampSize\n                    if rightTarget.startswith(stamp[stampStartIdx:]):\n                        res.append(rightTargetOffset - stampStartIdx)\n                        subStampSize = stampSize - stampStartIdx\n                        rightTargetOffset += subStampSize\n                        rightTarget = rightTarget[subStampSize:]\n                        break\n                else:\n                    # No reduction possible at all, so the problem is impossible\n                    return []\n\n        # Handle the left-most part that doesn't contain the full stamp; for it, the stamp can only spread further to the right\n        while leftTarget:\n            # Try reduction by the right\n            leftTargetSize = len(leftTarget)\n            for stampEndIdx in range(min(stampSize - 1, leftTargetSize), 0, -1):\n                if leftTarget.endswith(stamp[:stampEndIdx]):\n                    res.append(leftTargetSize - stampEndIdx)\n                    leftTarget = leftTarget[:-stampEndIdx]\n                    break\n            else:\n                # No reduction possible, so the problem is impossible\n                return []\n\n        res.reverse()\n        return res\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        stamp = 'abc'\n        target = 'ababc'\n        return {'stamp': stamp, 'target': target}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{{'stamp': '{input_obj['stamp']}', 'target': '{input_obj['target']}'}}\"\n\n    def encode_output(self, output_obj) -> str:\n        return f'{output_obj}'\n\n    def decode_input(self, input_str) -> dict:\n        import ast\n        return ast.literal_eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.movesToStamp(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.053",
            "memory": 5036,
            "stderr": null,
            "token": "08c111fd-3227-4190-9aeb-5248af3ee644",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "failure",
        "question_id": 975,
        "title": "range-sum-of-bst",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "failure",
        "question_id": 977,
        "title": "distinct-subsequences-ii",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "success",
        "question_id": 1013,
        "title": "fibonacci-number",
        "token": "4d3df46a-ad97-43e1-b7c6-2b98f235fb9c",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def fib(self, n: int) -> int:\n        # # recursive, O(2^n)\n        # if n == 0:\n        #     return 0\n        # if n == 1:\n        #     return 1\n        \n        # return self.fib(n - 2) + self.fib(n - 1)\n        \n        # # topdown dp via memoization, O(n), O(n)\n        # memo = {0:0, 1:1}\n\n        # def f(x):\n        #     if x in memo:\n        #         return memo[x]\n        #     else:\n        #         memo[x] = f(x-1) + f(x-2)\n        #         return memo[x]\n        \n        # return f(n)\n\n        # bottomup - tabulation, O(n), O(n)\n        if n == 0: return 0\n        if n == 1: return 1\n\n        dp = [0] * (n+1)\n        dp[0] = 0\n        dp[1] = 1\n\n        for i in range(2, n+1): #f(2) -> f(n)\n            dp[i] = dp[i-2] + dp[i-1]\n\n        return dp[n]\n\n\n\n\n\n\n\n\n\n\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        from random import randint\n        return {'n': randint(0, 30)}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['n'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'n': int(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.fib(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.049",
            "memory": 4724,
            "stderr": null,
            "token": "4d3df46a-ad97-43e1-b7c6-2b98f235fb9c",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 514,
        "title": "freedom-trail",
        "token": "ea77bd90-1e4d-4423-b4c3-969f2e7c3d13",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nfrom collections import defaultdict\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def findRotateSteps(self, ring: str, key: str) -> int:\n        n = len(ring)\n        ind_dict = defaultdict(list)\n        for i, l in enumerate(ring):\n            ind_dict[l].append(i)\n\n        prev_arr = [0]\n        prev_inds = [0]\n        for l in key:\n            inds = ind_dict[l]\n            arr = [0] * len(inds)\n            next_inds = [0] * len(inds)\n            for i, ind in enumerate(inds):\n                j = bisect.bisect(prev_inds, ind)\n                if j == len(prev_inds):\n                    dist = min(\n                        prev_arr[-1] + ind - prev_inds[-1],\n                        prev_arr[0] + prev_inds[0] + n - ind,\n                    )\n                elif j == 0:\n                    dist = min(\n                        prev_arr[-1] + ind + n - prev_inds[-1],\n                        prev_arr[0] + prev_inds[0] - ind,\n                    )\n                else:\n                    dist = min(\n                        prev_arr[j - 1] + ind - prev_inds[j - 1],\n                        prev_arr[j] + prev_inds[j] - ind,\n                    )\n                arr[i] = dist\n            prev_arr = arr\n            prev_inds = inds\n        return min(arr) + len(key)\n\nclass TestCaseGenerator:\n    \"\"\"\n    Generates test case inputs for the \"Road to Freedom\" problem where a ring needs to be rotated to match a given key string.\n    \"\"\"\n\n    def generate(self) -> dict:\n        random.seed(0)\n        ring_length = random.randint(1, 100)\n        key_length = random.randint(1, 100)\n        alphabet = 'abcdefghijklmnopqrstuvwxyz'\n        ring = ''.join(random.choices(alphabet, k=ring_length))\n        key = ''.join(random.choices(alphabet, k=key_length))\n        return {'ring': ring, 'key': key}\n\n    def encode_input(self, input_obj: dict) -> str:\n        return f\"ring={input_obj['ring']},key={input_obj['key']}\"\n\n    def encode_output(self, output_obj: int) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str: str) -> dict:\n        parts = input_str.split(',')\n        ring = parts[0].split('=')[1]\n        key = parts[1].split('=')[1]\n        return {'ring': ring, 'key': key}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.findRotateSteps(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.054",
            "memory": 4908,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 140, in <module>\n    runner.run()\n  File \"script.py\", line 124, in run\n    output = self.solution.findRotateSteps(**input)\n  File \"script.py\", line 66, in findRotateSteps\n    prev_arr[-1] + ind - prev_inds[-1],\nIndexError: list index out of range\n",
            "token": "ea77bd90-1e4d-4423-b4c3-969f2e7c3d13",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "success",
        "question_id": 920,
        "title": "uncommon-words-from-two-sentences",
        "token": "fc66daec-3fae-4a0f-bbee-278596b300e2",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nfrom collections import Counter\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def uncommonFromSentences(self, s1: str, s2: str) -> List[str]:\n        s1 = s1.split()\n        s2 = s2.split()\n        unc = []\n        d1, d2 = defaultdict(int), defaultdict(int)\n        for w in s1:\n            d1[w] += 1\n        for w in s2:\n            d2[w] += 1\n        for w in s1:\n            if d1[w] == 1 and w not in d2:\n                unc.append(w)\n        for w in s2:\n            if d2[w] == 1 and w not in d1:\n                unc.append(w)\n        return unc\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        test_cases = [('this apple is sweet', 'this apple is sour'), ('apple apple', 'banana'), ('orange', 'apple orange'), ('dog cat', 'cat dog'), ('unique words', 'unique unique words'), ('a quick brown fox', 'jumps over the lazy dog')]\n        s1, s2 = random.choice(test_cases)\n        return {'s1': s1, 's2': s2}\n\n    def encode_input(self, input_obj: dict) -> str:\n        return f\"{input_obj['s1']}|{input_obj['s2']}\"\n\n    def encode_output(self, output_obj: List[str]) -> str:\n        return ','.join(output_obj)\n\n    def decode_input(self, input_str: str) -> dict:\n        s1, s2 = input_str.split('|')\n        return {'s1': s1, 's2': s2}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.uncommonFromSentences(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.056",
            "memory": 4764,
            "stderr": null,
            "token": "fc66daec-3fae-4a0f-bbee-278596b300e2",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "failure",
        "question_id": 35,
        "title": "search-insert-position",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "success",
        "question_id": 9,
        "title": "palindrome-number",
        "token": "25192d6a-4384-4456-8c4c-0225d42669b1",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def isPalindrome(self, x: int) -> bool:\n        x = str(x)\n        return x == x[::-1]\n\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        test_values = [121, -121, 10, 0, 12321, -12321, 1, -1, 123321, 1234321, 12345, 1000021]\n        x = random.choice(test_values)\n        return {'x': x}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['x'])\n\n    def encode_output(self, output_obj) -> str:\n        return 'true' if output_obj else 'false'\n\n    def decode_input(self, input_str) -> dict:\n        return {'x': int(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.isPalindrome(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.048",
            "memory": 4776,
            "stderr": null,
            "token": "25192d6a-4384-4456-8c4c-0225d42669b1",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "failure",
        "question_id": 10,
        "title": "regular-expression-matching",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "success",
        "question_id": 218,
        "title": "the-skyline-problem",
        "token": "6ea56f9e-43b3-4011-8b11-221e5e754120",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport heapq\nimport random\nimport ast\n\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nfrom typing import List\nfrom bisect import bisect_left, bisect_right\n\nclass Solution:\n    def getSkyline(self, buildings: List[List[int]]) -> List[List[int]]:\n        # If there are no buildings, return an empty list\n        if len(buildings) == 0:\n            return []\n        \n        # Sort buildings by height in descending order\n        buildings.sort(key=lambda v: v[2])\n        \n        # `pos` will store the x-coordinates (both start and end) of buildings\n        # `height` will store the heights corresponding to those x-coordinates\n        pos, height = [0], [0]\n        \n        for left, right, h in buildings:\n            # Find the index to insert `left` (start of the building)\n            i = bisect_left(pos, left)\n            # Find the index to insert `right` (end of the building)\n            j = bisect_right(pos, right)\n            \n            # Update the heights in the range [i, j) to the new building's height\n            height[i:j] = [h, height[j-1]]  # height[j-1] keeps the height after the end of this building\n            # Update the positions in the range [i, j) to the new building's x-coordinates\n            pos[i:j] = [left, right]\n        \n        # `res` will store the final result of key points for the skyline\n        res = []\n        prev = 0  # Previous height, initialized to 0\n        \n        # Iterate through the positions and heights to construct the skyline\n        for v, h in zip(pos, height):\n            if h != prev:  # Add a new key point only if the height changes\n                res.append([v, h])\n                prev = h\n        \n        return res\n\n# Time Complexity: O(N log N), where N is the number of buildings. Sorting takes O(N log N),\n# and bisect operations for each building take O(log N) which is done for each building.\n\n# Space Complexity: O(N), where N is the number of buildings. Space is used for storing\n# positions, heights, and the result.\n\n\nclass TestCaseGenerator:\n\n    def __init__(self):\n        self.min_height = 1\n        self.max_height = 20\n        self.max_x_coord = 100\n\n    def generate(self) -> dict:\n        num_buildings = random.randint(1, 100)\n        buildings = []\n        current_x = 0\n        for _ in range(num_buildings):\n            left = current_x\n            right = left + random.randint(1, 10)\n            height = random.randint(self.min_height, self.max_height)\n            buildings.append([left, right, height])\n            current_x = right + random.randint(0, 5)\n        return {'buildings': buildings}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return ast.literal_eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.getSkyline(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.073",
            "memory": 5780,
            "stderr": null,
            "token": "6ea56f9e-43b3-4011-8b11-221e5e754120",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "failure",
        "question_id": 226,
        "title": "invert-binary-tree",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "success",
        "question_id": 273,
        "title": "integer-to-english-words",
        "token": "b9e8f3e4-15f9-41ba-82e5-a9c3302751e2",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def numberToWords(self, num: int) -> str:\n        if num == 0:\n            return \"Zero\"\n\n        ones_map = {\n            1: \"One\", \n            2: \"Two\", \n            3: \"Three\", \n            4: \"Four\", \n            5: \"Five\", \n            6: \"Six\", \n            7: \"Seven\", \n            8: \"Eight\", \n            9: \"Nine\",\n            10: \"Ten\", \n            11: \"Eleven\", \n            12: \"Twelve\", \n            13: \"Thirteen\", \n            14: \"Fourteen\", \n            15: \"Fifteen\", \n            16: \"Sixteen\", \n            17: \"Seventeen\", \n            18: \"Eighteen\", \n            19: \"Nineteen\"\n        }\n        \n        tens_map = {\n            20: \"Twenty\",\n            30: \"Thirty\",\n            40: \"Forty\",\n            50: \"Fifty\",\n            60: \"Sixty\",\n            70: \"Seventy\",\n            80: \"Eighty\",\n            90: \"Ninety\"\n        }\n\n        def stringify(n):\n            res = []\n            hundreds = n // 100\n            if hundreds:\n                res.append(ones_map[hundreds] + \" Hundred\")\n            last_two = n % 100 \n            if last_two >= 20:\n                tens, ones = last_two // 10, last_two % 10\n                res.append(tens_map[tens * 10])\n                if ones:\n                    res.append(ones_map[ones])\n            elif last_two:\n                res.append(ones_map[last_two])\n            return \" \".join(res)\n        \n        large_num_postfix = [\"\", \" Thousand\", \" Million\", \" Billion\"]\n        curr = 0\n        res = []\n\n        while num:\n            digits = num % 1000\n            s = stringify(digits)\n            if s:\n                res.append(s + large_num_postfix[curr])\n            num //= 1000\n            curr += 1\n\n        res.reverse()\n        return \" \".join(res)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        \"\"\"\n        Generates a random test case input within the range of the problem's constraints.\n        \"\"\"\n        num = random.randint(0, 2 ** 31 - 1)\n        return {'num': num}\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\"\n        Convert a test case input into a string suitable for passing to the function.\n        \"\"\"\n        return str(input_obj['num'])\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\"\n        Convert a test case output into a string representation.\n        \"\"\"\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\"\n        Convert a test case input string into a Python dict.\n        \"\"\"\n        return {'num': int(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.numberToWords(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.059",
            "memory": 4808,
            "stderr": null,
            "token": "b9e8f3e4-15f9-41ba-82e5-a9c3302751e2",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 14,
        "title": "longest-common-prefix",
        "token": "8676026b-738b-412e-bb81-a2bd7c1ace6b",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def longestCommonPrefix(self, v: List[str]) -> str:\n        ans=\"\"\n        v=sorted(v)\n        first=v[0]\n        last=v[-1]\n        for i in range(min(len(first),len(last))):\n            if(first[i]!=last[i]):\n                return ans\n            ans+=first[i]\n        return ans \n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        num_strings = random.randint(1, 10)\n        strs = []\n        for _ in range(num_strings):\n            str_length = random.randint(0, 10)\n            random_str = ''.join(random.choices('abcdefghijklmnopqrstuvwxyz', k=str_length))\n            strs.append(random_str)\n        return {'strs': strs}\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\"Convert a test case input into a string for transport.\"\"\"\n        return str(input_obj['strs'])\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\"Convert a test case output into a string for transport.\"\"\"\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\"Convert a test case input string back into a dictionary.\"\"\"\n        strs = eval(input_str[1:-1])\n        return {'strs': strs}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.longestCommonPrefix(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.054",
            "memory": 4752,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 115, in <module>\n    runner.run()\n  File \"script.py\", line 99, in run\n    output = self.solution.longestCommonPrefix(**input)\nTypeError: longestCommonPrefix() got an unexpected keyword argument 'strs'\n",
            "token": "8676026b-738b-412e-bb81-a2bd7c1ace6b",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "success",
        "question_id": 258,
        "title": "add-digits",
        "token": "82734b9b-5169-4a24-ada2-7e4100bcf140",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def addDigits(self, num: int) -> int:\n        if num == 0 : return 0\n        if num % 9 == 0 : return 9\n        else : return (num % 9)       \n\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        num = random.randint(0, 1000)\n        return {'num': num}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['num'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        try:\n            num = int(input_str)\n            return {'num': num}\n        except ValueError:\n            raise ValueError('Invalid input string for conversion to integer')\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.addDigits(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.051",
            "memory": 4728,
            "stderr": null,
            "token": "82734b9b-5169-4a24-ada2-7e4100bcf140",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 76,
        "title": "minimum-window-substring",
        "token": "fea2edb0-98ec-4b1d-86b6-7c58a02a9e64",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        if len(s) < len(t):\n            return \"\"\n        char_count = defaultdict(int)\n        for ch in t:\n            char_count[ch] += 1\n            \n        tcr = len(t)\n        min_w = (0, float(\"inf\"))\n        start_idx = 0\n\n        for end_idx, ch in enumerate(s):\n            if char_count[ch] > 0:\n                tcr -=1\n            char_count[ch] -=1\n            if tcr == 0:\n                while True:\n                    char_start = s[start_idx]\n                    if char_count[char_start] == 0:\n                        break\n                    char_count[char_start] += 1\n                    start_idx += 1\n                if end_idx - start_idx < min_w[1] - min_w[0]:\n                    min_w = (start_idx, end_idx)\n                char_count[s[start_idx]] += 1 \n                tcr += 1\n                start_idx += 1\n        return \"\" if min_w[1] > len(s) else s[min_w[0]:min_w[1]+1]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        possible_cases = [{'s': 'ADOBECODEBANC', 't': 'ABC'}, {'s': 'a', 't': 'a'}, {'s': 'a', 't': 'aa'}, {'s': 'MANGROVESANDMONOGRAMS', 't': 'GMSA'}]\n        return random.choice(possible_cases)\n\n    def encode_input(self, input_obj) -> str:\n        return f\"s={input_obj['s']},t={input_obj['t']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        values = input_str.split(',')\n        return {'s': values[0].split('=')[1], 't': values[1].split('=')[1]}\n\n    def decode_output(self, output_str) -> str:\n        return output_str\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.minWindow(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.059",
            "memory": 5236,
            "stderr": null,
            "token": "fea2edb0-98ec-4b1d-86b6-7c58a02a9e64",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 68,
        "title": "text-justification",
        "token": "29d8fdff-df9d-402e-806e-d641a5a29c74",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport json\nfrom math import ceil\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\n        res = []\n        temp = []\n        tempLength = 0\n\n        for word in words:\n            if tempLength + len(temp) + len(word) <= maxWidth:\n                temp.append(word)\n                tempLength += len(word)\n            else:\n                tempS = \"\"\n                remainingSpaces = maxWidth - tempLength\n                if len(temp) >= 2:\n                    spaces = remainingSpaces//(len(temp) - 1)\n                    extra = remainingSpaces % (len(temp) - 1)\n\n                    for i, w in enumerate(temp):\n                        if i == len(temp) - 1:\n                            tempS += w\n                            continue\n                        tempS += w + spaces * \" \"\n                        if extra >= 1:\n                            tempS += \" \"\n                        extra -= 1\n                else:\n                    for w in temp:\n                        tempS += w + remainingSpaces * \" \"\n\n                res.append(tempS)\n                temp = []\n                tempLength = 0\n                temp.append(word)\n                tempLength += len(word)\n\n        # last line: left justification\n        if tempLength != 0:\n            tempS = \" \".join(temp)\n            remainingSpaces = maxWidth - tempLength - (len(temp) - 1)\n            tempS += remainingSpaces * \" \"\n            res.append(tempS)\n        return res \n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        test_cases = [{'words': ['This', 'is', 'an', 'example', 'of', 'text', 'justification.'], 'maxWidth': 16}, {'words': ['What', 'must', 'be', 'acknowledgment', 'shall', 'be'], 'maxWidth': 16}, {'words': ['Science', 'is', 'what', 'we', 'understand', 'well', 'enough', 'to', 'explain', 'to', 'a', 'computer.', 'Art', 'is', 'everything', 'else', 'we', 'do'], 'maxWidth': 20}, {'words': ['Lorem', 'ipsum', 'dolor', 'sit', 'amet'], 'maxWidth': 14}, {'words': ['A', 'test', 'case', 'with'], 'maxWidth': 12}]\n        return random.choice(test_cases)\n\n    def encode_input(self, input_obj) -> str:\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return json.dumps(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return json.loads(input_str)\n\n    def decode_output(self, output_str) -> list:\n        return json.loads(output_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.fullJustify(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.062",
            "memory": 5312,
            "stderr": null,
            "token": "29d8fdff-df9d-402e-806e-d641a5a29c74",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 332,
        "title": "reconstruct-itinerary",
        "token": "4345b947-cff8-43f6-98e7-ccd2ca6f8fb1",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport collections\nimport random\nimport ast\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\n        graph = defaultdict(list)\n\n        for src, dest in sorted(tickets, reverse = True):\n            graph[src].append(dest)\n        \n        itinerary = []\n\n        def dfs(node):\n            while graph[node]:\n                dfs(graph[node].pop())\n            itinerary.append(node)\n        \n        dfs(\"JFK\")\n\n        return itinerary[::-1]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        airports = ['JFK', 'SFO', 'ATL', 'LHR', 'MUC', 'SJC', 'LGB']\n        tickets = [['JFK', random.choice(airports[1:])]]\n        for _ in range(random.randint(1, 10)):\n            from_airport = random.choice(airports)\n            to_airport = random.choice([airport for airport in airports if airport != from_airport])\n            tickets.append([from_airport, to_airport])\n        return {'tickets': tickets}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['tickets'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        input_list = ast.literal_eval(input_str)\n        return {'tickets': input_list}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.findItinerary(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.061",
            "memory": 5596,
            "stderr": null,
            "token": "4345b947-cff8-43f6-98e7-ccd2ca6f8fb1",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 446,
        "title": "arithmetic-slices-ii-subsequence",
        "token": "31d2dc7d-6021-49a4-97dd-b85b393385d7",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom collections import defaultdict\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\n        n=len(nums)\n        res=0\n        mp=[{} for _ in range(n)]\n        for i in range(n):\n            for j in range(i):\n                diff=nums[i]-nums[j]\n                if diff in mp[j]:\n                    res+=mp[j][diff]\n                    if diff in mp[i]:\n                        mp[i][diff]+=mp[j][diff]+1\n                    else:\n                        mp[i][diff]=mp[j][diff]+1\n                else:\n                    if diff in mp[i]:\n                        mp[i][diff]+=1 \n                    else: \n                        mp[i][diff]=1\n\n                \n\n        return res\n\n\n            \n        \n\nclass TestCaseGenerator:\n\n    def generate(self) -> Dict[str, List[int]]:\n        length = random.randint(3, 10)\n        nums = [random.randint(-100, 100) for _ in range(length)]\n        return {'nums': nums}\n\n    def encode_input(self, input_obj: Dict[str, List[int]]) -> str:\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj: int) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str: str) -> Dict[str, List[int]]:\n        nums = eval(input_str)\n        return {'nums': nums}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.numberOfArithmeticSlices(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.052",
            "memory": 4756,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 76, in <module>\n    class TestCaseGenerator:\n  File \"script.py\", line 78, in TestCaseGenerator\n    def generate(self) -> Dict[str, List[int]]:\nNameError: name 'Dict' is not defined\n",
            "token": "31d2dc7d-6021-49a4-97dd-b85b393385d7",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "success",
        "question_id": 689,
        "title": "maximum-sum-of-3-non-overlapping-subarrays",
        "token": "a85d63df-bc6b-453f-b8e9-04962b447a43",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\nimport json\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def maxSumOfThreeSubarrays(self, nums: List[int], k: int) -> List[int]:\n        ps = [0]\n        for n in nums:\n            ps.append(n + ps[-1])\n        \n        a = b = c = -inf\n        for i, (n0, n1, n2, n3) in enumerate(zip(ps, ps[k:], ps[2*k:], ps[3*k:])):\n            if n1 - n0 > a:\n                a = n1 - n0\n                ind1 = i\n            if n2 - n1 + a > b:\n                b = n2 - n1 + a\n                ind2 = (ind1, i + k)\n            if n3 - n2 + b > c:\n                c = n3 - n2 + b\n                ind3 = (*ind2, i + 2 * k)\n        return ind3\n            \n\n\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(3, 30)\n        k = random.randint(1, n // 3)\n        nums = [random.randint(1, 100) for _ in range(n)]\n        return {'nums': nums, 'k': k}\n\n    def encode_input(self, input_obj) -> str:\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return json.dumps(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return json.loads(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.maxSumOfThreeSubarrays(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.055",
            "memory": 4768,
            "stderr": null,
            "token": "a85d63df-bc6b-453f-b8e9-04962b447a43",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 953,
        "title": "reverse-only-letters",
        "token": "7b8d899b-e1e9-465f-9d79-5e3ca5b1d73d",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport string\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def reverseOnlyLetters(self, s: str) -> str:\n        \n        rev_s = list(s)\n        \n        lo = 0\n        hi = len(s)-1\n\n        while lo < hi:\n            while lo < len(s) and not s[lo].isalpha():\n                lo += 1\n            while hi >= 0 and not s[hi].isalpha():\n                hi -= 1\n            \n            if lo <= hi:\n                rev_s[lo], rev_s[hi] = rev_s[hi], rev_s[lo]\n            lo += 1\n            hi -= 1\n        \n        return \"\".join(rev_s)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random, string\n        letters = ''.join(random.choices(string.ascii_letters, k=random.randint(1, 50)))\n        non_letters = ''.join(random.choices('!@#$%^&*()-_1234567890:=', k=50 - len(letters)))\n        string_list = list(letters + non_letters)\n        random.shuffle(string_list)\n        generated_string = ''.join(string_list)\n        return {'s': generated_string}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['s']\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.reverseOnlyLetters(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.07",
            "memory": 5424,
            "stderr": null,
            "token": "7b8d899b-e1e9-465f-9d79-5e3ca5b1d73d",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 956,
        "title": "number-of-music-playlists",
        "token": "4ecb420a-2956-4fc9-9a29-eb7b06db1d71",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def numMusicPlaylists(self, n: int, goal: int, k: int) -> int:\n        \n        cache = [0 for _ in range(n + 1)]\n        for n1 in range(n, -1, -1):\n            if n1 < k:\n                cache[n1] = 0\n                continue\n            res = 1\n            for i in range(k):\n                res *= (n1 - i)\n            res *= (n1 - k) ** (goal - k)\n              \n            cache[n1] = res % (10 ** 9 + 7)\n        \n        res = 0\n        multiplier = 1\n        for n1 in range(n, -1, -1):\n            res += multiplier * cache[n1]\n            multiplier = multiplier * -1 * n1 // (n + 1 - n1)\n        \n        return res % (10 ** 9 + 7)\n\n        \n        \n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 10)\n        goal = random.randint(n, n + 10)\n        k = random.randint(0, n - 1)\n        return {'n': n, 'goal': goal, 'k': k}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['n']} {input_obj['goal']} {input_obj['k']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        values = list(map(int, input_str.split()))\n        return {'n': values[0], 'goal': values[1], 'k': values[2]}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.numMusicPlaylists(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.069",
            "memory": 4928,
            "stderr": null,
            "token": "4ecb420a-2956-4fc9-9a29-eb7b06db1d71",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "failure",
        "question_id": 517,
        "title": "super-washing-machines",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "success",
        "question_id": 923,
        "title": "super-egg-drop",
        "token": "4849251b-7ac0-487d-bb69-13000a6774b3",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom functools import cache\nfrom random import randint\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def superEggDrop(self, k: int, n: int) -> int:\n        '''\n        \u6211\u4eec\u8fd9\u6837\u6765\u601d\u8003\u8fd9\u4e2a\u95ee\u9898\u3002 \u65e2\u7136\u9898\u76ee\u8981\u6c42\u6700\u5c11\u7684\u6254\u7684\u6b21\u6570\uff0c\n        \u5047\u8bbe\u6709\u4e00\u4e2a\u51fd\u6570 f(k, i)\uff0c\u4ed6\u7684\u529f\u80fd\u662f\u6c42\u51fa k \u4e2a\u9e21\u86cb\uff0c\u6254 i \u6b21\u6240\u80fd\u68c0\u6d4b\u7684\u6700\u9ad8\u697c\u5c42\u3002\n        \u6211\u4eec\u53ea\u9700\u8981\u4e0d\u65ad\u8fdb\u884c\u53d1\u95ee\uff1a\n        \u201df \u51fd\u6570\u554a f \u51fd\u6570\uff0c\u6211\u6254\u4e00\u6b21\u53ef\u4ee5\u4e48\uff1f\u201c\uff0c \u4e5f\u5c31\u662f\u5224\u65ad f(k, 1) >= n \u7684\u8fd4\u56de\u503c\n        \u201df \u51fd\u6570\u554a f \u51fd\u6570\uff0c\u6211\u6254\u4e24\u6b21\u5462\uff1f\u201c\uff0c \u4e5f\u5c31\u662f\u5224\u65ad f(k, 2) >= n \u7684\u8fd4\u56de\u503c\n        \u2026\n        \u201df \u51fd\u6570\u554a f \u51fd\u6570\uff0c\u6211\u6254 i \u6b21\u5462\uff1f\u201c\uff0c \u4e5f\u5c31\u662f\u5224\u65ad f(k, i) >= n \u7684\u8fd4\u56de\u503c\n        \u6211\u4eec\u53ea\u9700\u8981\u8fd4\u56de\u7b2c\u4e00\u4e2a\u8fd4\u56de\u503c\u4e3a true \u7684 i \u5373\u53ef\u3002\n        \u6216\u8005\u4e0d\u65b7\u8a08\u7b97f(k, i)\uff0c\u627e\u5230\u7b2c\u4e00\u500b\u8d85\u904en\u7684\n\n        \u6454\u788e\u7684\u60c5\u51b5\uff0c\u53ef\u4ee5\u68c0\u6d4b\u7684\u6700\u9ad8\u697c\u5c42\u662ff(k - 1, m - 1) + 1\u3002\n        \u56e0\u4e3a\u788e\u4e86\u561b\uff0c\u6211\u4eec\u591a\u68c0\u6d4b\u4e86\u6454\u788e\u7684\u8fd9\u4e00\u5c42\u3002\n        \u6ca1\u6709\u6454\u788e\u7684\u60c5\u51b5\uff0c\u53ef\u4ee5\u68c0\u6d4b\u7684\u6700\u9ad8\u697c\u5c42\u662ff(k, m - 1)\u3002\n        \u56e0\u4e3a\u6ca1\u6709\u788e\uff0c\u4e5f\u5c31\u662f\u8bf4\u6211\u4eec\u5565\u90fd\u6ca1\u68c0\u6d4b\u51fa\u6765\uff08\u5bf9\u80fd\u68c0\u6d4b\u7684\u6700\u9ad8\u697c\u5c42\u65e0\u8d21\u732e\uff09\u3002\n        '''\n        @lru_cache\n        def f(k, m):\n            if k == 0 or m == 0:\n                return 0\n            return f(k - 1, m - 1) + 1 + f(k, m - 1)\n        i = 0\n        while f(k, i) < n:\n            i += 1\n        return i\n\n    def superEggDropWrong(self, k: int, n: int) -> int:\n        '''\n        \u9019\u4e0d\u5c31\u662f\u7b97log\u9ebc\u6211\u8349\n        '''\n        if k == 1:\n            return n\n        if n == 1:\n            return 1\n        ans = math.log(n, 2)\n        if int(ans) == ans:\n            return int(ans) + 1\n        else:\n            return math.ceil(ans)\n\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        from random import randint\n        k = randint(1, 10)\n        n = randint(1, 100)\n        return {'k': k, 'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{{'k': {input_obj['k']}, 'n': {input_obj['n']}}}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        input_obj = eval(input_str)\n        return input_obj\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.superEggDrop(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.053",
            "memory": 4596,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 26, in <module>\n    from functools import cache\nImportError: cannot import name 'cache' from 'functools' (/usr/local/python-3.8.1/lib/python3.8/functools.py)\n",
            "token": "4849251b-7ac0-487d-bb69-13000a6774b3",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "failure",
        "question_id": 924,
        "title": "fair-candy-swap",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "success",
        "question_id": 632,
        "title": "smallest-range-covering-elements-from-k-lists",
        "token": "0d6686a4-c0fd-4060-bc28-98e983e88c45",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom collections import defaultdict\nimport heapq\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def smallestRange(self, nums: List[List[int]]) -> List[int]:\n        d = defaultdict(list)\n        for i, evs in enumerate(nums):\n            for v in evs:\n                d[v].append(i)\n        keys = sorted(d.keys())\n        lo = 0\n        n = len(nums)\n        dd = defaultdict(int)\n        le, ri = -1, float('Inf')\n        have = 0\n        for hi in range(len(keys)):\n            for x in d[keys[hi]]:\n                dd[x] += 1\n                if dd[x] == 1:\n                    have += 1\n            while have == n:\n                curr = keys[hi] - keys[lo]\n                if ri - le > curr:\n                    ri = keys[hi]\n                    le = keys[lo]\n                for x in d[keys[lo]]:\n                    dd[x] -= 1\n                    if dd[x] == 0:\n                        have -= 1\n                lo += 1\n        return [le, ri]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        k = random.randint(1, 10)\n        nums = []\n        for _ in range(k):\n            size_of_list = random.randint(1, 10)\n            start_value = random.randint(-100, 100)\n            num_list = sorted((random.randint(start_value, start_value + 20) for _ in range(size_of_list)))\n            nums.append(num_list)\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'nums': eval(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.smallestRange(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.062",
            "memory": 4880,
            "stderr": null,
            "token": "0d6686a4-c0fd-4060-bc28-98e983e88c45",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 637,
        "title": "average-of-levels-in-binary-tree",
        "token": "e36c4b30-4158-4db2-af26-bd0c6ffc14ea",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom collections import deque\nfrom typing import List, Optional\nimport json\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nfrom collections import deque\n\nclass Solution:\n    def averageOfLevels(self, root: Optional[TreeNode]) -> List[float]:\n        ans = []\n        \n        q = deque([root])\n        while q:\n            size = len(q)\n            avg = 0\n            for i in range(size):\n                n = q.popleft()\n                avg += n.val\n                if n.left:\n                    q.append(n.left)\n                if n.right:\n                    q.append(n.right)\n            ans.append(avg/size)\n        \n        return ans\n\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        \"\"\"Generates a sample tree for testing purposes.\"\"\"\n        root = TreeNode(3)\n        root.left = TreeNode(9)\n        root.right = TreeNode(20, TreeNode(15), TreeNode(7))\n        return {'root': root}\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\"Encodes a tree structure into a JSON-compatible string.\"\"\"\n\n        def serialize(root):\n            values = []\n            queue = [root]\n            while queue:\n                node = queue.pop(0)\n                if node:\n                    values.append(node.val)\n                    queue.append(node.left)\n                    queue.append(node.right)\n                else:\n                    values.append(None)\n            return json.dumps(values)\n        return serialize(input_obj['root'])\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\"Converts the result into a JSON string.\"\"\"\n        return json.dumps(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\"Decodes a JSON string back into a tree structure.\"\"\"\n\n        def deserialize(data):\n            data = json.loads(data)\n            if not data or data[0] is None:\n                return None\n            root = TreeNode(data[0])\n            queue = [root]\n            i = 1\n            while queue and i < len(data):\n                node = queue.pop(0)\n                if data[i] is not None:\n                    node.left = TreeNode(data[i])\n                    queue.append(node.left)\n                i += 1\n                if i < len(data) and data[i] is not None:\n                    node.right = TreeNode(data[i])\n                    queue.append(node.right)\n                i += 1\n            return root\n        return {'root': deserialize(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.averageOfLevels(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.068",
            "memory": 5100,
            "stderr": null,
            "token": "e36c4b30-4158-4db2-af26-bd0c6ffc14ea",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 979,
        "title": "di-string-match",
        "token": "901a96b7-b73d-413c-9a35-7420eb916a0b",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\nimport ast\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def diStringMatch(self, s: str) -> List[int]:\n        res = []\n        ic,dc = 0,len(s)\n        for i in range(len(s)):\n            if s[i] == 'I' :\n                res.append(ic)\n                ic+=1\n            if s[i] =='D':\n                res.append(dc)\n                dc-=1\n        if s[-1] == 'I': res.append(ic)\n        else:res.append(dc)\n        return res\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(1, 20)\n        s = ''.join((random.choice(['I', 'D']) for _ in range(length)))\n        return {'s': s}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{{'s': '{input_obj['s']}'}}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return ast.literal_eval(input_str)\n\n    def decode_output(self, output_str) -> list:\n        return eval(output_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.diStringMatch(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Input {'s': 'DIDDDIIIDDIIDDDDI'}\nExpected Output:  [1, 0, 5, 4, 3, 2, 6, 7, 10, 9, 8, 11, 16, 15, 14, 13, 12, 17]\nActual Output:  [17, 0, 16, 15, 14, 1, 2, 3, 13, 12, 4, 5, 11, 10, 9, 8, 6, 7]\n1 Test Failed!\n",
            "time": "0.082",
            "memory": 6348,
            "stderr": null,
            "token": "901a96b7-b73d-413c-9a35-7420eb916a0b",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 4,
                "description": "Wrong Answer"
            }
        }
    },
    {
        "status": "success",
        "question_id": 981,
        "title": "delete-columns-to-make-sorted",
        "token": "629bd3c3-599b-4247-b8b3-5e58b1529591",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def minDeletionSize(self, strs: List[str]) -> int:\n        ans = 0\n        for l in zip(*strs):\n            if list(l) != sorted(l):\n                ans += 1\n        return ans\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 100)\n        m = random.randint(1, 1000)\n        strs = [''.join(random.choices('abcdefghijklmnopqrstuvwxyz', k=m)) for _ in range(n)]\n        return {'strs': strs}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.minDeletionSize(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.107",
            "memory": 11792,
            "stderr": null,
            "token": "629bd3c3-599b-4247-b8b3-5e58b1529591",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 927,
        "title": "sum-of-subsequence-widths",
        "token": "300ca902-836d-4ba6-9027-b38ab0a5017d",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def sumSubseqWidths(self, nums: List[int]) -> int:\n        mod = 10**9 + 7\n        nums.sort()  # \u0421\u043e\u0440\u0442\u0438\u0440\u0443\u0435\u043c \u043c\u0430\u0441\u0441\u0438\u0432 \u0434\u043b\u044f \u0443\u043f\u0440\u043e\u0449\u0435\u043d\u0438\u044f \u0440\u0430\u0441\u0447\u0435\u0442\u043e\u0432\n        ans, pow2 = 0, 1  # \u0418\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0438\u0440\u0443\u0435\u043c \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0435 \u0434\u043b\u044f \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u0430 \u0438 \u0441\u0442\u0435\u043f\u0435\u043d\u0438 \u0434\u0432\u043e\u0439\u043a\u0438\n        \n        # \u0426\u0438\u043a\u043b \u043f\u043e \u043f\u0430\u0440\u0430\u043c: x - \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u044b \u043c\u0430\u0441\u0441\u0438\u0432\u0430 \u0432 \u043e\u0431\u044b\u0447\u043d\u043e\u043c \u043f\u043e\u0440\u044f\u0434\u043a\u0435, y - \u0432 \u043e\u0431\u0440\u0430\u0442\u043d\u043e\u043c \u043f\u043e\u0440\u044f\u0434\u043a\u0435\n        for x, y in zip(nums, reversed(nums)):\n            # \u0414\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u0432\u043a\u043b\u0430\u0434 \u0440\u0430\u0437\u043d\u043e\u0441\u0442\u0438 x \u0438 y, \u0443\u043c\u043d\u043e\u0436\u0435\u043d\u043d\u043e\u0439 \u043d\u0430 \u0442\u0435\u043a\u0443\u0449\u0443\u044e \u0441\u0442\u0435\u043f\u0435\u043d\u044c \u0434\u0432\u043e\u0439\u043a\u0438\n            ans += (x - y) * pow2\n            # \u041e\u0431\u043d\u043e\u0432\u043b\u044f\u0435\u043c \u0441\u0442\u0435\u043f\u0435\u043d\u044c \u0434\u0432\u043e\u0439\u043a\u0438 \u043f\u043e \u043c\u043e\u0434\u0443\u043b\u044e\n            pow2 = pow2 * 2 % mod\n        \n        # \u0412\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043c \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442 \u043f\u043e \u043c\u043e\u0434\u0443\u043b\u044e 10**9 + 7\n        return ans % mod\n\nclass TestCaseGenerator:\n\n    def __init__(self):\n        self.random = random\n\n    def generate(self) -> dict:\n        \"\"\" Generate a random test case within reasonable constraints. \"\"\"\n        length = self.random.randint(1, 10)\n        nums = [self.random.randint(1, 100) for _ in range(length)]\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\" Convert the dict input into a JSON-like string format. \"\"\"\n        return str(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\" The output is an integer so we convert it to a string directly. \"\"\"\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\" Convert the input string back to a dictionary object. \"\"\"\n        return eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.sumSubseqWidths(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.063",
            "memory": 5100,
            "stderr": null,
            "token": "300ca902-836d-4ba6-9027-b38ab0a5017d",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 928,
        "title": "surface-area-of-3d-shapes",
        "token": "fabe53b8-8719-4fe1-b5b7-3c404fe67f8a",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport ast\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def surfaceArea(self, grid: List[List[int]]) -> int:\n        surface_area = 0\n      \n        for i, row in enumerate(grid):\n            for j, height in enumerate(row):\n                if height:\n                    surface_area += 2 + height * 4\n                    if i:\n                        surface_area -= min(height, grid[i - 1][j]) * 2\n                    if j:\n                        surface_area -= min(height, grid[i][j - 1]) * 2\n\n        return surface_area\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 5)\n        grid = [[random.randint(0, 5) for _ in range(n)] for _ in range(n)]\n        return {'grid': grid}\n\n    def encode_input(self, input_obj) -> str:\n        grid_str = '['\n        for row in input_obj['grid']:\n            grid_str += '[' + ','.join(map(str, row)) + '],'\n        grid_str = grid_str[:-1] + ']'\n        return f'grid = {grid_str}'\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        grid_str = input_str.split('=')[1].strip()\n        grid = ast.literal_eval(grid_str)\n        return {'grid': grid}\n\n    def decode_output(self, output_str) -> int:\n        return int(output_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.surfaceArea(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.069",
            "memory": 5076,
            "stderr": null,
            "token": "fabe53b8-8719-4fe1-b5b7-3c404fe67f8a",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "failure",
        "question_id": 933,
        "title": "increasing-order-search-tree",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "success",
        "question_id": 488,
        "title": "zuma-game",
        "token": "5efeba0b-60ce-449c-b111-e8481554757c",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom functools import cache\nfrom itertools import groupby\nimport random\nfrom math import inf\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nfrom functools import cache\n\nclass Solution:\n    def findMinStep(self, board: str, hand: str) -> int:\n        color_to_id = dict(zip(\"RYBGW\", range(5)))\n        board = tuple(color_to_id[i] for i in board)\n        hand_color_counts = [0] * 5\n        for color in hand:\n            hand_color_counts[color_to_id[color]] += 1\n\n        min_step = start_chain_reaction(board, tuple(hand_color_counts))\n        return -1 if min_step == float(\"inf\") else min_step\n\ndef generate_consecutive_colors(board):\n    begin = 0\n    while begin < len(board):\n        end = begin + 1\n        while end < len(board) and board[end] == board[begin]:\n            end += 1\n\n        yield board[begin], begin, end\n        begin = end\n\n@cache\ndef start_chain_reaction(board, hand):\n    if not board:\n        return 0\n\n    min_steps = float(\"inf\")\n    for color, begin, end in generate_consecutive_colors(board):\n        if hand[color] >= (balls_to_insert := 3 - (end - begin)):\n            h = list(hand)\n            h[color] -= balls_to_insert\n            b = board[:begin] + board[end:]\n            min_steps = min(min_steps, balls_to_insert + interrupt(b, h))\n\n    return min_steps\n\ndef interrupt(board, hand):\n    for color, begin, end in generate_consecutive_colors(board):\n        if end - begin >= 3:\n            min_steps = interrupt(board[:begin] + board[end:], hand)\n\n            for insert in range(begin + 1, end):\n                for balls_color, balls in enumerate(hand):\n                    if balls and balls_color != color:\n                        h = list(hand)\n                        h[balls_color] -= 1\n                        b = list(board)\n                        b.insert(insert, balls_color)\n                        min_steps = min(min_steps, 1 + interrupt(b, h))\n\n            return min_steps\n\n    return start_chain_reaction(tuple(board), tuple(hand))\n\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        colors = ['R', 'Y', 'B', 'G', 'W']\n        board_length = random.randint(1, 16)\n        hand_length = random.randint(1, 5)\n        board = ''.join((random.choice(colors) for _ in range(board_length)))\n        hand = ''.join((random.choice(colors) for _ in range(hand_length)))\n        return {'board': board, 'hand': hand}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"board={input_obj['board']},hand={input_obj['hand']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        parts = input_str.split(',')\n        board_part = parts[0].split('=')[1]\n        hand_part = parts[1].split('=')[1]\n        return {'board': board_part, 'hand': hand_part}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.findMinStep(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.059",
            "memory": 4636,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 26, in <module>\n    from functools import cache\nImportError: cannot import name 'cache' from 'functools' (/usr/local/python-3.8.1/lib/python3.8/functools.py)\n",
            "token": "5efeba0b-60ce-449c-b111-e8481554757c",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "success",
        "question_id": 493,
        "title": "reverse-pairs",
        "token": "ed1e371f-d9df-4fdf-84fb-d45475cf6338",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nfrom random import randint\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def reversePairs(self, nums: List[int]) -> int:\n        from sortedcontainers import SortedList\n        sl = SortedList([])\n        ans = 0\n        for num in nums:\n            ans += len(sl) - sl.bisect_right(2*num)\n            sl.add(num)\n        return ans\n\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = randint(1, 100)\n        nums = [randint(-2 ** 31, 2 ** 31 - 1) for _ in range(n)]\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'nums': eval(input_str)}\n\n    def decode_output(self, output_str) -> int:\n        return int(output_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.reversePairs(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.062",
            "memory": 4976,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 108, in <module>\n    runner.run()\n  File \"script.py\", line 92, in run\n    output = self.solution.reversePairs(**input)\n  File \"script.py\", line 50, in reversePairs\n    from sortedcontainers import SortedList\nModuleNotFoundError: No module named 'sortedcontainers'\n",
            "token": "ed1e371f-d9df-4fdf-84fb-d45475cf6338",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "success",
        "question_id": 495,
        "title": "teemo-attacking",
        "token": "b17d451f-41b6-46f3-b906-c2ed6cfdba09",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\nfrom ast import literal_eval\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def findPoisonedDuration(self, timeSeries: list[int], duration: int) -> int:\n        if not timeSeries:\n            return 0\n        total_poisoned_time = 0\n        last_end_time = 0\n        for attack_time in timeSeries:\n            start = attack_time\n            end = start + duration\n            if start > last_end_time:\n                total_poisoned_time += duration\n            else:\n                total_poisoned_time += end - last_end_time\n            last_end_time = end\n        return total_poisoned_time\n\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(1, 20)\n        time_series = sorted(random.sample(range(1, 100), length))\n        duration = random.randint(1, 10)\n        return {'timeSeries': time_series, 'duration': duration}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return literal_eval(input_str)\n\n    def decode_output(self, output_str) -> int:\n        return int(output_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.findPoisonedDuration(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.059",
            "memory": 4956,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 49, in <module>\n    class Solution:\n  File \"script.py\", line 50, in Solution\n    def findPoisonedDuration(self, timeSeries: list[int], duration: int) -> int:\nTypeError: 'type' object is not subscriptable\n",
            "token": "b17d451f-41b6-46f3-b906-c2ed6cfdba09",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "success",
        "question_id": 496,
        "title": "next-greater-element-i",
        "token": "f4cfc22e-9578-4fe8-98f3-74c813d286f7",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        nums1Idx = { n:i for i,n in enumerate(nums1)}\n        res = [-1] * len(nums1)\n        \n        for i in range(len(nums2)):\n            if (nums2[i] not in nums1Idx):\n                continue\n            for j in range(i+1, len(nums2)):\n                if (nums2[j] > nums2[i]):\n                    idx = nums1Idx[nums2[i]]\n                    res[idx] = nums2[j]\n                    break\n\n        return res\n\n\nclass TestCaseGenerator:\n\n    def __init__(self):\n        pass\n\n    @staticmethod\n    def generate() -> dict:\n        nums2_length = random.randint(2, 10)\n        nums2 = random.sample(range(0, 1000), nums2_length)\n        nums1_length = random.randint(1, nums2_length)\n        nums1 = random.sample(nums2, nums1_length)\n        return {'nums1': nums1, 'nums2': nums2}\n\n    @staticmethod\n    def encode_input(input_obj) -> str:\n        return f\"{input_obj['nums1']}, {input_obj['nums2']}\"\n\n    @staticmethod\n    def encode_output(output_obj) -> str:\n        return f'{output_obj}'\n\n    @staticmethod\n    def decode_input(input_str) -> dict:\n        nums1_str, nums2_str = input_str.split('],')\n        nums1 = list(map(int, nums1_str.strip('[] ').split(',')))\n        nums2 = list(map(int, nums2_str.strip('[] ').strip().split(',')))\n        return {'nums1': nums1, 'nums2': nums2}\n\n    @staticmethod\n    def decode_output(output_str) -> list:\n        return list(map(int, output_str.strip('[] ').split(',')))\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.nextGreaterElement(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.065",
            "memory": 4864,
            "stderr": null,
            "token": "f4cfc22e-9578-4fe8-98f3-74c813d286f7",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 830,
        "title": "largest-triangle-area",
        "token": "65446a2e-7888-46b8-9fd8-2192048b281d",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\nimport ast\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\n        def cross(o, a, b):\n            return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])\n        \n        def area(p1, p2, p3):\n            return abs(p1[0]*p2[1] + p2[0]*p3[1] + p3[0]*p1[1] - p1[1]*p2[0] - p2[1]*p3[0] - p3[1]*p1[0]) / 2\n        \n        # Step 1: Find the Convex Hull\n        points = sorted(points)\n        lower = []\n        for p in points:\n            while len(lower) >= 2 and cross(lower[-2], lower[-1], p) <= 0:\n                lower.pop()\n            lower.append(p)\n        \n        upper = []\n        for p in reversed(points):\n            while len(upper) >= 2 and cross(upper[-2], upper[-1], p) <= 0:\n                upper.pop()\n            upper.append(p)\n        \n        hull = lower[:-1] + upper[:-1]  # Remove the duplicate end points\n        \n        # Step 2: Find the largest triangle by iterating through all combinations of 3 points on the hull\n        max_area = 0\n        n = len(hull)\n        for i in range(n):\n            for j in range(i + 1, n):\n                for k in range(j + 1, n):\n                    max_area = max(max_area, area(hull[i], hull[j], hull[k]))\n        \n        return max_area\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        num_points = random.randint(3, 50)\n        points = [[random.randint(-50, 50), random.randint(-50, 50)] for _ in range(num_points)]\n        points = list(map(list, set(map(tuple, points))))\n        return {'points': points}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['points'])\n\n    def encode_output(self, output_obj) -> str:\n        return f'{output_obj:.5f}'\n\n    def decode_input(self, input_str) -> dict:\n        return {'points': ast.literal_eval(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.largestTriangleArea(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.07",
            "memory": 5424,
            "stderr": null,
            "token": "65446a2e-7888-46b8-9fd8-2192048b281d",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 836,
        "title": "race-car",
        "token": "835d0c5c-11f0-41f5-9f3e-3cd9a381233a",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom collections import deque\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nfrom collections import deque\n\nclass Solution(object):\n    def racecar(self, target):\n        q = deque([(0, 1, 0)]) # (pos, speed, step)\n        \n        while q:\n            pos, spd, n = q.popleft()\n            if pos == target:\n                return n\n            q.append((pos + spd, spd * 2, n + 1))\n            if spd > 0:\n                if pos + spd > target:\n                    q.append((pos, -1, n + 1))\n            else:\n                if pos + spd < target:\n                    q.append((pos, 1, n + 1))\n\n\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        target = random.randint(1, 10000)\n        return {'target': target}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.racecar(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.087",
            "memory": 5284,
            "stderr": null,
            "token": "835d0c5c-11f0-41f5-9f3e-3cd9a381233a",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 861,
        "title": "flipping-an-image",
        "token": "57c84c31-fa08-4576-8785-62ba1892d440",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\n        for row in image:\n            row.reverse()\n        for r in range(len(image)):\n            for c in range(len(image[0])):\n                image[r][c] = 1 if image[r][c]==0 else 0\n        return image\n\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 5)\n        image = [[random.choice([0, 1]) for _ in range(n)] for _ in range(n)]\n        return {'image': image}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['image'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'image': eval(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.flipAndInvertImage(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.058",
            "memory": 4800,
            "stderr": null,
            "token": "57c84c31-fa08-4576-8785-62ba1892d440",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 741,
        "title": "cherry-pickup",
        "token": "373d6101-c63d-41ba-89bc-6306284bdca1",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\nimport json\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def cherryPickup(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n\n        dp = [[-float('inf')] * (n + 1) for _ in range(n + 1)]\n        dp[n - 1][n - 1] = grid[-1][-1]\n\n        for sumCord in range(2 * n - 3, -1, -1):\n            minV, maxV = max(0, sumCord - n + 1), min(n, sumCord + 1)\n            for x1 in range(minV, maxV):\n                y1 = sumCord - x1\n                if grid[x1][y1] != -1:\n                    for x2 in range(minV, x1 + 1):\n                        y2 = sumCord - x2\n\n                        if grid[x2][y2] != -1:\n                            max_prev = max(dp[x1][x2], dp[x1 + 1][x2], dp[x1][x2 + 1], dp[x1 + 1][x2 + 1])\n                            dp[x1][x2] = grid[x1][y1] + grid[x2][y2] + max_prev\n\n                            if x1 == x2:\n                                dp[x1][x2] -= grid[x1][y1]\n                        else:\n                            dp[x1][x2] = -float('inf')\n\n                else:\n                    for x2 in range(minV, x1 + 1):\n                        dp[x1][x2] = -float('inf')\n        \n        return max(dp[0][0], 0)\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 6)\n        grid = [[random.choice([0, 1, -1]) for _ in range(n)] for _ in range(n)]\n        grid[0][0] = random.choice([0, 1])\n        grid[n - 1][n - 1] = random.choice([0, 1])\n        for i in range(n):\n            grid[i][0] = random.choice([0, 1])\n        for j in range(n):\n            grid[n - 1][j] = random.choice([0, 1])\n        return {'grid': grid}\n\n    def encode_input(self, input_obj) -> str:\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return json.loads(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.cherryPickup(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.055",
            "memory": 4888,
            "stderr": null,
            "token": "373d6101-c63d-41ba-89bc-6306284bdca1",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 750,
        "title": "contain-virus",
        "token": "6d8f073e-f838-4ab4-91b9-a9190be65633",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def containVirus(self, isInfected: List[List[int]]) -> int:\n        def traverse_infected(r, c):\n            infected, uninfected, walls = [], set(), 0\n            stack = [(r, c)]\n            visited.add((r, c))\n            while stack:\n                x, y = stack.pop()\n                infected.append((x, y))\n                for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                    nx, ny = x + dx, y + dy\n                    if 0 <= nx < m and 0 <= ny < n:\n                        if isInfected[nx][ny] == 1 and (nx, ny) not in visited:\n                            visited.add((nx, ny))\n                            stack.append((nx, ny))\n                        elif isInfected[nx][ny] == 0:\n                            uninfected.add((nx, ny))\n                            walls += 1\n            return infected, uninfected, walls\n\n        def most_threatening_region():\n            max_threat, region_idx = 0, -1\n            for i, (infected, uninfected, _) in enumerate(regions):\n                if len(uninfected) > max_threat:\n                    max_threat = len(uninfected)\n                    region_idx = i\n            return region_idx\n\n        m, n = len(isInfected), len(isInfected[0])\n        total_walls = 0\n\n        while True:\n            visited = set()\n            regions = []\n\n            for r in range(m):\n                for c in range(n):\n                    if isInfected[r][c] == 1 and (r, c) not in visited:\n                        regions.append(traverse_infected(r, c))\n\n            if not regions:\n                break\n\n            region_idx = most_threatening_region()\n\n            if region_idx == -1:\n                break\n\n            total_walls += regions[region_idx][2]\n\n            for i, (infected, uninfected, _) in enumerate(regions):\n                if i == region_idx:\n                    for x, y in infected:\n                        isInfected[x][y] = -1\n                else:\n                    for x, y in uninfected:\n                        isInfected[x][y] = 1\n\n            if all(isInfected[i][j] in {0, -1} for i in range(m) for j in range(n)):\n                break\n\n        return total_walls\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        m = random.randint(1, 50)\n        n = random.randint(1, 50)\n        isInfected = [[random.choice([0, 1]) for _ in range(n)] for _ in range(m)]\n        return {'isInfected': isInfected}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.containVirus(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.091",
            "memory": 6928,
            "stderr": null,
            "token": "6d8f073e-f838-4ab4-91b9-a9190be65633",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 699,
        "title": "falling-squares",
        "token": "af7fb3cc-fdff-4337-8ffd-604f2c93563e",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom bisect import bisect_right, bisect_left\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def fallingSquares(self, positions: List[List[int]]) -> List[int]:\n        height = [0]\n        pos = [0]\n        res = []\n        max_h = 0\n        for left, side in positions:\n            i = bisect.bisect_right(pos, left)\n            j = bisect.bisect_left(pos, left + side)\n            high = max(height[i - 1:j] or [0]) + side\n            pos[i:j] = [left, left + side]\n            height[i:j] = [high, height[j - 1]]\n            max_h = max(max_h, high)\n            res.append(max_h)\n        return res\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 10)\n        positions = [[random.randint(1, 100), random.randint(1, 10)] for _ in range(n)]\n        return {'positions': positions}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['positions'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'positions': eval(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.fallingSquares(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.071",
            "memory": 4920,
            "stderr": null,
            "token": "af7fb3cc-fdff-4337-8ffd-604f2c93563e",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 779,
        "title": "max-chunks-to-make-sorted-ii",
        "token": "47cf091b-a972-4508-82e7-2ea89194650e",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\nimport json\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n        for val in arr:\n            if not stack or stack[-1]<=val:\n                stack.append(val)\n            else:\n                ma = stack.pop()\n                while stack and stack[-1]>val:\n                    stack.pop()\n                stack.append(ma)\n        return len(stack)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(1, 10)\n        arr = [random.randint(0, 100) for _ in range(length)]\n        return {'arr': arr}\n\n    def encode_input(self, input_obj) -> str:\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return json.loads(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.maxChunksToSorted(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.054",
            "memory": 4764,
            "stderr": null,
            "token": "47cf091b-a972-4508-82e7-2ea89194650e",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 759,
        "title": "set-intersection-size-at-least-two",
        "token": "52743a4d-80a7-4a6f-89d1-9d85a260c45b",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List, Dict\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def intersectionSizeTwo(self, intervals: List[List[int]]) -> int:\n        intervals.sort(key = lambda x:x[1])\n        size = 0\n        prev_start = -1\n        prev_end = -1\n\n        for curr_start, curr_end in intervals:\n            if prev_start == -1 or prev_end < curr_start: #if intervals do not overlap\n                size += 2\n                prev_start = curr_end-1\n                prev_end = curr_end\n\n            elif prev_start < curr_start: #if intervals overlap\n                if prev_end != curr_end:\n                    prev_start = prev_end\n                    prev_end = curr_end\n                    \n                else:\n                    prev_start = curr_end-1\n                    prev_end = curr_end\n\n                size += 1\n\n        return size\n\n        \n\nclass TestCaseGenerator:\n\n    def generate(self) -> Dict[str, List[List[int]]]:\n        return {'intervals': [[1, 3], [3, 7], [8, 9]]}\n\n    def encode_input(self, input_obj: Dict[str, List[List[int]]]) -> str:\n        return str(input_obj['intervals'])\n\n    def encode_output(self, output_obj: int) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str: str) -> Dict[str, List[List[int]]]:\n        return {'intervals': eval(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.intersectionSizeTwo(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.05",
            "memory": 4644,
            "stderr": null,
            "token": "52743a4d-80a7-4a6f-89d1-9d85a260c45b",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 854,
        "title": "making-a-large-island",
        "token": "8491c11b-406e-43ad-b3ed-99cf338e958c",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List, Dict, Any\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def largestIsland(self, grid: List[List[int]]) -> int:\n        sizes = {}\n        island_number = 0\n        n_rows = len(grid)\n        for i, row in enumerate(grid):\n            n_cols = len(row)\n            for j, val in enumerate(row):\n                if val <= 0:\n                    continue\n                island_number -= 1\n                grid[i][j] = island_number\n                stack = [(i, j)]\n                sizes[island_number] = 0\n                while stack:\n                    ii, jj = stack.pop()\n                    sizes[island_number] += 1\n                    if ii - 1 >= 0 and grid[ii-1][jj] > 0:\n                        grid[ii-1][jj] = island_number\n                        stack.append((ii-1, jj))\n                    if ii + 1 < n_rows and grid[ii+1][jj] > 0:\n                        grid[ii+1][jj] = island_number\n                        stack.append((ii+1, jj))\n                    if jj - 1 >= 0 and grid[ii][jj-1] > 0:\n                        grid[ii][jj-1] = island_number\n                        stack.append((ii, jj-1))\n                    if jj + 1 < n_cols and grid[ii][jj+1] > 0:\n                        grid[ii][jj+1] = island_number\n                        stack.append((ii, jj+1))\n        if not sizes:\n            return 1\n        # Make sure we start off max_size with the size of the largest\n        # island in case there are no zeros\n        max_size = max(sizes.values())\n        for i, row in enumerate(grid):\n            n_cols = len(row)\n            for j, val in enumerate(row):\n                if val != 0:\n                    continue\n                this_size = 1\n                # We have to be careful to find unique island numbers\n                # this connects.\n                islands = set()\n                if i - 1 >= 0 and grid[i-1][j]:\n                    islands.add(grid[i-1][j])\n                if i + 1 < n_rows and grid[i+1][j]:\n                    islands.add(grid[i+1][j])\n                if j - 1 >= 0 and grid[i][j-1]:\n                    islands.add(grid[i][j-1])\n                if j + 1 < n_cols and grid[i][j+1]:\n                    islands.add(grid[i][j+1])\n                for island in islands:\n                    this_size += sizes[island]\n                if this_size > max_size:\n                    max_size = this_size\n\n        return max_size \n\nclass TestCaseGenerator:\n\n    def generate(self) -> Dict[str, Any]:\n        grid_variants = [[[1, 0], [0, 1]], [[1, 1], [1, 0]], [[1, 1], [1, 1]], [[0, 0, 1], [0, 1, 0], [0, 0, 0]], [[1]], [[0]]]\n        grid = random.choice(grid_variants)\n        return {'grid': grid}\n\n    def encode_input(self, input_obj: Dict[str, Any]) -> str:\n        return str(input_obj['grid'])\n\n    def encode_output(self, output_obj: int) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str: str) -> Dict[str, List[List[int]]]:\n        import ast\n        return {'grid': ast.literal_eval(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.largestIsland(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.066",
            "memory": 6452,
            "stderr": null,
            "token": "8491c11b-406e-43ad-b3ed-99cf338e958c",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 855,
        "title": "count-unique-characters-of-all-substrings-of-a-given-string",
        "token": "306cfe30-cb38-4456-b45c-619d6f58444a",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def uniqueLetterString(self, s: str) -> int:\n        dp = defaultdict(lambda: (-1, -1))\n        ans = 0\n        for i, c in enumerate(s):\n            j, k = dp[c]\n            ans += (i - k) * (k - j)\n            dp[c] = (k, i)\n        \n        for c in dp:\n            j, k = dp[c]\n            ans += (len(s) - k) * (k - j)\n        return ans\n                         \n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(1, 10 ** 5)\n        s = ''.join(random.choices('ABCDEFGHIJKLMNOPQRSTUVWXYZ', k=length))\n        return {'s': s}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['s']\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.uniqueLetterString(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.222",
            "memory": 17512,
            "stderr": null,
            "token": "306cfe30-cb38-4456-b45c-619d6f58444a",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 856,
        "title": "consecutive-numbers-sum",
        "token": "0617cbdf-b399-4876-a3c0-f5cdb104b53b",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport json \n\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def consecutiveNumbersSum(self, n: int) -> int:\n        res = 1\n        # get rid of all even factors\n        while n % 2 == 0:\n            n //= 2\n        i = 3\n        # try all odd numbers <= sqrt(n)\n        while i * i <= n:\n            exp = 0 \n            while n % i == 0:\n                n //= i\n                exp += 1\n            res *= (exp + 1)\n            i += 2\n        return res if n == 1 else res * 2\n\n\nclass TestCaseGenerator:\n\n    def __init__(self):\n        pass\n\n    def generate(self) -> dict:\n        n = random.randint(1, 1000)\n        return {'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return '{\"n\": %d}' % input_obj['n']\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        from json import loads\n        return loads(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.consecutiveNumbersSum(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.064",
            "memory": 5336,
            "stderr": null,
            "token": "0617cbdf-b399-4876-a3c0-f5cdb104b53b",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 564,
        "title": "find-the-closest-palindrome",
        "token": "136f88de-5402-4288-9284-b85497d78ec8",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport math\n\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def nearestPalindromic(self, numberStr: str) -> str:\n        number = int(numberStr)\n        if number <= 10:\n            return str(number - 1)\n        if number == 11:\n            return \"9\"\n\n        length = len(numberStr)\n        leftHalf = int(numberStr[:(length + 1) // 2])\n        \n        palindromeCandidates = [\n            self.generatePalindromeFromLeft(leftHalf - 1, length % 2 == 0),\n            self.generatePalindromeFromLeft(leftHalf, length % 2 == 0),\n            self.generatePalindromeFromLeft(leftHalf + 1, length % 2 == 0),\n            10**(length - 1) - 1,\n            10**length + 1\n        ]\n\n        nearestPalindrome = 0\n        minDifference = float('inf')\n\n        for candidate in palindromeCandidates:\n            if candidate == number:\n                continue\n            difference = abs(candidate - number)\n            if difference < minDifference or (difference == minDifference and candidate < nearestPalindrome):\n                minDifference = difference\n                nearestPalindrome = candidate\n\n        return str(nearestPalindrome)\n\n    def generatePalindromeFromLeft(self, leftHalf: int, isEvenLength: bool) -> int:\n        palindrome = leftHalf\n        if not isEvenLength:\n            leftHalf //= 10\n        while leftHalf > 0:\n            palindrome = palindrome * 10 + leftHalf % 10\n            leftHalf //= 10\n        return palindrome\n\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(1, 18)\n        n = ''.join(random.choices('1234567890', k=length)).lstrip('0')\n        if not n:\n            n = '1'\n        return {'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['n']\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        return {'n': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.nearestPalindromic(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.056",
            "memory": 4828,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 139, in <module>\n    runner.run()\n  File \"script.py\", line 123, in run\n    output = self.solution.nearestPalindromic(**input)\nTypeError: nearestPalindromic() got an unexpected keyword argument 'n'\n",
            "token": "136f88de-5402-4288-9284-b85497d78ec8",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "failure",
        "question_id": 552,
        "title": "student-attendance-record-ii",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "success",
        "question_id": 938,
        "title": "numbers-at-most-n-given-digit-set",
        "token": "943624bd-ca83-45d1-ba9d-12079f2b13d8",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom functools import cache\nimport random\nimport json\n\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def atMostNGivenDigitSet(self, digits: List[str], n: int) -> int:\n        value_string = str(n)\n\n        @cache\n        def solve(index: int, if_zero: bool) -> int:\n            if index >= len(value_string):\n                return 1\n            count = 0\n            if if_zero and index < len(value_string) - 1:\n                for length in range(1, len(value_string) - index):\n                    count += len(digits) ** length\n            for digit in digits:\n                if digit < value_string[index]:\n                    count += len(digits) ** (len(value_string) - index - 1)\n                elif digit == value_string[index]:\n                    count += solve(index + 1, False)\n            return count\n\n        return solve(0, True)\n\nclass TestCaseGenerator:\n\n    def __init__(self):\n        self.random = random\n        self.json = json\n\n    def generate(self) -> dict:\n        length_of_digits = self.random.randint(1, 9)\n        digits = [str(self.random.randint(1, 9)) for _ in range(length_of_digits)]\n        digits = sorted(list(set(digits)))\n        n = self.random.randint(1, 1000000)\n        return {'digits': digits, 'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return self.json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return self.json.loads(input_str)\n\n    def decode_output(self, output_str) -> int:\n        return int(output_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.atMostNGivenDigitSet(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.053",
            "memory": 4676,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 26, in <module>\n    from functools import cache\nImportError: cannot import name 'cache' from 'functools' (/usr/local/python-3.8.1/lib/python3.8/functools.py)\n",
            "token": "943624bd-ca83-45d1-ba9d-12079f2b13d8",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "success",
        "question_id": 939,
        "title": "valid-permutations-for-di-sequence",
        "token": "c85392ee-9c58-488a-8c72-d62aa26ebd0c",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport hashlib\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def numPermsDISequence(self, s: str) -> int:\n        k = 1_000_000_007\n        x = len(s)\n        dp = [[0] * (x + 1) for _ in range(x + 1)]\n        for j in range(x + 1):\n            dp[0][j] = 1\n        for i in range(1, x + 1):\n            if s[i - 1] == 'I':  \n                postfix_sum = 0\n                for j in range(x - i, -1, -1):\n                    postfix_sum = (postfix_sum + dp[i - 1][j + 1]) % k\n                    dp[i][j] = postfix_sum\n            else:  \n                prefix_sum = 0\n                for j in range(x - i + 1):\n                    prefix_sum = (prefix_sum + dp[i - 1][j]) % k\n                    dp[i][j] = prefix_sum\n        return dp[x][0]\n\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(1, 200)\n        pattern = ''.join((random.choice('DI') for _ in range(length)))\n        return {'s': pattern}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['s']\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\n    def decode_output(self, output_str) -> int:\n        return int(output_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.numPermsDISequence(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Input {'s': 'DDDIIDIIIIDIDIDIIIDIDDIIIDDDDIIIDDIIIIDDIDIIDIIIIIDDIIDIIDIIDIIIIDIIDIDIIIDIIIDIIIIIDDIDIIIDIDIDDIDIIDIDDIIDIIDDDDIDIIIID'}\nExpected Output:  []\nActual Output:  463618668\n1 Test Failed!\n",
            "time": "0.069",
            "memory": 6116,
            "stderr": null,
            "token": "c85392ee-9c58-488a-8c72-d62aa26ebd0c",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 4,
                "description": "Wrong Answer"
            }
        }
    }
]