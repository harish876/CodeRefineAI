[
    {
        "status": "success",
        "question_id": 131,
        "title": "palindrome-partitioning",
        "token": "fb2bf159-7f3a-45a9-aa15-186fc331853f",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\nimport string\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        n = len(s)\n        dp = [[False] * n for _ in range(n)]\n\n        for i in range(n - 1, -1, -1):\n            for j in range(i, n):\n                if s[i] == s[j] and (j - i <= 2 or dp[i + 1][j - 1]):\n                    dp[i][j] = True\n\n        res = []\n        def backtrack(i, curr):\n            if i == n:\n                res.append(curr[:])\n                return\n\n            for j in range(i, n):\n                if dp[i][j]:\n                    curr.append(s[i:j+1])\n                    backtrack(j+1, curr)\n                    curr.pop()\n\n        backtrack(0, [])\n        return res\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(1, 16)\n        s = ''.join((random.choice(string.ascii_lowercase) for _ in range(length)))\n        return {'s': s}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['s']\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.partition(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.077",
            "memory": 10068,
            "stderr": null,
            "token": "fb2bf159-7f3a-45a9-aa15-186fc331853f",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 132,
        "title": "palindrome-partitioning-ii",
        "token": "7a3c0187-d4c5-41b6-a495-44c14d2f1358",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport json\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def minCut(self, s: str) -> int:\n        n = len(s)\n        is_palindrome = [[False] * n for _ in range(n)]\n\n        for i in range(n):\n            is_palindrome[i][i] = True\n\n        for i in range(n - 1):\n            if s[i] == s[i+1]:\n                is_palindrome[i][i+1] = True\n\n        for length in range(3, n + 1):\n            for i in range(n - length + 1):\n                j = i + length - 1\n                if s[i] == s[j] and is_palindrome[i+1][j-1]:\n                    is_palindrome[i][j] = True\n\n        dp = [0] * n\n        for i in range(n):\n            if is_palindrome[0][i]:\n                dp[i] = 0\n            else:\n                dp[i] = i\n                for j in range(i):\n                    if is_palindrome[j+1][i]:\n                        dp[i] = min(dp[i], dp[j] + 1)\n\n        return dp[n-1]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        \"\"\"\n        Generates a test case input containing a random string `s` of length between 1 and 10.\n        This ensures we have a reasonable range for testing without excessive computation time.\n        \"\"\"\n        min_length = 1\n        max_length = 10\n        length = random.randint(min_length, max_length)\n        s = ''.join(random.choices('abcdefghijklmnopqrstuvwxyz', k=length))\n        return {'s': s}\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\"\n        Encodes the test case input into a JSON string.\n        \"\"\"\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\"\n        Encodes the test case output, which is an integer, to a string.\n        \"\"\"\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\"\n        Decodes a JSON string into a dictionary representing the test case input.\n        \"\"\"\n        return json.loads(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.minCut(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.06",
            "memory": 4780,
            "stderr": null,
            "token": "7a3c0187-d4c5-41b6-a495-44c14d2f1358",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 135,
        "title": "candy",
        "token": "13bdb6a4-182a-4ac1-af53-4647b4ea476a",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def candy(self, ratings: List[int]) -> int:\n        n = len(ratings)\n        candies = [1] * n\n\n        # First pass: From left to right\n        for i in range(1, n):\n            if ratings[i] > ratings[i - 1]:\n                candies[i] = candies[i - 1] + 1\n\n        # Second pass: From right to left\n        for i in range(n - 2, -1, -1):\n            if ratings[i] > ratings[i + 1]:\n                candies[i] = max(candies[i], candies[i + 1] + 1)\n\n        return sum(candies)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        test_case_1 = {'ratings': [1, 0, 2]}\n        test_case_2 = {'ratings': [1, 2, 2]}\n        test_case_3 = {'ratings': [3, 2, 1]}\n        test_case_4 = {'ratings': [1, 3, 4, 5, 2]}\n        test_case_5 = {'ratings': [1, 2, 87, 87, 87, 2, 1]}\n        return random.choice([test_case_1, test_case_2, test_case_3, test_case_4, test_case_5])\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.candy(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.054",
            "memory": 4816,
            "stderr": null,
            "token": "13bdb6a4-182a-4ac1-af53-4647b4ea476a",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 137,
        "title": "single-number-ii",
        "token": "d565b9e2-5281-4461-99b6-3c7bf9ce3298",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        result = 0\n        for num in nums:\n            result ^= num\n        return result\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        \"\"\"\n        Generate a sample test case input where elements \n        appear three times except one. This will return \n        a dictionary with one element `nums` containing \n        a list.\n        \"\"\"\n        nums = [2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\"\n        Convert a test case input into a string.\n        This typically involves converting the list into a string format.\n        \"\"\"\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\"\n        Since the expected output is an integer, simply convert it to string.\n        This will help in returning a stringified version of the integer result.\n        \"\"\"\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\"\n        Given the input string, convert it back to a dictionary with key `nums`.\n        Warning: eval() is used here for simplicity; in production, safer alternatives\n        should be used to parse the input format to avoid code injection vulnerabilities.\n        \"\"\"\n        nums = eval(input_str)\n        return {'nums': nums}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.singleNumber(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Input {'nums': [2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]}\nExpected Output:  3\nActual Output:  6\n1 Test Failed!\n",
            "time": "0.056",
            "memory": 4724,
            "stderr": null,
            "token": "d565b9e2-5281-4461-99b6-3c7bf9ce3298",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 4,
                "description": "Wrong Answer"
            }
        }
    },
    {
        "status": "success",
        "question_id": 138,
        "title": "copy-list-with-random-pointer",
        "token": "8d2af899-1b36-4133-9ce2-3097f97f8a87",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import Optional\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\n\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        old_to_new = {None:None}\n        \n        old = head\n        while old:\n            new = Node(old.val)\n            old_to_new[old] = new\n            old = old.next\n        \n        old = head\n        while old:\n            new = old_to_new[old]\n            new.next = old_to_new[old.next]\n            new.random = old_to_new[old.random]\n            old = old.next\n        \n        return old_to_new[head]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        nodes = [{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]\n        head = self.build_linked_list(nodes)\n        return {'head': head}\n\n    def build_linked_list(self, node_info):\n        if not node_info:\n            return None\n        nodes = [Node(info['val']) for info in node_info]\n        for i in range(len(nodes) - 1):\n            nodes[i].next = nodes[i + 1]\n        for i, info in enumerate(node_info):\n            if info['random_index'] is not None:\n                nodes[i].random = nodes[info['random_index']]\n        return nodes[0]\n\n    def encode_input(self, input_obj) -> str:\n        return str(self.linked_list_to_array(input_obj['head']))\n\n    def encode_output(self, output_obj) -> str:\n        if not output_obj:\n            return str([])\n        return str(self.linked_list_to_array(output_obj))\n\n    def decode_input(self, input_str) -> dict:\n        data = eval(input_str)\n        return {'head': self.build_linked_list(data)}\n\n    def linked_list_to_array(self, head: 'Node') -> list:\n        if not head:\n            return []\n        nodes = []\n        current = head\n        while current:\n            random_index = None\n            if current.random is not None:\n                random_index = self.find_index(head, current.random)\n            nodes.append({'val': current.val, 'random_index': random_index})\n            current = current.next\n        return nodes\n\n    def find_index(self, head: 'Node', node: 'Node') -> int:\n        current, index = (head, 0)\n        while current:\n            if current == node:\n                return index\n            current = current.next\n            index += 1\n        return -1\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.copyRandomList(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.053",
            "memory": 4928,
            "stderr": null,
            "token": "8d2af899-1b36-4133-9ce2-3097f97f8a87",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 140,
        "title": "word-break-ii",
        "token": "735b5657-bea8-412e-bc32-25ae92070a24",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nfrom typing import List\n\nclass Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\n        word_set = set(wordDict)\n        n = len(s)\n        dp = [[] for _ in range(n + 1)]\n        dp[0] = [\"\"]\n\n        for i in range(1, n + 1):\n            for j in range(i):\n                word = s[j:i]\n                if word in word_set and dp[j]:\n                    for sentence in dp[j]:\n                        dp[i].append((sentence + \" \" + word).strip())\n\n        return dp[n]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        test_cases = [{'s': 'catsanddog', 'wordDict': ['cat', 'cats', 'and', 'sand', 'dog']}, {'s': 'pineapplepenapple', 'wordDict': ['apple', 'pen', 'applepen', 'pine', 'pineapple']}, {'s': 'catsandog', 'wordDict': ['cats', 'dog', 'sand', 'and', 'cat']}]\n        return random.choice(test_cases)\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['s']}|{'|'.join(input_obj['wordDict'])}\"\n\n    def encode_output(self, output_obj) -> str:\n        return '|'.join(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        s, *wordDict = input_str.split('|')\n        return {'s': s, 'wordDict': wordDict}\n\n    def decode_output(self, output_str) -> list:\n        return output_str.split('|')\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.wordBreak(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.053",
            "memory": 4812,
            "stderr": null,
            "token": "735b5657-bea8-412e-bc32-25ae92070a24",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 134,
        "title": "gas-station",
        "token": "4d5394ca-99f5-4cd4-b651-921427b883fc",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\n        n = len(gas)\n        total_gas = 0\n        curr_gas = 0\n        start_index = 0\n\n        for i in range(n):\n            total_gas += gas[i] - cost[i]\n            curr_gas += gas[i] - cost[i]\n\n            if curr_gas < 0:\n                curr_gas = 0\n                start_index = i + 1\n        \n        return start_index if total_gas >= 0 else -1\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 10)\n        gas = [random.randint(0, 10) for _ in range(n)]\n        cost = [random.randint(0, 10) for _ in range(n)]\n        return {'gas': gas, 'cost': cost}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['gas']}|{input_obj['cost']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        gas_str, cost_str = input_str.split('|')\n        gas = list(map(int, gas_str.strip('[]').split(', ')))\n        cost = list(map(int, cost_str.strip('[]').split(', ')))\n        return {'gas': gas, 'cost': cost}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.canCompleteCircuit(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.06",
            "memory": 4752,
            "stderr": null,
            "token": "4d5394ca-99f5-4cd4-b651-921427b883fc",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 228,
        "title": "summary-ranges",
        "token": "1a15c6e8-3a5f-480c-be0f-e9e82551ac27",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def summaryRanges(self, nums: List[int]) -> List[str]:\n        result = []\n        if not nums:\n            return result\n\n        start = nums[0]\n        end = nums[0]\n\n        for i in range(1, len(nums)):\n            if nums[i] == end + 1:\n                end = nums[i]\n            else:\n                if start == end:\n                    result.append(str(start))\n                else:\n                    result.append(f\"{start}->{end}\")\n                start = nums[i]\n                end = nums[i]\n\n        if start == end:\n            result.append(str(start))\n        else:\n            result.append(f\"{start}->{end}\")\n\n        return result\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(0, 20)\n        nums = sorted(random.sample(range(-100, 100), length))\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'nums': eval(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.summaryRanges(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.065",
            "memory": 4916,
            "stderr": null,
            "token": "1a15c6e8-3a5f-480c-be0f-e9e82551ac27",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 229,
        "title": "majority-element-ii",
        "token": "2bae4f71-beae-4fde-9aca-e37bc7d1d7e4",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nfrom collections import defaultdict\nimport random\nimport json\n\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def majorityElement(self, nums: List[int]) -> List[int]:\n        n1=None\n        c1=0\n        n2=None\n        c2=0\n        for num in nums:\n            if n1==num:\n                c1+=1\n            elif n2==num:\n                c2+=1\n            elif c1==0:\n                n1=num\n                c1=1\n            elif c2==0:\n                n2=num\n                c2=1\n            else:\n                c1-=1\n                c2-=1\n        c1=0\n        c2=0\n        for num in nums:\n            if num==n1:\n                c1+=1\n            if num==n2:\n                c2+=1\n        ans=[]\n        if c1>len(nums)//3:\n            ans.append(n1)\n        if c2>len(nums)//3 and n1 != n2:\n            ans.append(n2)\n        return ans\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(1, 100)\n        nums = [random.randint(-10, 10) for _ in range(length)]\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return json.dumps(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return json.loads(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.majorityElement(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.069",
            "memory": 4932,
            "stderr": null,
            "token": "2bae4f71-beae-4fde-9aca-e37bc7d1d7e4",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 230,
        "title": "kth-smallest-element-in-a-bst",
        "token": "1d275811-20b8-49f4-85a1-f07fd44626b2",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import Optional\nimport json\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def helper(self, root, res):\n        if root:\n            self.helper(root.left, res)\n            res.append(root.val)\n            self.helper(root.right, res)\n        return\n\n\n    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:\n        stack = []\n        cur = root\n        while stack or cur:\n            while cur:\n                stack.append(cur)\n                cur = cur.left\n            cur = stack.pop()\n            k-=1\n            if k==0:\n                return cur.val\n            cur = cur.right\n        return -1\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        root = TreeNode(3)\n        root.left = TreeNode(1)\n        root.right = TreeNode(4)\n        root.left.right = TreeNode(2)\n        k = 1\n        return {'root': root, 'k': k}\n\n    def encode_input(self, input_obj) -> str:\n\n        def tree_to_list(node):\n            if not node:\n                return None\n            return [node.val, tree_to_list(node.left), tree_to_list(node.right)]\n        as_list = tree_to_list(input_obj['root'])\n        return json.dumps({'root': as_list, 'k': input_obj['k']})\n\n    def encode_output(self, output_obj) -> str:\n        return json.dumps({'output': output_obj})\n\n    def decode_input(self, input_str) -> dict:\n\n        def list_to_tree(lst):\n            if not lst:\n                return None\n            node = TreeNode(lst[0])\n            node.left = list_to_tree(lst[1])\n            node.right = list_to_tree(lst[2])\n            return node\n        data = json.loads(input_str)\n        return {'root': list_to_tree(data['root']), 'k': data['k']}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.kthSmallest(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.063",
            "memory": 4784,
            "stderr": null,
            "token": "1d275811-20b8-49f4-85a1-f07fd44626b2",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 231,
        "title": "power-of-two",
        "token": "af0e08df-174a-4ee7-b3cf-2681ee926fa0",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def isPowerOfTwo(self, n: int) -> bool:\n        return n > 0 and (n & (n - 1) == 0)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        \"\"\" Generate random test cases for `isPowerOfTwo` method. \"\"\"\n        n = random.choice([1, 2, 4, 8, 16, 32, 64, 3, 5, 7, 9, 0, -1])\n        return {'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\" Convert the generate method's output into a test input string. \"\"\"\n        return str(input_obj['n'])\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\" Convert the output of the entry_point method into a test output string. \"\"\"\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\" Convert a test input string back into a Python dict for use in the entry_point method. \"\"\"\n        return {'n': int(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.isPowerOfTwo(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Input {'n': 8}\nExpected Output:  8\nActual Output:  True\n1 Test Failed!\n",
            "time": "0.06",
            "memory": 4760,
            "stderr": null,
            "token": "af0e08df-174a-4ee7-b3cf-2681ee926fa0",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 4,
                "description": "Wrong Answer"
            }
        }
    },
    {
        "status": "success",
        "question_id": 123,
        "title": "best-time-to-buy-and-sell-stock-iii",
        "token": "f53d35ac-38d1-4c35-ab81-34a53d1a8872",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        n = len(prices)\n        dp = [[[0 for _ in range(3)] for _ in range(2)] for _ in range(2)]\n\n        for i in range(n - 1, -1, -1):\n            for j in range(2):\n                for k in range(1, 3):\n                    if j == 0:\n                        dp[i % 2][j][k] = max(-prices[i] + dp[(i + 1) % 2][1][k], 0 + dp[(i + 1) % 2][0][k])\n                    else:\n                        dp[i % 2][j][k] = max(+prices[i] + dp[(i + 1) % 2][0][k - 1], 0 + dp[(i + 1) % 2][1][k])\n\n        return dp[0][0][2]\n\nclass TestCaseGenerator:\n    import random\n\n    def generate(self) -> dict:\n        length = self.random.randint(1, 100)\n        prices = [self.random.randint(0, 100) for _ in range(length)]\n        return {'prices': prices}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.maxProfit(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.068",
            "memory": 5016,
            "stderr": null,
            "token": "f53d35ac-38d1-4c35-ab81-34a53d1a8872",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 125,
        "title": "valid-palindrome",
        "token": "23da5d61-f999-43b7-881d-ab6f4d52db2a",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport json\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def isPalindrome(self, s: str) -> bool:\n        l, r = 0, len(s) - 1\n        while l < r:\n            while l < r and not s[l].isalnum():\n                l += 1\n            while l < r and not s[r].isalnum():\n                r -= 1\n            if s[l].casefold() != s[r].casefold():\n                return False\n            l += 1\n            r -= 1\n        return True\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        \"\"\"Generate random test case input for isPalindrome function.\"\"\"\n        test_cases = ['A man, a plan, a canal: Panama', 'race a car', '', ' ', 'Able was I ere I saw Elba', '!!!abcba!!!', '12321', 'No lemon, no melon', 'Step on no pets']\n        return {'s': random.choice(test_cases)}\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\"Convert a test case input into a JSON string.\"\"\"\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\"Convert a test case output into a JSON string.\"\"\"\n        return 'true' if output_obj else 'false'\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\"Convert a test case input string into a Python dict.\"\"\"\n        return json.loads(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.isPalindrome(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.06",
            "memory": 4836,
            "stderr": null,
            "token": "23da5d61-f999-43b7-881d-ab6f4d52db2a",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 128,
        "title": "longest-consecutive-sequence",
        "token": "d1fc0730-c40f-452a-b7a7-9328d1daccd5",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\nimport json\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def longestConsecutive(self, nums: List[int]) -> int:\n        numset = set(nums)\n        res = 0\n        for n in nums:\n            # check if n is a start of  seq\n            if (n-1) not in numset:\n                op = 0\n                while (n+op) in numset:\n                    op+=1\n                res = max(res,op)\n        return res\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(0, 100)\n        nums = random.sample(range(-10 ** 9, 10 ** 9), length)\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return json.loads(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.longestConsecutive(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.063",
            "memory": 4972,
            "stderr": null,
            "token": "d1fc0730-c40f-452a-b7a7-9328d1daccd5",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 130,
        "title": "surrounded-regions",
        "token": "759bb76b-d7c3-4ee3-a119-a5d7cfa5f812",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport collections\nimport random\nfrom typing import List\nfrom ast import literal_eval\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def solve(self, board: List[List[str]]) -> None:\n        \"\"\"\n        Do not return anything, modify board in-place instead.\n        \"\"\"\n        if not board:\n            return\n\n        M, N = len(board), len(board[0])\n\n        def dfs(i, j):\n            if i < 0 or i >= M or j < 0 or j >= N or board[i][j] != 'O':\n                return\n            \n            board[i][j] = '#'\n            dfs(i + 1, j)\n            dfs(i - 1, j)\n            dfs(i, j + 1)\n            dfs(i, j - 1)\n\n        # Mark 'O's connected to the boundary\n        for i in range(M):\n            if board[i][0] == 'O':\n                dfs(i, 0)\n            if board[i][N - 1] == 'O':\n                dfs(i, N - 1)\n\n        for j in range(N):\n            if board[0][j] == 'O':\n                dfs(0, j)\n            if board[M - 1][j] == 'O':\n                dfs(M - 1, j)\n\n        # Replace remaining 'O's with 'X's and restore '#'s to 'O's\n        for i in range(M):\n            for j in range(N):\n                if board[i][j] == 'O':\n                    board[i][j] = 'X'\n                elif board[i][j] == '#':\n                    board[i][j] = 'O'\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        ...\n\n    def encode_input(self, input_obj) -> str:\n        ...\n\n    def encode_output(self, output_obj) -> str:\n        ...\n\n    def decode_input(self, input_str) -> dict:\n        ...\n\n    def decode_output(self, output_str) -> str:\n        ...\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.solve(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.069",
            "memory": 5508,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 138, in <module>\n    runner.run()\n  File \"script.py\", line 122, in run\n    output = self.solution.solve(**input)\nTypeError: solve() argument after ** must be a mapping, not NoneType\n",
            "token": "759bb76b-d7c3-4ee3-a119-a5d7cfa5f812",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "success",
        "question_id": 82,
        "title": "remove-duplicates-from-sorted-list-ii",
        "token": "e91ad65b-c7f5-4c6b-8392-d954ed9b7892",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import Optional\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        fake = ListNode(-1)\n        fake.next = head\n        prev, curr = fake, head\n        while curr:\n            while curr.next and curr.val == curr.next.val:\n                curr = curr.next\n            if prev.next == curr:\n                prev = prev.next\n                curr = curr.next\n            else:\n                prev.next = curr.next\n                curr = prev.next\n        return fake.next\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        list_values = self._create_random_sorted_list()\n        head = self._convert_list_to_linkedlist(list_values)\n        return {'head': head}\n\n    def encode_input(self, input_obj) -> str:\n        encoded_input = []\n        current = input_obj['head']\n        while current:\n            encoded_input.append(current.val)\n            current = current.next\n        return str(encoded_input)\n\n    def encode_output(self, output_obj) -> str:\n        encoded_output = []\n        current = output_obj\n        while current:\n            encoded_output.append(current.val)\n            current = current.next\n        return str(encoded_output)\n\n    def decode_input(self, input_str) -> dict:\n        node_values = eval(input_str)\n        head = self._convert_list_to_linkedlist(node_values)\n        return {'head': head}\n\n    def _create_random_sorted_list(self) -> list:\n        list_size = random.randint(0, 30)\n        values = []\n        while len(values) < list_size:\n            rand_value = random.randint(-100, 100)\n            if random.choice([True, False]):\n                values += [rand_value] * random.randint(1, 3)\n            else:\n                values.append(rand_value)\n        values = sorted(values[:300])\n        return values\n\n    def _convert_list_to_linkedlist(self, values: list) -> Optional[ListNode]:\n        if not values:\n            return None\n        head = ListNode(values[0])\n        current = head\n        for value in values[1:]:\n            current.next = ListNode(value)\n            current = current.next\n        return head\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.deleteDuplicates(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.069",
            "memory": 4916,
            "stderr": null,
            "token": "e91ad65b-c7f5-4c6b-8392-d954ed9b7892",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 84,
        "title": "largest-rectangle-in-histogram",
        "token": "596a35c1-6544-4d0e-befa-12ba418240c8",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def largestRectangleArea(self, heights: List[int]) -> int:\n        st = []\n        area = 0\n        heights = [0] + heights + [0]\n\n        for i,a in enumerate(heights):\n            while(st and heights[st[-1]] > a):\n                rr = i\n                k = st.pop()\n                ll = st[-1]\n                h = heights[k]\n                length = rr - ll - 1 \n                area = max(area, h * length)\n\n            st.append(i)\n\n        return area\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        num_bars = random.randint(1, 10)\n        heights = [random.randint(0, 10) for _ in range(num_bars)]\n        return {'heights': heights}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['heights'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        heights = eval(input_str)\n        return {'heights': heights}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.largestRectangleArea(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.061",
            "memory": 4772,
            "stderr": null,
            "token": "596a35c1-6544-4d0e-befa-12ba418240c8",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 85,
        "title": "maximal-rectangle",
        "token": "327bd77b-853a-4cf2-8f0a-07c5e500b5e7",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\n        if not matrix:\n            return 0\n\n        m, n = len(matrix), len(matrix[0])\n        heights = [0] * n\n        max_area = 0\n\n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == '1':\n                    heights[j] += 1\n                else:\n                    heights[j] = 0\n\n            max_area = max(max_area, self.largestRectangleArea(heights))\n\n        return max_area\n\n    def largestRectangleArea(self, heights: List[int]) -> int:\n        stack = []\n        max_area = 0\n        n = len(heights)\n\n        for i in range(n + 1):\n            while stack and (i == n or heights[stack[-1]] >= heights[i]):\n                height = heights[stack.pop()]\n                width = i if not stack else i - stack[-1] - 1\n                max_area = max(max_area, height * width)\n            stack.append(i)\n\n        return max_area\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        rows = random.randint(1, 20)\n        cols = random.randint(1, 20)\n        matrix = [[random.choice(['0', '1']) for _ in range(cols)] for _ in range(rows)]\n        return {'matrix': matrix}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['matrix'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        input_list = eval(input_str)\n        return {'matrix': input_list}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.maximalRectangle(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.063",
            "memory": 5088,
            "stderr": null,
            "token": "327bd77b-853a-4cf2-8f0a-07c5e500b5e7",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 87,
        "title": "scramble-string",
        "token": "1b0d6319-8e23-4312-9acb-bddda093d2ad",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport numpy as np\nimport random\nimport string\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def isScramble(self, s1: str, s2: str) -> bool:\n        n = len(s1)\n        if n != len(s2):\n            return False\n        if s1 == s2:\n            return True\n        if sorted(s1) != sorted(s2):\n            return False\n\n        memo = {}\n\n        def solve(s1, s2):\n            if (s1, s2) in memo:\n                return memo[(s1, s2)]\n\n            if s1 == s2:\n                return True\n\n            if sorted(s1) != sorted(s2):\n                memo[(s1, s2)] = False\n                return False\n\n            n = len(s1)\n            for i in range(1, n):\n                if (solve(s1[:i], s2[:i]) and solve(s1[i:], s2[i:])) or \\\n                   (solve(s1[:i], s2[n-i:]) and solve(s1[i:], s2[:n-i])):\n                    memo[(s1, s2)] = True\n                    return True\n\n            memo[(s1, s2)] = False\n            return False\n\n        return solve(s1, s2)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(1, 30)\n        s1 = ''.join(random.choices(string.ascii_lowercase, k=length))\n        s2 = self.scramble(s1)\n        return {'s1': s1, 's2': s2}\n\n    def scramble(self, s: str) -> str:\n        if len(s) == 1:\n            return s\n        i = random.randint(1, len(s) - 1)\n        x, y = (s[:i], s[i:])\n        if random.random() > 0.5:\n            return self.scramble(x) + self.scramble(y)\n        else:\n            return self.scramble(y) + self.scramble(x)\n\n    def encode_input(self, input_obj: dict) -> str:\n        return f\"{input_obj['s1']},{input_obj['s2']}\"\n\n    def encode_output(self, output_obj: bool) -> str:\n        return 'true' if output_obj else 'false'\n\n    def decode_input(self, input_str: str) -> dict:\n        s1, s2 = input_str.split(',')\n        return {'s1': s1, 's2': s2}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.isScramble(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.06",
            "memory": 4676,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 26, in <module>\n    import numpy as np\nModuleNotFoundError: No module named 'numpy'\n",
            "token": "1b0d6319-8e23-4312-9acb-bddda093d2ad",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "success",
        "question_id": 88,
        "title": "merge-sorted-array",
        "token": "8bb3549e-5cf4-4159-8e27-65cfbe97f492",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\nimport ast\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\n        \"\"\"\n        Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        p1 = m-1\n        p2 = n-1\n        p = m+n-1\n        while p2 >= 0:\n            if p1 >= 0 and nums1[p1] > nums2[p2]:\n                nums1[p] = nums1[p1]\n                p1 -= 1\n            else:\n                nums1[p] = nums2[p2]\n                p2 -= 1\n            p -= 1\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        test_cases = [{'nums1': [1, 2, 3, 0, 0, 0], 'm': 3, 'nums2': [2, 5, 6], 'n': 3}, {'nums1': [4, 5, 6, 0, 0, 0], 'm': 3, 'nums2': [1, 2, 3], 'n': 3}, {'nums1': [1], 'm': 1, 'nums2': [], 'n': 0}, {'nums1': [0], 'm': 0, 'nums2': [1], 'n': 1}, {'nums1': [1, 2, 4, 5, 6, 0, 0, 0], 'm': 5, 'nums2': [3, 7, 8], 'n': 3}]\n        return random.choice(test_cases)\n\n    def encode_input(self, input_obj) -> str:\n        return f'{input_obj}'\n\n    def encode_output(self, output_obj) -> str:\n        return f'{output_obj}'\n\n    def decode_input(self, input_str) -> dict:\n        return ast.literal_eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.merge(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.067",
            "memory": 5096,
            "stderr": null,
            "token": "8bb3549e-5cf4-4159-8e27-65cfbe97f492",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 89,
        "title": "gray-code",
        "token": "aa8f82da-2eda-44c7-b184-fc589c04d451",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def grayCode(self, n: int) -> List[int]:\n        result = [0]\n        for i in range(n):\n            mask = 1 << i\n            for j in range(len(result) - 1, -1, -1):\n                result.append(result[j] | mask)\n        return result\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 16)\n        return {'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"n = {input_obj['n']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return f'{output_obj}'\n\n    def decode_input(self, input_str) -> dict:\n        lines = input_str.split(' = ')\n        return {'n': int(lines[1])}\n\n    def decode_output(self, output_str) -> dict:\n        output_obj = eval(output_str)\n        return output_obj\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.grayCode(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.1",
            "memory": 15972,
            "stderr": null,
            "token": "aa8f82da-2eda-44c7-b184-fc589c04d451",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 90,
        "title": "subsets-ii",
        "token": "f6f707df-16c5-4b0f-a0ab-5d1b9522a58b",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\n        ans=[]\n        ds=[]\n\n        def findSubsets(ind:int):\n            ans.append(ds[:])\n            for i in range(ind,len(nums)):\n                if i != ind and nums[i] == nums[i-1]:\n                    continue\n                ds.append(nums[i])\n                findSubsets(i+1)\n                ds.pop()\n        nums.sort()\n        findSubsets(0)\n        return ans\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(1, 10)\n        nums = [random.randint(-10, 10) for _ in range(length)]\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.subsetsWithDup(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Input {'nums': [-7, 2, 4]}\nExpected Output:  [[], [-7], [2], [-7, 2], [4], [-7, 4], [2, 4], [-7, 2, 4]]\nActual Output:  [[], [-7], [-7, 2], [-7, 2, 4], [-7, 4], [2], [2, 4], [4]]\n1 Test Failed!\n",
            "time": "0.069",
            "memory": 5416,
            "stderr": null,
            "token": "f6f707df-16c5-4b0f-a0ab-5d1b9522a58b",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 4,
                "description": "Wrong Answer"
            }
        }
    },
    {
        "status": "success",
        "question_id": 144,
        "title": "binary-tree-preorder-traversal",
        "token": "0950efa0-b5ca-438b-b99e-18ee7d768517",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List, Optional, Union\nimport random\n\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        ans = []\n        def solve(root):\n            if root is None:\n                return\n\n            ans.append(root.val)\n            solve(root.left)\n            solve(root.right)\n        solve(root)\n        return ans\n\nclass TestCaseGenerator:\n\n    class TreeNode:\n\n        def __init__(self, val=0, left=None, right=None):\n            self.val = val\n            self.left = left\n            self.right = right\n\n    def generate(self) -> dict:\n\n        def generate_random_tree(size=100):\n            if size == 0:\n                return None\n            nodes = [self.TreeNode(val=random.randint(-100, 100)) for _ in range(size)]\n            for i in range(size):\n                if 2 * i + 1 < size:\n                    nodes[i].left = nodes[2 * i + 1]\n                if 2 * i + 2 < size:\n                    nodes[i].right = nodes[2 * i + 2]\n            return nodes[0] if size > 0 else None\n        tree_size = random.randint(0, 10)\n        root = generate_random_tree(tree_size)\n        return {'root': root}\n\n    def encode_input(self, input_obj: dict) -> str:\n\n        def tree_to_list(root):\n            if not root:\n                return []\n            queue = [(root, 0)]\n            result = []\n            while queue:\n                node, index = queue.pop(0)\n                if node:\n                    if index >= len(result):\n                        result.extend([None] * (index - len(result) + 1))\n                    result[index] = node.val\n                    queue.append((node.left, 2 * index + 1))\n                    queue.append((node.right, 2 * index + 2))\n            while result and result[-1] is None:\n                result.pop()\n            return result\n        root = input_obj['root']\n        return str(tree_to_list(root))\n\n    def encode_output(self, output_obj: List[int]) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str: str) -> dict:\n\n        def list_to_tree(nodes: List[Union[int, None]]):\n            if not nodes:\n                return None\n            tree_nodes = [self.TreeNode(val=v) if v is not None else None for v in nodes]\n            for i in range(len(nodes)):\n                if tree_nodes[i] is not None:\n                    left_index = 2 * i + 1\n                    right_index = 2 * i + 2\n                    if left_index < len(tree_nodes):\n                        tree_nodes[i].left = tree_nodes[left_index]\n                    if right_index < len(tree_nodes):\n                        tree_nodes[i].right = tree_nodes[right_index]\n            return tree_nodes[0] if tree_nodes else None\n        nodes_list = eval(input_str)\n        root = list_to_tree(nodes_list)\n        return {'root': root}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.preorderTraversal(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.071",
            "memory": 4884,
            "stderr": null,
            "token": "0950efa0-b5ca-438b-b99e-18ee7d768517",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 148,
        "title": "sort-list",
        "token": "284c3726-1e4f-4cd9-9416-2cd317459c1c",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import Optional\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        def merge(head1, head2):\n            resultHead = ListNode(0)\n            cur = resultHead\n            while head1 and head2:\n                if head1.val < head2.val:\n                    cur.next = head1\n                    head1 = head1.next\n                else:\n                    cur.next = head2\n                    head2 = head2.next\n                cur = cur.next\n            \n            if head1:\n                cur.next = head1\n            if head2:\n                cur.next = head2\n            \n            return resultHead.next\n\n\n        def findOneBeforeMiddle(head):\n            slow = head\n            fast = head.next\n            while fast and fast.next:\n                slow = slow.next\n                fast = fast.next.next\n            return slow\n        \n        if not head or not head.next:\n            return head\n\n        middle = findOneBeforeMiddle(head)\n        temp = middle.next\n        middle.next = None\n\n        return merge(self.sortList(head), self.sortList(temp))\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        ...\n\n    def encode_input(self, input_obj) -> str:\n        ...\n\n    def encode_output(self, output_obj) -> str:\n        ...\n\n    def decode_input(self, input_str) -> dict:\n        ...\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.sortList(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.07",
            "memory": 4876,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 136, in <module>\n    runner.run()\n  File \"script.py\", line 120, in run\n    output = self.solution.sortList(**input)\nTypeError: sortList() argument after ** must be a mapping, not NoneType\n",
            "token": "284c3726-1e4f-4cd9-9416-2cd317459c1c",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "success",
        "question_id": 149,
        "title": "max-points-on-a-line",
        "token": "2dfba9db-265a-41ba-ad3c-9a5d001a9961",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nfrom collections import defaultdict\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nfrom typing import List\nfrom collections import defaultdict\nfrom math import gcd\n\nclass Solution:\n\n    def maxPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        if n <= 2:\n            return n\n        \n        max_count = 0\n        for i in range(n):\n            lines = defaultdict(int)\n            same_point = 1\n            for j in range(i + 1, n):\n                if points[i] == points[j]:\n                    same_point += 1\n                else:\n                    dx = points[j][0] - points[i][0]\n                    dy = points[j][1] - points[i][1]\n                    \n                    g = gcd(dx, dy)\n                    dx //= g\n                    dy //= g\n                    \n                    lines[(dx, dy)] += 1\n            \n            max_count = max(max_count, same_point)\n            for slope in lines:\n                max_count = max(max_count, lines[slope] + same_point)\n        \n        return max_count\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        simple_line = [[1, 1], [2, 2], [3, 3]]\n        mixed_points = [[1, 1], [3, 2], [5, 3], [4, 1], [2, 3], [1, 4]]\n        single_point = [[0, 0]]\n        return {'points': simple_line}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['points'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'points': eval(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.maxPoints(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.053",
            "memory": 4672,
            "stderr": null,
            "token": "2dfba9db-265a-41ba-ad3c-9a5d001a9961",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 150,
        "title": "evaluate-reverse-polish-notation",
        "token": "66ba1cfc-1407-49c9-91f0-16897b7af852",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport operator as op\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def evalRPN(self, tokens):\n        stack = []\n        for token in tokens:\n            if token == '+':\n                operand2 = stack.pop()\n                operand1 = stack.pop()\n                stack.append(operand1 + operand2)\n            elif token == '-':\n                operand2 = stack.pop()\n                operand1 = stack.pop()\n                stack.append(operand1 - operand2)\n            elif token == '*':\n                operand2 = stack.pop()\n                operand1 = stack.pop()\n                stack.append(operand1 * operand2)\n            elif token == '/':\n                operand2 = stack.pop()\n                operand1 = stack.pop()\n                stack.append(int(operand1 / operand2))\n            else:\n                stack.append(int(token))\n        return stack[0]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        operators = ['+', '-', '*', '/']\n        expressions = [('2', '1', '+', '3', '*'), ('4', '13', '5', '/', '+'), ('10', '6', '9', '3', '+', '-11', '*', '/', '*', '17', '+', '5', '+')]\n        selected_expr = random.choice(expressions)\n        return {'tokens': list(selected_expr)}\n\n    def encode_input(self, input_obj) -> str:\n        return ','.join(input_obj['tokens'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        tokens = input_str.split(',')\n        return {'tokens': tokens}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.evalRPN(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.055",
            "memory": 4764,
            "stderr": null,
            "token": "66ba1cfc-1407-49c9-91f0-16897b7af852",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 153,
        "title": "find-minimum-in-rotated-sorted-array",
        "token": "9a506cf0-f3ac-44c7-aa81-37b11fd7b3a5",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom random import randint, shuffle\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def findMin(self, arr: List[int]) -> int:\n        n = len(arr)\n        l = 0\n        h = n - 1\n\n        while l <= h:\n            if arr[l] < arr[h]:\n                return min(arr[l], arr[l]) # already min, no need to compare with ans\n            \n            m = (l + h) // 2\n\n            if arr[l] <= arr[m]:\n                \n                l = m + 1\n            else:\n                \n                h = m - 1\n\n        return arr[l] if l < n else arr[0]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = randint(2, 100)\n        sorted_array = sorted((randint(-5000, 5000) for _ in range(n)))\n        k = randint(1, n)\n        rotated_array = sorted_array[-k:] + sorted_array[:-k]\n        return {'nums': rotated_array}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'nums': eval(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.findMin(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.059",
            "memory": 4880,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 117, in <module>\n    runner.run()\n  File \"script.py\", line 101, in run\n    output = self.solution.findMin(**input)\nTypeError: findMin() got an unexpected keyword argument 'nums'\n",
            "token": "9a506cf0-f3ac-44c7-aa81-37b11fd7b3a5",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "success",
        "question_id": 160,
        "title": "intersection-of-two-linked-lists",
        "token": "a36e03e4-56aa-46f3-a4a5-a93f7df0e196",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import Optional\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        pA=headA\n        pB=headB\n        while pA!=pB:\n            pA=pA.next if pA else headB\n            pB=pB.next if pB else headA\n        return pA\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        \"\"\"\n        Generates a test case with an intersection in the linked list.\n        Returns a dictionary containing two linked list heads: headA and headB.\n        \"\"\"\n        common = ListNode(8)\n        common.next = ListNode(4)\n        common.next.next = ListNode(5)\n        listA = ListNode(4)\n        listA.next = ListNode(1)\n        listA.next.next = common\n        listB = ListNode(5)\n        listB.next = ListNode(6)\n        listB.next.next = ListNode(1)\n        listB.next.next.next = common\n        headA = listA\n        headB = listB\n        return {'headA': headA, 'headB': headB}\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\"\n        Encodes the length of both linked lists into a string.\n        \"\"\"\n        lengthA, lengthB = (0, 0)\n        currentA, currentB = (input_obj['headA'], input_obj['headB'])\n        while currentA:\n            lengthA += 1\n            currentA = currentA.next\n        while currentB:\n            lengthB += 1\n            currentB = currentB.next\n        return f'LENGTHS: A={lengthA}, B={lengthB}'\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\"\n        Returns the value of the intersecting node, or \"No Intersection\" if there isn\u2019t one.\n        \"\"\"\n        if output_obj:\n            return str(output_obj.val)\n        return 'No Intersection'\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\"\n        Decodes input (statically in our case) to provide test case linked lists.\n        \"\"\"\n        example_listA = [4, 1, 8, 4, 5]\n        example_listB = [5, 6, 1, 8, 4, 5]\n        headA, headB = (self._create_linked_list(example_listA), self._create_linked_list(example_listB))\n        return {'headA': headA, 'headB': headB}\n\n    def _create_linked_list(self, values):\n        \"\"\"\n        Helper method to create a linked list from a list of values.\n        \"\"\"\n        if not values:\n            return None\n        head = ListNode(values[0])\n        current = head\n        for val in values[1:]:\n            current.next = ListNode(val)\n            current = current.next\n        return head\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.getIntersectionNode(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.054",
            "memory": 4756,
            "stderr": null,
            "token": "a36e03e4-56aa-46f3-a4a5-a93f7df0e196",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 238,
        "title": "product-of-array-except-self",
        "token": "c83d915c-684d-4245-b6aa-7dd07138f4db",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nfrom random import randint\nimport ast\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def productExceptSelf(self, List, nums: List[int]) -> List[int]:\n        res = [1] * len(nums)\n\n        prefix = 1\n        for i in range(len(nums)):\n            res[i] = prefix\n            prefix *= nums[i]\n\n        postfix = 1\n        for i in range(len(nums) -1, -1, -1):\n            res[i] *= postfix\n            postfix *= nums[i]\n        return res\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = randint(2, 10)\n        nums = [randint(-30, 30) for _ in range(length)]\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return ast.literal_eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.productExceptSelf(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.056",
            "memory": 5160,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 110, in <module>\n    runner.run()\n  File \"script.py\", line 94, in run\n    output = self.solution.productExceptSelf(**input)\nTypeError: productExceptSelf() missing 1 required positional argument: 'List'\n",
            "token": "c83d915c-684d-4245-b6aa-7dd07138f4db",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "success",
        "question_id": 239,
        "title": "sliding-window-maximum",
        "token": "05fa6bbc-357b-4db5-aa80-428e790269f5",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport heapq\nimport random\nimport json\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nfrom collections import deque\n\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        d = deque()\n        result = []\n\n        for i, num in enumerate(nums):\n            # Remove elements out of the window\n            while d and d[0] <= i - k:\n                d.popleft()\n\n            # Remove elements smaller than the current element\n            while d and nums[d[-1]] <= num:\n                d.pop()\n\n            d.append(i)\n\n            if i >= k - 1:\n                result.append(nums[d[0]])\n\n        return result\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 100)\n        nums = [random.randint(-10000, 10000) for _ in range(n)]\n        k = random.randint(1, n)\n        return {'nums': nums, 'k': k}\n\n    def encode_input(self, input_obj: dict) -> str:\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj: list) -> str:\n        return json.dumps(output_obj)\n\n    def decode_input(self, input_str: str) -> dict:\n        return json.loads(input_str)\n\n    def decode_output(self, output_str: str) -> list:\n        return json.loads(output_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.maxSlidingWindow(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.059",
            "memory": 4896,
            "stderr": null,
            "token": "05fa6bbc-357b-4db5-aa80-428e790269f5",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 241,
        "title": "different-ways-to-add-parentheses",
        "token": "e5bfffaf-b649-48b5-8c95-b6de375911f1",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport functools\nimport random\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def diffWaysToCompute(self, expression: str) -> List[int]:\n        memo = {}\n\n        def compute(expr):\n            if expr in memo:\n                return memo[expr]\n\n            if expr.isdigit():\n                return [int(expr)]\n\n            res = []\n            for i, s in enumerate(expr):\n                if s in \"+-*\":\n                    left = compute(expr[:i])\n                    right = compute(expr[i+1:])\n                    for l in left:\n                        for r in right:\n                            if s == '+':\n                                res.append(l + r)\n                            elif s == '-':\n                                res.append(l - r)\n                            else:\n                                res.append(l * r)\n\n            memo[expr] = res\n            return res\n\n        return compute(expression)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        operators = ['+', '-', '*']\n        num_parts = random.randint(2, 5)\n        expression = str(random.randint(0, 99))\n        for _ in range(num_parts - 1):\n            operator = random.choice(operators)\n            number = random.randint(0, 99)\n            expression += operator + str(number)\n        return {'expression': expression}\n\n    def encode_input(self, input_obj: dict) -> str:\n        return input_obj['expression']\n\n    def encode_output(self, output_obj: List[int]) -> str:\n        return ','.join(map(str, output_obj))\n\n    def decode_input(self, input_str: str) -> dict:\n        return {'expression': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.diffWaysToCompute(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.058",
            "memory": 4816,
            "stderr": null,
            "token": "e5bfffaf-b649-48b5-8c95-b6de375911f1",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 242,
        "title": "valid-anagram",
        "token": "4fee9d9a-b876-41fa-ad77-615c3a03c428",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def isAnagram(self, s: str, t: str) -> bool:\n        if len(s) != len(t):\n            return False\n        sa = [0]*26\n        ta = [0]*26\n        for i in range(len(s)):\n            sa[ord(s[i])-ord('a')] += 1\n            ta[ord(t[i])-ord('a')] += 1\n        return sa==ta\n\nclass TestCaseGenerator:\n\n    def __init__(self):\n        self.examples = [{'s': 'anagram', 't': 'nagaram'}, {'s': 'rat', 't': 'car'}, {'s': 'listen', 't': 'silent'}, {'s': 'hello', 't': 'bello'}, {'s': 'debitcard', 't': 'badcredit'}]\n\n    def generate(self) -> dict:\n        return random.choice(self.examples)\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['s']},{input_obj['t']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj).lower()\n\n    def decode_input(self, input_str) -> dict:\n        s, t = input_str.split(',')\n        return {'s': s, 't': t}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.isAnagram(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.05",
            "memory": 4764,
            "stderr": null,
            "token": "4fee9d9a-b876-41fa-ad77-615c3a03c428",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 31,
        "title": "next-permutation",
        "token": "a355454d-11f5-4dff-82ca-5c096e6b4e76",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def swap(self, nums, i, j):\n        nums[i], nums[j] = nums[j], nums[i]\n    def reverse(self, nums, i, j):\n        while i < j:\n            self.swap(nums, i, j)\n            i += 1\n            j -= 1\n            \n    def nextPermutation(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        i = len(nums) - 2\n        while i >= 0 and nums[i] >= nums[i + 1]:\n            i -= 1\n        if i >= 0:\n            j = len(nums) - 1\n            while nums[j] <= nums[i]:\n                j -= 1\n            self.swap(nums, i, j)\n        self.reverse(nums, i+1, len(nums) - 1)\n\nclass TestCaseGenerator:\n\n    def __init__(self):\n        self.sample = random.sample\n        self.randint = random.randint\n\n    def generate(self) -> dict:\n        length = self.randint(1, 10)\n        nums = self.sample(range(0, 101), length)\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'nums': list(map(int, input_str.strip('[]').split(',')))}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.nextPermutation(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.058",
            "memory": 4800,
            "stderr": null,
            "token": "a355454d-11f5-4dff-82ca-5c096e6b4e76",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 32,
        "title": "longest-valid-parentheses",
        "token": "8a7191c0-fece-41db-91d7-e9af637b1c2c",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def longestValidParentheses(self, s: str) -> int:\n        max_len = 0\n        stack = [-1]\n        for i in range(len(s)):\n            if s[i] == '(':\n                stack.append(i)\n            else:\n                stack.pop()\n                if not stack:\n                    stack.append(i)\n                else:\n                    max_len = max(max_len, i - stack[-1])\n        return max_len\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        length = random.randint(0, 20)\n        parentheses = [random.choice(['(', ')']) for _ in range(length)]\n        return {'s': ''.join(parentheses)}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['s']\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.longestValidParentheses(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.06",
            "memory": 4804,
            "stderr": null,
            "token": "8a7191c0-fece-41db-91d7-e9af637b1c2c",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 33,
        "title": "search-in-rotated-sorted-array",
        "token": "d3fb8f9e-c28d-4344-92b5-51462c550ddf",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        l = 0\n        r = len(nums) - 1\n        while l <= r:\n            mid = (l + r) // 2\n            if nums[mid] == target:\n                return mid\n\n            if nums[l] <= nums[mid]:\n                if nums[l] <= target <= nums[mid]:\n                    r = mid - 1\n                else:\n                    l = mid + 1\n            else:\n                if nums[mid] <= target <= nums[r]:\n                    l = mid + 1\n                else:\n                    r = mid - 1\n\n        return -1\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 20)\n        array = sorted(random.sample(range(-50, 50), n))\n        k = random.randint(0, n - 1)\n        rotated_array = array[k:] + array[:k]\n        target = random.choice(rotated_array + [101])\n        return {'nums': rotated_array, 'target': target}\n\n    def encode_input(self, input_obj) -> str:\n        nums_str = ','.join(map(str, input_obj['nums']))\n        target_str = str(input_obj['target'])\n        return f'nums=[{nums_str}], target={target_str}'\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        input_str = input_str.strip()\n        nums_part = input_str.split('target=')[0].strip()\n        target_part = input_str.split('target=')[1].strip()\n        nums = list(map(int, nums_part[nums_part.index('[') + 1:nums_part.rindex(']')].split(',')))\n        target = int(target_part)\n        return {'nums': nums, 'target': target}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.search(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.064",
            "memory": 4748,
            "stderr": null,
            "token": "d3fb8f9e-c28d-4344-92b5-51462c550ddf",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 34,
        "title": "find-first-and-last-position-of-element-in-sorted-array",
        "token": "32dfcb86-ceef-4f48-a7b1-aa20644c26d4",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nfrom typing import List\nfrom bisect import bisect_left, bisect_right\n\nclass Solution:\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\n        l = bisect_left(nums, target)\n        if l == len(nums) or nums[l] != target:\n            return [-1, -1]\n        r = bisect_right(nums, target)\n        return [l, r - 1]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        test_cases = [{'nums': [5, 7, 7, 8, 8, 10], 'target': 8}, {'nums': [5, 7, 7, 8, 8, 10], 'target': 6}, {'nums': [], 'target': 0}, {'nums': [2, 2, 2, 2, 2], 'target': 2}, {'nums': [1, 3, 5, 6, 8, 10], 'target': 7}]\n        return random.choice(test_cases)\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['nums']}|{input_obj['target']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        nums_str, target_str = input_str.split('|')\n        nums = list(map(int, nums_str.strip('[]').split(','))) if nums_str.strip('[]') else []\n        target = int(target_str)\n        return {'nums': nums, 'target': target}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.searchRange(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.066",
            "memory": 4852,
            "stderr": null,
            "token": "32dfcb86-ceef-4f48-a7b1-aa20644c26d4",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 191,
        "title": "number-of-1-bits",
        "token": "ba499410-05a2-4684-9eec-c6851f0fc341",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport json\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def hammingWeight(self, n: int) -> int:\n        count = 0\n        while n:\n            count += n & 1\n            n >>= 1\n        return count\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 2 ** 20)\n        return {'n': n}\n\n    def encode_input(self, input_obj: dict) -> str:\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj: int) -> str:\n        return json.dumps({'result': output_obj})\n\n    def decode_input(self, input_str: str) -> dict:\n        return json.loads(input_str)\n\n    def decode_output(self, output_str: str) -> int:\n        return json.loads(output_str)['result']\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.hammingWeight(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.06",
            "memory": 4756,
            "stderr": null,
            "token": "ba499410-05a2-4684-9eec-c6851f0fc341",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 198,
        "title": "house-robber",
        "token": "5120bc8d-d1a0-49c3-a248-bfda9b938935",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def rob(self, nums: List[int]) -> int:\n        \n        if (len(nums) == 0):\n            return 0\n        elif (len(nums) == 1):\n            return nums[0]\n        \n        rob1, rob2 = 0, 0\n        \n        for n in nums:\n            temp = max(n + rob1, rob2)\n            rob1 = rob2\n            rob2 = temp\n            \n        return rob2\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(2, 20)\n        nums = [random.randint(0, 400) for _ in range(length)]\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        nums = eval(input_str)\n        return {'nums': nums}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.rob(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.054",
            "memory": 4784,
            "stderr": null,
            "token": "5120bc8d-d1a0-49c3-a248-bfda9b938935",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "failure",
        "question_id": 199,
        "title": "binary-tree-right-side-view",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "success",
        "question_id": 201,
        "title": "bitwise-and-of-numbers-range",
        "token": "09958024-1d89-418a-b3d1-fc335e400061",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def rangeBitwiseAnd(self, left: int, right: int) -> int:\n        while left < right:\n            right &= (right - 1)\n        return right\n\nclass TestCaseGenerator:\n\n    @staticmethod\n    def generate() -> dict:\n        left = random.randint(0, 10000)\n        right = random.randint(left, left + random.randint(0, 10000))\n        return {'left': left, 'right': right}\n\n    @staticmethod\n    def encode_input(input_obj) -> str:\n        return f\"{input_obj['left']},{input_obj['right']}\"\n\n    @staticmethod\n    def encode_output(output_obj) -> str:\n        return str(output_obj)\n\n    @staticmethod\n    def decode_input(input_str) -> dict:\n        left, right = map(int, input_str.split(','))\n        return {'left': left, 'right': right}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.rangeBitwiseAnd(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.051",
            "memory": 4740,
            "stderr": null,
            "token": "09958024-1d89-418a-b3d1-fc335e400061",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 205,
        "title": "isomorphic-strings",
        "token": "0d13bb3e-0c96-4595-a14e-55d5dc1e27f2",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport string\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def isIsomorphic(self, s: str, t: str) -> bool:\n        stot = {}\n        ttos = {}\n        for s_, t_ in zip(s, t):\n            if s_ in stot and stot.get(s_)!=t_:\n                return False\n            if t_ in ttos and ttos.get(t_)!=s_:\n                return False\n\n            stot[s_] = t_\n            ttos[t_] = s_\n        return True\n\nclass TestCaseGenerator:\n\n    def __init__(self):\n        self.libraries = ['random', 'string']\n\n    def generate(self) -> dict:\n        length = random.randint(1, 100)\n        s = ''.join((random.choice(string.ascii_letters) for _ in range(length)))\n        t = ''.join((random.choice(string.ascii_letters) for _ in range(length)))\n        return {'s': s, 't': t}\n\n    def encode_input(self, input_obj) -> str:\n        return f'''s = \"{input_obj['s']}\", t = \"{input_obj['t']}\"'''\n\n    def encode_output(self, output_obj) -> str:\n        return 'true' if output_obj else 'false'\n\n    def decode_input(self, input_str) -> dict:\n        input_parts = input_str.split(', ')\n        s_value = input_parts[0].split('= ')[1].strip('\"')\n        t_value = input_parts[1].split('= ')[1].strip('\"')\n        return {'s': s_value, 't': t_value}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.isIsomorphic(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.051",
            "memory": 4892,
            "stderr": null,
            "token": "0d13bb3e-0c96-4595-a14e-55d5dc1e27f2",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 210,
        "title": "course-schedule-ii",
        "token": "f26d9987-b5f9-4a4a-aa7b-53065d904328",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom collections import deque\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\n        graph = [[] for _ in range(numCourses)]\n        in_degree = [0] * numCourses\n        \n        for course, pre in prerequisites:\n            graph[pre].append(course)\n            in_degree[course] += 1\n        \n        queue = [i for i in range(numCourses) if in_degree[i] == 0]\n        result = []\n        \n        while queue:\n            course = queue.pop(0)\n            result.append(course)\n            \n            for next_course in graph[course]:\n                in_degree[next_course] -= 1\n                if in_degree[next_course] == 0:\n                    queue.append(next_course)\n        \n        if len(result) == numCourses:\n            return result\n        else:\n            return []\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        numCourses = random.randint(1, 10)\n        prereq_num = random.randint(0, min(10, numCourses * (numCourses - 1)))\n        prerequisites = []\n        seen = set()\n        for _ in range(prereq_num):\n            a, b = random.sample(range(numCourses), 2)\n            if (a, b) not in seen:\n                seen.add((a, b))\n                prerequisites.append([a, b])\n        return {'numCourses': numCourses, 'prerequisites': prerequisites}\n\n    def encode_input(self, input_obj: dict) -> str:\n        return f\"{input_obj['numCourses']}, {input_obj['prerequisites']}\"\n\n    def encode_output(self, output_obj: list) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str: str) -> dict:\n        num_courses_str, prerequisites_str = input_str.split(',', 1)\n        num_courses = int(num_courses_str)\n        prerequisites = eval(prerequisites_str.strip())\n        return {'numCourses': num_courses, 'prerequisites': prerequisites}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.findOrder(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Input {'numCourses': 8, 'prerequisites': [[4, 3], [2, 7], [5, 7], [5, 6], [6, 7]]}\nExpected Output:  deque([1, 0, 7, 6, 5, 2, 3, 4])\nActual Output:  [0, 1, 3, 7, 4, 2, 6, 5]\n1 Test Failed!\n",
            "time": "0.058",
            "memory": 4856,
            "stderr": null,
            "token": "f26d9987-b5f9-4a4a-aa7b-53065d904328",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 4,
                "description": "Wrong Answer"
            }
        }
    },
    {
        "status": "success",
        "question_id": 214,
        "title": "shortest-palindrome",
        "token": "e7c63883-38c1-4e53-a19f-156e4b9c9b63",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport string\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def shortestPalindrome(self, s: str) -> str:\n        n = len(s)\n        combined = s + \"#\" + s[::-1]\n        m = len(combined)\n        lps = [0] * m\n        \n        for i in range(1, m):\n            length = lps[i - 1]\n            while length > 0 and combined[i] != combined[length]:\n                length = lps[length - 1]\n            if combined[i] == combined[length]:\n                length += 1\n            lps[i] = length\n        \n        return s[lps[-1]:][::-1] + s\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(1, 100)\n        random_str = ''.join((random.choice(string.ascii_lowercase) for _ in range(length)))\n        return {'s': random_str}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['s']\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.shortestPalindrome(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.053",
            "memory": 4848,
            "stderr": null,
            "token": "e7c63883-38c1-4e53-a19f-156e4b9c9b63",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 216,
        "title": "combination-sum-iii",
        "token": "e8b12701-50ba-4469-bd56-f9622bd0643a",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\n        if 45-(9-k)*(10-k)/2 < n or k*(k+1)/2 > n:\n            return []\n\n        def backtrack(comb, s, n):\n            if n == 0 and len(comb) == k:\n                output.append(comb.copy())\n                return\n            if len(comb) > k or n < 0:\n                return\n            for i in range(s, min(n+1, 10)):\n                comb.append(i)\n                backtrack(comb, i+1, n-i)\n                comb.pop()\n        \n        output = []\n        backtrack([], 1, n)\n        return output\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        k = random.randint(2, 9)\n        n = random.randint(1, 60)\n        return {'k': k, 'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['k']} {input_obj['n']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        k, n = map(int, input_str.split())\n        return {'k': k, 'n': n}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.combinationSum3(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.066",
            "memory": 4804,
            "stderr": null,
            "token": "e8b12701-50ba-4469-bd56-f9622bd0643a",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 93,
        "title": "restore-ip-addresses",
        "token": "e6e14ee2-de2b-432e-b691-86a80ca8b0e3",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        path = []\n        result = []\n        len_s = len(s)\n\n        def is_valid_ip(s):\n            if not s:\n                return False\n            if (s[0] == '0' and len(s) > 1) or int(s) > 255:\n                return False\n            else:\n                return True\n\n        def backtracking(start_idx, point_count):\n            if point_count == 4:\n                if start_idx == len_s:\n                    result.append(\".\".join(path))\n                return\n\n            if len_s - start_idx < (4 - point_count) or len_s - start_idx > (4 - point_count) * 3:\n                return\n            \n\n            for i in range(start_idx, min(start_idx + 3, len_s)):\n                temp = s[start_idx:i + 1]\n                if is_valid_ip(temp):\n                    path.append(temp)\n                    backtracking(i + 1, point_count + 1)\n                    path.pop()\n\n        backtracking(0, 0)\n        return result\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        \"\"\"Generates a random test case for the restoreIpAddresses function.\"\"\"\n        s = ''.join((random.choice('0123456789') for _ in range(random.randint(4, 12))))\n        return {'s': s}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['s']\n\n    def encode_output(self, output_obj) -> str:\n        return ','.join(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.restoreIpAddresses(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.054",
            "memory": 4764,
            "stderr": null,
            "token": "e6e14ee2-de2b-432e-b691-86a80ca8b0e3",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "failure",
        "question_id": 127,
        "title": "word-ladder",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "success",
        "question_id": 81,
        "title": "search-in-rotated-sorted-array-ii",
        "token": "1c5eb2b3-1647-48d3-a66e-08c4437e5aea",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def search(self, nums: List[int], target: int) -> bool:\n        left = 0\n        right = len(nums) - 1\n        while left <= right:\n            middle = (left + right) // 2\n            if nums[middle] == target:\n                return True\n            if (nums[left] == nums[middle] and nums[middle] == nums[right]):\n                left += 1\n                right -= 1\n            elif nums[left] <= nums[middle]:\n                if nums[left] <= target and target < nums[middle]:\n                    right = middle - 1\n                else:\n                    left = middle + 1\n            else:\n                if target > nums[middle] and target <= nums[right]:\n                    left = middle + 1\n                else:\n                    right = middle - 1\n        return False\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        n = random.randint(1, 100)\n        nums = sorted([random.randint(-10000, 10000) for _ in range(n)])\n        pivot = random.randint(0, n - 1)\n        nums = nums[pivot:] + nums[:pivot]\n        target = random.choice(nums + [random.randint(-10000, 10000)])\n        return {'nums': nums, 'target': target}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.search(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.056",
            "memory": 5044,
            "stderr": null,
            "token": "1c5eb2b3-1647-48d3-a66e-08c4437e5aea",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 151,
        "title": "reverse-words-in-a-string",
        "token": "53eec5f2-f086-4683-b485-ee403875666b",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def reverseWords(self, s: str) -> str:\n        words = []\n        word = \"\"\n        for char in s:\n            if char == \" \":\n                if word:\n                    words.append(word)\n                    word = \"\"\n            else:\n                word += char\n        if word:\n            words.append(word)\n        \n        reversed_words = []\n        for i in range(len(words) - 1, -1, -1):\n            reversed_words.append(words[i])\n        \n        return \" \".join(reversed_words)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        test_cases = [{'s': 'the sky is blue'}, {'s': '  hello world  '}, {'s': 'a good   example'}, {'s': 'singleword'}, {'s': '  multiple words   with   extra spaces '}, {'s': '    boundary   '}]\n        return test_cases[0]\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['s']\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.reverseWords(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.054",
            "memory": 4832,
            "stderr": null,
            "token": "53eec5f2-f086-4683-b485-ee403875666b",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 152,
        "title": "maximum-product-subarray",
        "token": "71be9faf-fb7d-4b17-848c-3b65fe0c84e6",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def maxProduct(self, nums: List[int]) -> int:\n        max_prod = float('-inf')\n        prefix, suffix = 1, 1\n        n = len(nums)\n        for i in range(n):\n            prefix *= nums[i]\n            suffix *= nums[n - i - 1]\n            max_prod = max(max_prod, prefix, suffix)\n            if prefix == 0: prefix = 1\n            if suffix == 0: suffix = 1\n        return max_prod\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        nums_length = random.randint(1, 20)\n        nums = [random.randint(-10, 10) for _ in range(nums_length)]\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.maxProduct(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.061",
            "memory": 4880,
            "stderr": null,
            "token": "71be9faf-fb7d-4b17-848c-3b65fe0c84e6",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "failure",
        "question_id": 95,
        "title": "unique-binary-search-trees-ii",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "success",
        "question_id": 96,
        "title": "unique-binary-search-trees",
        "token": "f9d9d1f7-2b1b-4c59-914f-7bf990fa0518",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport json\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def numTrees(self, n: int) -> int:\n\n        list_ = [0]*(n + 1)\n        list_[0], list_[1] = 1,1\n        for i in range(2, n+1):\n            for j in range(1,i+1):\n                list_[i] += list_[j-1]*list_[i-j]\n\n        return list_[n]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 19)\n        return {'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return json.dumps(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return json.loads(input_str)\n\n    def decode_output(self, output_str) -> int:\n        return json.loads(output_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.numTrees(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.061",
            "memory": 4816,
            "stderr": null,
            "token": "f9d9d1f7-2b1b-4c59-914f-7bf990fa0518",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 97,
        "title": "interleaving-string",
        "token": "85875e18-9830-48ee-a0d2-b4fdf2581a95",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import Dict\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n\n        # dp[i][j] represents whether the first i characters in s1\n        # and the first j characters in s2\n        # can form the first i + j characters of s3\n\n        if len(s1) + len(s2) != len(s3):\n            return False\n\n        dp = [[False] * (len(s2) + 1) for _ in range((len(s1) + 1))]\n\n        # true for empty string\n        dp[0][0] = True\n\n        for i in range(len(s1) + 1):\n            for j in range(len(s2) + 1):\n                if i == 0 and j == 0:\n                    continue\n                # initialise base cases i and j\n                elif i == 0:\n                    dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\n                elif j == 0:\n                    dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\n                # interleave using either s1 OR s2\n                else:\n                    dp[i][j] = (dp[i][j - 1] and s2[j - 1] == s3[j + i - 1]) or \\\n                               (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1])\n\n        return dp[len(s1)][len(s2)]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        return {'s1': 'aabcc', 's2': 'dbbca', 's3': 'aadbbcbcac'}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{{'s1': '{input_obj['s1']}', 's2': '{input_obj['s2']}', 's3': '{input_obj['s3']}'}}\"\n\n    def encode_output(self, output_obj) -> str:\n        return 'true' if output_obj else 'false'\n\n    def decode_input(self, input_str) -> dict:\n        input_obj = eval(input_str)\n        return {'s1': input_obj['s1'], 's2': input_obj['s2'], 's3': input_obj['s3']}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.isInterleave(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.059",
            "memory": 4752,
            "stderr": null,
            "token": "85875e18-9830-48ee-a0d2-b4fdf2581a95",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 1,
        "title": "two-sum",
        "token": "03d51ee6-0eb6-4f56-8526-62addd26c422",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        num_map = {}\n        for index, num in enumerate(nums):\n            complement = target - num\n            if complement in num_map:\n                return [num_map[complement], index]\n            num_map[num] = index\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        length = random.randint(2, 10)\n        nums = random.sample(range(-100, 100), length)\n        idx1, idx2 = random.sample(range(length), 2)\n        target = nums[idx1] + nums[idx2]\n        return {'nums': nums, 'target': target}\n\n    def encode_input(self, input_obj) -> str:\n        nums_str = ','.join(map(str, input_obj['nums']))\n        return f\"nums=[{nums_str}],target={input_obj['target']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return f'{output_obj[0]},{output_obj[1]}'\n\n    def decode_input(self, input_str) -> dict:\n        input_vars = input_str.split('],')\n        nums_str = input_vars[0].replace('nums=[', '')\n        nums = list(map(int, nums_str.split(',')))\n        target = int(input_vars[1].replace('target=', ''))\n        return {'nums': nums, 'target': target}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.twoSum(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.052",
            "memory": 4876,
            "stderr": null,
            "token": "03d51ee6-0eb6-4f56-8526-62addd26c422",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 5,
        "title": "longest-palindromic-substring",
        "token": "b7d23ead-360b-4481-9b01-56a71d78afdf",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport string\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        longest = \"\"\n        n = len(s)\n        dp = [[False] * n for _ in range(n)]\n\n        for i in range(n):\n            dp[i][i] = True\n            if len(longest) == 0:\n                longest = s[i]\n\n        for i in range(n - 1):\n            if s[i] == s[i + 1]:\n                dp[i][i + 1] = True\n                if len(longest) < 2:\n                    longest = s[i:i+2]\n\n        for length in range(3, n + 1):\n            for i in range(n - length + 1):\n                j = i + length - 1\n                if s[i] == s[j] and dp[i + 1][j - 1]:\n                    dp[i][j] = True\n                    if length > len(longest):\n                        longest = s[i:j+1]\n\n        return longest\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(1, 100)\n        s = ''.join(random.choices(string.ascii_letters + string.digits, k=length))\n        return {'s': s}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['s']\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.longestPalindrome(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.062",
            "memory": 4892,
            "stderr": null,
            "token": "b7d23ead-360b-4481-9b01-56a71d78afdf",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 6,
        "title": "zigzag-conversion",
        "token": "4eac096b-c987-4052-8de8-15506a0dc9db",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom math import ceil\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def convert(self, s: str, numRows: int) -> str:\n        if numRows <= 1 or numRows >= len(s):\n            return s\n\n        result = \"\"\n        cycle_len = 2 * numRows - 2\n\n        for row in range(numRows):\n            for j in range(0, len(s), cycle_len):\n                index = j + row\n                if index < len(s):\n                    result += s[index]\n                if row != 0 and row != numRows - 1 and j + cycle_len - row < len(s):\n                    result += s[j + cycle_len - row]\n\n        return result\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz,.'\n        string_length = random.randint(1, 20)\n        random_string = ''.join((random.choice(letters) for _ in range(string_length)))\n        num_rows = random.randint(1, min(string_length, 10))\n        return {'s': random_string, 'numRows': num_rows}\n\n    def encode_input(self, input_obj) -> str:\n        s = input_obj['s']\n        numRows = input_obj['numRows']\n        return f\"{{'s': '{s}', 'numRows': {numRows}}}\"\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        return eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.convert(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.051",
            "memory": 4872,
            "stderr": null,
            "token": "4eac096b-c987-4052-8de8-15506a0dc9db",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 8,
        "title": "string-to-integer-atoi",
        "token": "1ff570fe-4882-4d1d-b273-53d6db97475f",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def myAtoi(self, s: str) -> int:\n        negative = False\n        start_digit = False\n        result = 0\n        INT_MAX = 2**31 - 1\n        INT_MIN = -2**31\n        \n        for char in s:\n            if char == \" \" and not start_digit:\n                continue\n            \n            if char == \"-\" and not start_digit:\n                negative = True\n                start_digit = True\n                continue\n            elif char == \"+\" and not start_digit:\n                start_digit = True\n                continue\n            \n            if char.isdigit():\n                digit = int(char)\n                if result > INT_MAX // 10 or (result == INT_MAX // 10 and digit > 7):\n                    return INT_MAX if not negative else INT_MIN\n                result = result * 10 + digit\n                start_digit = True\n                continue\n            \n            # If a non-digit character is encountered after starting to read digits\n            if start_digit:\n                break\n            \n            # If the character is invalid at the start (non-digit and not a sign)\n            if not char.isdigit() and not start_digit:\n                return 0\n        \n        if negative:\n            result = -result\n        \n        return result\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        cases = ['42', '    -42', '+123', '1337abc', ' ', '9223372036854775808', '-2147483649', '3.14159', '00100', 'words 456']\n        return {'s': random.choice(cases)}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['s']\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.myAtoi(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.051",
            "memory": 4852,
            "stderr": null,
            "token": "1ff570fe-4882-4d1d-b273-53d6db97475f",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 309,
        "title": "best-time-to-buy-and-sell-stock-with-cooldown",
        "token": "544be328-723a-4e3a-a89d-6399203402ec",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List\nimport ast\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def maxProfit(self, prices: list[int]) -> int:\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        max_profit = 0\n        min_price = float('inf')\n\n        for price in prices:\n            min_price = min(min_price, price)\n            profit = price - min_price\n            max_profit = max(max_profit, profit)\n\n        return max_profit\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(1, 100)\n        prices = [random.randint(0, 1000) for _ in range(length)]\n        return {'prices': prices}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['prices'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        prices = ast.literal_eval(input_str)\n        return {'prices': prices}\n\n    def decode_output(self, output_str) -> int:\n        return int(output_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.maxProfit(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.068",
            "memory": 5040,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 49, in <module>\n    class Solution:\n  File \"script.py\", line 50, in Solution\n    def maxProfit(self, prices: list[int]) -> int:\nTypeError: 'type' object is not subscriptable\n",
            "token": "544be328-723a-4e3a-a89d-6399203402ec",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "success",
        "question_id": 299,
        "title": "bulls-and-cows",
        "token": "40fc3ed1-442f-4dfa-bf75-0da1204e7aa7",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom collections import Counter\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def getHint(self, secret: str, guess: str) -> str:\n        counts = {}\n        bulls = 0\n        cows = 0\n\n        for i in range(len(secret)):\n            if secret[i] == guess[i]:\n                bulls += 1\n            else:\n                counts[secret[i]] = counts.get(secret[i], 0) + 1\n\n        for i in range(len(secret)):\n            if secret[i] != guess[i]:\n                if guess[i] in counts and counts[guess[i]] > 0:\n                    cows += 1\n                    counts[guess[i]] -= 1\n\n        return f'{bulls}A{cows}B'\n\nclass TestCaseGenerator:\n\n    def __init__(self):\n        self.random = random\n\n    def generate(self) -> dict:\n        length = self.random.randint(1, 10)\n        secret = ''.join(self.random.choices('0123456789', k=length))\n        guess = ''.join(self.random.choices('0123456789', k=length))\n        return {'secret': secret, 'guess': guess}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"secret={input_obj['secret']}&guess={input_obj['guess']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        parts = input_str.split('&')\n        secret = parts[0].split('=')[1]\n        guess = parts[1].split('=')[1]\n        return {'secret': secret, 'guess': guess}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.getHint(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.066",
            "memory": 4860,
            "stderr": null,
            "token": "40fc3ed1-442f-4dfa-bf75-0da1204e7aa7",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 301,
        "title": "remove-invalid-parentheses",
        "token": "9d961043-6aed-4c90-9010-68a4517d86d5",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def removeInvalidParentheses(self, s: str) -> List[str]:\n        def is_valid(s):\n            count = 0\n            for char in s:\n                if char == '(':\n                    count += 1\n                elif char == ')':\n                    count -= 1\n                    if count < 0:\n                        return False\n            return count == 0\n\n        level = {s}\n        while True:\n            valid = list(filter(is_valid, level))\n            if valid:\n                return valid\n\n            next_level = set()\n            for item in level:\n                for i in range(len(item)):\n                    if item[i] in '()':\n                        next_level.add(item[:i] + item[i+1:])\n            level = next_level\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        input_length = random.randint(1, 25)\n        charset = 'abcdefghijklmnopqrstuvwxyz()'\n        s = ''.join((random.choice(charset) for _ in range(input_length)))\n        return {'s': s}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj.get('s', '')\n\n    def encode_output(self, output_obj) -> str:\n        return ','.join(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.removeInvalidParentheses(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Input {'s': ')erslahfmk'}\nExpected Output:  bgcnljowklo\nActual Output:  erslahfmk\n2 Test Failed!\n",
            "time": "0.056",
            "memory": 4764,
            "stderr": null,
            "token": "9d961043-6aed-4c90-9010-68a4517d86d5",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 4,
                "description": "Wrong Answer"
            }
        }
    },
    {
        "status": "success",
        "question_id": 162,
        "title": "find-peak-element",
        "token": "d3a0a030-d1bb-498c-bcf6-6ff18a9f689c",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\nimport ast\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def findPeakElement(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n == 1:\n            return 0\n        if nums[0] > nums[1]:\n            return 0\n        if nums[n-1] > nums[n-2]:\n            return n-1\n        \n        for i in range(1, n-1):\n            if nums[i] > nums[i-1] and nums[i] > nums[i+1]:\n                return i\n        return 0\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        \"\"\" Generate a random test case within problem constraints. \"\"\"\n        length = random.randint(1, 1000)\n        nums = [random.randint(-1000, 1000) for _ in range(length)]\n        for i in range(1, len(nums)):\n            while nums[i] == nums[i - 1]:\n                nums[i] = random.randint(-1000, 1000)\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\" Convert test case input to string. \"\"\"\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\" Convert test case output to string. \"\"\"\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\" Convert input string back to dictionary format. \"\"\"\n        return {'nums': ast.literal_eval(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.findPeakElement(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Input {'nums': [924, -300, -870, 464, -442, -512, -900, 964, 945, 435, 163, 879, 379, 575, -577, -312, 301, -206, -479, 408, 182, -11, -578, 971, -137, -901, 272, -359, 537, -463, 76, -709, 938, -692, -268, -120, 336, -610, -124, 227, 607, -65, 989, -773, 666, 171, 935, 745, -328, 40, -141, -146, 257, -179, -133, 710, 222, -276, 890, 837, 647, 507, -863, -587, 489, -611, -662, 739, -979, 526, 774, 257, 741, 242, 50, -211, 366, -107, 876, 147, -747, -151, -630, 721, -207, -63, -768, 480, -714, -155, 854, 256, 560, -856, -985, -548, 212, -533, -453, 401, -752, 258, -660, 816, 31, -695, 690, -123, -661, 311, 674, 962, 52, 250, -218, 366, 194, -800, -292, -437, 0, -55, -547, -892, 683, -548, 256, -785, 114, 188, 640, 994, -298, -430, 509, 681, 397, -90, 454, 838, -700, 816, 586, 174, -820, -86, -673, -44, -864, -982, 159, -520, 160, 130, -398, 963, -556, 991, -743, 764, -481, -702, -437, 973, -95, 536, -426, -814, -52, 723, 226, -350, -810, 101, -992, -41, -775, -59, -454, 739, -642, 759, 634, -879, 279, -644, 87, 904, -200, 322, 367, -81, 323, -429, -306, 589, -193, -432, -517, 929, 339, -568, 777, -405, -28, -152, -69, -115, -253, 99, 643, -611, -386, 377, -487, 746, 426, -42, 240, 290, 616, 551, -997, -660, 673, 835, 548, 411, 337, 174, 540, -755, -528, -32, -603, -949, -943, 188, -940, -706, 247, -319, -300, 602, -404, 786, -215, -822, 180, 161, -528, 852, -452, -944, -231, -454, -830, -948, 270, -760, -705, -253, 866, 5, -462, -667, 17, -617, 940, -111, 46, 717, 61, 31, 0, 260, -11, 86, 18, -213, 512, -983, -194, 290, 288, 860, -956, -80, 296, 841, -64, 933, 145, 607, -182, 29, -191, 589, 732, -688, 953, -694, -614, 634, 707, -472, 254, -616, 685, -419, 683, 158, -456, 88, 319, -361, 315, -999, -736, -700, -37, -601, -962, 780]}\nExpected Output:  254\nActual Output:  0\n1 Test Failed!\n",
            "time": "0.068",
            "memory": 5764,
            "stderr": null,
            "token": "d3a0a030-d1bb-498c-bcf6-6ff18a9f689c",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 4,
                "description": "Wrong Answer"
            }
        }
    },
    {
        "status": "success",
        "question_id": 164,
        "title": "maximum-gap",
        "token": "309cbb60-d843-4723-a33e-f977617a5752",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom random import randint, shuffle\nfrom typing import List, Dict\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def maximumGap(self, nums: List[int]) -> int:\n        if len(nums) < 2:\n            return 0\n        if len(nums) == 2:\n            return abs(nums[0] - nums[1])\n        nmax, nmin = max(nums), min(nums)\n        if nmax == nmin:\n            return 0\n        num_buckets = len(nums) - 1\n        bucket_size = (nmax - nmin) / num_buckets\n        buckets = [[float('inf'), -1] for _ in range(num_buckets)]\n        for num in nums:\n            bucket_num = min(int((num - nmin) // bucket_size), num_buckets - 1)\n            buckets[bucket_num][0] = min(buckets[bucket_num][0], num)\n            buckets[bucket_num][1] = max(buckets[bucket_num][1], num)\n        prev_bucket = [float('inf'), nmin] # Changed initialization to include nmin\n        ret = 0 # Changed initialization to 0\n        for i in range(len(buckets)):\n            cur_bucket = buckets[i]\n            if cur_bucket[1] != -1:\n                ret = max(ret, cur_bucket[0] - prev_bucket[1])\n                prev_bucket = cur_bucket\n        ret = max(ret, nmax - prev_bucket[1]) # Handle the gap between last non-empty bucket and nmax\n        return ret\n\nclass TestCaseGenerator:\n\n    def generate(self) -> Dict[str, List[int]]:\n        case_type = randint(1, 3)\n        if case_type == 1:\n            nums = [3, 6, 9, 1]\n        elif case_type == 2:\n            size = randint(2, 100)\n            nums = [randint(0, 1000) for _ in range(size)]\n        else:\n            nums = [10]\n        shuffle(nums)\n        return {'nums': nums}\n\n    def encode_input(self, input_obj: Dict[str, List[int]]) -> str:\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj: int) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str: str) -> Dict[str, List[int]]:\n        nums = [int(x) for x in input_str.strip('[]').split(',') if x.strip()]\n        return {'nums': nums}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.maximumGap(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.069",
            "memory": 4796,
            "stderr": null,
            "token": "309cbb60-d843-4723-a33e-f977617a5752",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 166,
        "title": "fraction-to-recurring-decimal",
        "token": "c6924a2a-c205-4a2a-a7ff-74ee6bc79f4c",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\n        if numerator==0:\n            return \"0\"\n        if denominator == 0:\n            return\n        string = []\n        if numerator * denominator < 0 :\n            string.append(\"-\")\n        numerator, denominator = abs(numerator), abs(denominator)\n        quo = numerator//denominator\n        string.append(str(quo))\n        rem = numerator%denominator\n\n        if rem==0:\n            return ''.join(string)\n        else:\n            string.append(\".\")\n        seen = {}\n        while rem:\n            if rem in seen:\n                ind = seen[rem]\n                return ''.join(string[:ind]) + \"(\" + ''.join(string[ind:]) + \")\"\n            seen[rem] = len(string)\n            rem *= 10\n            quo = rem//denominator\n            rem = rem%denominator\n            string.append(str(quo))\n        return ''.join(string)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        numerators = [1, 2, 4, random.randint(-1000, 1000)]\n        denominators = [2, 1, 333, random.randint(-1000, 1000)]\n        numerator = random.choice(numerators)\n        denominator = random.choice([d for d in denominators if d != 0])\n        return {'numerator': numerator, 'denominator': denominator}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['numerator']},{input_obj['denominator']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        numerator, denominator = map(int, input_str.split(','))\n        return {'numerator': numerator, 'denominator': denominator}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.fractionToDecimal(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.051",
            "memory": 4820,
            "stderr": null,
            "token": "c6924a2a-c205-4a2a-a7ff-74ee6bc79f4c",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 168,
        "title": "excel-sheet-column-title",
        "token": "558bdf05-d248-4c68-86fc-e8032ae953d1",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def convertToTitle(self, columnNumber: int) -> str:\n        result = ''\n        while columnNumber > 0:\n            columnNumber -= 1\n            remainder = columnNumber % 26\n            result = chr(65 + remainder) + result\n            columnNumber //= 26\n        return result\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        column_number = random.randint(1, 1000)\n        return {'columnNumber': column_number}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['columnNumber'])\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        column_number = int(input_str)\n        return {'columnNumber': column_number}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.convertToTitle(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.066",
            "memory": 4772,
            "stderr": null,
            "token": "558bdf05-d248-4c68-86fc-e8032ae953d1",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 43,
        "title": "multiply-strings",
        "token": "9a3980c4-5b84-4535-ab40-b563f8b30d76",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def multiply(self, num1: str, num2: str) -> str:\n        if num1 == \"0\" or num2 == \"0\":\n            return \"0\"\n\n        n1, n2 = len(num1), len(num2)\n        product = [0] * (n1 + n2)\n\n        for i in range(n1 - 1, -1, -1):\n            carry = 0\n            for j in range(n2 - 1, -1, -1):\n                product[i + j + 1] += int(num1[i]) * int(num2[j]) + carry\n                carry = product[i + j + 1] // 10\n                product[i + j + 1] %= 10\n            product[i] += carry\n\n        result = \"\".join(map(str, product))\n        while result[0] == '0' and len(result) > 1:\n            result = result[1:]\n        return result\n\nclass TestCaseGenerator:\n\n    def __init__(self):\n        self.max_len = 200\n\n    def generate(self) -> dict:\n        import random\n        len1 = random.randint(1, self.max_len)\n        len2 = random.randint(1, self.max_len)\n        num1 = ''.join([random.choice('123456789') if i == 0 else random.choice('0123456789') for i in range(len1)])\n        num2 = ''.join([random.choice('123456789') if i == 0 else random.choice('0123456789') for i in range(len2)])\n        return {'num1': num1, 'num2': num2}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['num1']},{input_obj['num2']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        num1, num2 = input_str.split(',')\n        return {'num1': num1, 'num2': num2}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.multiply(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.157",
            "memory": 5016,
            "stderr": null,
            "token": "9a3980c4-5b84-4535-ab40-b563f8b30d76",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 50,
        "title": "powx-n",
        "token": "95412a80-3795-42b8-b5d1-37a0e376d243",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom random import uniform, randint\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def myPow(self, x: float, n: int) -> float:\n        ans = 1\n        abs_n = abs(n)\n        while abs_n > 0:\n            if abs_n & 1:\n                ans *= x\n            x *= x\n            abs_n >>= 1\n\n        if n < 0:\n            return 1 / ans\n        else:\n            return ans\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        return {'x': round(uniform(-99.9, 99.9), 5), 'n': randint(-20, 20)}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['x']},{input_obj['n']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return f'{output_obj:.5f}'\n\n    def decode_input(self, input_str) -> dict:\n        x, n = input_str.split(',')\n        return {'x': float(x), 'n': int(n)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.myPow(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.062",
            "memory": 4764,
            "stderr": null,
            "token": "95412a80-3795-42b8-b5d1-37a0e376d243",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 221,
        "title": "maximal-square",
        "token": "103f2363-da16-4353-be2b-be5a109ef6a0",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\n        if not matrix:\n            return 0\n\n        rows, cols = len(matrix), len(matrix[0])\n        dp = [[0] * cols for _ in range(rows)]\n        max_side = 0\n\n        for i in range(rows):\n            for j in range(cols):\n                if matrix[i][j] == '1':\n                    if i == 0 or j == 0:\n                        dp[i][j] = 1\n                    else:\n                        dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n                    max_side = max(max_side, dp[i][j])\n\n        return max_side * max_side\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        m = random.randint(1, 100)\n        n = random.randint(1, 100)\n        matrix = [[random.choice(['0', '1']) for _ in range(n)] for _ in range(m)]\n        return {'matrix': matrix}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['matrix'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        matrix = eval(input_str)\n        return {'matrix': matrix}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.maximalSquare(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.171",
            "memory": 10832,
            "stderr": null,
            "token": "103f2363-da16-4353-be2b-be5a109ef6a0",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 223,
        "title": "rectangle-area",
        "token": "956b9734-b7b3-4cf0-a2eb-352c704e1c93",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\n\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -> int:\n        area_a = (ax2 - ax1) * (ay2 - ay1)\n        area_b = (bx2 - bx1) * (by2 - by1)\n\n        intersect_width = max(0, min(ax2, bx2) - max(ax1, bx1))\n        intersect_height = max(0, min(ay2, by2) - max(ay1, by1))\n\n        return area_a + area_b - intersect_width * intersect_height\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        \"\"\"\n        Generate a test case input for the problem where two rectangles are defined by their bottom-left \n        and top-right corners.\n        \"\"\"\n        test_cases = [{'ax1': -3, 'ay1': 0, 'ax2': 3, 'ay2': 4, 'bx1': 5, 'by1': 4, 'bx2': 10, 'by2': 8}, {'ax1': 0, 'ay1': 0, 'ax2': 4, 'ay2': 3, 'bx1': 2, 'by1': 2, 'bx2': 6, 'by2': 5}, {'ax1': -2, 'ay1': -2, 'ax2': 2, 'ay2': 2, 'bx1': -2, 'by1': -2, 'bx2': 2, 'by2': 2}, {'ax1': 0, 'ay1': 0, 'ax2': 2, 'ay2': 2, 'bx1': 2, 'by1': 0, 'bx2': 4, 'by2': 2}, {'ax1': 1, 'ay1': 1, 'ax2': 4, 'ay2': 5, 'bx1': 1, 'by1': 1, 'bx2': 4, 'by2': 5}]\n        return test_cases[0]\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\"\n        Encode a test case input dictionary into a string.\n        \"\"\"\n        return ','.join((f'{value}' for value in input_obj.values()))\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\"\n        Encode a test case output integer into a string.\n        \"\"\"\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\"\n        Decode an input string back into a test case input dictionary.\n        \"\"\"\n        values = list(map(int, input_str.split(',')))\n        return {'ax1': values[0], 'ay1': values[1], 'ax2': values[2], 'ay2': values[3], 'bx1': values[4], 'by1': values[5], 'bx2': values[6], 'by2': values[7]}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.computeArea(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.067",
            "memory": 4740,
            "stderr": null,
            "token": "956b9734-b7b3-4cf0-a2eb-352c704e1c93",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "failure",
        "question_id": 107,
        "title": "binary-tree-level-order-traversal-ii",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "success",
        "question_id": 109,
        "title": "convert-sorted-list-to-binary-search-tree",
        "token": "ddb775fd-0383-48c0-bd57-078be6bf52b3",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom collections import deque\nfrom typing import Optional\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        def find_size(head):\n            size = 0\n            curr = head\n            while curr:\n                size += 1\n                curr = curr.next\n            return size\n\n        def to_bst(start, end):\n            if start > end:\n                return None\n\n            mid = (start + end) // 2\n\n            left = to_bst(start, mid - 1)\n\n            nonlocal head\n            node = TreeNode(head.val)\n            node.left = left\n            head = head.next\n\n            node.right = to_bst(mid + 1, end)\n\n            return node\n\n        size = find_size(head)\n        return to_bst(0, size - 1)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(0, 20)\n        if n == 0:\n            return {'head': None}\n        sorted_values = sorted(random.sample(range(-100, 100), n))\n        head = ListNode(sorted_values[0])\n        current = head\n        for value in sorted_values[1:]:\n            current.next = ListNode(value)\n            current = current.next\n        return {'head': head}\n\n    def encode_input(self, input_obj) -> str:\n        if input_obj['head'] is None:\n            return '[]'\n        res = []\n        current = input_obj['head']\n        while current is not None:\n            res.append(current.val)\n            current = current.next\n        return str(res)\n\n    def encode_output(self, output_obj) -> str:\n        if not output_obj:\n            return '[]'\n        queue = deque([output_obj])\n        result = []\n        while queue:\n            node = queue.popleft()\n            if node:\n                result.append(node.val)\n                queue.append(node.left)\n                queue.append(node.right)\n            else:\n                result.append(None)\n        while result and result[-1] is None:\n            result.pop()\n        return str(result)\n\n    def decode_input(self, input_str) -> dict:\n        vals = eval(input_str)\n        if not vals:\n            return {'head': None}\n        head = ListNode(vals[0])\n        current = head\n        for value in vals[1:]:\n            current.next = ListNode(value)\n            current = current.next\n        return {'head': head}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.sortedListToBST(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.059",
            "memory": 4856,
            "stderr": null,
            "token": "ddb775fd-0383-48c0-bd57-078be6bf52b3",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "failure",
        "question_id": 268,
        "title": "missing-number",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "success",
        "question_id": 172,
        "title": "factorial-trailing-zeroes",
        "token": "4d870b88-efa9-450e-b883-77082b1660c7",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def trailingZeroes(self, n: int) -> int:\n        ans = 0\n        while n > 0:\n            n //= 5\n            ans += n\n        return ans\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(0, 100)\n        return {'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['n'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'n': int(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.trailingZeroes(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.058",
            "memory": 4844,
            "stderr": null,
            "token": "4d870b88-efa9-450e-b883-77082b1660c7",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 179,
        "title": "largest-number",
        "token": "96d0f8a8-2938-4977-a477-7741b6656d8d",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport heapq\nimport random\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def largestNumber(self, nums: List[int]) -> str:\n        nums = [str(num) for num in nums]\n        nums.sort(key=lambda x: x * 3, reverse=True)\n        return str(int(\"\".join(nums)))\n\nclass TestCaseGenerator:\n    \"\"\"\n    A helper class to generate test cases, encode/decode inputs and outputs\n    \"\"\"\n\n    def generate(self) -> dict:\n        \"\"\"\n        Generates a random test case input, ensuring scenarios of different input sizes.\n        \"\"\"\n        import random\n        length = random.randint(1, 20)\n        nums = [random.randint(0, 10000) for _ in range(length)]\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\"\n        Converts the test case input into a human-readable string.\n        \"\"\"\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\"\n        Converts the test case output (a string) into a human-readable string format.\n        \"\"\"\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\"\n        Transforms an input string back into a Python dictionary structure.\n        \"\"\"\n        nums = eval(input_str)\n        return {'nums': nums}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.largestNumber(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.065",
            "memory": 4796,
            "stderr": null,
            "token": "96d0f8a8-2938-4977-a477-7741b6656d8d",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 187,
        "title": "repeated-dna-sequences",
        "token": "54e78758-8455-4a73-8235-1661a518794e",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def findRepeatedDnaSequences(self, s: str) -> List[str]:\n        if len(s) < 10:\n            return []\n\n        mapping = {'A': 0, 'C': 1, 'G': 2, 'T': 3}\n        seen = set()\n        repeated = set()\n        ans = []\n\n        for i in range(len(s) - 9):\n            num = 0\n            for j in range(i, i + 10):\n                num <<= 2\n                num |= mapping[s[j]]\n\n            if num in seen:\n                if num not in repeated:\n                    ans.append(s[i:i+10])\n                    repeated.add(num)\n            else:\n                seen.add(num)\n\n        return ans\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        nucleotides = ['A', 'C', 'G', 'T']\n        length = random.randint(20, 200)\n        s = ''.join(random.choices(nucleotides, k=length))\n        return {'s': s}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['s']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return '[' + ', '.join((f'\"{seq}\"' for seq in output_obj)) + ']'\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.findRepeatedDnaSequences(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.066",
            "memory": 4888,
            "stderr": null,
            "token": "54e78758-8455-4a73-8235-1661a518794e",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 12,
        "title": "integer-to-roman",
        "token": "90ced8f7-025f-4e5e-9076-4dda81fd3ecd",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\n\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def intToRoman(self, num: int) -> str:\n        dictionary = {1000:'M', 900:'CM', 500:'D', 400:'CD', 100:'C', 90:'XC', 50:'L', 40:'XL', 10:'X', 9:'IX', 5:'V', 4:'IV', 1:'I'}\n        ans=''\n        for key, val in dictionary.items():\n            while num>=key:\n                ans+=val\n                num-=key\n            if num==0:break\n        return ans\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        return {'num': 3}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['num'])\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        return {'num': int(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.intToRoman(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.065",
            "memory": 4708,
            "stderr": null,
            "token": "90ced8f7-025f-4e5e-9076-4dda81fd3ecd",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 13,
        "title": "roman-to-integer",
        "token": "c15df2b3-0e7b-40fd-8a43-6af06227958d",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def romanToInt(self, s: str) -> int:\n        m = {\n            'I': 1,\n            'V': 5,\n            'X': 10,\n            'L': 50,\n            'C': 100,\n            'D': 500,\n            'M': 1000\n        }\n        \n        ans = 0\n        \n        for i in range(len(s)):\n            if i < len(s) - 1 and m[s[i]] < m[s[i+1]]:\n                ans -= m[s[i]]\n            else:\n                ans += m[s[i]]\n        \n        return ans\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        \"\"\"\n        Generate a random test case input.\n        Limited range of test cases for simplicity.\n        \"\"\"\n        test_cases = [{'s': 'III'}, {'s': 'IV'}, {'s': 'IX'}, {'s': 'LVIII'}, {'s': 'XLIX'}, {'s': 'XC'}, {'s': 'CCCXC'}, {'s': 'CMXCIX'}, {'s': 'MCMXCIV'}, {'s': 'MMXXII'}]\n        return random.choice(test_cases)\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\"\n        Convert a test case input into a string.\n        \"\"\"\n        return input_obj['s']\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\"\n        Convert a test case output into a string.\n        \"\"\"\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\"\n        Convert a test case input string into a Python dict.\n        \"\"\"\n        return {'s': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.romanToInt(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.074",
            "memory": 4796,
            "stderr": null,
            "token": "c15df2b3-0e7b-40fd-8a43-6af06227958d",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "failure",
        "question_id": 113,
        "title": "path-sum-ii",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "failure",
        "question_id": 117,
        "title": "populating-next-right-pointers-in-each-node-ii",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "success",
        "question_id": 118,
        "title": "pascals-triangle",
        "token": "8c6de119-94c2-4209-863a-70c3fee39009",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def generate(self, numRows: int) -> List[List[int]]:\n        \n        result = []\n        for i in range(numRows):\n            row = [None for _ in range(i+1)]\n            row[0], row[-1] = 1, 1\n            for j in range(1, len(row)-1):\n                row[j] = result[i-1][j-1] + result[i-1][j]\n            result.append(row)\n        return result\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        numRows = random.randint(1, 10)\n        return {'numRows': numRows}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['numRows'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'numRows': int(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.generate(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.076",
            "memory": 5328,
            "stderr": null,
            "token": "8c6de119-94c2-4209-863a-70c3fee39009",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 119,
        "title": "pascals-triangle-ii",
        "token": "0032a4d4-28c3-433a-8ee2-0d9603769e94",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def getRow(self, rowIndex: int) -> List[int]:\n        row = [0] * (rowIndex + 1)\n        row[0] = 1\n\n        for i in range(1, rowIndex + 1):\n            for j in range(i, 0, -1):\n                row[j] = row[j] + row[j - 1]\n        return row\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        row_index = random.randint(0, 10)\n        return {'rowIndex': row_index}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['rowIndex']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'rowIndex': int(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.getRow(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.059",
            "memory": 5104,
            "stderr": null,
            "token": "0032a4d4-28c3-433a-8ee2-0d9603769e94",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 260,
        "title": "single-number-iii",
        "token": "be980357-22ae-42ca-a6a1-7b877816d162",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport ast\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def singleNumber(self, nums: List[int]) -> List[int]:\n        counts = {}\n        for num in nums:\n            counts[num] = counts.get(num, 0) + 1\n\n        L = []\n        for num, count in counts.items():\n            if count == 1:\n                L.append(num)\n\n        return L\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        return {'nums': [4, 2, 2, 1, 4, 5, 1, 6]}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'nums': ast.literal_eval(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.singleNumber(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Input {'nums': [4, 2, 2, 1, 4, 5, 1, 6]}\nExpected Output:  [6, 5]\nActual Output:  [5, 6]\n1 Test Failed!\n",
            "time": "0.067",
            "memory": 5008,
            "stderr": null,
            "token": "be980357-22ae-42ca-a6a1-7b877816d162",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 4,
                "description": "Wrong Answer"
            }
        }
    },
    {
        "status": "success",
        "question_id": 264,
        "title": "ugly-number-ii",
        "token": "dbc783aa-44a9-4b46-8dce-f08e984a9583",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nfrom heapq import heappop, heappush\n\nclass Solution:\n    def nthUglyNumber(self, n: int) -> int:\n        \n        heap = [1]\n        seen = {1}\n        count=1\n        while count<n:\n            smal = heappop(heap)\n            \n            if smal*2 not in seen:\n                heappush(heap,smal*2)\n                seen.add(smal*2)\n            if smal*3 not in seen:\n                heappush(heap,smal*3)\n                seen.add(smal*3)\n            if smal*5 not in seen:\n                heappush(heap,smal*5)\n                seen.add(smal*5)\n            count+=1\n        return heappop(heap)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 100)\n        return {'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.nthUglyNumber(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.056",
            "memory": 4748,
            "stderr": null,
            "token": "dbc783aa-44a9-4b46-8dce-f08e984a9583",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 71,
        "title": "simplify-path",
        "token": "f0fd09a5-5f7c-4efe-a8f6-2554900d3e0d",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def simplifyPath(self, path: str) -> str:\n        components = path.split('/')\n        stack = []\n        \n        for component in components:\n            if not component or component == '.':\n                continue\n            elif component == '..':\n                if stack:\n                    stack.pop()\n            else:\n                stack.append(component)\n        \n        simplified_path = '/' + '/'.join(stack)\n        return simplified_path\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        paths = ['/home/', '/home//foo/', '/home/user/Documents/../Pictures', '/../', '/.../a/../b/c/../d/./', '/a/b/c/../../', '/a/b//c/.././d', '/a/./b/./c/./d', '/a/b/c/././../..', '/a///b////c/']\n        random_path = random.choice(paths)\n        return {'path': random_path}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['path']\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        return {'path': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.simplifyPath(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.058",
            "memory": 4824,
            "stderr": null,
            "token": "f0fd09a5-5f7c-4efe-a8f6-2554900d3e0d",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "failure",
        "question_id": 75,
        "title": "sort-colors",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "success",
        "question_id": 77,
        "title": "combinations",
        "token": "0912ece3-3a5a-47bb-a297-635d3e6c67be",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def combine(self, n: int, k: int) -> List[List[int]]:\n        res = []\n        combination = [0] * k\n\n        def backtrack(index, start):\n            if index == k:\n                res.append(combination[:])\n                return\n\n            for i in range(start, n + 1):\n                combination[index] = i\n                backtrack(index + 1, i + 1)\n\n        backtrack(0, 1)\n        return res\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        n = random.randint(1, 10)\n        k = random.randint(1, n)\n        return {'n': n, 'k': k}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['n']} {input_obj['k']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return ','.join(('[' + ','.join(map(str, combo)) + ']' for combo in output_obj))\n\n    def decode_input(self, input_str) -> dict:\n        n, k = map(int, input_str.split())\n        return {'n': n, 'k': k}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.combine(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.06",
            "memory": 4872,
            "stderr": null,
            "token": "0912ece3-3a5a-47bb-a297-635d3e6c67be",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 80,
        "title": "remove-duplicates-from-sorted-array-ii",
        "token": "d970331f-7a2d-4fe5-9746-0197e0423e45",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List, Dict\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n        \n        k = 0  # Index for the modified array\n        count = 0  # Count of occurrences of the current number\n        \n        for i in range(len(nums)):\n            if i == 0 or nums[i] != nums[i-1]:\n                nums[k] = nums[i]\n                k += 1\n                count = 1\n            elif nums[i] == nums[i-1] and count < 2:\n                nums[k] = nums[i]\n                k += 1\n                count += 1\n                \n        return k\n\nclass TestCaseGenerator:\n\n    def generate(self) -> Dict[str, List[int]]:\n        \"\"\"\n        Generate a random test case input within a reasonable range\n        (based on the problem constraints) for invoking the entry_point function.\n        \"\"\"\n        length = random.randint(1, 100)\n        nums = []\n        for _ in range(length):\n            if nums and random.random() > 0.5:\n                nums.append(nums[-1])\n            else:\n                nums.append(nums[-1] + random.randint(1, 3) if nums else random.randint(-10, 10))\n        nums = self._limit_duplicates(nums)\n        return {'nums': nums}\n\n    def _limit_duplicates(self, nums: List[int]) -> List[int]:\n        \"\"\"\n        Make sure no number appears more than two times sequentially. Ensures input validity.\n        \"\"\"\n        result = []\n        count, current = (0, None)\n        for num in nums:\n            if num == current:\n                if count < 2:\n                    result.append(num)\n                    count += 1\n            else:\n                result.append(num)\n                current = num\n                count = 1\n        return result\n\n    def encode_input(self, input_obj: Dict[str, List[int]]) -> str:\n        \"\"\"\n        Convert a test case input into a JSON string representation.\n        \"\"\"\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj: int) -> str:\n        \"\"\"\n        Convert a test case output into a string.\n        \"\"\"\n        return str(output_obj)\n\n    def decode_input(self, input_str: str) -> Dict[str, List[int]]:\n        \"\"\"\n        Convert a test case input string into a Python dict with a numerical list.\n        \"\"\"\n        return {'nums': eval(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.removeDuplicates(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.061",
            "memory": 4972,
            "stderr": null,
            "token": "d970331f-7a2d-4fe5-9746-0197e0423e45",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 21,
        "title": "merge-two-sorted-lists",
        "token": "a8fbbe06-2a4b-42e5-ae53-c329bfb1057d",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import Optional\nfrom random import randint, choice\nfrom ast import literal_eval\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\n        cur = ListNode()\n        d = cur\n        while list1 and list2:\n            if list1.val < list2.val:\n                cur.next = list1\n                list1 = list1.next\n            else:\n                cur.next = list2\n                list2 = list2.next\n\n            cur = cur.next\n        if list1:\n            cur.next = list1\n        else:\n            cur.next = list2\n        return d.next\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        from random import randint, choice\n        length1 = randint(0, 10)\n        length2 = randint(0, 10)\n        list1 = sorted((randint(-100, 100) for _ in range(length1)))\n        list2 = sorted((randint(-100, 100) for _ in range(length2)))\n        return {'list1': self.build_linked_list(list1), 'list2': self.build_linked_list(list2)}\n\n    def build_linked_list(self, values):\n        head = ListNode(values[0]) if values else None\n        current = head\n        for val in values[1:]:\n            current.next = ListNode(val)\n            current = current.next\n        return head\n\n    def encode_input(self, input_obj) -> str:\n        return str((self.list_to_array(input_obj['list1']), self.list_to_array(input_obj['list2'])))\n\n    def list_to_array(self, node):\n        array = []\n        while node:\n            array.append(node.val)\n            node = node.next\n        return array\n\n    def encode_output(self, output_obj) -> str:\n        return str(self.list_to_array(output_obj))\n\n    def decode_input(self, input_str) -> dict:\n        from ast import literal_eval\n        list1, list2 = literal_eval(input_str)\n        return {'list1': self.build_linked_list(list1), 'list2': self.build_linked_list(list2)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.mergeTwoLists(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.078",
            "memory": 5620,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 139, in <module>\n    runner.run()\n  File \"script.py\", line 123, in run\n    output = self.solution.mergeTwoLists(**input)\n  File \"script.py\", line 56, in mergeTwoLists\n    cur = ListNode()\nTypeError: __init__() missing 1 required positional argument: 'x'\n",
            "token": "a8fbbe06-2a4b-42e5-ae53-c329bfb1057d",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "success",
        "question_id": 27,
        "title": "remove-element",
        "token": "f59bf80d-dd1b-4712-b2a2-3ca29e8c01b6",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        i = 0\n        for j in range(len(nums)):\n            if nums[j] != val:\n                nums[i] = nums[j]\n                i += 1\n        return i\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        \"\"\"\n        Generate a random test case input to be used for invoking the\n        removeElement function.\n        \"\"\"\n        nums_length = random.randint(1, 100)\n        nums = [random.randint(0, 50) for _ in range(nums_length)]\n        val = random.randint(0, 50)\n        return {'nums': nums, 'val': val}\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\"\n        Convert a test case input dictionary into a string.\n        \"\"\"\n        nums_str = ','.join(map(str, input_obj['nums']))\n        val_str = str(input_obj['val'])\n        return f'nums=[{nums_str}],val={val_str}'\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\"\n        Convert a test case output into a string.\n        \"\"\"\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\"\n        Convert a test case input string into a Python dictionary.\n        \"\"\"\n        nums_part, val_part = input_str.split('],val=')\n        nums_str = nums_part.split('=')[1].strip('[]')\n        nums = list(map(int, nums_str.split(','))) if nums_str else []\n        val = int(val_part)\n        return {'nums': nums, 'val': val}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.removeElement(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.054",
            "memory": 4876,
            "stderr": null,
            "token": "f59bf80d-dd1b-4712-b2a2-3ca29e8c01b6",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 28,
        "title": "find-the-index-of-the-first-occurrence-in-a-string",
        "token": "1ade3dab-509a-4fda-a3b5-98a7fce9915d",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        if not needle:\n            return 0\n        n = len(haystack)\n        m = len(needle)\n        \n        for i in range(n - m + 1):\n            if haystack[i:i+m] == needle:\n                return i\n        return -1\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        cases = [{'haystack': 'sadbutsad', 'needle': 'sad'}, {'haystack': 'leetcode', 'needle': 'leeto'}, {'haystack': 'a' * 1000 + 'b', 'needle': 'a' * 500}, {'haystack': 'hello', 'needle': 'll'}, {'haystack': 'aaaaaa', 'needle': 'b'}]\n        return random.choice(cases)\n\n    def encode_input(self, input_obj) -> str:\n        return f\"haystack={input_obj['haystack']}, needle={input_obj['needle']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        parts = input_str.split(', ')\n        haystack = parts[0].split('=')[1]\n        needle = parts[1].split('=')[1]\n        return {'haystack': haystack, 'needle': needle}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.strStr(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.063",
            "memory": 4920,
            "stderr": null,
            "token": "1ade3dab-509a-4fda-a3b5-98a7fce9915d",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 29,
        "title": "divide-two-integers",
        "token": "9849c4d2-7efa-4f08-9b3b-f80ae90ae483",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def divide(self, dividend: int, divisor: int) -> int:\n        # Constants for 32-bit signed integer limits\n        INT_MAX, INT_MIN = 2**31 - 1, -2**31\n        \n        # Edge case for overflow\n        if dividend == INT_MIN and divisor == -1:\n            return INT_MAX\n        \n        # Determine the sign of the result\n        sign = (dividend < 0) != (divisor < 0)\n        \n        # Work with absolute values\n        dividend, divisor = abs(dividend), abs(divisor)\n        \n        # Initialize the result\n        quotient = 0\n        \n        # The power of two divisor\n        power = 31\n        # The value of divisor shifted left\n        \n        while dividend >= divisor:\n            divisor_power = divisor << power\n            while divisor_power > dividend:\n                divisor_power >>= 1\n                power -= 1\n            dividend -= divisor_power\n            quotient += 1 << power\n        \n        # Apply the sign\n        if sign:\n            quotient = -quotient\n        \n        # Clamp the result within the 32-bit signed integer range\n        return min(max(quotient, INT_MIN), INT_MAX)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        dividend = random.randint(-1000, 1000)\n        divisor = random.randint(-1000, 1000)\n        while divisor == 0:\n            divisor = random.randint(-1000, 1000)\n        return {'dividend': dividend, 'divisor': divisor}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['dividend']}, {input_obj['divisor']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        dividend, divisor = map(int, input_str.split(','))\n        return {'dividend': dividend, 'divisor': divisor}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.divide(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.06",
            "memory": 5428,
            "stderr": null,
            "token": "9849c4d2-7efa-4f08-9b3b-f80ae90ae483",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 30,
        "title": "substring-with-concatenation-of-all-words",
        "token": "7090a771-8832-4683-ab7b-f6c67b62b4a7",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        if not s or not words:\n            return []\n\n        n = len(s)\n        num_words = len(words)\n        word_len = len(words[0])\n        substring_len = num_words * word_len\n        word_counts = Counter(words)\n        result_indices = []\n\n        for i in range(n - substring_len + 1):\n            seen_words = defaultdict(int)\n            words_found = 0\n            for j in range(num_words):\n                word_start = i + j * word_len\n                word = s[word_start:word_start + word_len]\n\n                if word in word_counts:\n                    seen_words[word] += 1\n                    if seen_words[word] <= word_counts[word]:\n                        words_found += 1\n                    else:\n                        break\n                else:\n                    break\n            if words_found == num_words:\n                result_indices.append(i)\n\n        return result_indices\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 50)\n        num_words = random.randint(1, 5)\n        word_length = random.randint(1, 5)\n        s = ''.join((random.choice('abcdefghijklmnopqrstuvwxyz') for _ in range(n)))\n        words = [''.join((random.choice('abcdefghijklmnopqrstuvwxyz') for _ in range(word_length))) for _ in range(num_words)]\n        return {'s': s, 'words': words}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"s={input_obj['s']};words={input_obj['words']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return ','.join(map(str, output_obj))\n\n    def decode_input(self, input_str) -> dict:\n        parts = input_str.split(';')\n        s = parts[0].split('=')[1]\n        words = parts[1].split('=')[1].strip('[]').replace('\"', '').split(',')\n        return {'s': s, 'words': words}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.findSubstring(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.067",
            "memory": 4772,
            "stderr": null,
            "token": "7090a771-8832-4683-ab7b-f6c67b62b4a7",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 62,
        "title": "unique-paths",
        "token": "bee52026-6e82-49c1-bb0f-64b666e4f1db",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport math\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        row = [1] * n\n        \n        for i in range(1, m):\n            new_row = [1] * n\n            for j in range(1, n):\n                new_row[j] = new_row[j-1] + row[j]\n            row = new_row\n        \n        return row[-1]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        m = random.randint(1, 100)\n        n = random.randint(1, 100)\n        return {'m': m, 'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['m']} {input_obj['n']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        m, n = map(int, input_str.split())\n        return {'m': m, 'n': n}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.uniquePaths(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.056",
            "memory": 4872,
            "stderr": null,
            "token": "bee52026-6e82-49c1-bb0f-64b666e4f1db",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 64,
        "title": "minimum-path-sum",
        "token": "15b1dd31-3c84-43b9-95d4-fe79556c0e5b",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\nimport json\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        if not grid or not grid[0]:\n            return 0\n        \n        m, n = len(grid), len(grid[0])\n        \n        dp = [0] * n\n        \n        dp[0] = grid[0][0]\n        \n        for j in range(1, n):\n            dp[j] = dp[j-1] + grid[0][j]\n            \n        for i in range(1, m):\n            dp[0] = dp[0] + grid[i][0]\n            for j in range(1, n):\n                dp[j] = grid[i][j] + min(dp[j-1], dp[j])\n        \n        return dp[n-1]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        m = random.randint(1, 10)\n        n = random.randint(1, 10)\n        grid = [[random.randint(0, 200) for _ in range(n)] for _ in range(m)]\n        return {'grid': grid}\n\n    def encode_input(self, input_obj) -> str:\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return json.loads(input_str)\n\n    def decode_output(self, output_str) -> int:\n        return int(output_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.minPathSum(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.063",
            "memory": 4808,
            "stderr": null,
            "token": "15b1dd31-3c84-43b9-95d4-fe79556c0e5b",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 65,
        "title": "valid-number",
        "token": "5eebdb99-ce7f-4a01-b9bd-b9ce336c0979",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport string\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nimport re\n\nclass Solution:\n    def isNumber(self, s: str) -> bool:\n        s = s.strip()\n        pattern = r'^[-+]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?$'\n        return bool(re.match(pattern, s))\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        import string\n        case_type = random.choice(['valid', 'invalid'])\n        valid_chars = string.digits + '+-' + 'eE' + '.'\n        invalid_chars = string.ascii_letters + ''.join(set(valid_chars) - set(string.digits))\n        if case_type == 'valid':\n            return {'s': random.choice(['', '+', '-']) + str(random.randint(0, 999)) + random.choice(['', '.', '.']) + ''.join(random.choices(string.digits, k=random.randint(0, 3))) + random.choice(['', 'e', 'E']) + random.choice(['', '+', '-']) + ''.join(random.choices(string.digits, k=random.randint(0, 3)))}\n        else:\n            return {'s': ''.join(random.choices(valid_chars + invalid_chars, k=random.randint(1, 20)))}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['s']\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\n    def decode_output(self, output_str) -> bool:\n        return output_str == 'True'\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.isNumber(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.07",
            "memory": 4768,
            "stderr": null,
            "token": "5eebdb99-ce7f-4a01-b9bd-b9ce336c0979",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 66,
        "title": "plus-one",
        "token": "21aed1be-fa9f-4138-970a-96090411667c",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom ast import literal_eval\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def plusOne(self, digits: List[int]) -> List[int]:\n        n=len(digits)\n        for i  in range(n-1,-1,-1):\n            if digits[i]<9:\n                digits[i]+=1\n                return digits\n            else:\n                digits[i]=0\n        return [1]+digits\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 10)\n        digits = [random.randint(1, 9)] + [random.randint(0, 9) for _ in range(n - 1)]\n        return {'digits': digits}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['digits'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'digits': literal_eval(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.plusOne(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.08",
            "memory": 5068,
            "stderr": null,
            "token": "21aed1be-fa9f-4138-970a-96090411667c",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 67,
        "title": "add-binary",
        "token": "a6215f0b-4a9b-47e7-864a-c94843c7d016",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def addBinary(self, a: str, b: str) -> str:\n        i= len(a)-1\n        j= len(b)-1\n\n        car=0\n        sol=[]\n        while i >= 0 or j >= 0 or car:\n            digit_a = int(a[i]) if i >= 0 else 0\n            digit_b = int(b[j]) if j >= 0 else 0\n            \n            total = digit_a + digit_b + car\n            sol.append(str(total % 2))\n            car = total // 2  \n\n            i-=1\n            j-=1\n        return \"\".join(sol[::-1])\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length_a = random.randint(1, 15)\n        length_b = random.randint(1, 15)\n        a = ''.join((random.choice('01') for _ in range(length_a)))\n        b = ''.join((random.choice('01') for _ in range(length_b)))\n        return {'a': a, 'b': b}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['a']},{input_obj['b']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        a, b = input_str.split(',')\n        return {'a': a, 'b': b}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.addBinary(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Input {'a': '010011110', 'b': '0010111100'}\nExpected Output:  101011010\nActual Output:  0101011010\n4 Test Failed!\n",
            "time": "0.054",
            "memory": 4816,
            "stderr": null,
            "token": "a6215f0b-4a9b-47e7-864a-c94843c7d016",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 4,
                "description": "Wrong Answer"
            }
        }
    },
    {
        "status": "success",
        "question_id": 69,
        "title": "sqrtx",
        "token": "a5d10290-caa6-4855-93df-06734c224b8a",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport json\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def mySqrt(self, x: int) -> int:\n        if x == 0 or x == 1:\n            return x\n        \n        low = 1\n        high = x\n        \n        while low <= high:\n            mid = (low + high) // 2\n            \n            if mid * mid == x:\n                return mid\n            elif mid * mid < x:\n                low = mid + 1\n            else:\n                high = mid - 1\n        \n        return high\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        x = random.randint(0, 1000000)\n        return {'x': x}\n\n    def encode_input(self, input_obj) -> str:\n        import json\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        import json\n        return json.dumps({'result': output_obj})\n\n    def decode_input(self, input_str) -> dict:\n        import json\n        return json.loads(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.mySqrt(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.059",
            "memory": 4776,
            "stderr": null,
            "token": "a5d10290-caa6-4855-93df-06734c224b8a",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 70,
        "title": "climbing-stairs",
        "token": "8cc0bceb-d222-4444-ad4a-31999af0c361",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom functools import cache\nimport random\n\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def climbStairs(self, n: int) -> int:\n        if n <= 2:\n            return n\n        dp = [0] * (n + 1)\n        dp[1] = 1\n        dp[2] = 2\n        for i in range(3, n + 1):\n            dp[i] = dp[i - 1] + dp[i - 2]\n        return dp[n]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        return {'n': random.randint(1, 10)}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['n'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'n': int(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.climbStairs(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.054",
            "memory": 4628,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 26, in <module>\n    from functools import cache\nImportError: cannot import name 'cache' from 'functools' (/usr/local/python-3.8.1/lib/python3.8/functools.py)\n",
            "token": "8cc0bceb-d222-4444-ad4a-31999af0c361",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "failure",
        "question_id": 51,
        "title": "n-queens",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "success",
        "question_id": 52,
        "title": "n-queens-ii",
        "token": "c720d261-90a1-4d3c-8623-47b322a3cc3c",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def totalNQueens(self, n: int) -> int:\n        cols = set()\n        pos_diags = set()  # (row + col)\n        neg_diags = set()  # (row - col)\n\n        count = 0\n\n        def backtrack(row):\n            nonlocal count\n\n            if row == n:\n                count += 1\n                return\n\n            for col in range(n):\n                if col in cols or (row + col) in pos_diags or (row - col) in neg_diags:\n                    continue\n\n                cols.add(col)\n                pos_diags.add(row + col)\n                neg_diags.add(row - col)\n\n                backtrack(row + 1)\n\n                cols.remove(col)\n                pos_diags.remove(row + col)\n                neg_diags.remove(row - col)\n\n        backtrack(0)\n        return count\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 9)\n        return {'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['n'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'n': int(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.totalNQueens(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.134",
            "memory": 4856,
            "stderr": null,
            "token": "c720d261-90a1-4d3c-8623-47b322a3cc3c",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 53,
        "title": "maximum-subarray",
        "token": "e1e3b781-4d12-4b66-9edb-2d7941a732f6",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        maxSum = float('-inf')\n        currentSum = 0\n        \n        for num in nums:\n            currentSum += num\n            \n            if currentSum > maxSum:\n                maxSum = currentSum\n            \n            if currentSum < 0:\n                currentSum = 0\n        \n        return maxSum\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        \"\"\"\n        Generate a random test case input for the maxSubArray function.\n        :return: A dictionary with 'nums' as key and list of integers as value.\n        \"\"\"\n        length = random.randint(1, 100)\n        nums = [random.randint(-10000, 10000) for _ in range(length)]\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\"\n        Convert a test case input into a string (JSON-like format).\n        :param input_obj: A dictionary with 'nums' as key.\n        :return: A string representation of 'nums'\n        \"\"\"\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\"\n        Convert a test case output into a string.\n        :param output_obj: The output value to be encoded.\n        :return: A string representation of the output.\n        \"\"\"\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\"\n        Convert a test case input string into a Python dict.\n        :param input_str: The input string to decode.\n        :return: A dictionary with 'nums' as key.\n        \"\"\"\n        nums = eval(input_str)\n        return {'nums': nums}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.maxSubArray(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.063",
            "memory": 4928,
            "stderr": null,
            "token": "e1e3b781-4d12-4b66-9edb-2d7941a732f6",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 55,
        "title": "jump-game",
        "token": "03a4f4d0-e743-4459-8a6b-c6562ebc890b",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List, Dict\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def canJump(self, nums: List[int]) -> bool:\n        reachable = 0\n        for i, num in enumerate(nums):\n            if i > reachable:\n                return False\n            reachable = max(reachable, i + num)\n            if reachable >= len(nums) - 1:\n                return True\n        return True\n\nclass TestCaseGenerator:\n\n    def generate(self) -> Dict[str, List[int]]:\n        nums_length = random.randint(1, 20)\n        nums = [random.randint(0, 5) for _ in range(nums_length)]\n        return {'nums': nums}\n\n    def encode_input(self, input_obj: Dict[str, List[int]]) -> str:\n        return ','.join(map(str, input_obj['nums']))\n\n    def encode_output(self, output_obj: bool) -> str:\n        return 'true' if output_obj else 'false'\n\n    def decode_input(self, input_str: str) -> Dict[str, List[int]]:\n        nums = list(map(int, input_str.split(',')))\n        return {'nums': nums}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.canJump(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.07",
            "memory": 5680,
            "stderr": null,
            "token": "03a4f4d0-e743-4459-8a6b-c6562ebc890b",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 58,
        "title": "length-of-last-word",
        "token": "8fbeac09-4e23-463b-b77e-cd1eb1378fb3",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def lengthOfLastWord(self, s: str) -> int:\n        s = s.rstrip()\n        if not s:\n            return 0\n        return len(s.split(\" \")[-1])\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        words = ['abcdefghijklmnopqrstuvwxyz', 'hello', 'world', 'moon', 'joyboy']\n        sentence = ' '.join(random.choices(words, k=random.randint(1, 5)))\n        sentence = sentence.rjust(len(sentence) + random.randint(0, 5))\n        sentence = sentence.ljust(len(sentence) + random.randint(0, 5))\n        return {'s': sentence.strip()}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['s']\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\n    def decode_output(self, output_str) -> int:\n        return int(output_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.lengthOfLastWord(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.071",
            "memory": 7696,
            "stderr": null,
            "token": "8fbeac09-4e23-463b-b77e-cd1eb1378fb3",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 60,
        "title": "permutation-sequence",
        "token": "aec20089-a7c1-447d-9eda-163b26c4a49e",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport math\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def getPermutation(self, n: int, k: int) -> str:\n        fact = [1] * (n + 1)\n        for i in range(2, n + 1):\n            fact[i] = fact[i - 1] * i\n\n        nums = list(range(1, n + 1))\n        k -= 1\n        result = \"\"\n\n        for i in range(n - 1, -1, -1):\n            index = k // fact[i]\n            result += str(nums[index])\n            nums.pop(index)\n            k %= fact[i]\n\n        return result\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 9)\n        k = random.randint(1, math.factorial(n))\n        return {'n': n, 'k': k}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['n']},{input_obj['k']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        n, k = map(int, input_str.split(','))\n        return {'n': n, 'k': k}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.getPermutation(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.06",
            "memory": 5200,
            "stderr": null,
            "token": "aec20089-a7c1-447d-9eda-163b26c4a49e",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 282,
        "title": "expression-add-operators",
        "token": "a7743a43-6016-4e62-9b2b-55d19620c3f4",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def addOperators(self, num: str, target: int) -> List[str]:\n        n = len(num)\n        res = []\n\n        def backtrack(index, current_expression, current_value, previous_operand):\n            if index == n:\n                if current_value == target:\n                    res.append(current_expression)\n                return\n\n            for i in range(index, n):\n                if i > index and num[index] == '0':\n                    break  # Avoid leading zeros\n\n                current_string = num[index:i + 1]\n                current_num = int(current_string)\n\n                if index == 0:\n                    backtrack(i + 1, current_string, current_num, current_num)\n                else:\n                    backtrack(i + 1, current_expression + \"+\" + current_string, current_value + current_num, current_num)\n                    backtrack(i + 1, current_expression + \"-\" + current_string, current_value - current_num, -current_num)\n                    backtrack(i + 1, current_expression + \"*\" + current_string, current_value - previous_operand + previous_operand * current_num, previous_operand * current_num)\n\n        backtrack(0, \"\", 0, 0)\n        return res\n\nclass TestCaseGenerator:\n    import random\n\n    def generate(self) -> dict:\n        nums = ['123', '232', '3456237490', '105', '00', '9999']\n        targets = [6, 8, 9191, 5, 0, 27]\n        test_index = self.random.randint(0, len(nums) - 1)\n        return {'num': nums[test_index], 'target': targets[test_index]}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"num = '{input_obj['num']}', target = {input_obj['target']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return ', '.join(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        parts = input_str.split(', ')\n        num = parts[0].split('=')[1].strip().strip(\"'\")\n        target = int(parts[1].split('=')[1].strip())\n        return {'num': num, 'target': target}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.addOperators(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "1.069",
            "memory": 4872,
            "stderr": null,
            "token": "a7743a43-6016-4e62-9b2b-55d19620c3f4",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 283,
        "title": "move-zeroes",
        "token": "d19accda-a763-4958-9baa-f3ac3f2618eb",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def moveZeroes(self, nums: List[int]) -> None:\n        n = len(nums)\n        left = 0\n        for right in range(n):\n            if nums[right] != 0:\n                nums[left], nums[right] = nums[right], nums[left]\n                left += 1\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        test_case = {'nums': [random.choice(range(-10, 10)) for _ in range(random.randint(1, 20))]}\n        return test_case\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        nums = eval(input_str)\n        return {'nums': nums}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.moveZeroes(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.061",
            "memory": 4848,
            "stderr": null,
            "token": "d19accda-a763-4958-9baa-f3ac3f2618eb",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "failure",
        "question_id": 336,
        "title": "palindrome-pairs",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "success",
        "question_id": 338,
        "title": "counting-bits",
        "token": "48198590-da29-4e6a-abb2-9060c7392125",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def countBits(self, n: int) -> List[int]:\n        dp = [0] * (n + 1)\n        for i in range(1, n + 1):\n            dp[i] = dp[i >> 1] + (i & 1)\n        return dp\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(0, 1000)\n        return {'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['n'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        n = int(input_str)\n        return {'n': n}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.countBits(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.062",
            "memory": 5156,
            "stderr": null,
            "token": "48198590-da29-4e6a-abb2-9060c7392125",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 342,
        "title": "power-of-four",
        "token": "589e521b-870b-4e69-84e5-09f7932e3172",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def isPowerOfFour(self, n: int) -> bool:\n        if n <= 0:\n            return False\n        while n % 4 == 0:\n            n //= 4\n        return n == 1\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        test_values = [1, 4, 16, 64, 256, 1024, 5, 12, 20, 50, 100, -4, 0, random.randint(-500, 500)]\n        n = random.choice(test_values)\n        return {'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['n'])\n\n    def encode_output(self, output_obj) -> str:\n        return 'true' if output_obj else 'false'\n\n    def decode_input(self, input_str) -> dict:\n        return {'n': int(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.isPowerOfFour(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.054",
            "memory": 4860,
            "stderr": null,
            "token": "589e521b-870b-4e69-84e5-09f7932e3172",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 345,
        "title": "reverse-vowels-of-a-string",
        "token": "352b570f-8bbd-4e81-9679-cdb0e74228d6",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\n\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def reverseVowels(self, s: str) -> str:\n        buf = list(s)\n        myset = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        vowels = []\n        indexs = []\n\n        for i in range(len(s)):\n            if s[i] in myset:\n                vowels.append(s[i])\n                indexs.append(i)\n        \n        vowels.reverse()\n        \n        for i in range(len(indexs)):\n            buf[indexs[i]] = vowels[i]\n        \n        answer = ''.join(buf)\n        return answer\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        return {'s': 'ExampleTestString'}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['s']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.reverseVowels(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.05",
            "memory": 4732,
            "stderr": null,
            "token": "352b570f-8bbd-4e81-9679-cdb0e74228d6",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 389,
        "title": "find-the-difference",
        "token": "91ecf86e-5fa0-4d13-ac90-be004a6837bb",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def findTheDifference(self, s: str, t: str) -> str:\n        s_sum = sum(ord(c) for c in s)\n        t_sum = sum(ord(c) for c in t)\n        return chr(t_sum - s_sum)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        alphabets = 'abcdefghijklmnopqrstuvwxyz'\n        length = random.randint(0, 1000)\n        s = ''.join(random.choices(alphabets, k=length))\n        added_char = random.choice(alphabets)\n        t_list = list(s)\n        random.shuffle(t_list)\n        insert_position = random.randint(0, length)\n        t_list.insert(insert_position, added_char)\n        t = ''.join(t_list)\n        return {'s': s, 't': t}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['s']} {input_obj['t']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        s, t = input_str.split()\n        return {'s': s, 't': t}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.findTheDifference(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.052",
            "memory": 5044,
            "stderr": null,
            "token": "91ecf86e-5fa0-4d13-ac90-be004a6837bb",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 391,
        "title": "perfect-rectangle",
        "token": "621c7c7c-f0c7-4ef9-aa53-272c06669b7e",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport numpy as np\nfrom typing import List\nimport ast\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\n        x1 = float('inf')\n        y1 = float('inf')\n        x2 = float('-inf')\n        y2 = float('-inf')\n        area = 0\n        points = set()\n        for x, y, a, b in rectangles:\n            x1 = min(x1, x)\n            y1 = min(y1, y)\n            x2 = max(x2, a)\n            y2 = max(y2, b)\n            area += (a - x) * (b - y)\n            \n            points.add((x, y))\n            points.add((x, b))\n            points.add((a, y))\n            points.add((a, b))\n            \n        expected_area = (x2 - x1) * (y2 - y1)\n        if expected_area != area:\n            return False\n        \n        corners = [(x1, y1), (x1, y2), (x2, y1), (x2, y2)]\n        corner_count = 0\n        for corner in corners:\n            if corner in points:\n                corner_count += 1\n                points.remove(corner)\n        \n        if corner_count != 4:\n            return False\n\n        return not points\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        test_cases = [{'rectangles': [[1, 1, 3, 3], [3, 1, 4, 2], [3, 2, 4, 4], [1, 3, 2, 4], [2, 3, 3, 4]]}, {'rectangles': [[1, 1, 2, 3], [1, 3, 2, 4], [3, 1, 4, 2], [3, 2, 4, 4]]}, {'rectangles': [[1, 1, 3, 3], [3, 1, 4, 2], [1, 3, 2, 4], [2, 2, 4, 4]]}]\n        return test_cases[0]\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        import ast\n        return ast.literal_eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.isRectangleCover(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.06",
            "memory": 4676,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 26, in <module>\n    import numpy as np\nModuleNotFoundError: No module named 'numpy'\n",
            "token": "621c7c7c-f0c7-4ef9-aa53-272c06669b7e",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "success",
        "question_id": 392,
        "title": "is-subsequence",
        "token": "dea355f3-c7a2-4ec9-bc93-f2d8cefc2fae",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport string\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def isSubsequence(self, s: str, t: str) -> bool:\n        s_ptr = 0\n        t_ptr = 0\n        while s_ptr < len(s) and t_ptr < len(t):\n            if s[s_ptr] == t[t_ptr]:\n                s_ptr += 1\n            t_ptr += 1\n        return s_ptr == len(s)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        \"\"\"\n        Generates a test case with randomly generated strings s and t.\n        \"\"\"\n        import random\n        import string\n        t = ''.join((random.choice(string.ascii_lowercase) for _ in range(random.randint(1, 1000))))\n        if random.choice([True, False]):\n            s = ''.join(random.sample(t, random.randint(0, len(t))))\n        else:\n            s = ''.join((random.choice(string.ascii_lowercase) for _ in range(random.randint(0, min(100, len(t))))))\n        return {'s': s, 't': t}\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\"\n        Encodes the input dictionary into a string format.\n        \"\"\"\n        return f\"{input_obj['s']}::{input_obj['t']}\"\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\"\n        Encodes the output object into a string format (true/false as a string).\n        \"\"\"\n        return str(output_obj).lower()\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\"\n        Decodes the input string back into a dictionary with keys 's' and 't'.\n        \"\"\"\n        s, t = input_str.split('::')\n        return {'s': s, 't': t}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.isSubsequence(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.057",
            "memory": 5008,
            "stderr": null,
            "token": "dea355f3-c7a2-4ec9-bc93-f2d8cefc2fae",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 479,
        "title": "largest-palindrome-product",
        "token": "6ee30f07-8883-44dd-9673-133cdc0f5eac",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport math\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def largestPalindrome(self, n: int) -> int:\n        if n == 1:\n            return 9\n\n        max_num = 10**n - 1\n        min_num = 10**(n - 1)\n\n        for a in range(max_num, min_num - 1, -1):\n            palindrome = int(str(a) + str(a)[::-1])\n\n            for x in range(max_num, int(palindrome**0.5) - 1, -1):\n                if palindrome % x == 0 and palindrome // x <= max_num:\n                    return palindrome % 1337\n        return 0\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        n = random.randint(1, 8)\n        return {'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['n'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'n': int(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.largestPalindrome(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.834",
            "memory": 4840,
            "stderr": null,
            "token": "6ee30f07-8883-44dd-9673-133cdc0f5eac",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 483,
        "title": "smallest-good-base",
        "token": "40211bcf-0b69-4a82-9859-d636851887ed",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport math\nimport time\nfrom fractions import Fraction\nfrom random import randint\n\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def smallestGoodBase(self, n: str) -> str:\n        n = int(n)\n        m_max = int((n + 1)**(0.5))\n\n        for m in range(int(n**0.3333333333333333) + 1, int(n**0.5) + 2):\n\n            k = int(round(n**(1/m)))\n            if k <= 1:\n              continue\n\n            num = k**(m+1) - 1\n            den = k - 1\n\n            if num % den == 0:\n              if num // den == n:\n                return str(k)\n        \n        for m in range(62, 0, -1):\n            k = int(round(n**(1/m)))\n            if k <= 1:\n              continue\n            if k > (1 << 31): continue\n                \n            num = k**(m+1) - 1\n            den = k - 1\n\n            if num % den == 0:\n                if num // den == n:\n                    return str(k)\n\n        return str(n - 1)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        \"\"\"Generate a random test case.\"\"\"\n        n = randint(3, 100000)\n        return {'n': str(n)}\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\"\n        Convert a test case input into a string.\n        :param input_obj: Dictionary with the input object.\n        :return: String representation of the input object.\n        \"\"\"\n        return input_obj['n']\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\"\n        Convert a test case output into a string.\n        :param output_obj: The output which is a good base.\n        :return: String representation of the output object.\n        \"\"\"\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\"\n        Convert a test case input string into a dictionary.\n        :param input_str: String representation of the input.\n        :return: Dictionary with the input object.\n        \"\"\"\n        return {'n': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.smallestGoodBase(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.065",
            "memory": 6168,
            "stderr": null,
            "token": "40211bcf-0b69-4a82-9859-d636851887ed",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "failure",
        "question_id": 485,
        "title": "max-consecutive-ones",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "failure",
        "question_id": 410,
        "title": "split-array-largest-sum",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "success",
        "question_id": 414,
        "title": "third-maximum-number",
        "token": "17b479df-d3c8-4aed-ae70-52a44f884faa",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport json\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def thirdMax(self, nums: List[int]) -> int:\n        nums = sorted(list(set(nums)), reverse=True)\n        if len(nums) >= 3:\n            return nums[2]\n        else:\n            return nums[0]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        nums_length = random.randint(1, 100)\n        nums = [random.randint(-2 ** 31, 2 ** 31 - 1) for _ in range(nums_length)]\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return json.loads(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.thirdMax(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.059",
            "memory": 5024,
            "stderr": null,
            "token": "17b479df-d3c8-4aed-ae70-52a44f884faa",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 472,
        "title": "concatenated-words",
        "token": "b754cf29-0933-44aa-97d8-8a0a25321d9c",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nfrom functools import cache\nimport json\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\n        word_set = set(words)\n        result = []\n        \n        def can_form(word):\n            if not word:\n                return False\n            dp = [False] * (len(word) + 1)\n            dp[0] = True\n            \n            for i in range(1, len(word) + 1):\n                for j in range(i):\n                    if dp[j] and word[j:i] in word_set:\n                        dp[i] = True\n                        break\n            \n            return dp[len(word)]\n\n        for word in words:\n            word_set.remove(word)\n            if can_form(word):\n                result.append(word)\n            word_set.add(word)\n            \n        return result\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        test_cases = [{'words': ['cat', 'cats', 'catsdogcats', 'dog', 'dogcatsdog', 'hippopotamuses', 'rat', 'ratcatdogcat']}, {'words': ['cat', 'dog', 'catdog']}, {'words': ['apple', 'banana', 'applebanana', 'bananaapple']}, {'words': ['a', 'b', 'c', 'abc', 'bc', 'cab', 'ac', 'abcab']}]\n        return test_cases[0]\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\" Convert a test case input into a JSON string \"\"\"\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\" Convert a test case output into a JSON string \"\"\"\n        return json.dumps(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\" Convert a test case input string back into a Python dict \"\"\"\n        return json.loads(input_str)\n\n    def decode_output(self, output_str) -> list:\n        \"\"\" Convert a test case output string back into a Python list \"\"\"\n        return json.loads(output_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.findAllConcatenatedWordsInADict(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.057",
            "memory": 4664,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 27, in <module>\n    from functools import cache\nImportError: cannot import name 'cache' from 'functools' (/usr/local/python-3.8.1/lib/python3.8/functools.py)\n",
            "token": "b754cf29-0933-44aa-97d8-8a0a25321d9c",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "success",
        "question_id": 476,
        "title": "number-complement",
        "token": "27e0781d-a423-4c12-afa0-53d0d6e21278",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        bits = num.bit_length()\n        mask = (1 << bits) - 1\n        return num ^ mask\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        num = random.randint(1, 10 ** 5)\n        return {'num': num}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['num'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'num': int(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.findComplement(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.061",
            "memory": 4732,
            "stderr": null,
            "token": "27e0781d-a423-4c12-afa0-53d0d6e21278",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 440,
        "title": "k-th-smallest-in-lexicographical-order",
        "token": "52016936-11f4-4283-8e4b-d928d657a36a",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution(object):\n    def findKthNumber(self, n, k):\n        curr = 1\n        k -= 1\n        \n        while k > 0:\n            step = self.countSteps(n, curr, curr + 1)\n            if step <= k:\n                curr += 1\n                k -= step\n            else:\n                curr *= 10\n                k -= 1\n\n        return curr\n\n    def countSteps(self, n, prefix1, prefix2):\n        steps = 0\n        while prefix1 <= n:\n            steps += min(n + 1, prefix2) - prefix1\n            prefix1 *= 10\n            prefix2 *= 10\n        return steps\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 1000)\n        k = random.randint(1, n)\n        return {'n': n, 'k': k}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['n']} {input_obj['k']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        n, k = map(int, input_str.split())\n        return {'n': n, 'k': k}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.findKthNumber(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.054",
            "memory": 4764,
            "stderr": null,
            "token": "52016936-11f4-4283-8e4b-d928d657a36a",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 441,
        "title": "arranging-coins",
        "token": "7b12af19-30c3-4b9a-b8f1-0af95ccd2e0e",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def arrangeCoins(self, n: int) -> int:\n        left, right = 0, n\n        while left <= right:\n            mid = left + (right - left) // 2\n            coins_needed = mid * (mid + 1) // 2\n            if coins_needed == n:\n                return mid\n            elif coins_needed < n:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return right\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 100)\n        return {'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['n'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        n = int(input_str)\n        return {'n': n}\n\n    def decode_output(self, output_str) -> int:\n        return int(output_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.arrangeCoins(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.057",
            "memory": 4796,
            "stderr": null,
            "token": "7b12af19-30c3-4b9a-b8f1-0af95ccd2e0e",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "failure",
        "question_id": 401,
        "title": "binary-watch",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "success",
        "question_id": 404,
        "title": "sum-of-left-leaves",
        "token": "0d022d26-fa72-401e-9e81-fa7cb72332ad",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom collections import deque\nfrom typing import Optional\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sumOfLeftLeaves(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        \n        stack = [(root, False)]  # (node, is_left)\n        total_sum = 0\n        \n        while stack:\n            node, is_left = stack.pop()\n            \n            if node:\n                if is_left and not node.left and not node.right:\n                    total_sum += node.val\n                \n                if node.left:\n                    stack.append((node.left, True))\n                if node.right:\n                    stack.append((node.right, False))\n        \n        return total_sum\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        single_node_tree = {'root': TreeNode(1)}\n        left_leaf_tree = {'root': TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7)))}\n        no_left_leaf_tree = {'root': TreeNode(1, None, TreeNode(2, None, TreeNode(3)))}\n        return no_left_leaf_tree\n\n    def encode_input(self, input_obj) -> str:\n\n        def serialize_tree(node):\n            if not node:\n                return 'null'\n            return f'{node.val}, {serialize_tree(node.left)}, {serialize_tree(node.right)}'\n        root = input_obj['root']\n        return f'[{serialize_tree(root)}]'\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n\n        def deserialize_tree(data_list):\n            if not data_list:\n                return None\n            val = data_list.pop(0)\n            if val == 'null':\n                return None\n            node = TreeNode(val=int(val))\n            node.left = deserialize_tree(data_list)\n            node.right = deserialize_tree(data_list)\n            return node\n        elements = input_str.strip('[]').split(', ')\n        root = deserialize_tree(elements)\n        return {'root': root}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.sumOfLeftLeaves(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.054",
            "memory": 4756,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 142, in <module>\n    runner.run()\n  File \"script.py\", line 123, in run\n    input = self.test.decode_input(test_case['input'])\n  File \"script.py\", line 109, in decode_input\n    root = deserialize_tree(elements)\n  File \"script.py\", line 104, in deserialize_tree\n    node = TreeNode(val=int(val))\nTypeError: __init__() got an unexpected keyword argument 'val'\n",
            "token": "0d022d26-fa72-401e-9e81-fa7cb72332ad",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "success",
        "question_id": 363,
        "title": "max-sum-of-rectangle-no-larger-than-k",
        "token": "591963dd-64ab-49a4-9f90-a6a6b16440c4",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport math\nfrom sortedcontainers import SortedList\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nimport bisect\nfrom typing import List\n\nclass Solution:\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\n        m = len(matrix)\n        n = len(matrix[0])\n        max_sum = float('-inf')\n\n        for left in range(n):\n            row_sums = [0] * m\n            for right in range(left, n):\n                for i in range(m):\n                    row_sums[i] += matrix[i][right]\n\n                cur_sum = 0\n                prefix_sums = [0]\n                current_max = float('-inf')\n\n                for row_sum in row_sums:\n                    cur_sum += row_sum\n                    target = cur_sum - k\n                    idx = bisect.bisect_left(prefix_sums, target)\n                    if idx < len(prefix_sums):\n                        current_max = max(current_max, cur_sum - prefix_sums[idx])\n\n                    bisect.insort(prefix_sums, cur_sum)\n\n                max_sum = max(max_sum, current_max)\n\n        return max_sum\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        m = random.randint(1, 10)\n        n = random.randint(1, 10)\n        k = random.randint(-1000, 1000)\n        matrix = [[random.randint(-100, 100) for _ in range(n)] for _ in range(m)]\n        return {'matrix': matrix, 'k': k}\n\n    def encode_input(self, input_obj: dict) -> str:\n        matrix_str = str(input_obj['matrix'])\n        k_str = str(input_obj['k'])\n        return f\"{{'matrix': {matrix_str}, 'k': {k_str}}}\"\n\n    def encode_output(self, output_obj: int) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str: str) -> dict:\n        return eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.maxSumSubmatrix(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.045",
            "memory": 4680,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 27, in <module>\n    from sortedcontainers import SortedList\nModuleNotFoundError: No module named 'sortedcontainers'\n",
            "token": "591963dd-64ab-49a4-9f90-a6a6b16440c4",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "success",
        "question_id": 459,
        "title": "repeated-substring-pattern",
        "token": "f95e8e19-feb0-46ad-a0cd-65d6916788b7",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def repeatedSubstringPattern(self, s: str) -> bool:\n        n = len(s)\n        for i in range(1, n // 2 + 1):\n            if n % i == 0:\n                sub = s[:i]\n                k = n // i\n                new = sub * k\n                if new == s:\n                    return True\n        return False\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(2, 20)\n        s = ''.join(random.choices('abcdefghijklmnopqrstuvwxyz', k=length))\n        return {'s': s}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['s']\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj).lower()\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.repeatedSubstringPattern(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.058",
            "memory": 4736,
            "stderr": null,
            "token": "f95e8e19-feb0-46ad-a0cd-65d6916788b7",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 461,
        "title": "hamming-distance",
        "token": "c36acedf-b704-415b-9b52-f1e0495642fb",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def hammingDistance(self, x: int, y: int) -> int:\n        xor_result = x ^ y\n        hamming_distance = 0\n        while xor_result:\n            hamming_distance += xor_result & 1\n            xor_result >>= 1\n        return hamming_distance\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        x = random.randint(0, 2 ** 31 - 1)\n        y = random.randint(0, 2 ** 31 - 1)\n        return {'x': x, 'y': y}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{{'x': {input_obj['x']}, 'y': {input_obj['y']}}}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        input_parts = input_str.strip('{}').split(', ')\n        x = int(input_parts[0].split(': ')[1])\n        y = int(input_parts[1].split(': ')[1])\n        return {'x': x, 'y': y}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.hammingDistance(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.056",
            "memory": 4840,
            "stderr": null,
            "token": "c36acedf-b704-415b-9b52-f1e0495642fb",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 463,
        "title": "island-perimeter",
        "token": "82cd42dd-7c4b-4257-beed-60dd9a008b90",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List\nimport ast\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def islandPerimeter(self, grid: List[List[int]]) -> int:\n        rows, cols = len(grid), len(grid[0])\n        perimeter = 0\n        for i in range(rows):\n            for j in range(cols):\n                if grid[i][j] == 1:\n                    # Check top\n                    if i == 0 or grid[i-1][j] == 0:\n                        perimeter += 1\n                    # Check bottom\n                    if i == rows - 1 or grid[i+1][j] == 0:\n                        perimeter += 1\n                    # Check left\n                    if j == 0 or grid[i][j-1] == 0:\n                        perimeter += 1\n                    # Check right\n                    if j == cols - 1 or grid[i][j+1] == 0:\n                        perimeter += 1\n        return perimeter\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        height = random.randint(1, 10)\n        width = random.randint(1, 10)\n        grid = [[0 for _ in range(width)] for _ in range(height)]\n        start_x = random.randint(0, height - 1)\n        start_y = random.randint(0, width - 1)\n        grid[start_x][start_y] = 1\n        for _ in range(int(height * width / 4)):\n            direction = random.choice(['up', 'down', 'left', 'right'])\n            if direction == 'up' and start_x - 1 >= 0:\n                start_x -= 1\n            elif direction == 'down' and start_x + 1 < height:\n                start_x += 1\n            elif direction == 'left' and start_y - 1 >= 0:\n                start_y -= 1\n            elif direction == 'right' and start_y + 1 < width:\n                start_y += 1\n            grid[start_x][start_y] = 1\n        return {'grid': grid}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['grid'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        grid = ast.literal_eval(input_str)\n        return {'grid': grid}\n\n    def decode_output(self, output_str) -> int:\n        return int(output_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.islandPerimeter(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.064",
            "memory": 5216,
            "stderr": null,
            "token": "82cd42dd-7c4b-4257-beed-60dd9a008b90",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 685,
        "title": "redundant-connection-ii",
        "token": "c57fc73d-a75e-497f-bb78-e353cb6525dd",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nfrom collections import defaultdict\n\nclass Solution:\n    def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[List[int]]:\n        n = len(edges)\n        parent = list(range(n + 1))\n\n        def find(i):\n            if parent[i] == i:\n                return i\n            parent[i] = find(parent[i])\n            return parent[i]\n\n        def union(i, j):\n            root_i = find(i)\n            root_j = find(j)\n            if root_i != root_j:\n                parent[root_i] = root_j\n                return True\n            return False\n\n        in_degree = defaultdict(int)\n        node_with_multiple_parents = None\n\n        for u, v in edges:\n            in_degree[v] += 1\n            if in_degree[v] > 1:\n                node_with_multiple_parents = v\n                break\n\n        if node_with_multiple_parents is None:\n            # No node with multiple parents, so there must be a cycle\n            for u, v in edges:\n                if not union(u, v):\n                    return [u, v]\n            return []  # Should never happen\n        else:\n            # Node with multiple parents exists\n            edges1 = []\n            edges2 = []\n            target_node = node_with_multiple_parents\n            for u, v in edges:\n                if v == target_node:\n                    edges2.append([u,v])\n                else:\n                    edges1.append([u,v])\n            parent = list(range(n + 1))\n            for u, v in edges1:\n                union(u, v)\n            for u,v in edges2:\n                if not union(u,v):\n                    return [u,v]\n            return edges2[0]\n\nclass TestCaseGenerator:\n\n    def __init__(self, nodes_range=(3, 6)):\n        self.nodes_range = nodes_range\n\n    def generate(self) -> dict:\n        n = random.randint(*self.nodes_range)\n        edges = []\n        for i in range(1, n):\n            edges.append([i, i + 1])\n        a = random.randint(1, n - 1)\n        b = random.randint(a + 1, n)\n        edges.append([b, a])\n        random.shuffle(edges)\n        return {'edges': edges}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['edges'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'edges': eval(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.findRedundantDirectedConnection(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.061",
            "memory": 4904,
            "stderr": null,
            "token": "c57fc73d-a75e-497f-bb78-e353cb6525dd",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 736,
        "title": "parse-lisp-expression",
        "token": "0ad61dcd-e65d-4269-bbc5-b78ab3faf61c",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List, Dict\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nfrom collections import deque\n\nclass Solution:\n    def evaluate(self, expression: str) -> int:\n        \"\"\"\n        expr := (let [string expr]*)\n        expr := (add  expr expr)\n        expr := (mult expr expr)\n        expr := var \n        \"\"\"\n\n        def tokenize(s):\n            Q = deque()\n            cur = 0\n            n = len(s)\n            while cur < n:\n                c = s[cur]\n                if c in ('(', ')'):\n                    Q.append(c)\n                    cur += 1\n                    continue\n                if c.isdigit() or c == '-':\n                    res = 0\n                    sign = 1\n                    if c == '-':\n                        sign = -1\n                        cur += 1\n                    while cur < n and s[cur].isdigit():\n                        res = res*10 + int(s[cur])\n                        cur += 1\n                    Q.append(sign * res)\n                    continue\n                if c.isalpha():\n                    res = []\n                    while cur < n and (s[cur].isalpha() or s[cur].isdigit()):\n                        res.append(s[cur])\n                        cur += 1\n                    Q.append(''.join(res))\n                    continue\n                cur += 1\n            return Q\n\n        tokens = tokenize(expression)\n\n        def string():\n            return tokens.popleft()\n\n        def var(mp):\n            s = tokens.popleft()\n            if s in mp:\n                return mp[s]\n            return int(s)\n\n        def expr(mp):\n            if tokens[0] == '(':\n                tokens.popleft()\n                op = tokens.popleft()\n                if op == 'let':\n                    new_vars = {}\n                    while tokens[0] != ')':\n                        variable_name = string()\n                        if tokens[0] == '(':\n                            expression = expr(mp)\n                        else:\n                            try:\n                                expression = int(tokens[0])\n                                tokens.popleft()\n                            except ValueError:\n                                expression = var(mp)\n                        new_vars[variable_name] = expression\n                        mp[variable_name] = expression\n                    tokens.popleft()\n                    expression = expr(mp)\n\n                    for k in new_vars:\n                        del mp[k]\n                    return expression\n                elif op == 'mult':\n                    expr1 = expr(mp)\n                    expr2 = expr(mp)\n                    expression = expr1 * expr2\n                elif op == 'add':\n                    expr1 = expr(mp)\n                    expr2 = expr(mp)\n                    expression = expr1 + expr2\n                tokens.popleft()\n                return expression\n            else:\n                return var(mp)\n\n        return expr({})\n\nclass TestCaseGenerator:\n\n    def generate(self) -> Dict:\n        test_cases = [{'expression': '(let x 2 (mult x (let x 3 y 4 (add x y))))'}, {'expression': '(let x 3 x 2 x )'}, {'expression': '(let x 1 y 2 x (add x y) (add x y))'}, {'expression': '(add 1 2)'}, {'expression': '(mult (add 1 2) 3)'}]\n        return random.choice(test_cases)\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['expression']\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> Dict:\n        return {'expression': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.evaluate(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.067",
            "memory": 4836,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 113, in expr\n    expression = int(tokens[0])\nValueError: invalid literal for int() with base 10: ')'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"script.py\", line 185, in <module>\n    runner.run()\n  File \"script.py\", line 169, in run\n    output = self.solution.evaluate(**input)\n  File \"script.py\", line 138, in evaluate\n    return expr({})\n  File \"script.py\", line 116, in expr\n    expression = var(mp)\n  File \"script.py\", line 99, in var\n    return int(s)\nValueError: invalid literal for int() with base 10: ')'\n",
            "token": "0ad61dcd-e65d-4269-bbc5-b78ab3faf61c",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "success",
        "question_id": 973,
        "title": "stamping-the-sequence",
        "token": "866fd20d-370d-4316-88d2-215dcdcecb8c",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        m, n = len(stamp), len(target)\n        A = [0] * (n - m + 1)\n        todo = []\n        stars = [0] * n\n        for i in range(n - m + 1):\n            for j in range(m):\n                if target[i + j] == stamp[j]:\n                    A[i] += 1\n                else:\n                    A[i] = -1\n                    stars[i + j] += 1\n        \n        res = []\n        q = [i for i in range(n) if stars[i] == 0]\n        seen = [False] * n\n\n        while q:\n            i = q.pop(0)\n            for j in range(max(0, i - m + 1), min(n - m + 1, i + 1)):\n                if A[j] >= 0:\n                    A[j] -= 1\n                    if A[j] == 0:\n                        res.append(j)\n                        for k in range(m):\n                            neighbor = j + k\n                            stars[neighbor] -= 1\n                            if stars[neighbor] == 0:\n                                q.append(neighbor)\n        \n        return res[::-1] if all(s == 0 for s in stars) else []\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        stamp = 'abc'\n        target = 'ababc'\n        return {'stamp': stamp, 'target': target}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{{'stamp': '{input_obj['stamp']}', 'target': '{input_obj['target']}'}}\"\n\n    def encode_output(self, output_obj) -> str:\n        return f'{output_obj}'\n\n    def decode_input(self, input_str) -> dict:\n        import ast\n        return ast.literal_eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.movesToStamp(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Input {'stamp': 'abc', 'target': 'ababc'}\nExpected Output:  [0, 2]\nActual Output:  []\n1 Test Failed!\n",
            "time": "0.053",
            "memory": 4948,
            "stderr": null,
            "token": "866fd20d-370d-4316-88d2-215dcdcecb8c",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 4,
                "description": "Wrong Answer"
            }
        }
    },
    {
        "status": "failure",
        "question_id": 975,
        "title": "range-sum-of-bst",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "failure",
        "question_id": 977,
        "title": "distinct-subsequences-ii",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "success",
        "question_id": 1013,
        "title": "fibonacci-number",
        "token": "7c7ab924-fd10-4b5d-a9a5-89efe1906b6e",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def fib(self, n: int) -> int:\n        if n < 2:\n            return n\n        \n        memo = {}\n        \n        def fib_memo(n):\n            if n in memo:\n                return memo[n]\n            if n < 2:\n                return n\n            memo[n] = fib_memo(n-1) + fib_memo(n-2)\n            return memo[n]\n        \n        return fib_memo(n)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        from random import randint\n        return {'n': randint(0, 30)}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['n'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'n': int(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.fib(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.061",
            "memory": 4748,
            "stderr": null,
            "token": "7c7ab924-fd10-4b5d-a9a5-89efe1906b6e",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 514,
        "title": "freedom-trail",
        "token": "4eb50823-c51f-42e1-b8c5-4866e022f1e1",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nfrom collections import defaultdict\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def findRotateSteps(self, ring: str, key: str) -> int:\n        n, m = len(ring), len(key)\n        pos = [[] for _ in range(26)]\n        for i, c in enumerate(ring):\n            pos[ord(c) - ord('a')].append(i)\n        \n        dp = [[float('inf')] * n for _ in range(m + 1)]\n        dp[m][0] = 0\n        \n        for i in reversed(range(m)):\n            for j in range(n):\n                for k in pos[ord(key[i]) - ord('a')]:\n                    diff = abs(j - k)\n                    min_dist = min(diff, n - diff)\n                    dp[i][j] = min(dp[i][j], dp[i + 1][k] + min_dist + 1)\n        \n        return dp[0][0]\n\nclass TestCaseGenerator:\n    \"\"\"\n    Generates test case inputs for the \"Road to Freedom\" problem where a ring needs to be rotated to match a given key string.\n    \"\"\"\n\n    def generate(self) -> dict:\n        random.seed(0)\n        ring_length = random.randint(1, 100)\n        key_length = random.randint(1, 100)\n        alphabet = 'abcdefghijklmnopqrstuvwxyz'\n        ring = ''.join(random.choices(alphabet, k=ring_length))\n        key = ''.join(random.choices(alphabet, k=key_length))\n        return {'ring': ring, 'key': key}\n\n    def encode_input(self, input_obj: dict) -> str:\n        return f\"ring={input_obj['ring']},key={input_obj['key']}\"\n\n    def encode_output(self, output_obj: int) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str: str) -> dict:\n        parts = input_str.split(',')\n        ring = parts[0].split('=')[1]\n        key = parts[1].split('=')[1]\n        return {'ring': ring, 'key': key}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.findRotateSteps(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.265",
            "memory": 5036,
            "stderr": null,
            "token": "4eb50823-c51f-42e1-b8c5-4866e022f1e1",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 920,
        "title": "uncommon-words-from-two-sentences",
        "token": "40cbfa65-dba4-4dc0-800b-7ecbfd033ecf",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nfrom collections import Counter\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def uncommonFromSentences(self, s1: str, s2: str) -> List[str]:\n        d=Counter(s1.split())+Counter(s2.split())\n        return [x for x in d if d[x]==1]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        test_cases = [('this apple is sweet', 'this apple is sour'), ('apple apple', 'banana'), ('orange', 'apple orange'), ('dog cat', 'cat dog'), ('unique words', 'unique unique words'), ('a quick brown fox', 'jumps over the lazy dog')]\n        s1, s2 = random.choice(test_cases)\n        return {'s1': s1, 's2': s2}\n\n    def encode_input(self, input_obj: dict) -> str:\n        return f\"{input_obj['s1']}|{input_obj['s2']}\"\n\n    def encode_output(self, output_obj: List[str]) -> str:\n        return ','.join(output_obj)\n\n    def decode_input(self, input_str: str) -> dict:\n        s1, s2 = input_str.split('|')\n        return {'s1': s1, 's2': s2}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.uncommonFromSentences(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.068",
            "memory": 5944,
            "stderr": null,
            "token": "40cbfa65-dba4-4dc0-800b-7ecbfd033ecf",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "failure",
        "question_id": 35,
        "title": "search-insert-position",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "failure",
        "question_id": 10,
        "title": "regular-expression-matching",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "success",
        "question_id": 218,
        "title": "the-skyline-problem",
        "token": "0cac2e45-02f0-4f19-b3d8-52a27bbff052",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport heapq\nimport random\nimport ast\n\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def getSkyline(self, buildings: List[List[int]]) -> List[List[int]]:\n        import heapq\n\n        skyline = []\n        events = [(L, -H, R) for L, R, H in buildings]\n        events += [(R, 0, 0) for _, R, _ in buildings]\n        events.sort()\n\n        heap = [(0, float('inf'))]\n        current_height = 0\n\n        for x, neg_h, r in events:\n            # Remove processed buildings from heap\n            while heap and heap[0][1] <= x:\n                heapq.heappop(heap)\n\n            # Add current building to heap\n            if neg_h != 0:\n                heapq.heappush(heap, (neg_h, r))\n\n            # Check if current height changes\n            peak_height = -heap[0][0]\n            if skyline and skyline[-1][1] == peak_height:\n                continue\n\n            if peak_height != current_height:\n                skyline.append([x, peak_height])\n                current_height = peak_height\n\n        return skyline\n\nclass TestCaseGenerator:\n\n    def __init__(self):\n        self.min_height = 1\n        self.max_height = 20\n        self.max_x_coord = 100\n\n    def generate(self) -> dict:\n        num_buildings = random.randint(1, 100)\n        buildings = []\n        current_x = 0\n        for _ in range(num_buildings):\n            left = current_x\n            right = left + random.randint(1, 10)\n            height = random.randint(self.min_height, self.max_height)\n            buildings.append([left, right, height])\n            current_x = right + random.randint(0, 5)\n        return {'buildings': buildings}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return ast.literal_eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.getSkyline(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.082",
            "memory": 5752,
            "stderr": null,
            "token": "0cac2e45-02f0-4f19-b3d8-52a27bbff052",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "failure",
        "question_id": 226,
        "title": "invert-binary-tree",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "success",
        "question_id": 273,
        "title": "integer-to-english-words",
        "token": "a2de59b1-55c0-4716-b35b-ef7a792f77c9",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def numberToWords(self, num: int) -> str:\n        if num == 0:\n            return \"Zero\"\n\n        less_than_20 = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\",\n                           \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\",\n                           \"Eighteen\", \"Nineteen\"]\n        tens = [\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n        thousands = [\"\", \"Thousand\", \"Million\", \"Billion\"]\n\n        def helper(n):\n            if n < 20:\n                return less_than_20[n]\n            elif n < 100:\n                return tens[n // 10] + (\" \" + less_than_20[n % 10]) if n % 10 else tens[n // 10]\n            else:\n                return less_than_20[n // 100] + \" Hundred \" + helper(n % 100)\n\n        result = []\n        for i in range(4):\n            if num % 1000 != 0:\n                result.append(helper(num % 1000) + \" \" + thousands[i])\n            num //= 1000\n\n        return \" \".join(result[::-1]).strip()\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        \"\"\"\n        Generates a random test case input within the range of the problem's constraints.\n        \"\"\"\n        num = random.randint(0, 2 ** 31 - 1)\n        return {'num': num}\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\"\n        Convert a test case input into a string suitable for passing to the function.\n        \"\"\"\n        return str(input_obj['num'])\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\"\n        Convert a test case output into a string representation.\n        \"\"\"\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\"\n        Convert a test case input string into a Python dict.\n        \"\"\"\n        return {'num': int(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.numberToWords(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.067",
            "memory": 4888,
            "stderr": null,
            "token": "a2de59b1-55c0-4716-b35b-ef7a792f77c9",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 14,
        "title": "longest-common-prefix",
        "token": "faf7a7f2-3688-4f48-b27c-b7d2658c962d",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def longestCommonPrefix(self, strs: List[str]) -> str:\n        if not strs:\n            return \"\"\n        \n        prefix = strs[0]\n        for i in range(1, len(strs)):\n            while strs[i].find(prefix) != 0:\n                prefix = prefix[:-1]\n                if not prefix:\n                    return \"\"\n        return prefix\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        num_strings = random.randint(1, 10)\n        strs = []\n        for _ in range(num_strings):\n            str_length = random.randint(0, 10)\n            random_str = ''.join(random.choices('abcdefghijklmnopqrstuvwxyz', k=str_length))\n            strs.append(random_str)\n        return {'strs': strs}\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\"Convert a test case input into a string for transport.\"\"\"\n        return str(input_obj['strs'])\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\"Convert a test case output into a string for transport.\"\"\"\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\"Convert a test case input string back into a dictionary.\"\"\"\n        strs = eval(input_str[1:-1])\n        return {'strs': strs}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.longestCommonPrefix(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.069",
            "memory": 4824,
            "stderr": null,
            "token": "faf7a7f2-3688-4f48-b27c-b7d2658c962d",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 258,
        "title": "add-digits",
        "token": "5c987761-c800-4e91-bb58-72714874605e",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def addDigits(self, num: int) -> int:\n        if num == 0: \n            return 0\n        mod = num % 9 \n        if mod == 0:\n            return 9 \n        else: return mod\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        num = random.randint(0, 1000)\n        return {'num': num}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['num'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        try:\n            num = int(input_str)\n            return {'num': num}\n        except ValueError:\n            raise ValueError('Invalid input string for conversion to integer')\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.addDigits(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.065",
            "memory": 4760,
            "stderr": null,
            "token": "5c987761-c800-4e91-bb58-72714874605e",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 76,
        "title": "minimum-window-substring",
        "token": "64bd49df-ee20-447a-b018-22b2b4ad69ae",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nfrom collections import Counter\n\nclass Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        if not s or not t:\n            return \"\"\n\n        t_count = Counter(t)\n        window_count = {}\n        required = len(t_count)\n        formed = 0\n        left = 0\n        right = 0\n        min_length = float('inf')\n        min_window = \"\"\n\n        while right < len(s):\n            character = s[right]\n            window_count[character] = window_count.get(character, 0) + 1\n\n            if character in t_count and window_count[character] == t_count[character]:\n                formed += 1\n\n            while left <= right and formed == required:\n                character = s[left]\n\n                if right - left + 1 < min_length:\n                    min_length = right - left + 1\n                    min_window = s[left:right + 1]\n\n                window_count[character] -= 1\n                if character in t_count and window_count[character] < t_count[character]:\n                    formed -= 1\n\n                left += 1\n            right += 1\n        return min_window\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        possible_cases = [{'s': 'ADOBECODEBANC', 't': 'ABC'}, {'s': 'a', 't': 'a'}, {'s': 'a', 't': 'aa'}, {'s': 'MANGROVESANDMONOGRAMS', 't': 'GMSA'}]\n        return random.choice(possible_cases)\n\n    def encode_input(self, input_obj) -> str:\n        return f\"s={input_obj['s']},t={input_obj['t']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        values = input_str.split(',')\n        return {'s': values[0].split('=')[1], 't': values[1].split('=')[1]}\n\n    def decode_output(self, output_str) -> str:\n        return output_str\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.minWindow(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.064",
            "memory": 4808,
            "stderr": null,
            "token": "64bd49df-ee20-447a-b018-22b2b4ad69ae",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 68,
        "title": "text-justification",
        "token": "fc6203f2-eec5-4f35-aaaf-e0c667526100",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport json\nfrom math import ceil\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\n        \n        n=len(words)\n        output,line,width=[],[],0\n        \n        for w in words:\n            if width + len(w) + len(line) > maxWidth:\n                if len(line) > 1:\n                    spaces_needed = maxWidth - width\n                    spaces_between = spaces_needed // (len(line) - 1)\n                    extra_spaces = spaces_needed % (len(line) - 1)\n                    \n                    for i in range(len(line) - 1):\n                        line[i] += ' ' * spaces_between\n                        if i < extra_spaces:\n                            line[i] += ' '\n                output += [''.join(line)]\n                line=[]\n                width=0\n            line += [w]\n            width += len(w)\n        \n        return output + [' '.join(line).ljust(maxWidth)]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        test_cases = [{'words': ['This', 'is', 'an', 'example', 'of', 'text', 'justification.'], 'maxWidth': 16}, {'words': ['What', 'must', 'be', 'acknowledgment', 'shall', 'be'], 'maxWidth': 16}, {'words': ['Science', 'is', 'what', 'we', 'understand', 'well', 'enough', 'to', 'explain', 'to', 'a', 'computer.', 'Art', 'is', 'everything', 'else', 'we', 'do'], 'maxWidth': 20}, {'words': ['Lorem', 'ipsum', 'dolor', 'sit', 'amet'], 'maxWidth': 14}, {'words': ['A', 'test', 'case', 'with'], 'maxWidth': 12}]\n        return random.choice(test_cases)\n\n    def encode_input(self, input_obj) -> str:\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return json.dumps(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return json.loads(input_str)\n\n    def decode_output(self, output_str) -> list:\n        return json.loads(output_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.fullJustify(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Input {'words': ['What', 'must', 'be', 'acknowledgment', 'shall', 'be'], 'maxWidth': 16}\nExpected Output:  [\"What   must   be\", \"acknowledgment  \", \"shall be        \"]\nActual Output:  [\"What   must   be\", \"acknowledgment\", \"shall be        \"]\n1 Test Failed!\n",
            "time": "0.064",
            "memory": 4880,
            "stderr": null,
            "token": "fc6203f2-eec5-4f35-aaaf-e0c667526100",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 4,
                "description": "Wrong Answer"
            }
        }
    },
    {
        "status": "success",
        "question_id": 332,
        "title": "reconstruct-itinerary",
        "token": "6c92aecd-80ee-4e98-b4cf-c63037a7ca49",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport collections\nimport random\nimport ast\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\n        self.graph = {}\n        for src, dst in tickets:\n            self.graph.setdefault(src, []).append(dst)\n        \n        for src_dst in self.graph.values():\n            src_dst.sort() # sort destinations by increasing lexical order\n        \n        self.res = []\n        self.dfs(\"JFK\")\n        return self.res[::-1]\n    \n    def dfs(self, src):\n        destinations = self.graph.get(src, [])\n        while destinations:\n            dst = destinations.pop(0)\n            self.dfs(dst)\n        self.res.append(src)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        airports = ['JFK', 'SFO', 'ATL', 'LHR', 'MUC', 'SJC', 'LGB']\n        tickets = [['JFK', random.choice(airports[1:])]]\n        for _ in range(random.randint(1, 10)):\n            from_airport = random.choice(airports)\n            to_airport = random.choice([airport for airport in airports if airport != from_airport])\n            tickets.append([from_airport, to_airport])\n        return {'tickets': tickets}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['tickets'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        input_list = ast.literal_eval(input_str)\n        return {'tickets': input_list}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.findItinerary(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.067",
            "memory": 5228,
            "stderr": null,
            "token": "6c92aecd-80ee-4e98-b4cf-c63037a7ca49",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 689,
        "title": "maximum-sum-of-3-non-overlapping-subarrays",
        "token": "23dc9299-9e5e-49e0-8ef4-6d089664323c",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\nimport json\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def maxSumOfThreeSubarrays(self, nums: List[int], k: int) -> List[int]:\n        n = len(nums)\n        sums = [0] * (n - k + 1)\n        current_sum = sum(nums[:k])\n        sums[0] = current_sum\n        for i in range(1, n - k + 1):\n            current_sum = current_sum - nums[i - 1] + nums[i + k - 1]\n            sums[i] = current_sum\n\n        left = [0] * (n - k + 1)\n        best = 0\n        for i in range(n - k + 1):\n            if sums[i] > sums[best]:\n                best = i\n            left[i] = best\n\n        right = [n - k] * (n - k + 1)\n        best = n - k\n        for i in range(n - k, -1, -1):\n            if sums[i] >= sums[best]:\n                best = i\n            right[i] = best\n\n        result = []\n        max_sum = 0\n        for mid in range(k, n - 2 * k + 1):\n            l, r = left[mid - k], right[mid + k]\n            cur_sum = sums[l] + sums[r] + sums[mid]\n            if cur_sum > max_sum:\n                max_sum = cur_sum\n                result = [l, mid, r]\n        return result\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(3, 30)\n        k = random.randint(1, n // 3)\n        nums = [random.randint(1, 100) for _ in range(n)]\n        return {'nums': nums, 'k': k}\n\n    def encode_input(self, input_obj) -> str:\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return json.dumps(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return json.loads(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.maxSumOfThreeSubarrays(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.059",
            "memory": 4840,
            "stderr": null,
            "token": "23dc9299-9e5e-49e0-8ef4-6d089664323c",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 953,
        "title": "reverse-only-letters",
        "token": "50137cbb-5e98-43ee-bb3a-ff207e037e4b",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport string\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n\n\n    def reverseOnlyLetters(self, s: str) -> str:\n        left = 0\n        right = len(s) - 1\n        s_list = list(s)\n        while (left < right):\n            if not s_list[left].isalpha():\n                left += 1\n                continue\n            if not s_list[right].isalpha():\n                right -= 1\n                continue\n            temp = s_list[left]\n            s_list[left] = s_list[right]\n            s_list[right] = temp\n            left += 1\n            right -=1\n        \n        return \"\".join(s_list)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random, string\n        letters = ''.join(random.choices(string.ascii_letters, k=random.randint(1, 50)))\n        non_letters = ''.join(random.choices('!@#$%^&*()-_1234567890:=', k=50 - len(letters)))\n        string_list = list(letters + non_letters)\n        random.shuffle(string_list)\n        generated_string = ''.join(string_list)\n        return {'s': generated_string}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['s']\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.reverseOnlyLetters(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.053",
            "memory": 4768,
            "stderr": null,
            "token": "50137cbb-5e98-43ee-bb3a-ff207e037e4b",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 923,
        "title": "super-egg-drop",
        "token": "02d2851e-b1a2-4d2b-8fec-f90b0c273e87",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom functools import cache\nfrom random import randint\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    from functools import cache\n    @cache\n    def superEggDrop(self, k: int, n: int) -> int:\n        \n        # base condition\n\n        if n==0:\n            return 0\n        if n==1:\n            return 1\n        if k==1:\n            return n\n        ans = float('inf')\n        s, e = 1, n\n        while (s <= e):\n            x = (s+e)//2\n            low = self.superEggDrop(k-1, x-1)\n            high = self.superEggDrop(k, n-x)\n            if low > high:\n                ans = min(ans,low )\n                e = x-1\n            else:\n                ans = min(ans,high )\n                s = x+1\n        # for x in range(1, n+1):\n        #     ans  = min(ans, max(self.superEggDrop(k-1, x-1), self.superEggDrop(k, n-x)))\n        \n        return ans +1\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        from random import randint\n        k = randint(1, 10)\n        n = randint(1, 100)\n        return {'k': k, 'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{{'k': {input_obj['k']}, 'n': {input_obj['n']}}}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        input_obj = eval(input_str)\n        return input_obj\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.superEggDrop(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.057",
            "memory": 4572,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 26, in <module>\n    from functools import cache\nImportError: cannot import name 'cache' from 'functools' (/usr/local/python-3.8.1/lib/python3.8/functools.py)\n",
            "token": "02d2851e-b1a2-4d2b-8fec-f90b0c273e87",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "failure",
        "question_id": 924,
        "title": "fair-candy-swap",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "success",
        "question_id": 632,
        "title": "smallest-range-covering-elements-from-k-lists",
        "token": "f009e173-0e70-47f4-a723-86c9c0240ad2",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom collections import defaultdict\nimport heapq\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nfrom collections import defaultdict\nimport heapq\n\nclass Solution:\n    def smallestRange(self, nums: List[List[int]]) -> List[int]:\n        k = len(nums)\n        pointers = [0] * k\n        heap = []\n        max_range = float('-inf')\n        \n        for i in range(k):\n            heapq.heappush(heap, (nums[i][0], i))\n            max_range = max(max_range, nums[i][0])\n            \n        range_start, range_end = -10**5, 10**5\n        \n        while True:\n            min_val, min_index = heapq.heappop(heap)\n            \n            if max_range - min_val < range_end - range_start:\n                range_start, range_end = min_val, max_range\n            \n            pointers[min_index] += 1\n            \n            if pointers[min_index] == len(nums[min_index]):\n                break\n            \n            new_val = nums[min_index][pointers[min_index]]\n            max_range = max(max_range, new_val)\n            heapq.heappush(heap, (new_val, min_index))\n        \n        return [range_start, range_end]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        k = random.randint(1, 10)\n        nums = []\n        for _ in range(k):\n            size_of_list = random.randint(1, 10)\n            start_value = random.randint(-100, 100)\n            num_list = sorted((random.randint(start_value, start_value + 20) for _ in range(size_of_list)))\n            nums.append(num_list)\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'nums': eval(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.smallestRange(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.065",
            "memory": 4936,
            "stderr": null,
            "token": "f009e173-0e70-47f4-a723-86c9c0240ad2",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 637,
        "title": "average-of-levels-in-binary-tree",
        "token": "d791f383-e9ff-4ec2-9fb0-2aaba70a234a",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom collections import deque\nfrom typing import List, Optional\nimport json\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nfrom collections import deque\nclass Solution:\n    def averageOfLevels(self, root: Optional[TreeNode]) -> List[float]:\n        levelsAverageList = []\n        if root != None:\n            queue = deque()\n            queue.append(root)\n            while queue:\n                size = len(queue)\n                level_sum = 0\n                level_count = 0\n                for start in range(size):\n                    treeNode = queue.popleft()\n                    level_sum += treeNode.val\n                    level_count += 1\n                    if treeNode.left != None:\n                        queue.append(treeNode.left)\n                    if treeNode.right != None:\n                        queue.append(treeNode.right)\n                levelsAverageList.append(float(level_sum/level_count))\n        return levelsAverageList\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        \"\"\"Generates a sample tree for testing purposes.\"\"\"\n        root = TreeNode(3)\n        root.left = TreeNode(9)\n        root.right = TreeNode(20, TreeNode(15), TreeNode(7))\n        return {'root': root}\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\"Encodes a tree structure into a JSON-compatible string.\"\"\"\n\n        def serialize(root):\n            values = []\n            queue = [root]\n            while queue:\n                node = queue.pop(0)\n                if node:\n                    values.append(node.val)\n                    queue.append(node.left)\n                    queue.append(node.right)\n                else:\n                    values.append(None)\n            return json.dumps(values)\n        return serialize(input_obj['root'])\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\"Converts the result into a JSON string.\"\"\"\n        return json.dumps(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\"Decodes a JSON string back into a tree structure.\"\"\"\n\n        def deserialize(data):\n            data = json.loads(data)\n            if not data or data[0] is None:\n                return None\n            root = TreeNode(data[0])\n            queue = [root]\n            i = 1\n            while queue and i < len(data):\n                node = queue.pop(0)\n                if data[i] is not None:\n                    node.left = TreeNode(data[i])\n                    queue.append(node.left)\n                i += 1\n                if i < len(data) and data[i] is not None:\n                    node.right = TreeNode(data[i])\n                    queue.append(node.right)\n                i += 1\n            return root\n        return {'root': deserialize(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.averageOfLevels(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.059",
            "memory": 4640,
            "stderr": null,
            "token": "d791f383-e9ff-4ec2-9fb0-2aaba70a234a",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 979,
        "title": "di-string-match",
        "token": "5f185148-1d67-4607-b042-b767fe3d0cae",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\nimport ast\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def diStringMatch(self, s: str) -> List[int]:\n        n = len(s)\n        low = 0\n        high = n\n        result = []\n        for c in s:\n            if c == 'I':\n                result.append(low)\n                low += 1\n            else:\n                result.append(high)\n                high -= 1\n        result.append(low)\n        return result\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(1, 20)\n        s = ''.join((random.choice(['I', 'D']) for _ in range(length)))\n        return {'s': s}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{{'s': '{input_obj['s']}'}}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return ast.literal_eval(input_str)\n\n    def decode_output(self, output_str) -> list:\n        return eval(output_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.diStringMatch(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Input {'s': 'DIDDDIIIDDIIDDDDI'}\nExpected Output:  [1, 0, 5, 4, 3, 2, 6, 7, 10, 9, 8, 11, 16, 15, 14, 13, 12, 17]\nActual Output:  [17, 0, 16, 15, 14, 1, 2, 3, 13, 12, 4, 5, 11, 10, 9, 8, 6, 7]\n1 Test Failed!\n",
            "time": "0.064",
            "memory": 5168,
            "stderr": null,
            "token": "5f185148-1d67-4607-b042-b767fe3d0cae",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 4,
                "description": "Wrong Answer"
            }
        }
    },
    {
        "status": "success",
        "question_id": 981,
        "title": "delete-columns-to-make-sorted",
        "token": "dae5df25-7e15-4011-97a1-5a21203679ab",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def minDeletionSize(self, strs: List[str]) -> int:\n        count = 0\n        for col in range(len(strs[0])):\n            for row in range(1, len(strs)):\n                if strs[row][col] < strs[row - 1][col]:\n                    count += 1\n                    break\n        return count\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 100)\n        m = random.randint(1, 1000)\n        strs = [''.join(random.choices('abcdefghijklmnopqrstuvwxyz', k=m)) for _ in range(n)]\n        return {'strs': strs}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.minDeletionSize(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.076",
            "memory": 11832,
            "stderr": null,
            "token": "dae5df25-7e15-4011-97a1-5a21203679ab",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 927,
        "title": "sum-of-subsequence-widths",
        "token": "46e9e5ed-98f4-4cfe-86b5-96995d8676a6",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def sumSubseqWidths(self, nums: List[int]) -> int:\n        nums = sorted(nums)\n        total = 0\n        n = len(nums)\n        mod = 10**9 + 7\n        power_of_2 = [1] * n\n        for i in range(1, n):\n            power_of_2[i] = (power_of_2[i - 1] * 2) % mod\n\n        for i in range(n):\n            total = (total + (power_of_2[i] - power_of_2[n - i - 1]) * nums[i]) % mod\n\n        return total\n\nclass TestCaseGenerator:\n\n    def __init__(self):\n        self.random = random\n\n    def generate(self) -> dict:\n        \"\"\" Generate a random test case within reasonable constraints. \"\"\"\n        length = self.random.randint(1, 10)\n        nums = [self.random.randint(1, 100) for _ in range(length)]\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\" Convert the dict input into a JSON-like string format. \"\"\"\n        return str(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\" The output is an integer so we convert it to a string directly. \"\"\"\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\" Convert the input string back to a dictionary object. \"\"\"\n        return eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.sumSubseqWidths(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.057",
            "memory": 4884,
            "stderr": null,
            "token": "46e9e5ed-98f4-4cfe-86b5-96995d8676a6",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "failure",
        "question_id": 933,
        "title": "increasing-order-search-tree",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "success",
        "question_id": 488,
        "title": "zuma-game",
        "token": "4590ddc9-6db0-49aa-8a10-44296a7043cb",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom functools import cache\nfrom itertools import groupby\nimport random\nfrom math import inf\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nfrom collections import defaultdict\nfrom functools import cache\n\nclass Solution:\n    def compress(self, s):\n        stack = []\n        for c in s:\n            if stack and stack[-1][0] != c and stack[-1][1] >= 3:\n                stack.pop()\n            if not stack or stack[-1][0] != c:\n                stack.append([c, 1])\n            else:\n                stack[-1][1] += 1\n        if stack and stack[-1][1] >= 3:\n            stack.pop()\n        return ''.join(a*b for a, b in stack)\n\n    def findMinStep(self, board: str, hand: str) -> int:\n        n = len(hand)\n        hand = ''.join(sorted(hand))\n\n        @cache\n        def solve(board_tuple, hand_tuple):\n            board = \"\".join(board_tuple)\n            hand = \"\".join(hand_tuple)\n            \n            board = self.compress(board)\n            if board == '': return n - len(hand)\n            if hand == '': return float('inf')\n\n            ans = float('inf')\n            for i in range(len(hand)):\n                if i > 0 and hand[i] == hand[i-1]: continue\n    \n                for j in range(len(board)):\n                    if board[j] == hand[i] or j > 0 and board[j] == board[j-1] and board[j] != hand[i]:\n                        ans = min(ans, solve(tuple(list(board[0:j]) + [hand[i]] + list(board[j:]))), tuple(list(hand[0:i]) + list(hand[i+1:]))))\n            return ans\n        \n        res = solve(tuple(list(board)), tuple(list(hand)))\n        if res == float('inf'): return -1\n        else: return res\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        colors = ['R', 'Y', 'B', 'G', 'W']\n        board_length = random.randint(1, 16)\n        hand_length = random.randint(1, 5)\n        board = ''.join((random.choice(colors) for _ in range(board_length)))\n        hand = ''.join((random.choice(colors) for _ in range(hand_length)))\n        return {'board': board, 'hand': hand}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"board={input_obj['board']},hand={input_obj['hand']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        parts = input_str.split(',')\n        board_part = parts[0].split('=')[1]\n        hand_part = parts[1].split('=')[1]\n        return {'board': board_part, 'hand': hand_part}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.findMinStep(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.029",
            "memory": 3288,
            "stderr": "  File \"script.py\", line 86\n    ans = min(ans, solve(tuple(list(board[0:j]) + [hand[i]] + list(board[j:]))), tuple(list(hand[0:i]) + list(hand[i+1:]))))\n                                                                                                                           ^\nSyntaxError: unmatched ')'\n",
            "token": "4590ddc9-6db0-49aa-8a10-44296a7043cb",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "success",
        "question_id": 493,
        "title": "reverse-pairs",
        "token": "455d2f58-4015-4015-9780-63d457746179",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nfrom random import randint\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass BIT:\n\n    def __init__(self, n):\n        self.n = n+1\n        self.lt = [0]*self.n\n\n    def search(self, indx):\n        res = 0\n        while indx>0:\n            res += self.lt[indx]\n            indx -= indx&(-indx)\n        return res\n\n    def update(self, indx, val):\n        while indx<self.n:\n            self.lt[indx] += val\n            indx += indx&(-indx)\n\n\nclass Solution:\n    def reversePairs(self, nums: List[int]) -> int:\n        n = len(nums)\n        res = 0\n        unique_nums = sorted(list(set(nums + [x * 2 for x in nums])))\n        num_map = {num: i + 1 for i, num in enumerate(unique_nums)}\n        bit = BIT(len(unique_nums))\n\n        for num in nums:\n            res += bit.search(len(unique_nums)) - bit.search(num_map[num * 2])\n            bit.update(num_map[num], 1)\n        return res\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = randint(1, 100)\n        nums = [randint(-2 ** 31, 2 ** 31 - 1) for _ in range(n)]\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'nums': eval(input_str)}\n\n    def decode_output(self, output_str) -> int:\n        return int(output_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.reversePairs(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.063",
            "memory": 5120,
            "stderr": null,
            "token": "455d2f58-4015-4015-9780-63d457746179",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 495,
        "title": "teemo-attacking",
        "token": "fa9ed6c0-f129-4078-ac5e-798b3c04e87f",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\nfrom ast import literal_eval\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def findPoisonedDuration(self, timeSeries: List[int], duration: int) -> int:\n        n = len(timeSeries)\n        res = 0\n        if n == 0:\n            return 0\n        \n        for i in range(n - 1):\n            res += min(duration, timeSeries[i + 1] - timeSeries[i])\n        return res + duration\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(1, 20)\n        time_series = sorted(random.sample(range(1, 100), length))\n        duration = random.randint(1, 10)\n        return {'timeSeries': time_series, 'duration': duration}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return literal_eval(input_str)\n\n    def decode_output(self, output_str) -> int:\n        return int(output_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.findPoisonedDuration(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.053",
            "memory": 5104,
            "stderr": null,
            "token": "fa9ed6c0-f129-4078-ac5e-798b3c04e87f",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 496,
        "title": "next-greater-element-i",
        "token": "8f0b762a-1dbd-4aca-aabd-1551650ef088",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        next_greater = {}\n        stack = []\n        for num in nums2:\n            while stack and num > stack[-1]:\n                next_greater[stack.pop()] = num\n            stack.append(num)\n        \n        while stack:\n            next_greater[stack.pop()] = -1\n        \n        res_out = [next_greater[num] for num in nums1]\n        return res_out\n\nclass TestCaseGenerator:\n\n    def __init__(self):\n        pass\n\n    @staticmethod\n    def generate() -> dict:\n        nums2_length = random.randint(2, 10)\n        nums2 = random.sample(range(0, 1000), nums2_length)\n        nums1_length = random.randint(1, nums2_length)\n        nums1 = random.sample(nums2, nums1_length)\n        return {'nums1': nums1, 'nums2': nums2}\n\n    @staticmethod\n    def encode_input(input_obj) -> str:\n        return f\"{input_obj['nums1']}, {input_obj['nums2']}\"\n\n    @staticmethod\n    def encode_output(output_obj) -> str:\n        return f'{output_obj}'\n\n    @staticmethod\n    def decode_input(input_str) -> dict:\n        nums1_str, nums2_str = input_str.split('],')\n        nums1 = list(map(int, nums1_str.strip('[] ').split(',')))\n        nums2 = list(map(int, nums2_str.strip('[] ').strip().split(',')))\n        return {'nums1': nums1, 'nums2': nums2}\n\n    @staticmethod\n    def decode_output(output_str) -> list:\n        return list(map(int, output_str.strip('[] ').split(',')))\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.nextGreaterElement(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.057",
            "memory": 4864,
            "stderr": null,
            "token": "8f0b762a-1dbd-4aca-aabd-1551650ef088",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 830,
        "title": "largest-triangle-area",
        "token": "f8c62905-adfe-4717-a510-dbc14c67c1be",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\nimport ast\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\n        res = 0\n        n = len(points)\n        for i in range(n):\n            for j in range(i + 1, n):\n                for k in range(j + 1, n):\n                    x1, y1 = points[i]\n                    x2, y2 = points[j]\n                    x3, y3 = points[k]\n                    area = 0.5 * abs(x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2))\n                    res = max(res, area)\n        return res\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        num_points = random.randint(3, 50)\n        points = [[random.randint(-50, 50), random.randint(-50, 50)] for _ in range(num_points)]\n        points = list(map(list, set(map(tuple, points))))\n        return {'points': points}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['points'])\n\n    def encode_output(self, output_obj) -> str:\n        return f'{output_obj:.5f}'\n\n    def decode_input(self, input_str) -> dict:\n        return {'points': ast.literal_eval(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.largestTriangleArea(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.146",
            "memory": 5324,
            "stderr": null,
            "token": "f8c62905-adfe-4717-a510-dbc14c67c1be",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 861,
        "title": "flipping-an-image",
        "token": "9aabf30b-0b9d-4ff5-80fc-a58711c839f9",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\n        for row in image:\n            for i in range((len(row) + 1) // 2):\n                row[i], row[len(row) - 1 - i] = (row[len(row) - 1 - i] ^ 1), (row[i] ^ 1)\n                if i == len(row) - 1 - i:\n                    row[i] = row[i]\n                \n        return image\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 5)\n        image = [[random.choice([0, 1]) for _ in range(n)] for _ in range(n)]\n        return {'image': image}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['image'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'image': eval(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.flipAndInvertImage(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.062",
            "memory": 4784,
            "stderr": null,
            "token": "9aabf30b-0b9d-4ff5-80fc-a58711c839f9",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 741,
        "title": "cherry-pickup",
        "token": "6938df44-8be8-4d35-be7d-70b3fe3cac2d",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\nimport json\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def cherryPickup(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        dp = [[-float('inf')] * n for _ in range(n)]\n        dp[0][0] = grid[0][0]\n\n        for k in range(1, 2 * n - 1):\n            new_dp = [[-float('inf')] * n for _ in range(n)]\n            for x1 in range(max(0, k - (n - 1)), min(n, k + 1)):\n                for x2 in range(max(0, k - (n - 1)), min(n, k + 1)):\n                    y1, y2 = k - x1, k - x2\n                    if grid[x1][y1] == -1 or grid[x2][y2] == -1:\n                        continue\n\n                    best = -float('inf')\n                    for d1 in [0, 1]:\n                        for d2 in [0, 1]:\n                            px1, px2 = x1 - d1, x2 - d2\n                            if px1 >= 0 and px2 >= 0:\n                                best = max(best, dp[px1][px2])\n\n                    if best == -float('inf'):\n                        continue\n                    \n                    new_dp[x1][x2] = best + grid[x1][y1]\n                    if x1 != x2:\n                        new_dp[x1][x2] += grid[x2][y2]\n            dp = new_dp\n\n        return max(0, dp[n-1][n-1])\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 6)\n        grid = [[random.choice([0, 1, -1]) for _ in range(n)] for _ in range(n)]\n        grid[0][0] = random.choice([0, 1])\n        grid[n - 1][n - 1] = random.choice([0, 1])\n        for i in range(n):\n            grid[i][0] = random.choice([0, 1])\n        for j in range(n):\n            grid[n - 1][j] = random.choice([0, 1])\n        return {'grid': grid}\n\n    def encode_input(self, input_obj) -> str:\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return json.loads(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.cherryPickup(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.068",
            "memory": 4876,
            "stderr": null,
            "token": "6938df44-8be8-4d35-be7d-70b3fe3cac2d",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 750,
        "title": "contain-virus",
        "token": "f0de5eef-51a5-4aa9-994d-e0acd3bf91f2",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def containVirus(self, mat: List[List[int]]) -> int:\n        m, n = len(mat), len(mat[0])\n        DIRECTIONS = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        \n        def get_regions():\n            visited = set()\n            regions = []\n            for i in range(m):\n                for j in range(n):\n                    if mat[i][j] == 1 and (i, j) not in visited:\n                        infected = set()\n                        walls = 0\n                        queue = [(i, j)]\n                        visited.add((i, j))\n                        \n                        region_cells = set()\n\n                        while queue:\n                            r, c = queue.pop(0)\n                            region_cells.add((r, c))\n\n                            for dx, dy in DIRECTIONS:\n                                nr, nc = r + dx, c + dy\n                                if 0 <= nr < m and 0 <= nc < n:\n                                    if mat[nr][nc] == 1 and (nr, nc) not in visited:\n                                        queue.append((nr, nc))\n                                        visited.add((nr, nc))\n                                    elif mat[nr][nc] == 0:\n                                        infected.add((nr, nc))\n                                        walls += 1\n\n                        if infected:\n                            regions.append((infected, walls, region_cells))\n            return regions\n\n        def quarantine(region_cells):\n            for r, c in region_cells:\n                mat[r][c] = 2\n\n        def infect(infected_regions):\n            for region in infected_regions:\n                for r, c in region:\n                    mat[r][c] = 1\n        \n        ans = 0\n        while True:\n            regions = get_regions()\n            \n            if not regions:\n                break\n            \n            regions.sort(key=lambda x: -len(x[0]))\n            \n            max_infected, max_walls, max_region_cells = regions[0]\n            ans += max_walls\n            quarantine(max_region_cells)\n\n            infected_regions = []\n            for infected, _, region_cells in regions[1:]:\n                infected_regions.append(infected)\n            \n            infect(infected_regions)\n        \n        return ans\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        m = random.randint(1, 50)\n        n = random.randint(1, 50)\n        isInfected = [[random.choice([0, 1]) for _ in range(n)] for _ in range(m)]\n        return {'isInfected': isInfected}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.containVirus(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.057",
            "memory": 5492,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 161, in <module>\n    runner.run()\n  File \"script.py\", line 145, in run\n    output = self.solution.containVirus(**input)\nTypeError: containVirus() got an unexpected keyword argument 'isInfected'\n",
            "token": "f0de5eef-51a5-4aa9-994d-e0acd3bf91f2",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "success",
        "question_id": 699,
        "title": "falling-squares",
        "token": "2fe63a9d-c81e-4ef4-8376-4fe3b17eab0b",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom bisect import bisect_right, bisect_left\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Node:\n    def __init__(self, l, r):\n        self.l = l\n        self.r = r\n        self.mid = (l + r) // 2\n        self.v = 0\n        self.add = 0\n        self.left = None\n        self.right = None\n\nclass SegmentTree:\n    def __init__(self):\n        self.root = Node(1, int(1e9))\n\n    def modify(self, l, r, v):\n        stack = [(self.root, l, r)]\n        while stack:\n            node, start, end = stack.pop()\n            if start > end:\n                continue\n            if node.l >= start and node.r <= end:\n                node.v = v\n                node.add = v\n                continue\n            self.pushdown(node)\n            if start <= node.mid:\n                stack.append((node.left, start, min(end, node.mid)))\n            if end > node.mid:\n                stack.append((node.right, max(start, node.mid + 1), end))\n            self.pushup(node)\n\n    def query(self, l, r):\n        stack = [(self.root, l, r)]\n        max_height = 0\n        while stack:\n            node, start, end = stack.pop()\n            if start > end:\n                continue\n            if node.l >= start and node.r <= end:\n                max_height = max(max_height, node.v)\n                continue\n            self.pushdown(node)\n            if start <= node.mid:\n                stack.append((node.left, start, min(end, node.mid)))\n            if end > node.mid:\n                stack.append((node.right, max(start, node.mid + 1), end))\n        return max_height\n\n    def pushup(self, node):\n        if node.left and node.right:\n            node.v = max(node.left.v, node.right.v)\n\n    def pushdown(self, node):\n        if node.left is None:\n            node.left = Node(node.l, node.mid)\n        if node.right is None:\n            node.right = Node(node.mid + 1, node.r)\n        if node.add != 0:\n            node.left.add = node.add\n            node.right.add = node.add\n            node.left.v = node.add\n            node.right.v = node.add\n            node.add = 0\n\nclass Solution:\n    def fallingSquares(self, positions):\n        ans = []\n        tree = SegmentTree()\n        mx = 0\n        for pos in positions:\n            l, w = pos\n            r = l + w - 1\n            h = tree.query(l, r) + w\n            mx = max(mx, h)\n            ans.append(mx)\n            tree.modify(l, r, h)\n        return ans\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 10)\n        positions = [[random.randint(1, 100), random.randint(1, 10)] for _ in range(n)]\n        return {'positions': positions}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['positions'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'positions': eval(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.fallingSquares(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Input {'positions': [[2, 2], [97, 3], [99, 3], [61, 2], [70, 6]]}\nExpected Output:  [2, 3, 6, 6, 6]\nActual Output:  [2, 3, 3, 3, 6]\n5 Test Failed!\n",
            "time": "0.056",
            "memory": 4920,
            "stderr": null,
            "token": "2fe63a9d-c81e-4ef4-8376-4fe3b17eab0b",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 4,
                "description": "Wrong Answer"
            }
        }
    },
    {
        "status": "success",
        "question_id": 779,
        "title": "max-chunks-to-make-sorted-ii",
        "token": "d6224315-954e-401d-83ba-2c74532f6ed4",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\nimport json\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        ans = 0\n        max_seen = 0\n        for i, num in enumerate(arr):\n            max_seen = max(max_seen, num)\n            if max_seen == i:\n                ans += 1\n        return ans\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(1, 10)\n        arr = [random.randint(0, 100) for _ in range(length)]\n        return {'arr': arr}\n\n    def encode_input(self, input_obj) -> str:\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return json.loads(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.maxChunksToSorted(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Input {'arr': [58, 9]}\nExpected Output:  1\nActual Output:  0\n1 Test Failed!\n",
            "time": "0.057",
            "memory": 4804,
            "stderr": null,
            "token": "d6224315-954e-401d-83ba-2c74532f6ed4",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 4,
                "description": "Wrong Answer"
            }
        }
    },
    {
        "status": "success",
        "question_id": 759,
        "title": "set-intersection-size-at-least-two",
        "token": "6ba7b39f-02be-4d63-9ab7-8b97eb96a71f",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List, Dict\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def intersectionSizeTwo(self, intervals: List[List[int]]) -> int:\n        intervals.sort(key=lambda x: x[1])\n        res = []\n        for interval in intervals:\n            s, e = interval\n            needed = 0\n            for x in res:\n                if s <= x <= e:\n                    needed += 1\n            if needed == 2:\n                continue\n            elif needed == 1:\n                val = e\n                if val not in res:\n                    res.append(val)\n            else:\n                val1 = e - 1\n                val2 = e\n                if val1 > val2:\n                  val1, val2 = val2, val1\n                if val2 not in res:\n                  res.append(val2)\n                if val1 not in res:\n                  res.append(val1)\n        return len(res)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> Dict[str, List[List[int]]]:\n        return {'intervals': [[1, 3], [3, 7], [8, 9]]}\n\n    def encode_input(self, input_obj: Dict[str, List[List[int]]]) -> str:\n        return str(input_obj['intervals'])\n\n    def encode_output(self, output_obj: int) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str: str) -> Dict[str, List[List[int]]]:\n        return {'intervals': eval(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.intersectionSizeTwo(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.058",
            "memory": 4692,
            "stderr": null,
            "token": "6ba7b39f-02be-4d63-9ab7-8b97eb96a71f",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 854,
        "title": "making-a-large-island",
        "token": "44cb7bbd-4b77-4a86-a95c-e92cdcf67195",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List, Dict, Any\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def largestIsland(self, grid: List[List[int]]) -> int:\n        \n        directions = {(-1, 0), (1, 0), (0, -1), (0, 1)}\n        \n        def findAndSetArea(row, col, island_id):\n            stack = [(row, col)]\n            area = 0\n            grid[row][col] = island_id\n            while stack:\n                r, c = stack.pop()\n                area += 1\n\n                for dr, dc in directions:\n                    nr, nc = r + dr, c + dc\n                    if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and grid[nr][nc] == 1:\n                        grid[nr][nc] = island_id\n                        stack.append((nr, nc))\n            return area\n\n        island_id = 2 \n        island_sizes = {}\n        for r in range(len(grid)):\n            for c in range(len(grid[0])):\n                if grid[r][c] == 1:\n                    area = findAndSetArea(r, c, island_id)\n                    island_sizes[island_id] = area\n                    island_id += 1\n\n        max_area = 0\n        for size in island_sizes.values():\n            max_area = max(max_area, size)\n        \n        for r in range(len(grid)):\n            for c in range(len(grid[0])):\n                if grid[r][c] == 0:\n                    neighboring_islands = set()\n                    for dr, dc in directions:\n                        nr, nc = r + dr, c + dc\n                        if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and grid[nr][nc] > 1:\n                            neighboring_islands.add(grid[nr][nc])\n                    \n                    area_with_this_0 = 1\n                    for island in neighboring_islands:\n                        area_with_this_0 += island_sizes[island]\n                    max_area = max(max_area, area_with_this_0)\n\n        return max_area\n\nclass TestCaseGenerator:\n\n    def generate(self) -> Dict[str, Any]:\n        grid_variants = [[[1, 0], [0, 1]], [[1, 1], [1, 0]], [[1, 1], [1, 1]], [[0, 0, 1], [0, 1, 0], [0, 0, 0]], [[1]], [[0]]]\n        grid = random.choice(grid_variants)\n        return {'grid': grid}\n\n    def encode_input(self, input_obj: Dict[str, Any]) -> str:\n        return str(input_obj['grid'])\n\n    def encode_output(self, output_obj: int) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str: str) -> Dict[str, List[List[int]]]:\n        import ast\n        return {'grid': ast.literal_eval(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.largestIsland(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.06",
            "memory": 5156,
            "stderr": null,
            "token": "44cb7bbd-4b77-4a86-a95c-e92cdcf67195",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 855,
        "title": "count-unique-characters-of-all-substrings-of-a-given-string",
        "token": "e0f8c866-217b-4f8c-87b7-07ff3ebcd67e",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nimport collections\n\nclass Solution:\n    def uniqueLetterString(self, s: str) -> int:\n        index = collections.defaultdict(list)\n        for i, c in enumerate(s):\n            index[c].append(i)\n        ans = 0\n        for c in index:\n            arr = index[c]\n            for i in range(len(arr)):\n                prev = arr[i - 1] if i > 0 else -1\n                nxt = arr[i + 1] if i < len(arr) - 1 else len(s)\n                ans += (arr[i] - prev) * (nxt - arr[i])\n        return ans\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(1, 10 ** 5)\n        s = ''.join(random.choices('ABCDEFGHIJKLMNOPQRSTUVWXYZ', k=length))\n        return {'s': s}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['s']\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.uniqueLetterString(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.467",
            "memory": 17456,
            "stderr": null,
            "token": "e0f8c866-217b-4f8c-87b7-07ff3ebcd67e",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 856,
        "title": "consecutive-numbers-sum",
        "token": "650ee234-bccd-4d71-94e9-b28682c849a7",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport json \n\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def consecutiveNumbersSum(self, n: int) -> int:\n        w = 0\n        k = 1\n        while k * (k + 1) / 2 <= n:\n            if (n - k * (k - 1) / 2) % k == 0:\n                w += 1\n            k += 1\n\n        return w\n\nclass TestCaseGenerator:\n\n    def __init__(self):\n        pass\n\n    def generate(self) -> dict:\n        n = random.randint(1, 1000)\n        return {'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return '{\"n\": %d}' % input_obj['n']\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        from json import loads\n        return loads(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.consecutiveNumbersSum(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.05",
            "memory": 4812,
            "stderr": null,
            "token": "650ee234-bccd-4d71-94e9-b28682c849a7",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "failure",
        "question_id": 552,
        "title": "student-attendance-record-ii",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "success",
        "question_id": 939,
        "title": "valid-permutations-for-di-sequence",
        "token": "9a137e5f-ec9e-4a0d-8350-3a3531741ea0",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport hashlib\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nfrom collections import defaultdict\n\nclass Solution:\n    def numPermsDISequence(self, s: str) -> int:\n        n = len(s)\n        MOD = 10**9 + 7\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        dp[0][0] = 1\n\n        for i in range(1, n + 1):\n            new_dp = [[0] * (n + 1) for _ in range(n + 1)]\n            prefix_sum = 0\n            if s[i - 1] == 'D':\n                for j in range(n, -1, -1):\n                    prefix_sum = (prefix_sum + dp[i - 1][j]) % MOD\n                    new_dp[i][j] = prefix_sum\n            else:\n                for j in range(0, n + 1):\n                    prefix_sum = (prefix_sum + dp[i - 1][j]) % MOD\n                    new_dp[i][j] = prefix_sum\n                new_dp[i] = new_dp[i][::-1]\n\n            dp = new_dp\n\n        return sum(dp[n]) % MOD\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(1, 200)\n        pattern = ''.join((random.choice('DI') for _ in range(length)))\n        return {'s': pattern}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['s']\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\n    def decode_output(self, output_str) -> int:\n        return int(output_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.numPermsDISequence(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Input {'s': 'DDDIIDIIIIDIDIDIIIDIDDIIIDDDDIIIDDIIIIDDIDIIDIIIIIDDIIDIIDIIDIIIIDIIDIDIIIDIIIDIIIIIDDIDIIIDIDIDDIDIIDIDDIIDIIDDDDIDIIIID'}\nExpected Output:  []\nActual Output:  717564046\n1 Test Failed!\n",
            "time": "0.071",
            "memory": 6512,
            "stderr": null,
            "token": "9a137e5f-ec9e-4a0d-8350-3a3531741ea0",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 4,
                "description": "Wrong Answer"
            }
        }
    }
]