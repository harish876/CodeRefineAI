[
    {
        "status": "success",
        "question_id": 131,
        "title": "palindrome-partitioning",
        "token": "9925c6b7-83ca-4df2-8cbc-d653d115165e",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\nimport string\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        res = []\n\n        def backtrack(i,curr):\n            if i==len(s):\n                res.append(curr[:])\n            \n            for j in range(i,len(s)):\n                if s[i:j+1]==s[i:j+1][::-1]:\n                    curr.append(s[i:j+1])\n                    backtrack(j+1,curr)\n                    curr.pop()\n\n        backtrack(0,[])\n        return res\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(1, 16)\n        s = ''.join((random.choice(string.ascii_lowercase) for _ in range(length)))\n        return {'s': s}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['s']\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.partition(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.057",
            "memory": 6708,
            "stderr": null,
            "token": "9925c6b7-83ca-4df2-8cbc-d653d115165e",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 132,
        "title": "palindrome-partitioning-ii",
        "token": "c51a9247-73bc-4236-9ca3-e931ec285e1f",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport json\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def minCut(self, s: str) -> int:\n        def is_palindrome(s):\n            return s == s[::-1]\n        \n        @lru_cache(None)\n        def f(s):\n            if not s or len(s) == 1 or is_palindrome(s):\n                return 0\n\n            min_ = float('inf')\n\n\n                \n            for j in range(len(s)):\n                if is_palindrome(s[:j+1]):\n                    min_ = min(min_, 1 + f(s[j+1:]))\n            return min_\n\n        return f(s)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        \"\"\"\n        Generates a test case input containing a random string `s` of length between 1 and 10.\n        This ensures we have a reasonable range for testing without excessive computation time.\n        \"\"\"\n        min_length = 1\n        max_length = 10\n        length = random.randint(min_length, max_length)\n        s = ''.join(random.choices('abcdefghijklmnopqrstuvwxyz', k=length))\n        return {'s': s}\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\"\n        Encodes the test case input into a JSON string.\n        \"\"\"\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\"\n        Encodes the test case output, which is an integer, to a string.\n        \"\"\"\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\"\n        Decodes a JSON string into a dictionary representing the test case input.\n        \"\"\"\n        return json.loads(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.minCut(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.057",
            "memory": 5260,
            "stderr": null,
            "token": "c51a9247-73bc-4236-9ca3-e931ec285e1f",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 135,
        "title": "candy",
        "token": "0ce43427-936d-4fce-921f-cfb3ee1bac6b",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def candy(self, ratings: List[int]) -> int:\n        n=len(ratings)\n        sortedArr=[(ratings[i],i) for i in range(n)]\n        sortedArr.sort()\n        ans=[0]*n\n        for i in range(n):\n            curCandies=1\n            val,index=sortedArr[i]\n            if (index>0 and ratings[index-1]<ratings[index] and ans[index-1]>=curCandies):\n                curCandies=ans[index-1]+1\n            if (index<n-1 and ratings[index+1]<ratings[index] and ans[index+1]>=curCandies):\n                curCandies=ans[index+1]+1\n            ans[index]=curCandies\n        return sum(ans)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        test_case_1 = {'ratings': [1, 0, 2]}\n        test_case_2 = {'ratings': [1, 2, 2]}\n        test_case_3 = {'ratings': [3, 2, 1]}\n        test_case_4 = {'ratings': [1, 3, 4, 5, 2]}\n        test_case_5 = {'ratings': [1, 2, 87, 87, 87, 2, 1]}\n        return random.choice([test_case_1, test_case_2, test_case_3, test_case_4, test_case_5])\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.candy(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.068",
            "memory": 5124,
            "stderr": null,
            "token": "0ce43427-936d-4fce-921f-cfb3ee1bac6b",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 137,
        "title": "single-number-ii",
        "token": "619308c0-da4f-4335-9c9a-191d0efcd2e6",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        ln=len(nums)\n        if ln<999999:\n                while(1):\n                    val = nums[-1]\n                    nums.pop()\n                    if val in nums:\n                        nums.insert(0,val)\n                    else:\n                        return val\n        else:\n            dicto={}\n            for i in nums:\n                if i in dicto.keys():\n                    dicto[i]+=1\n                else:\n                    dicto[i]=1\n            mini=min(dicto.values())\n            for i in dicto.items():\n                if i[1]==mini:\n                    return i[0]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        \"\"\"\n        Generate a sample test case input where elements \n        appear three times except one. This will return \n        a dictionary with one element `nums` containing \n        a list.\n        \"\"\"\n        nums = [2, 2, 2, 3, 4, 4, 4, 5, 5, 5, 6]\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\"\n        Convert a test case input into a string.\n        This typically involves converting the list into a string format.\n        \"\"\"\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\"\n        Since the expected output is an integer, simply convert it to string.\n        This will help in returning a stringified version of the integer result.\n        \"\"\"\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\"\n        Given the input string, convert it back to a dictionary with key `nums`.\n        Warning: eval() is used here for simplicity; in production, safer alternatives\n        should be used to parse the input format to avoid code injection vulnerabilities.\n        \"\"\"\n        nums = eval(input_str)\n        return {'nums': nums}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.singleNumber(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Input {'nums': [2, 2, 2, 3, 4, 4, 4, 5, 5, 5]}\nExpected Output:  3\nActual Output:  6\n1 Test Failed!\n",
            "time": "0.064",
            "memory": 4712,
            "stderr": null,
            "token": "619308c0-da4f-4335-9c9a-191d0efcd2e6",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 4,
                "description": "Wrong Answer"
            }
        }
    },
    {
        "status": "success",
        "question_id": 138,
        "title": "copy-list-with-random-pointer",
        "token": "16f98b70-a5c1-4b17-901a-b4c31966683e",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import Optional\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\n\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        old_to_new = {None:None}\n        \n        old = head\n        while old:\n            new = Node(old.val)\n            old_to_new[old] = new\n            old = old.next\n        \n        old = head\n        while old:\n            new = old_to_new[old]\n            new.next = old_to_new[old.next]\n            new.random = old_to_new[old.random]\n            old = old.next\n        \n        return old_to_new[head]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        nodes = [{'val': 7, 'random_index': None}, {'val': 13, 'random_index': 0}, {'val': 11, 'random_index': 4}, {'val': 10, 'random_index': 2}, {'val': 1, 'random_index': 0}]\n        head = self.build_linked_list(nodes)\n        return {'head': head}\n\n    def build_linked_list(self, node_info):\n        if not node_info:\n            return None\n        nodes = [Node(info['val']) for info in node_info]\n        for i in range(len(nodes) - 1):\n            nodes[i].next = nodes[i + 1]\n        for i, info in enumerate(node_info):\n            if info['random_index'] is not None:\n                nodes[i].random = nodes[info['random_index']]\n        return nodes[0]\n\n    def encode_input(self, input_obj) -> str:\n        return str(self.linked_list_to_array(input_obj['head']))\n\n    def encode_output(self, output_obj) -> str:\n        if not output_obj:\n            return str([])\n        return str(self.linked_list_to_array(output_obj))\n\n    def decode_input(self, input_str) -> dict:\n        data = eval(input_str)\n        return {'head': self.build_linked_list(data)}\n\n    def linked_list_to_array(self, head: 'Node') -> list:\n        if not head:\n            return []\n        nodes = []\n        current = head\n        while current:\n            random_index = None\n            if current.random is not None:\n                random_index = self.find_index(head, current.random)\n            nodes.append({'val': current.val, 'random_index': random_index})\n            current = current.next\n        return nodes\n\n    def find_index(self, head: 'Node', node: 'Node') -> int:\n        current, index = (head, 0)\n        while current:\n            if current == node:\n                return index\n            current = current.next\n            index += 1\n        return -1\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.copyRandomList(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.06",
            "memory": 5404,
            "stderr": null,
            "token": "16f98b70-a5c1-4b17-901a-b4c31966683e",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 140,
        "title": "word-break-ii",
        "token": "145f7dac-ce16-498a-8f60-ed40ba20260c",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\n        # Time complexity: O(n\u22c52^n)\n        # Space complexity: O(2^n)\n\n        wordDict = set(wordDict)\n\n        # curr_i is where to continue iteration, stop_i is if > i then eating into next word, don't take\n        output = []\n\n        @lru_cache(None)\n        def dfs(curr_i, stop_i, word_str):\n            if stop_i == 0:\n                output.append(word_str[:-1])\n            elif curr_i < 0 or curr_i < 0:\n                return\n\n            for i in range(curr_i, -1, -1):\n                if s[i: stop_i] in wordDict:\n                    # Use a set instead of a dictionary, we can do look up of the word instead of looping through the word dic each time\n                    dfs(i - 1, i, s[i: stop_i] + \" \" + word_str)\n        \n        dfs(len(s)-1, len(s), \"\")\n        return output\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        test_cases = [{'s': 'catsanddog', 'wordDict': ['cat', 'cats', 'and', 'sand', 'dog']}, {'s': 'pineapplepenapple', 'wordDict': ['apple', 'pen', 'applepen', 'pine', 'pineapple']}, {'s': 'catsandog', 'wordDict': ['cats', 'dog', 'sand', 'and', 'cat']}]\n        return random.choice(test_cases)\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['s']}|{'|'.join(input_obj['wordDict'])}\"\n\n    def encode_output(self, output_obj) -> str:\n        return '|'.join(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        s, *wordDict = input_str.split('|')\n        return {'s': s, 'wordDict': wordDict}\n\n    def decode_output(self, output_str) -> list:\n        return output_str.split('|')\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.wordBreak(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Input {'s': 'catsanddog', 'wordDict': ['cat', 'cats', 'and', 'sand', 'dog']}\nExpected Output:  cat sand dog|cats and dog\nActual Output:  cats and dog|cat sand dog\n1 Test Failed!\n",
            "time": "0.052",
            "memory": 4988,
            "stderr": null,
            "token": "145f7dac-ce16-498a-8f60-ed40ba20260c",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 4,
                "description": "Wrong Answer"
            }
        }
    },
    {
        "status": "success",
        "question_id": 134,
        "title": "gas-station",
        "token": "4d08c273-ad06-475a-93d6-9f0dd9a39d46",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\n        n = len(gas)\n        total_gas = 0\n        curr_gas = 0\n        start_index = 0\n\n        for i in range(n):\n            total_gas += gas[i] - cost[i]\n            curr_gas += gas[i] - cost[i]\n\n            if curr_gas < 0:\n                curr_gas = 0\n                start_index = i + 1\n        \n        return start_index if total_gas >= 0 else -1\n            \n\n\n# Naive: iterate through gas, then check costs. if it doesnt work, move to next starting index and continue. O(n^2) time. Can we optimize? to O(n)? extra data structure?\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 10)\n        gas = [random.randint(0, 10) for _ in range(n)]\n        cost = [random.randint(0, 10) for _ in range(n)]\n        return {'gas': gas, 'cost': cost}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['gas']}|{input_obj['cost']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        gas_str, cost_str = input_str.split('|')\n        gas = list(map(int, gas_str.strip('[]').split(', ')))\n        cost = list(map(int, cost_str.strip('[]').split(', ')))\n        return {'gas': gas, 'cost': cost}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.canCompleteCircuit(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.062",
            "memory": 5248,
            "stderr": null,
            "token": "4d08c273-ad06-475a-93d6-9f0dd9a39d46",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 228,
        "title": "summary-ranges",
        "token": "df00366a-200a-499c-8949-9be84186c2bc",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def summaryRanges(self, nums: List[int]) -> List[str]:\n        result = []\n        if nums:\n            small_arr = [nums[0]]\n\n            prev = nums[0]\n            post = 0\n            for num in nums[1:]:\n                if num == prev + 1:\n                    small_arr.append(num)\n                    \n                else:\n                    if len(small_arr) == 1:\n                        result.append(str(small_arr[0]))\n                        small_arr = [num]\n                    else:\n                        result.append(f\"{small_arr[0]}->{small_arr[-1]}\")\n                        small_arr = [num]\n\n                prev = num\n\n            if len(small_arr) == 1:\n                        result.append(str(small_arr[0]))\n                       \n            else:\n                result.append(f\"{small_arr[0]}->{small_arr[-1]}\")\n             \n       \n        return result\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(0, 20)\n        nums = sorted(random.sample(range(-100, 100), length))\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'nums': eval(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.summaryRanges(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.055",
            "memory": 5184,
            "stderr": null,
            "token": "df00366a-200a-499c-8949-9be84186c2bc",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 229,
        "title": "majority-element-ii",
        "token": "6e426d71-815c-48e2-9886-f14ed88ff344",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nfrom collections import defaultdict\nimport random\nimport json\n\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def majorityElement(self, nums: List[int]) -> List[int]:\n        n1=None\n        c1=0\n        n2=None\n        c2=0\n        for num in nums:\n            if n1==None:\n                n1=num\n                c1=1\n            elif n2==None and num!=n1:\n                n2=num\n                c2=1\n            elif num==n1:\n                c1+=1\n            elif num==n2:\n                c2+=1\n            else:\n                if c1<=0:\n                    n1=num\n                    c1=1\n                elif c2<=0:\n                    n2=num\n                    c2=1\n                else:\n                    c1-=1\n                    c2-=1\n        c1=0\n        c2=0\n        for num in nums:\n            if num==n1:\n                c1+=1\n            elif num==n2:\n                c2+=1\n        ans=[]\n        if c1>len(nums)//3:\n            ans.append(n1)\n        if c2>len(nums)//3:\n            ans.append(n2)\n        return ans\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(1, 100)\n        nums = [random.randint(-10, 10) for _ in range(length)]\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return json.dumps(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return json.loads(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.majorityElement(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.053",
            "memory": 4944,
            "stderr": null,
            "token": "6e426d71-815c-48e2-9886-f14ed88ff344",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 230,
        "title": "kth-smallest-element-in-a-bst",
        "token": "c5e0aec5-1c61-4e2f-aa0c-e7b1c4093c48",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import Optional\nimport json\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def helper(self, root, res):\n        if root:\n            self.helper(root.left, res)\n            res.append(root.val)\n            self.helper(root.right, res)\n        return\n\n\n    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:\n        stack = []\n        cur = root\n        while stack or cur:\n            while cur:\n                stack.append(cur)\n                cur = cur.left\n            cur = stack.pop()\n            k-=1\n            if k==0:\n                return cur.val\n            cur = cur.right\n        return -1\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        root = TreeNode(3)\n        root.left = TreeNode(1)\n        root.right = TreeNode(4)\n        root.left.right = TreeNode(2)\n        k = 1\n        return {'root': root, 'k': k}\n\n    def encode_input(self, input_obj) -> str:\n\n        def tree_to_list(node):\n            if not node:\n                return None\n            return [node.val, tree_to_list(node.left), tree_to_list(node.right)]\n        as_list = tree_to_list(input_obj['root'])\n        return json.dumps({'root': as_list, 'k': input_obj['k']})\n\n    def encode_output(self, output_obj) -> str:\n        return json.dumps({'output': output_obj})\n\n    def decode_input(self, input_str) -> dict:\n\n        def list_to_tree(lst):\n            if not lst:\n                return None\n            node = TreeNode(lst[0])\n            node.left = list_to_tree(lst[1])\n            node.right = list_to_tree(lst[2])\n            return node\n        data = json.loads(input_str)\n        return {'root': list_to_tree(data['root']), 'k': data['k']}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.kthSmallest(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.057",
            "memory": 4692,
            "stderr": null,
            "token": "c5e0aec5-1c61-4e2f-aa0c-e7b1c4093c48",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 231,
        "title": "power-of-two",
        "token": "184de52a-1476-4ab5-983d-8c1cbeffe3a5",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def isPowerOfTwo(self, n: int) -> bool:\n        return n > 0 and str(bin(n)).count('1') == 1\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        \"\"\" Generate random test cases for `isPowerOfTwo` method. \"\"\"\n        n = random.choice([1, 2, 4, 8, 16, 32, 64, 3, 5, 7, 9, 0, -1])\n        return {'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\" Convert the generate method's output into a test input string. \"\"\"\n        return str(input_obj['n'])\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\" Convert the output of the entry_point method into a test output string. \"\"\"\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\" Convert a test input string back into a Python dict for use in the entry_point method. \"\"\"\n        return {'n': int(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.isPowerOfTwo(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Input {'n': 8}\nExpected Output:  8\nActual Output:  True\n1 Test Failed!\n",
            "time": "0.075",
            "memory": 5584,
            "stderr": null,
            "token": "184de52a-1476-4ab5-983d-8c1cbeffe3a5",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 4,
                "description": "Wrong Answer"
            }
        }
    },
    {
        "status": "success",
        "question_id": 123,
        "title": "best-time-to-buy-and-sell-stock-iii",
        "token": "245ca2a5-3d80-40f8-ad1c-34f0df8475f8",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        # Tabulation\n\n        n = len(prices)\n        dp = [[[0 for _ in range(3)] for _ in range(2)] for _ in range(n + 1)]\n\n        # Base cases are already covered as the dp is initialized to 0\n      \n        for i in range(n - 1, -1, -1):\n            for j in range(2):\n                for k in range(1, 3):\n                    if j == 0:\n                        dp[i][j][k] = max(-prices[i] + dp[i + 1][1][k], 0 + dp[i + 1][0][k])\n                    else:\n                        dp[i][j][k] = max(+prices[i] + dp[i + 1][0][k - 1], 0 + dp[i + 1][1][k])\n\n        return dp[0][0][2]\n\n\n\n        # # Memoization\n\n        # n = len(prices)\n        # # Create a 3D DP table with dimentions (n * 2 * 3) and initializa it with -1\n        # dp = [[[-1 for _ in range(3)] for _ in range(2)] for _ in range(n)]\n\n        # # Recursive funtion to find the maximum profit\n        # def memoization(ind, buy, cap):\n        #     # if we have reached the end of the array or used up all transactions, return zero profit\n        #     if ind == n or cap == 0:\n        #         return 0\n\n        #     # if the result is already computed, return it\n        #     if dp[ind][buy][cap]!= -1:\n        #         return dp[ind][buy][cap]\n            \n        #     profit = 0\n\n        #     if buy == 0:\n        #         # We can buy the stock\n        #         profit = max(0 + memoization(ind + 1, 0, cap), -prices[ind] + memoization(ind + 1, 1, cap))\n        #     elif buy == 1:\n        #         # We can buy the stock\n        #         profit = max(0 + memoization(ind + 1, 1, cap), prices[ind] + memoization(ind + 1, 0, cap - 1))\n\n        #     dp[ind][buy][cap] = profit\n        #     return dp[ind][buy][cap]\n        \n        # return memoization(0, 0, 2)\n        # # TC: O(n * 2 * 3)\n        # # SC: O(n * 2 * 3) + O(n)\n\nclass TestCaseGenerator:\n    import random\n\n    def generate(self) -> dict:\n        length = self.random.randint(1, 100)\n        prices = [self.random.randint(0, 100) for _ in range(length)]\n        return {'prices': prices}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.maxProfit(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.072",
            "memory": 6008,
            "stderr": null,
            "token": "245ca2a5-3d80-40f8-ad1c-34f0df8475f8",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 125,
        "title": "valid-palindrome",
        "token": "def72754-fb90-41d2-8c89-0721b58cfb55",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport json\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def isPalindrome(self, s: str) -> bool:\n        temp = \"\"\n        for i in s:\n            if i.isalpha() or i.isalnum():\n                temp += \"\".join(i.casefold())\n\n        result = temp[::-1]\n        if result == temp:\n            return True\n        else:\n            return False\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        \"\"\"Generate random test case input for isPalindrome function.\"\"\"\n        test_cases = ['A man, a plan, a canal: Panama', 'race a car', '', ' ', 'Able was I ere I saw Elba', '!!!abcba!!!', '12321', 'No lemon, no melon', 'Step on no pets']\n        return {'s': random.choice(test_cases)}\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\"Convert a test case input into a JSON string.\"\"\"\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\"Convert a test case output into a JSON string.\"\"\"\n        return 'true' if output_obj else 'false'\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\"Convert a test case input string into a Python dict.\"\"\"\n        return json.loads(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.isPalindrome(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.058",
            "memory": 5628,
            "stderr": null,
            "token": "def72754-fb90-41d2-8c89-0721b58cfb55",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 128,
        "title": "longest-consecutive-sequence",
        "token": "2df69bc2-bb2c-4071-9b5e-564e016d1e44",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\nimport json\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def longestConsecutive(self, nums: List[int]) -> int:\n        numset = set(nums)\n        res = 0\n        for n in nums:\n            # check if n is a start of  seq\n            if (n-1) not in numset:\n                op = 0\n                while (n+op) in numset:\n                    op+=1\n                res = max(res,op)\n        return res\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(0, 100)\n        nums = random.sample(range(-10 ** 9, 10 ** 9), length)\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return json.loads(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.longestConsecutive(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.063",
            "memory": 5988,
            "stderr": null,
            "token": "2df69bc2-bb2c-4071-9b5e-564e016d1e44",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 130,
        "title": "surrounded-regions",
        "token": "4efd3685-e1ca-4432-a1fd-e1e98b4a94db",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport collections\nimport random\nfrom typing import List\nfrom ast import literal_eval\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def solve(self, board: List[List[str]]) -> None:\n        \"\"\"\n        Do not return anything, modify board in-place instead.\n        \"\"\"\n        M, N = len(board), len(board[0])\n        total_visited = set()\n        def dfs(i,j):\n            nonlocal M,N,board,total_visited\n            curr_visited = set()\n            q = [(i,j)]\n            edged = False\n            while q:\n                curr = q.pop()\n                curr_visited.add(curr)\n                for di in [(-1,0), (1,0), (0,1), (0,-1)]:\n                    new_i, new_j = curr[0]+di[0], curr[1]+di[1]\n                    if new_i >= 0 and new_i < M and new_j >= 0 and new_j < N:\n                        if board[new_i][new_j] == 'O' and (new_i, new_j) not in curr_visited:\n                            q.append((new_i, new_j))\n                    else:\n                        edged = True\n            total_visited.update(curr_visited)\n            if edged:\n                return\n            for i,j in curr_visited:\n                board[i][j] = 'X'\n                \n\n        for i in range(M):\n            for j in range(N):\n                if board[i][j] == 'O' and (i,j) not in total_visited:\n                    dfs(i,j)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        ...\n\n    def encode_input(self, input_obj) -> str:\n        ...\n\n    def encode_output(self, output_obj) -> str:\n        ...\n\n    def decode_input(self, input_str) -> dict:\n        ...\n\n    def decode_output(self, output_str) -> str:\n        ...\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.solve(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.059",
            "memory": 5324,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 131, in <module>\n    runner.run()\n  File \"script.py\", line 115, in run\n    output = self.solution.solve(**input)\nTypeError: solve() argument after ** must be a mapping, not NoneType\n",
            "token": "4efd3685-e1ca-4432-a1fd-e1e98b4a94db",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "success",
        "question_id": 82,
        "title": "remove-duplicates-from-sorted-list-ii",
        "token": "21af5352-bb79-4a6d-92ac-2e2d91ad6ee9",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import Optional\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        fake = ListNode(-1)\n        fake.next = head\n        prev, curr = fake, head\n        while curr:\n            while curr.next and curr.val == curr.next.val:\n                curr = curr.next\n            if prev.next == curr:\n                prev = prev.next\n                curr = curr.next\n            else:\n                prev.next = curr.next\n                curr = prev.next\n        return fake.next\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        list_values = self._create_random_sorted_list()\n        head = self._convert_list_to_linkedlist(list_values)\n        return {'head': head}\n\n    def encode_input(self, input_obj) -> str:\n        encoded_input = []\n        current = input_obj['head']\n        while current:\n            encoded_input.append(current.val)\n            current = current.next\n        return str(encoded_input)\n\n    def encode_output(self, output_obj) -> str:\n        encoded_output = []\n        current = output_obj\n        while current:\n            encoded_output.append(current.val)\n            current = current.next\n        return str(encoded_output)\n\n    def decode_input(self, input_str) -> dict:\n        node_values = eval(input_str)\n        head = self._convert_list_to_linkedlist(node_values)\n        return {'head': head}\n\n    def _create_random_sorted_list(self) -> list:\n        list_size = random.randint(0, 30)\n        values = []\n        while len(values) < list_size:\n            rand_value = random.randint(-100, 100)\n            if random.choice([True, False]):\n                values += [rand_value] * random.randint(1, 3)\n            else:\n                values.append(rand_value)\n        values = sorted(values[:300])\n        return values\n\n    def _convert_list_to_linkedlist(self, values: list) -> Optional[ListNode]:\n        if not values:\n            return None\n        head = ListNode(values[0])\n        current = head\n        for value in values[1:]:\n            current.next = ListNode(value)\n            current = current.next\n        return head\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.deleteDuplicates(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.063",
            "memory": 4892,
            "stderr": null,
            "token": "21af5352-bb79-4a6d-92ac-2e2d91ad6ee9",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 84,
        "title": "largest-rectangle-in-histogram",
        "token": "a852ff28-1f28-4e5a-ac24-61cad5ae0cfe",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def largestRectangleArea(self, heights: List[int]) -> int:\n        # OK\n        # stack = []\n        # max_area = 0\n        # heights = [0] + heights + [0]  # Add dummy bars to simplify the code\n\n        # for i in range(len(heights)):\n        #     # While the current bar is lower than the bar at the top of the stack\n        #     while stack and heights[stack[-1]] > heights[i]:\n        #         # Calculate the area of the rectangle with the bar at the top of the stack as the smallest bar\n        #         h = heights[stack.pop()]\n        #         w = i - stack[-1] - 1\n        #         max_area = max(max_area, h * w)\n        #     # Push the index of the current bar onto the stack\n        #     stack.append(i)\n\n        # return max_area\n\n        # Practice:\n        st = []\n        area = 0\n        heights = [-1] + heights + [-1]  # some low value (0 works)\n        #          ^ to reference left boundary\n        #                           ^ to process as k the last, nth element from original list\n\n        for i,a in enumerate(heights):\n            while(st and heights[st[-1]] > a):\n                rr = i\n                k = st.pop()  # pop first\n                ll = st[-1]   # stack maintains next smaller index to left (larger values already popped)\n                h = heights[k]\n                length = rr - ll - 1 \n                area = max(area, heights[k] * length)\n\n            st.append(i)\n\n        return area\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        num_bars = random.randint(1, 10)\n        heights = [random.randint(0, 10) for _ in range(num_bars)]\n        return {'heights': heights}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['heights'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        heights = eval(input_str)\n        return {'heights': heights}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.largestRectangleArea(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.06",
            "memory": 4876,
            "stderr": null,
            "token": "a852ff28-1f28-4e5a-ac24-61cad5ae0cfe",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 85,
        "title": "maximal-rectangle",
        "token": "095b4b3f-979e-4e2b-ab3a-d0b92ab96667",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\n        m, n = len(matrix), len(matrix[0])\n        dp = [[[] for _ in range(n+1)] for _ in range(m+1)]\n        MAX = 0\n        for i in range(1, m+1):\n            for j in range(1, n+1):\n                if matrix[i-1][j-1] == '1':\n                    left, top = dp[i][j-1], dp[i-1][j]\n\n                    dp[i][j].append(left[0] + 1 if len(left) > 0 else 1)\n                    MAX = max(MAX, dp[i][j][0])\n                    k = 0\n                    while k < len(top):\n                        if k < len(left) - 1:\n                            temp = min(max(left[k+1] + 1, top[k]), dp[i][j][-1])\n                        else:\n                            temp = min(top[k], dp[i][j][-1])\n                        dp[i][j].append(temp)\n                        MAX = max(MAX, temp * (k+2))   ###\n                        k += 1\n        return MAX\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        rows = random.randint(1, 20)\n        cols = random.randint(1, 20)\n        matrix = [[random.choice(['0', '1']) for _ in range(cols)] for _ in range(rows)]\n        return {'matrix': matrix}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['matrix'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        input_list = eval(input_str)\n        return {'matrix': input_list}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.maximalRectangle(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.059",
            "memory": 5088,
            "stderr": null,
            "token": "095b4b3f-979e-4e2b-ab3a-d0b92ab96667",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 87,
        "title": "scramble-string",
        "token": "af0c032b-a23e-43dd-aecd-564dd1909ddd",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport numpy as np\nimport random\nimport string\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def isScramble(self, s1: str, s2: str) -> bool:\n        n=len(s1)\n        dp=[[[False for j in range(n)]for i in range(n)]for l in \n        range(n+1)];\n        for i in range(n):\n            for j in range(n):\n                dp[1][i][j]=s1[i]==s2[j]\n        for length in range(2,n+1):\n            for i in range(n+1-length):\n                for j in range(n+1-length):\n                    for new in range(1,length):\n                        dp1=dp[new][i]\n                        dp2=dp[length-new][i+new]\n                        dp[length][i][j]|=(\n                            dp1[j] and dp2[j+new]\n                        )\n                        dp[length][i][j]|=(\n                            dp2[j] and dp1[j+length-new]\n                        )\n        return dp[n][0][0]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(1, 30)\n        s1 = ''.join(random.choices(string.ascii_lowercase, k=length))\n        s2 = self.scramble(s1)\n        return {'s1': s1, 's2': s2}\n\n    def scramble(self, s: str) -> str:\n        if len(s) == 1:\n            return s\n        i = random.randint(1, len(s) - 1)\n        x, y = (s[:i], s[i:])\n        if random.random() > 0.5:\n            return self.scramble(x) + self.scramble(y)\n        else:\n            return self.scramble(y) + self.scramble(x)\n\n    def encode_input(self, input_obj: dict) -> str:\n        return f\"{input_obj['s1']},{input_obj['s2']}\"\n\n    def encode_output(self, output_obj: bool) -> str:\n        return 'true' if output_obj else 'false'\n\n    def decode_input(self, input_str: str) -> dict:\n        s1, s2 = input_str.split(',')\n        return {'s1': s1, 's2': s2}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.isScramble(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.057",
            "memory": 4632,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 26, in <module>\n    import numpy as np\nModuleNotFoundError: No module named 'numpy'\n",
            "token": "af0c032b-a23e-43dd-aecd-564dd1909ddd",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "success",
        "question_id": 88,
        "title": "merge-sorted-array",
        "token": "31dc1d92-965b-4ced-a883-bb231368287e",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\nimport ast\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\n        \"\"\"\n        Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        p1 = m-1\n        p2 = n-1\n        p = m+n-1\n        while p2 >= 0:\n            if p1 >= 0 and nums1[p1] > nums2[p2]:\n                nums1[p] = nums1[p1]\n                p1 -= 1\n            else:\n                nums1[p] = nums2[p2]\n                p2 -= 1\n            p -= 1\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        test_cases = [{'nums1': [1, 2, 3, 0, 0, 0], 'm': 3, 'nums2': [2, 5, 6], 'n': 3}, {'nums1': [4, 5, 6, 0, 0, 0], 'm': 3, 'nums2': [1, 2, 3], 'n': 3}, {'nums1': [1], 'm': 1, 'nums2': [], 'n': 0}, {'nums1': [0], 'm': 0, 'nums2': [1], 'n': 1}, {'nums1': [1, 2, 4, 5, 6, 0, 0, 0], 'm': 5, 'nums2': [3, 7, 8], 'n': 3}]\n        return random.choice(test_cases)\n\n    def encode_input(self, input_obj) -> str:\n        return f'{input_obj}'\n\n    def encode_output(self, output_obj) -> str:\n        return f'{output_obj}'\n\n    def decode_input(self, input_str) -> dict:\n        return ast.literal_eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.merge(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.06",
            "memory": 5148,
            "stderr": null,
            "token": "31dc1d92-965b-4ced-a883-bb231368287e",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 89,
        "title": "gray-code",
        "token": "637cf3a8-5974-4621-9321-be4d5417f9e4",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def grayCode(self, n: int) -> List[int]:\n        result = []\n        if n >= 1:\n            result = [0,1]\n\n        for i in range (1, n):\n            temp = result[::-1]\n            while temp:\n                result.append(temp.pop(0)+(2**i))\n        \n        return result\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 16)\n        return {'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"n = {input_obj['n']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return f'{output_obj}'\n\n    def decode_input(self, input_str) -> dict:\n        lines = input_str.split(' = ')\n        return {'n': int(lines[1])}\n\n    def decode_output(self, output_str) -> dict:\n        output_obj = eval(output_str)\n        return output_obj\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.grayCode(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.118",
            "memory": 15944,
            "stderr": null,
            "token": "637cf3a8-5974-4621-9321-be4d5417f9e4",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 90,
        "title": "subsets-ii",
        "token": "ef445f76-e96f-4fd2-a1d7-a03ddaf5bf8a",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\n        ans=[]\n        ds=[]\n\n        def findSubsets(ind:int):\n            ans.append(ds[:])\n            for i in range(ind,len(nums)):\n                if i!= ind and nums[i] == nums[i-1]:\n                    continue\n                ds.append(nums[i])\n                findSubsets(i+1)\n                ds.pop()\n        nums.sort()\n        findSubsets(0)\n        return ans\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(1, 10)\n        nums = [random.randint(-10, 10) for _ in range(length)]\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.subsetsWithDup(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Input {'nums': [-7, 2, 4]}\nExpected Output:  [[], [-7], [2], [-7, 2], [4], [-7, 4], [2, 4], [-7, 2, 4]]\nActual Output:  [[], [-7], [-7, 2], [-7, 2, 4], [-7, 4], [2], [2, 4], [4]]\n1 Test Failed!\n",
            "time": "0.065",
            "memory": 5380,
            "stderr": null,
            "token": "ef445f76-e96f-4fd2-a1d7-a03ddaf5bf8a",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 4,
                "description": "Wrong Answer"
            }
        }
    },
    {
        "status": "success",
        "question_id": 144,
        "title": "binary-tree-preorder-traversal",
        "token": "782877b9-98d9-481f-9681-98451b6a381f",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List, Optional, Union\nimport random\n\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\ndef solve(root, ans):\n    if root is None:\n        return\n\n    ans.append(root.val)\n    solve(root.left,ans)\n    solve(root.right,ans)\nclass Solution:\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        ans = []\n        solve(root,ans)\n        return ans\n\nclass TestCaseGenerator:\n\n    class TreeNode:\n\n        def __init__(self, val=0, left=None, right=None):\n            self.val = val\n            self.left = left\n            self.right = right\n\n    def generate(self) -> dict:\n\n        def generate_random_tree(size=100):\n            if size == 0:\n                return None\n            nodes = [self.TreeNode(val=random.randint(-100, 100)) for _ in range(size)]\n            for i in range(size):\n                if 2 * i + 1 < size:\n                    nodes[i].left = nodes[2 * i + 1]\n                if 2 * i + 2 < size:\n                    nodes[i].right = nodes[2 * i + 2]\n            return nodes[0] if size > 0 else None\n        tree_size = random.randint(0, 10)\n        root = generate_random_tree(tree_size)\n        return {'root': root}\n\n    def encode_input(self, input_obj: dict) -> str:\n\n        def tree_to_list(root):\n            if not root:\n                return []\n            queue = [(root, 0)]\n            result = []\n            while queue:\n                node, index = queue.pop(0)\n                if node:\n                    if index >= len(result):\n                        result.extend([None] * (index - len(result) + 1))\n                    result[index] = node.val\n                    queue.append((node.left, 2 * index + 1))\n                    queue.append((node.right, 2 * index + 2))\n            while result and result[-1] is None:\n                result.pop()\n            return result\n        root = input_obj['root']\n        return str(tree_to_list(root))\n\n    def encode_output(self, output_obj: List[int]) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str: str) -> dict:\n\n        def list_to_tree(nodes: List[Union[int, None]]):\n            if not nodes:\n                return None\n            tree_nodes = [self.TreeNode(val=v) if v is not None else None for v in nodes]\n            for i in range(len(nodes)):\n                if tree_nodes[i] is not None:\n                    left_index = 2 * i + 1\n                    right_index = 2 * i + 2\n                    if left_index < len(tree_nodes):\n                        tree_nodes[i].left = tree_nodes[left_index]\n                    if right_index < len(tree_nodes):\n                        tree_nodes[i].right = tree_nodes[right_index]\n            return tree_nodes[0] if tree_nodes else None\n        nodes_list = eval(input_str)\n        root = list_to_tree(nodes_list)\n        return {'root': root}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.preorderTraversal(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.064",
            "memory": 4924,
            "stderr": null,
            "token": "782877b9-98d9-481f-9681-98451b6a381f",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 148,
        "title": "sort-list",
        "token": "8f0c064b-3a1f-4ead-a612-871aa35759d8",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import Optional\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        def merge(head1, head2):\n            resultHead = ListNode(0)\n            cur = resultHead\n            while head1!= None or head2!= None:\n                if head1 == None:\n                    cur.next = head2\n                    head2 = None\n                elif head2 == None:\n                    cur.next = head1\n                    head1 = None\n                else:\n                    if head1.val < head2.val:\n                        cur.next = head1\n                        cur = head1\n                        head1 = head1.next \n                    else:\n                        cur.next = head2\n                        cur = head2\n                        head2 = head2.next\n            \n            return resultHead.next\n\n\n        def findOneBeforeMiddle(head):\n            fast = head\n            slow = head\n            prev = None\n            while fast and fast.next:\n                prev = slow\n\n                fast = fast.next.next\n                slow = slow.next\n                \n            return prev\n        \n        if not head or not head.next:\n            return head\n\n        prev = findOneBeforeMiddle(head)\n        if prev!= None:\n            middle = prev.next\n            prev.next = None\n\n        return merge(self.sortList(head), self.sortList(middle))\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        ...\n\n    def encode_input(self, input_obj) -> str:\n        ...\n\n    def encode_output(self, output_obj) -> str:\n        ...\n\n    def decode_input(self, input_str) -> dict:\n        ...\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.sortList(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.058",
            "memory": 4824,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 144, in <module>\n    runner.run()\n  File \"script.py\", line 128, in run\n    output = self.solution.sortList(**input)\nTypeError: sortList() argument after ** must be a mapping, not NoneType\n",
            "token": "8f0c064b-3a1f-4ead-a612-871aa35759d8",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "success",
        "question_id": 149,
        "title": "max-points-on-a-line",
        "token": "dee0e425-7d1c-4af9-aa32-795e93135050",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nfrom collections import defaultdict\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n\n    def num(self, points, p1, p2):\n        v = [p2[0]-p1[0], p2[1]-p1[1]]\n        n = [v[1], -v[0]]\n        C = p2[0]*p1[1]-p1[0]*p2[1]\n        count = 0\n        for p in points:\n            sum_v = n[0]*p[0] + n[1]*p[1] + C\n\n            if sum_v == 0:\n                count += 1\n        return count\n\n\n    def maxPoints(self, points: List[List[int]]) -> int:\n    \n        n = len(points)\n        if n == 1:\n            return 1\n        max_num = 0\n        d = {}\n        for i in range(n):\n            for j in range(i+1,n):\n                if (i,j) in d or (j,i) in d:\n                    continue\n                max_num = max(max_num, self.num(points, points[i], points[j]))\n                d[(i,j)] = max_num\n        return max_num\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        simple_line = [[1, 1], [2, 2], [3, 3]]\n        mixed_points = [[1, 1], [3, 2], [5, 3], [4, 1], [2, 3], [1, 4]]\n        single_point = [[0, 0]]\n        return {'points': simple_line}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['points'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'points': eval(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.maxPoints(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.063",
            "memory": 4756,
            "stderr": null,
            "token": "dee0e425-7d1c-4af9-aa32-795e93135050",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 150,
        "title": "evaluate-reverse-polish-notation",
        "token": "150fd150-570a-4fed-b44d-9a7de5775425",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport operator as op\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def evalRPN(self, tokens):\n        operators = ['+', '-', '*', '/']\n        stack = []\n        for i in tokens:\n            if i not in operators:\n                stack.append(i)\n            else:\n                operation = stack.pop(-2) + i + stack.pop()\n                stack.append(str(int(eval(operation))))\n        return int(stack[0])\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        operators = ['+', '-', '*', '/']\n        expressions = [('2', '1', '+', '3', '*'), ('4', '13', '5', '/', '+'), ('10', '6', '9', '3', '+', '-11', '*', '/', '*', '17', '+', '5', '+')]\n        selected_expr = random.choice(expressions)\n        return {'tokens': list(selected_expr)}\n\n    def encode_input(self, input_obj) -> str:\n        return ','.join(input_obj['tokens'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        tokens = input_str.split(',')\n        return {'tokens': tokens}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.evalRPN(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.053",
            "memory": 4760,
            "stderr": null,
            "token": "150fd150-570a-4fed-b44d-9a7de5775425",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 153,
        "title": "find-minimum-in-rotated-sorted-array",
        "token": "a0d4df59-2f0b-4c8b-b22d-4eb30d46b16b",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom random import randint, shuffle\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def findMin(self, arr: List[int]) -> int:\n        n = len(arr)\n        l = 0\n        h = n - 1\n        ans = float('inf')\n\n        while l <= h:\n            m = (l + h) // 2\n\n            if arr[l] <= arr[h]:\n                ans = min(arr[l], ans)\n                break\n\n            if arr[l] <= arr[m]:\n                ans = min (ans, arr[l])\n                l = m + 1\n            else:\n                ans = min(ans, arr[m])\n                h = m - 1\n        return ans\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = randint(2, 100)\n        sorted_array = sorted((randint(-5000, 5000) for _ in range(n)))\n        k = randint(1, n)\n        rotated_array = sorted_array[-k:] + sorted_array[:-k]\n        return {'nums': rotated_array}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'nums': eval(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.findMin(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.065",
            "memory": 4900,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 118, in <module>\n    runner.run()\n  File \"script.py\", line 102, in run\n    output = self.solution.findMin(**input)\nTypeError: findMin() got an unexpected keyword argument 'nums'\n",
            "token": "a0d4df59-2f0b-4c8b-b22d-4eb30d46b16b",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "success",
        "question_id": 160,
        "title": "intersection-of-two-linked-lists",
        "token": "888ee655-b6cd-4dde-a012-bd9de073df9c",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import Optional\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        pA=headA\n        pB=headB\n        while pA!=pB:\n            pA=pA.next if pA else headB\n            pB=pB.next if pB else headA\n        return pA\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        \"\"\"\n        Generates a test case with an intersection in the linked list.\n        Returns a dictionary containing two linked list heads: headA and headB.\n        \"\"\"\n        common = ListNode(8)\n        common.next = ListNode(4)\n        common.next.next = ListNode(5)\n        listA = ListNode(4)\n        listA.next = ListNode(1)\n        listA.next.next = common\n        listB = ListNode(5)\n        listB.next = ListNode(6)\n        listB.next.next = ListNode(1)\n        listB.next.next.next = common\n        headA = listA\n        headB = listB\n        return {'headA': headA, 'headB': headB}\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\"\n        Encodes the length of both linked lists into a string.\n        \"\"\"\n        lengthA, lengthB = (0, 0)\n        currentA, currentB = (input_obj['headA'], input_obj['headB'])\n        while currentA:\n            lengthA += 1\n            currentA = currentA.next\n        while currentB:\n            lengthB += 1\n            currentB = currentB.next\n        return f'LENGTHS: A={lengthA}, B={lengthB}'\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\"\n        Returns the value of the intersecting node, or \"No Intersection\" if there isn\u2019t one.\n        \"\"\"\n        if output_obj:\n            return str(output_obj.val)\n        return 'No Intersection'\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\"\n        Decodes input (statically in our case) to provide test case linked lists.\n        \"\"\"\n        example_listA = [4, 1, 8, 4, 5]\n        example_listB = [5, 6, 1, 8, 4, 5]\n        headA, headB = (self._create_linked_list(example_listA), self._create_linked_list(example_listB))\n        return {'headA': headA, 'headB': headB}\n\n    def _create_linked_list(self, values):\n        \"\"\"\n        Helper method to create a linked list from a list of values.\n        \"\"\"\n        if not values:\n            return None\n        head = ListNode(values[0])\n        current = head\n        for val in values[1:]:\n            current.next = ListNode(val)\n            current = current.next\n        return head\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.getIntersectionNode(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.059",
            "memory": 4748,
            "stderr": null,
            "token": "888ee655-b6cd-4dde-a012-bd9de073df9c",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 238,
        "title": "product-of-array-except-self",
        "token": "d4db0e51-50ee-46ad-b35f-0ca1dfd38959",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nfrom random import randint\nimport ast\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        res = [1] * len(nums)\n\n        prefix = 1\n        for i in range(len(nums)):\n            res[i] = prefix\n            prefix *= nums[i]\n\n        postfix = 1\n        for i in range(len(nums) -1, -1, -1):\n            res[i] *= postfix\n            postfix *= nums[i]\n        return res\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = randint(2, 10)\n        nums = [randint(-30, 30) for _ in range(length)]\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return ast.literal_eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.productExceptSelf(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.055",
            "memory": 5140,
            "stderr": null,
            "token": "d4db0e51-50ee-46ad-b35f-0ca1dfd38959",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 239,
        "title": "sliding-window-maximum",
        "token": "6ad66516-b325-40b5-9499-e9c7d2b42b44",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport heapq\nimport random\nimport json\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nfrom collections import deque\nimport heapq\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        q = deque()\n        heap = []\n        ans = []\n        if k == 1:\n            return nums\n\n        max = float('-inf')\n        for j, i in enumerate(nums):\n            if len(q) < k:\n                q.append(i)\n                if i > max:\n                    max = i\n                    heap = []\n                else:\n                    heapq.heappush(heap, (-1*i, j))\n            else:\n                ans.append(max)\n                pop = q.popleft()\n                if pop == max:\n                    pop, index = heapq.heappop(heap)\n                    max = pop*-1\n                    while heap:\n                        if heap[0][1] < index:\n                            heapq.heappop(heap)\n                        else:\n                            break\n                q.append(i)\n                if i > max:\n                    heap = []\n                    max = i\n                else:\n                    heapq.heappush(heap, (-1*i, j))\n        ans.append(max)\n        return ans\n\n        \n\n# 1 3 -1 : 3 : -1 \n# 3 -1 -3 : 3 : -1 -3\n# -1 -3 5 : if next one is larger, clear heap \n\n# -7 -8 7 5 : 7 : 5\n# -8 7 5 7 : 7 : \n# 7 5 7 1 : 7 : 1\n# 5 7 1 6 : 7 : 6 1\n\n# 3 8 3 3 3 6 3 7 3 4 3 3 3 3 \n# 3 8 3 3 3 6 3 7 : 8 : 7 6 \n# 3 3 3 6 3 7 3 4 : 7 : 6 4\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 100)\n        nums = [random.randint(-10000, 10000) for _ in range(n)]\n        k = random.randint(1, n)\n        return {'nums': nums, 'k': k}\n\n    def encode_input(self, input_obj: dict) -> str:\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj: list) -> str:\n        return json.dumps(output_obj)\n\n    def decode_input(self, input_str: str) -> dict:\n        return json.loads(input_str)\n\n    def decode_output(self, output_str: str) -> list:\n        return json.loads(output_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.maxSlidingWindow(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.062",
            "memory": 4920,
            "stderr": null,
            "token": "6ad66516-b325-40b5-9499-e9c7d2b42b44",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 241,
        "title": "different-ways-to-add-parentheses",
        "token": "deecb742-498e-4a16-ac95-21c81b20772d",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport functools\nimport random\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def diffWaysToCompute(self, expression: str) -> List[int]:\n\n        if expression.isdigit():\n            return [int(expression)]\n        res = []\n        for i, s in enumerate(expression):\n            if s in \"+-*\":\n                l = self.diffWaysToCompute(expression[:i])\n                r = self.diffWaysToCompute(expression[i+1:])\n                \n                for ls in l:\n                    for rs in r:\n                        res.append(eval(str(ls) + s + str(rs)))\n                \n        return res\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        operators = ['+', '-', '*']\n        num_parts = random.randint(2, 5)\n        expression = str(random.randint(0, 99))\n        for _ in range(num_parts - 1):\n            operator = random.choice(operators)\n            number = random.randint(0, 99)\n            expression += operator + str(number)\n        return {'expression': expression}\n\n    def encode_input(self, input_obj: dict) -> str:\n        return input_obj['expression']\n\n    def encode_output(self, output_obj: List[int]) -> str:\n        return ','.join(map(str, output_obj))\n\n    def decode_input(self, input_str: str) -> dict:\n        return {'expression': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.diffWaysToCompute(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.054",
            "memory": 4828,
            "stderr": null,
            "token": "deecb742-498e-4a16-ac95-21c81b20772d",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 242,
        "title": "valid-anagram",
        "token": "2c2e7b8d-175d-4b2f-86e2-18608b9c53ff",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def isAnagram(self, s: str, t: str) -> bool:\n        if len(s)!= len(t):\n            return False\n        sd = {}\n        td = {}\n        for i in range(len(s)):\n            if s[i] not in sd:\n                sd[s[i]] = 0\n            if t[i] not in td:\n                td[t[i]] = 0\n            sd[s[i]] += 1\n            td[t[i]] += 1\n        return td == sd\n        # if len(s)!= len(t):\n        #     return False\n        # sa = [0]*26\n        # ta = [0]*26\n        # for i in range(len(s)):\n        #     sa[ord(s[i])-ord('a')] += 1\n        #     ta[ord(t[i])-ord('a')] += 1\n        # return sa==ta\n\nclass TestCaseGenerator:\n\n    def __init__(self):\n        self.examples = [{'s': 'anagram', 't': 'nagaram'}, {'s': 'rat', 't': 'car'}, {'s': 'listen', 't': 'silent'}, {'s': 'hello', 't': 'bello'}, {'s': 'debitcard', 't': 'badcredit'}]\n\n    def generate(self) -> dict:\n        return random.choice(self.examples)\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['s']},{input_obj['t']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj).lower()\n\n    def decode_input(self, input_str) -> dict:\n        s, t = input_str.split(',')\n        return {'s': s, 't': t}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.isAnagram(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.055",
            "memory": 4856,
            "stderr": null,
            "token": "2c2e7b8d-175d-4b2f-86e2-18608b9c53ff",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 31,
        "title": "next-permutation",
        "token": "fb96762d-e5a1-4d24-9a2f-38cb4913b193",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def swap(self, nums, i, j):\n        temp = nums[i]\n        nums[i] = nums[j]\n        nums[j] = temp\n    def reverse(self, nums, i, j):\n        while i < j:\n            self.swap(nums, i, j)\n            i += 1\n            j -= 1\n            \n    def nextPermutation(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        i = len(nums) - 2\n        while i >= 0 and nums[i] >= nums[i + 1]:\n            i -= 1\n        if i >= 0:\n            j = len(nums) - 1\n            while nums[j] <= nums[i]:\n                j -= 1\n            self.swap(nums, i, j)\n        self.reverse(nums, i+1, len(nums) - 1)\n\n        return nums\n\nclass TestCaseGenerator:\n\n    def __init__(self):\n        self.sample = random.sample\n        self.randint = random.randint\n\n    def generate(self) -> dict:\n        length = self.randint(1, 10)\n        nums = self.sample(range(0, 101), length)\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'nums': list(map(int, input_str.strip('[]').split(',')))}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.nextPermutation(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Input {'nums': [31, 60, 41]}\nExpected Output:  None\nActual Output:  [31, 60, 41]\n1 Test Failed!\n",
            "time": "0.06",
            "memory": 4728,
            "stderr": null,
            "token": "fb96762d-e5a1-4d24-9a2f-38cb4913b193",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 4,
                "description": "Wrong Answer"
            }
        }
    },
    {
        "status": "success",
        "question_id": 32,
        "title": "longest-valid-parentheses",
        "token": "77ce3ab6-0e94-4f82-a595-83848f1ea1ef",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def longestValidParentheses(self, s: str) -> int:\n        memo = {}\n        def dfs(i):\n            if i >= len(s):\n                return 0\n            if i in memo:\n                return memo[i]\n            memo[i] = 0\n            if s[i] == '(':\n                if i + 1 < len(s) and s[i + 1] == ')':\n                    memo[i] = dfs(i + 2) + 2\n                elif i + dfs(i + 1) + 1 < len(s) and s[i + dfs(i + 1) + 1] == ')':\n                    memo[i] = dfs(i + 1) + 2 + dfs(i + dfs(i + 1) + 2)\n            return memo[i]\n\n        for i in range(len(s)):\n            dfs(i)\n        return max(memo.values()) if memo else 0\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        length = random.randint(0, 20)\n        parentheses = [random.choice(['(', ')']) for _ in range(length)]\n        return {'s': ''.join(parentheses)}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['s']\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.longestValidParentheses(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.06",
            "memory": 4744,
            "stderr": null,
            "token": "77ce3ab6-0e94-4f82-a595-83848f1ea1ef",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 33,
        "title": "search-in-rotated-sorted-array",
        "token": "af434c84-82e3-432b-afcd-ba3280691d12",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        l=0\n        r=len(nums)-1\n        while l<=r:\n            mid=(l+r)//2\n            if nums[mid]==target: return mid\n            if nums[mid]<target:\n                if (target<=nums[-1] and nums[mid]<=nums[-1]) or (target>=nums[0] and nums[mid]>=nums[0]): l=mid+1\n                else: r=mid-1\n            elif nums[mid]>target:\n                if (target<=nums[-1] and nums[mid]<=nums[-1]) or (target>=nums[0] and nums[mid]>=nums[0]): r=mid-1\n                else: l=mid+1\n        return -1\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 20)\n        array = sorted(random.sample(range(-50, 50), n))\n        k = random.randint(0, n - 1)\n        rotated_array = array[k:] + array[:k]\n        target = random.choice(rotated_array + [101])\n        return {'nums': rotated_array, 'target': target}\n\n    def encode_input(self, input_obj) -> str:\n        nums_str = ','.join(map(str, input_obj['nums']))\n        target_str = str(input_obj['target'])\n        return f'nums=[{nums_str}], target={target_str}'\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        input_str = input_str.strip()\n        nums_part = input_str.split('target=')[0].strip()\n        target_part = input_str.split('target=')[1].strip()\n        nums = list(map(int, nums_part[nums_part.index('[') + 1:nums_part.rindex(']')].split(',')))\n        target = int(target_part)\n        return {'nums': nums, 'target': target}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.search(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.062",
            "memory": 4860,
            "stderr": null,
            "token": "af434c84-82e3-432b-afcd-ba3280691d12",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 34,
        "title": "find-first-and-last-position-of-element-in-sorted-array",
        "token": "274b2461-522a-4f76-8fee-fdd6582308ae",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\n        l = bisect_left(nums, target)\n        if l == len(nums) or nums[l]!= target:\n            return [-1, -1]\n        r = bisect_right(nums, target)\n        return [l, r - 1]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        test_cases = [{'nums': [5, 7, 7, 8, 8, 10], 'target': 8}, {'nums': [5, 7, 7, 8, 8, 10], 'target': 6}, {'nums': [], 'target': 0}, {'nums': [2, 2, 2, 2, 2], 'target': 2}, {'nums': [1, 3, 5, 6, 8, 10], 'target': 7}]\n        return random.choice(test_cases)\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['nums']}|{input_obj['target']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        nums_str, target_str = input_str.split('|')\n        nums = list(map(int, nums_str.strip('[]').split(','))) if nums_str.strip('[]') else []\n        target = int(target_str)\n        return {'nums': nums, 'target': target}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.searchRange(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.052",
            "memory": 4744,
            "stderr": null,
            "token": "274b2461-522a-4f76-8fee-fdd6582308ae",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 191,
        "title": "number-of-1-bits",
        "token": "ff82ec29-e1a8-45cf-a0f1-9235ec497395",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport json\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def hammingWeight(self, n: int) -> int:\n        s=bin(n)\n        count=0\n        for i in range(0, len(s)):\n            if s[i] == '1':\n                count+=1\n        return count\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 2 ** 20)\n        return {'n': n}\n\n    def encode_input(self, input_obj: dict) -> str:\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj: int) -> str:\n        return json.dumps({'result': output_obj})\n\n    def decode_input(self, input_str: str) -> dict:\n        return json.loads(input_str)\n\n    def decode_output(self, output_str: str) -> int:\n        return json.loads(output_str)['result']\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.hammingWeight(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.065",
            "memory": 6072,
            "stderr": null,
            "token": "ff82ec29-e1a8-45cf-a0f1-9235ec497395",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 198,
        "title": "house-robber",
        "token": "97719b2e-ced9-4328-ac48-f4f55c58943d",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def rob(self, nums: List[int]) -> int:\n        \n        if (len(nums) == 0):\n            return 0\n        elif (len(nums) == 1):\n            return nums[0]\n        elif (len(nums) == 2):\n            return max(nums)\n        \n        dp = [0]* len(nums)\n        dp[0] = nums[0]\n        dp[1] = max(nums[0:2])\n        \n        \n        for i in range(2, len(nums)):\n            dp[i] = max(dp[i-1], dp[i-2]+nums[i])\n        return dp[-1]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(2, 20)\n        nums = [random.randint(0, 400) for _ in range(length)]\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        nums = eval(input_str)\n        return {'nums': nums}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.rob(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.054",
            "memory": 4904,
            "stderr": null,
            "token": "97719b2e-ced9-4328-ac48-f4f55c58943d",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "failure",
        "question_id": 199,
        "title": "binary-tree-right-side-view",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "success",
        "question_id": 201,
        "title": "bitwise-and-of-numbers-range",
        "token": "6f5275bb-2090-47bc-a5ae-94c10928b1f6",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def rangeBitwiseAnd(self, left: int, right: int) -> int:\n        bl = bin(left)[2:]\n        br = bin(right)[2:]\n\n        bl = '0'*(len(br)-len(bl)) + bl\n\n        n = len(br)\n        res = 0\n\n        for i in range(n):\n            if br[i] == '1':\n                if bl[i] == '1':\n                    res += 1 << (n-1-i)\n                else:\n                    break\n        \n        return res\n\nclass TestCaseGenerator:\n\n    @staticmethod\n    def generate() -> dict:\n        left = random.randint(0, 10000)\n        right = random.randint(left, left + random.randint(0, 10000))\n        return {'left': left, 'right': right}\n\n    @staticmethod\n    def encode_input(input_obj) -> str:\n        return f\"{input_obj['left']},{input_obj['right']}\"\n\n    @staticmethod\n    def encode_output(output_obj) -> str:\n        return str(output_obj)\n\n    @staticmethod\n    def decode_input(input_str) -> dict:\n        left, right = map(int, input_str.split(','))\n        return {'left': left, 'right': right}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.rangeBitwiseAnd(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.064",
            "memory": 7284,
            "stderr": null,
            "token": "6f5275bb-2090-47bc-a5ae-94c10928b1f6",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 205,
        "title": "isomorphic-strings",
        "token": "6740206e-2a3b-4a13-8036-8df631097066",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport string\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def isIsomorphic(self, s: str, t: str) -> bool:\n        stot = {}\n        ttos = {}\n        for s_, t_ in zip(s, t):\n            if s_ in stot and stot.get(s_)!=t_:\n                return False\n            if t_ in ttos and ttos.get(t_)!=s_:\n                return False\n\n            stot[s_] = t_\n            ttos[t_] = s_\n        return True\n            \n\n            \n\n\n\n\n\n\n\n\n\n        # s2t_dict = {}\n        # t2s_dict = {}\n        # for key, value in zip(s, t):\n        #     if (key in s2t_dict) and value!= s2t_dict[key]:\n        #         return False\n        #     if (value in t2s_dict) and key!= t2s_dict[value]:\n        #         return False\n            \n        #     if key not in s2t_dict:\n        #         s2t_dict[key] = value\n        #     if value not in t2s_dict:\n        #         t2s_dict[value] = key\n        \n        # return True\n\nclass TestCaseGenerator:\n\n    def __init__(self):\n        self.libraries = ['random', 'string']\n\n    def generate(self) -> dict:\n        length = random.randint(1, 100)\n        s = ''.join((random.choice(string.ascii_letters) for _ in range(length)))\n        t = ''.join((random.choice(string.ascii_letters) for _ in range(length)))\n        return {'s': s, 't': t}\n\n    def encode_input(self, input_obj) -> str:\n        return f'''s = \"{input_obj['s']}\", t = \"{input_obj['t']}\"'''\n\n    def encode_output(self, output_obj) -> str:\n        return 'true' if output_obj else 'false'\n\n    def decode_input(self, input_str) -> dict:\n        input_parts = input_str.split(', ')\n        s_value = input_parts[0].split('= ')[1].strip('\"')\n        t_value = input_parts[1].split('= ')[1].strip('\"')\n        return {'s': s_value, 't': t_value}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.isIsomorphic(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.056",
            "memory": 4856,
            "stderr": null,
            "token": "6740206e-2a3b-4a13-8036-8df631097066",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 210,
        "title": "course-schedule-ii",
        "token": "047aa8e5-6666-4617-a1d7-6f6bf3eb5092",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom collections import deque\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\n        world = [Node(n) for n in range(numCourses)]\n        for (a, b) in prerequisites:\n            world[a].prereqs.add(world[b])\n        res = []\n        taken = set()\n        for n in world:\n            if n.n in taken:\n                continue\n            ne = n.how_to_take_this(taken, visited=set())\n            if ne is False:\n                return []\n            taken |= set(ne)\n            res.append(ne)\n        return [ele for node in res for ele in node]\n\nclass Node:\n    def __init__(self, n):\n        self.n = n\n        self.prereqs = set()\n    def how_to_take_this(self, taken, visited=None):\n        if self.n in visited:\n            return False\n        visited.add(self.n)\n        res = []\n        for prereq in self.prereqs:\n            if prereq.n in taken:\n                continue\n            prereq_order = prereq.how_to_take_this(taken=taken, visited=visited)\n            if prereq_order is False:\n                return False\n            taken |= set(prereq_order)\n            res.extend(prereq_order)\n        res.append(self.n)\n        return res\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        numCourses = random.randint(1, 10)\n        prereq_num = random.randint(0, min(10, numCourses * (numCourses - 1)))\n        prerequisites = []\n        seen = set()\n        for _ in range(prereq_num):\n            a, b = random.sample(range(numCourses), 2)\n            if (a, b) not in seen:\n                seen.add((a, b))\n                prerequisites.append([a, b])\n        return {'numCourses': numCourses, 'prerequisites': prerequisites}\n\n    def encode_input(self, input_obj: dict) -> str:\n        return f\"{input_obj['numCourses']}, {input_obj['prerequisites']}\"\n\n    def encode_output(self, output_obj: list) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str: str) -> dict:\n        num_courses_str, prerequisites_str = input_str.split(',', 1)\n        num_courses = int(num_courses_str)\n        prerequisites = eval(prerequisites_str.strip())\n        return {'numCourses': num_courses, 'prerequisites': prerequisites}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.findOrder(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Input {'numCourses': 8, 'prerequisites': [[4, 3], [2, 7], [5, 7], [5, 6], [6, 7]]}\nExpected Output:  deque([1, 0, 7, 6, 5, 2, 3, 4])\nActual Output:  [0, 1, 7, 2, 3, 4, 6, 5]\n1 Test Failed!\n",
            "time": "0.065",
            "memory": 4824,
            "stderr": null,
            "token": "047aa8e5-6666-4617-a1d7-6f6bf3eb5092",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 4,
                "description": "Wrong Answer"
            }
        }
    },
    {
        "status": "success",
        "question_id": 214,
        "title": "shortest-palindrome",
        "token": "43e5e1f1-5f87-46ec-831d-121e93f9622b",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport string\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def shortestPalindrome(self, s: str) -> str:\n        n = len(s)\n        res = 0\n        for i in range(1, n+1):\n            if s[:i] == s[i-1::-1]:\n                res = i\n        return s[:res-1:-1] +s\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(1, 100)\n        random_str = ''.join((random.choice(string.ascii_lowercase) for _ in range(length)))\n        return {'s': random_str}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['s']\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.shortestPalindrome(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.063",
            "memory": 4868,
            "stderr": null,
            "token": "43e5e1f1-5f87-46ec-831d-121e93f9622b",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 216,
        "title": "combination-sum-iii",
        "token": "00ef9882-83b4-41b4-8628-d49e53c78a74",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\n        if 45-(9-k)*(10-k)/2 < n or k*(k+1)/2 > n:\n            return []\n\n        def backtrack(comb, s, n):\n            if n == 0 and len(comb) == k:\n                output.append(comb)\n                return\n            for i in range(s, min(n+1, 10)):\n                if n-i <0:\n                    break\n                backtrack(comb + [i], i+1, n-i)\n        \n        output = []\n        backtrack([], 1, n)\n        return output\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        k = random.randint(2, 9)\n        n = random.randint(1, 60)\n        return {'k': k, 'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['k']} {input_obj['n']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        k, n = map(int, input_str.split())\n        return {'k': k, 'n': n}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.combinationSum3(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.104",
            "memory": 4788,
            "stderr": null,
            "token": "00ef9882-83b4-41b4-8628-d49e53c78a74",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 93,
        "title": "restore-ip-addresses",
        "token": "2bee236b-7833-441d-a2c3-10d2443a99dc",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\r\n    def restoreIpAddresses(self, s: str) -> List[str]:\r\n        path = []\r\n        result = []\r\n\r\n        len_s = len(s)\r\n\r\n        def is_valid_ip(s):\r\n            if (s[0] == '0' and len(s) > 1) or int(s) > 255:\r\n                return False \r\n            else:\r\n                return True\r\n\r\n        def backtracking(start_idx, point_count):\r\n            if point_count == 4 and start_idx >= len_s:\r\n                result.append(\".\".join(path))\r\n                return \r\n\r\n            for i in range(start_idx, len_s):\r\n                temp = s[start_idx:i + 1]\r\n                if is_valid_ip(temp):\r\n                    path.append(temp)\r\n                    backtracking(i + 1, point_count + 1)\r\n                    path.pop()\r\n        \r\n        backtracking(0, 0)\r\n        return result\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        \"\"\"Generates a random test case for the restoreIpAddresses function.\"\"\"\n        s = ''.join((random.choice('0123456789') for _ in range(random.randint(4, 12))))\n        return {'s': s}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['s']\n\n    def encode_output(self, output_obj) -> str:\n        return ','.join(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.restoreIpAddresses(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.237",
            "memory": 4956,
            "stderr": null,
            "token": "2bee236b-7833-441d-a2c3-10d2443a99dc",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "failure",
        "question_id": 127,
        "title": "word-ladder",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "success",
        "question_id": 81,
        "title": "search-in-rotated-sorted-array-ii",
        "token": "32bf7d46-ce27-465f-962f-e3f4cb0a3ead",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def search(self, nums: List[int], target: int) -> bool:\n        left = 0\n        right = len(nums) - 1\n        while left <= right:\n            middle = (left + right) // 2\n            if nums[middle] == target:\n                return True\n            if (nums[left] == nums[middle] and nums[middle] == nums[right]):\n                left += 1\n                right -= 1\n            elif nums[left] <= nums[middle]:\n                if nums[left] <= target and target < nums[middle]:\n                    right = middle - 1\n                else:\n                    left = middle + 1 \n            else:\n                if target > nums[middle] and target <= nums[right]:\n                    left = middle + 1\n                else:\n                    right = middle - 1\n        return False\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        n = random.randint(1, 100)\n        nums = sorted([random.randint(-10000, 10000) for _ in range(n)])\n        pivot = random.randint(0, n - 1)\n        nums = nums[pivot:] + nums[:pivot]\n        target = random.choice(nums + [random.randint(-10000, 10000)])\n        return {'nums': nums, 'target': target}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.search(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.067",
            "memory": 5040,
            "stderr": null,
            "token": "32bf7d46-ce27-465f-962f-e3f4cb0a3ead",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 151,
        "title": "reverse-words-in-a-string",
        "token": "8a4f9cc9-cfd4-4714-9acd-ab86b1e04a14",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def reverseWords(self, s: str) -> str:\n        return \" \".join(reversed(s.split()))\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        test_cases = [{'s': 'the sky is blue'}, {'s': '  hello world  '}, {'s': 'a good   example'}, {'s': 'singleword'}, {'s': '  multiple words   with   extra spaces '}, {'s': '    boundary   '}]\n        return test_cases[0]\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['s']\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.reverseWords(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.091",
            "memory": 4772,
            "stderr": null,
            "token": "8a4f9cc9-cfd4-4714-9acd-ab86b1e04a14",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 152,
        "title": "maximum-product-subarray",
        "token": "7707dad9-6bc6-41f6-b40a-b8018f5b040e",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def maxProduct(self, nums: List[int]) -> int:\n        max_prod = float('-inf')\n        prefix, suffix = 1, 1\n        n = len(nums)\n        for i in range(n):\n            if prefix == 0: prefix = 1\n            if suffix == 0: suffix = 1\n\n            prefix *= nums[i]\n            suffix *= nums[n - i - 1]\n            max_prod = max(max_prod, prefix, suffix)    # update max_prod only when either\n                                                        # prefix or suffix is greater\n                                                        # else max_prod is kept as it is\n        return max_prod\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        nums_length = random.randint(1, 20)\n        nums = [random.randint(-10, 10) for _ in range(nums_length)]\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.maxProduct(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.066",
            "memory": 4896,
            "stderr": null,
            "token": "7707dad9-6bc6-41f6-b40a-b8018f5b040e",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "failure",
        "question_id": 95,
        "title": "unique-binary-search-trees-ii",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "success",
        "question_id": 96,
        "title": "unique-binary-search-trees",
        "token": "207ca7cb-f687-4456-86c3-bf8361b32096",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport json\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def numTrees(self, n: int) -> int:\n\n        list_ = [0]*(n + 1)\n        list_[0], list_[1] = 1,1\n        for i in range(2, n+1):\n            for j in range(1,i+1):\n                list_[i] += list_[j-1]*list_[i-j]\n\n        return list_[n]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 19)\n        return {'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return json.dumps(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return json.loads(input_str)\n\n    def decode_output(self, output_str) -> int:\n        return json.loads(output_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.numTrees(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.063",
            "memory": 4780,
            "stderr": null,
            "token": "207ca7cb-f687-4456-86c3-bf8361b32096",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 97,
        "title": "interleaving-string",
        "token": "67ab5a32-8343-4216-9e6c-9b1e5184f530",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import Dict\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n\n        # dp[i][j] represents whether the first i characters in s1\n        # and the first j characters in s2\n        # can form the first i + j characters of s3\n\n        if len(s1) + len(s2)!= len(s3):\n            return False\n\n        dp = [[False] * (len(s2) + 1) for _ in range((len(s1) + 1))]\n\n        # true for empty string\n        dp[0][0] = True\n\n        for i in range(len(s1) + 1):\n            for j in range(len(s2) + 1):\n                if i == 0 and j == 0:\n                    continue\n                # initialise base cases i and j\n                elif i == 0:\n                    dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\n                elif j == 0:\n                    dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\n                # interleave using either s1 OR s2\n                else:\n                    dp[i][j] = (dp[i][j - 1] and s2[j - 1] == s3[j + i - 1]) or \\\n                               (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1])\n\n        return dp[len(s1)][len(s2)]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        return {'s1': 'aabcc', 's2': 'dbbca', 's3': 'aadbbcbcac'}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{{'s1': '{input_obj['s1']}', 's2': '{input_obj['s2']}', 's3': '{input_obj['s3']}'}}\"\n\n    def encode_output(self, output_obj) -> str:\n        return 'true' if output_obj else 'false'\n\n    def decode_input(self, input_str) -> dict:\n        input_obj = eval(input_str)\n        return {'s1': input_obj['s1'], 's2': input_obj['s2'], 's3': input_obj['s3']}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.isInterleave(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.067",
            "memory": 4760,
            "stderr": null,
            "token": "67ab5a32-8343-4216-9e6c-9b1e5184f530",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 1,
        "title": "two-sum",
        "token": "86e426f0-7919-4dfd-92d4-593bef3095c5",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        indexes = []\n        #nums.append(0)\n        for idx, num in enumerate(nums):\n            complement = target - num\n    \n            # nums \ub9ac\uc2a4\ud2b8\uc5d0\uc11c \ud604\uc7ac \uc778\ub371\uc2a4\ub97c \uc81c\uc678\ud55c \ub2e4\ub978 \uc704\uce58\uc5d0\uc11c complement \ucc3e\uae30\n            for idx2, num2 in enumerate(nums):\n                if num2 == complement and idx!= idx2:\n                    indexes.append(idx)\n        \n        return indexes\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        length = random.randint(2, 10)\n        nums = random.sample(range(-100, 100), length)\n        idx1, idx2 = random.sample(range(length), 2)\n        target = nums[idx1] + nums[idx2]\n        return {'nums': nums, 'target': target}\n\n    def encode_input(self, input_obj) -> str:\n        nums_str = ','.join(map(str, input_obj['nums']))\n        return f\"nums=[{nums_str}],target={input_obj['target']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return f'{output_obj[0]},{output_obj[1]}'\n\n    def decode_input(self, input_str) -> dict:\n        input_vars = input_str.split('],')\n        nums_str = input_vars[0].replace('nums=[', '')\n        nums = list(map(int, nums_str.split(',')))\n        target = int(input_vars[1].replace('target=', ''))\n        return {'nums': nums, 'target': target}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.twoSum(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Input {'nums': [-87, -45, 48, 83, 41], 'target': -4}\nExpected Output:  0,3\nActual Output:  0,1\n9 Test Failed!\n",
            "time": "0.073",
            "memory": 4880,
            "stderr": null,
            "token": "86e426f0-7919-4dfd-92d4-593bef3095c5",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 4,
                "description": "Wrong Answer"
            }
        }
    },
    {
        "status": "success",
        "question_id": 5,
        "title": "longest-palindromic-substring",
        "token": "bb959a7b-8127-4679-a029-678a817d6d40",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport string\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        longest = s[0]\n        palin = set()\n        for i in range(len(s)):\n            for j in range(i + 1, len(s)):\n                if j - i < len(longest):\n                    continue\n                _s = s[i : j + 1]\n                if _s in palin:\n                    continue\n                elif self.check(_s, palin):\n                    palin.add(_s)\n                    if len(_s) > len(longest):\n                        longest = _s\n        return longest\n\n    def check(self, s, palin):\n        n = len(s)\n        i = 0\n        j = n - 1\n        while i < j:\n            if s in palin:\n                return True\n            if s[i]!= s[j]:\n                return False\n            else:\n                i += 1\n                j -= 1\n        return True\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(1, 100)\n        s = ''.join(random.choices(string.ascii_letters + string.digits, k=length))\n        return {'s': s}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['s']\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.longestPalindrome(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.08",
            "memory": 4860,
            "stderr": null,
            "token": "bb959a7b-8127-4679-a029-678a817d6d40",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 6,
        "title": "zigzag-conversion",
        "token": "309a71f6-e71a-4dad-9540-93c4fcd44e72",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom math import ceil\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def convert(self, s: str, numRows: int) -> str:\n        strings = []\n        currString = \"\"\n        if(numRows <= 1):\n            return s\n        idx = 0\n        while (idx < len(s)):\n            for i in range(0, numRows):\n                if(idx + i >= len(s)):\n                    currString += \"_\"\n                else:\n                    currString += s[idx + i]\n            idx += i\n            strings.append(currString)\n            currString = \"\"\n            for i in range (numRows - 2, 0, -1):\n                idx += 1\n                if(idx >= len(s)):\n                    break\n                for j in range(0, i):\n                    currString += \"_\"\n                currString += s[idx]\n                for j in range(i+1, numRows):\n                    currString += \"_\"\n                strings.append(currString)\n                currString = \"\"\n            idx += 1\n        outputString = \"\"\n        for idx in range(0, numRows):\n            for line in strings:\n                if(line[idx]!= \"_\"):\n                    outputString+= line[idx]\n        return outputString\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz,.'\n        string_length = random.randint(1, 20)\n        random_string = ''.join((random.choice(letters) for _ in range(string_length)))\n        num_rows = random.randint(1, min(string_length, 10))\n        return {'s': random_string, 'numRows': num_rows}\n\n    def encode_input(self, input_obj) -> str:\n        s = input_obj['s']\n        numRows = input_obj['numRows']\n        return f\"{{'s': '{s}', 'numRows': {numRows}}}\"\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        return eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.convert(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.071",
            "memory": 4812,
            "stderr": null,
            "token": "309a71f6-e71a-4dad-9540-93c4fcd44e72",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 8,
        "title": "string-to-integer-atoi",
        "token": "a5efc8a6-26fd-4571-9f38-0749a9d9865e",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def myAtoi(self, s: str) -> int:\n        negative = False\n        start_digit = False\n        string_number = \"\"\n        INT_MAX = 2**31 - 1\n        INT_MIN = -2**31\n        \n        for char in s:\n            if char == \" \" and not start_digit:\n                continue\n            \n            if char == \"-\" and not start_digit:\n                negative = True\n                start_digit = True\n                continue\n            elif char == \"+\" and not start_digit:\n                start_digit = True\n                continue\n            \n            if char.isdigit():\n                string_number += char\n                start_digit = True\n                continue\n            \n            # If a non-digit character is encountered after starting to read digits\n            if start_digit:\n                break\n            \n            # If the character is invalid at the start (non-digit and not a sign)\n            if not char.isdigit() and not start_digit:\n                return 0\n        \n        if not string_number:\n            return 0\n        \n        result = int(string_number)\n\n        if negative:\n            result = -result\n        \n        # Clamp the result to the 32-bit integer range\n        if result < INT_MIN:\n            return INT_MIN\n        if result > INT_MAX:\n            return INT_MAX\n        return result\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        cases = ['42', '    -42', '+123', '1337abc', ' ', '9223372036854775808', '-2147483649', '3.14159', '00100', 'words 456']\n        return {'s': random.choice(cases)}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['s']\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.myAtoi(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.058",
            "memory": 4744,
            "stderr": null,
            "token": "a5efc8a6-26fd-4571-9f38-0749a9d9865e",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 309,
        "title": "best-time-to-buy-and-sell-stock-with-cooldown",
        "token": "73948de9-bb10-4888-8549-bc5d9050d5d6",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List\nimport ast\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        L = len(prices)\n        # padding the array with additional zero to simply the logic\n        MP = [0] * (L + 2)\n\n        for i in range(L-1, -1, -1):\n            C1 = 0\n            # Case 1). buy and sell the stock\n            for sell in range(i + 1, L):\n                profit = (prices[sell] - prices[i]) + MP[sell + 2]\n                C1 = max(profit, C1)\n\n            # Case 2). do no transaction with the stock p[i]\n            C2 = MP[i + 1]\n\n            # sum up two cases\n            MP[i] = max(C1, C2)\n\n        return MP[0]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(1, 100)\n        prices = [random.randint(0, 1000) for _ in range(length)]\n        return {'prices': prices}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['prices'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        prices = ast.literal_eval(input_str)\n        return {'prices': prices}\n\n    def decode_output(self, output_str) -> int:\n        return int(output_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.maxProfit(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.075",
            "memory": 5300,
            "stderr": null,
            "token": "73948de9-bb10-4888-8549-bc5d9050d5d6",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 299,
        "title": "bulls-and-cows",
        "token": "02110103-acf1-4f55-a317-8371226b0dfd",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom collections import Counter\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def getHint(self, secret: str, guess: str) -> str:\n        guessDict = {}\n        secretDict = {}\n        bulls = 0\n        cows = 0\n\n        for i in range(len(secret)):\n            if secret[i] == guess[i]:\n                bulls += 1\n            else:\n                if secret[i] in guessDict and guessDict[secret[i]] > 0:\n                    cows += 1\n                    guessDict[secret[i]] -= 1\n                else:\n                    secretDict[secret[i]] = secretDict.get(secret[i], 0) + 1\n                if guess[i] in secretDict and secretDict[guess[i]] > 0:\n                    cows += 1\n                    secretDict[guess[i]] -= 1\n                else:\n                    guessDict[guess[i]] = guessDict.get(guess[i], 0) + 1\n        return f'{bulls}A{cows}B'\n\nclass TestCaseGenerator:\n\n    def __init__(self):\n        self.random = random\n\n    def generate(self) -> dict:\n        length = self.random.randint(1, 10)\n        secret = ''.join(self.random.choices('0123456789', k=length))\n        guess = ''.join(self.random.choices('0123456789', k=length))\n        return {'secret': secret, 'guess': guess}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"secret={input_obj['secret']}&guess={input_obj['guess']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        parts = input_str.split('&')\n        secret = parts[0].split('=')[1]\n        guess = parts[1].split('=')[1]\n        return {'secret': secret, 'guess': guess}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.getHint(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.061",
            "memory": 4772,
            "stderr": null,
            "token": "02110103-acf1-4f55-a317-8371226b0dfd",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 300,
        "title": "longest-increasing-subsequence",
        "token": "f7db7e72-82c3-4a94-9bae-34357a185da8",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def lengthOfLIS(self, nums: List[int]) -> int:\n        minH, copy = [], []\n        for num in nums[::-1]:\n            while copy and num >= copy[0][1]:\n                heapq.heappop(copy)\n            if copy:\n                heapq.heappush(minH, (copy[0][0]-1, num))\n            else:\n                heapq.heappush(minH, (-1, num))\n            copy = minH.copy()\n        return -minH[0][0]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 100)\n        nums = [random.randint(-1000, 1000) for _ in range(n)]\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['nums']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        nums = list(map(int, input_str.strip('[]').split(',')))\n        return {'nums': nums}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.lengthOfLIS(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.065",
            "memory": 4952,
            "stderr": null,
            "token": "f7db7e72-82c3-4a94-9bae-34357a185da8",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 301,
        "title": "remove-invalid-parentheses",
        "token": "b8dd4bd2-3424-43f5-8c9c-42032da93bbb",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def removeInvalidParentheses(self, s: str) -> List[str]:\n        def dfs(i, c, o):\n            if o < 0:\n                return set()\n            if i == len(s):\n                if o == 0:\n                    return {c}\n                else:\n                    return set()\n\n            combos = set()\n            if s[i] == \"(\":\n                combos |= dfs(i + 1, c + \"(\", o + 1)\n                combos |= dfs(i + 1, c, o)\n            elif s[i] == \")\":\n                combos |= dfs(i + 1, c + \")\", o - 1)\n                combos |= dfs(i + 1, c, o)\n            else:\n                combos |= dfs(i + 1, c + s[i], o)\n\n            maxlen = 0\n            for c in combos:\n                maxlen = max(maxlen, len(c))\n            for c in list(combos):\n                if len(c) < maxlen:\n                    combos.remove(c)\n\n            return combos\n\n        return list(dfs(0, \"\", 0))\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        input_length = random.randint(1, 25)\n        charset = 'abcdefghijklmnopqrstuvwxyz()'\n        s = ''.join((random.choice(charset) for _ in range(input_length)))\n        return {'s': s}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj.get('s', '')\n\n    def encode_output(self, output_obj) -> str:\n        return ','.join(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.removeInvalidParentheses(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Input {'s': ')erslahfmk'}\nExpected Output:  bgcnljowklo\nActual Output:  erslahfmk\n2 Test Failed!\n",
            "time": "0.057",
            "memory": 4884,
            "stderr": null,
            "token": "b8dd4bd2-3424-43f5-8c9c-42032da93bbb",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 4,
                "description": "Wrong Answer"
            }
        }
    },
    {
        "status": "success",
        "question_id": 162,
        "title": "find-peak-element",
        "token": "d675c055-79a9-472e-aef8-7a0c6480a757",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\nimport ast\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def findPeakElement(self, nums: List[int]) -> int:\n        prev_val = nums[0]\n\n        # nums.append(-(2**31) -1)\n\n        peak = 0\n\n        for i in range(1,len(nums)):\n          if nums[i] > prev_val:\n            peak = i\n            prev_val = nums[i]\n          else:\n            break\n\n        return peak\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        \"\"\" Generate a random test case within problem constraints. \"\"\"\n        length = random.randint(1, 1000)\n        nums = [random.randint(-1000, 1000) for _ in range(length)]\n        for i in range(1, len(nums)):\n            while nums[i] == nums[i - 1]:\n                nums[i] = random.randint(-1000, 1000)\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\" Convert test case input to string. \"\"\"\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\" Convert test case output to string. \"\"\"\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\" Convert input string back to dictionary format. \"\"\"\n        return {'nums': ast.literal_eval(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.findPeakElement(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Input {'nums': [924, -300, -870, 464, -442, -512, -900, 964, 945, 435, 163, 879, 379, 575, -577, -312, 301, -206, -479, 408, 182, -11, -578, 971, -137, -901, 272, -359, 537, -463, 76, -709, 938, -692, -268, -120, 336, -610, -124, 227, 607, -65, 989, -773, 666, 171, 935, 745, -328, 40, -141, -146, 257, -179, -133, 710, 222, -276, 890, 837, 647, 507, -863, -587, 489, -611, -662, 739, -979, 526, 774, 257, 741, 242, 50, -211, 366, -107, 876, 147, -747, -151, -630, 721, -207, -63, -768, 480, -714, -155, 854, 256, 560, -856, -985, -548, 212, -533, -453, 401, -752, 258, -660, 816, 31, -695, 690, -123, -661, 311, 674, 962, 52, 250, -218, 366, 194, -800, -292, -437, 0, -55, -547, -892, 683, -548, 256, -785, 114, 188, 640, 994, -298, -430, 509, 681, 397, -90, 454, 838, -700, 816, 586, 174, -820, -86, -673, -44, -864, -982, 159, -520, 160, 130, -398, 963, -556, 991, -743, 764, -481, -702, -437, 973, -95, 536, -426, -814, -52, 723, 226, -350, -810, 101, -992, -41, -775, -59, -454, 739, -642, 759, 634, -879, 279, -644, 87, 904, -200, 322, 367, -81, 323, -429, -306, 589, -193, -432, -517, 929, 339, -568, 777, -405, -28, -152, -69, -115, -253, 99, 643, -611, -386, 377, -487, 746, 426, -42, 240, 290, 616, 551, -997, -660, 673, 835, 548, 411, 337, 174, 540, -755, -528, -32, -603, -949, -943, 188, -940, -706, 247, -319, -300, 602, -404, 786, -215, -822, 180, 161, -528, 852, -452, -944, -231, -454, -830, -948, 270, -760, -705, -253, 866, 5, -462, -667, 17, -617, 940, -111, 46, 717, 61, 31, 0, 260, -11, 86, 18, -213, 512, -983, -194, 290, 288, 860, -956, -80, 296, 841, -64, 933, 145, 607, -182, 29, -191, 589, 732, -688, 953, -694, -614, 634, 707, -472, 254, -616, 685, -419, 683, 158, -456, 88, 319, -361, 315, -999, -736, -700, -37, -601, -962, 780]}\nExpected Output:  254\nActual Output:  0\n1 Test Failed!\n",
            "time": "0.069",
            "memory": 5748,
            "stderr": null,
            "token": "d675c055-79a9-472e-aef8-7a0c6480a757",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 4,
                "description": "Wrong Answer"
            }
        }
    },
    {
        "status": "success",
        "question_id": 164,
        "title": "maximum-gap",
        "token": "138b4185-2ff5-4dc2-8b38-f1bc264f2c75",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom random import randint, shuffle\nfrom typing import List, Dict\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def maximumGap(self, nums: List[int]) -> int:\n        if len(nums) < 2:\n            return 0\n        if len(nums) == 2:\n            return abs(nums[0] - nums[1])\n        nmax, nmin = max(nums), min(nums)\n        if nmax == nmin:\n            return 0\n        num_buckets = len(nums) - 1\n        bucket_size = (nmax - nmin) / num_buckets\n        buckets = [[float('inf'), -1] for _ in range(num_buckets)]\n        for num in nums:\n            bucket_num = min(int((num - nmin) // bucket_size), num_buckets - 1)\n            buckets[bucket_num][0] = min(buckets[bucket_num][0], num)\n            buckets[bucket_num][1] = max(buckets[bucket_num][1], num)\n        prev_bucket = buckets[0]\n        ret = -1\n        for i in range(1, len(buckets)):\n            cur_bucket = buckets[i]\n            if cur_bucket[1]!= -1:\n                ret = max(ret, cur_bucket[0] - prev_bucket[1])\n                prev_bucket = cur_bucket\n        return ret\n\nclass TestCaseGenerator:\n\n    def generate(self) -> Dict[str, List[int]]:\n        case_type = randint(1, 3)\n        if case_type == 1:\n            nums = [3, 6, 9, 1]\n        elif case_type == 2:\n            size = randint(2, 100)\n            nums = [randint(0, 1000) for _ in range(size)]\n        else:\n            nums = [10]\n        shuffle(nums)\n        return {'nums': nums}\n\n    def encode_input(self, input_obj: Dict[str, List[int]]) -> str:\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj: int) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str: str) -> Dict[str, List[int]]:\n        nums = [int(x) for x in input_str.strip('[]').split(',') if x.strip()]\n        return {'nums': nums}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.maximumGap(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.055",
            "memory": 4808,
            "stderr": null,
            "token": "138b4185-2ff5-4dc2-8b38-f1bc264f2c75",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 166,
        "title": "fraction-to-recurring-decimal",
        "token": "fa43b41f-1640-4fdb-be8e-6107ba5ba496",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\n        if numerator==0:\n            return \"0\"\n        if denominator == 0:\n            return\n        string = \"\"\n        if numerator * denominator < 0 :\n            string += \"-\"\n        numerator, denominator = abs(numerator), abs(denominator)\n        quo = numerator//denominator\n        string += str(quo)\n        rem = numerator%denominator\n\n        if rem==0:\n            return string\n        else:\n            string += \".\"\n        seen = {}\n        while rem:\n            if rem in seen:\n                ind = seen[rem]\n                return ''.join(string[:ind]) + \"(\" + ''.join(string[ind:]) + \")\"\n            seen[rem] = len(string)\n            rem *= 10\n            quo = rem//denominator\n            rem = rem%denominator\n            string += str(quo)\n        return ''.join(string)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        numerators = [1, 2, 4, random.randint(-1000, 1000)]\n        denominators = [2, 1, 333, random.randint(-1000, 1000)]\n        numerator = random.choice(numerators)\n        denominator = random.choice([d for d in denominators if d != 0])\n        return {'numerator': numerator, 'denominator': denominator}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['numerator']},{input_obj['denominator']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        numerator, denominator = map(int, input_str.split(','))\n        return {'numerator': numerator, 'denominator': denominator}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.fractionToDecimal(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.054",
            "memory": 4804,
            "stderr": null,
            "token": "fa43b41f-1640-4fdb-be8e-6107ba5ba496",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 168,
        "title": "excel-sheet-column-title",
        "token": "d72b019e-04bb-48b4-8b97-370a562c8a3f",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def convertToTitle(self, columnNumber: int) -> str:\n        alphanumeric = {val:chr(a) for a,val in zip(range(65,91), range(1,27))}\n        alphanumeric[0] = \"Z\"            \n\n        if columnNumber < 27 :\n            return alphanumeric[columnNumber]\n\n        if columnNumber % 26 == 0:\n            return self.convertToTitle((columnNumber//26)-1)+alphanumeric[(columnNumber%26)]\n        \n        return self.convertToTitle((columnNumber)//26) + self.convertToTitle(columnNumber%26)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        column_number = random.randint(1, 1000)\n        return {'columnNumber': column_number}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['columnNumber'])\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        column_number = int(input_str)\n        return {'columnNumber': column_number}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.convertToTitle(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.057",
            "memory": 4824,
            "stderr": null,
            "token": "d72b019e-04bb-48b4-8b97-370a562c8a3f",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 43,
        "title": "multiply-strings",
        "token": "ec4ea6f1-b7f7-4db0-b721-fe674f6f7f6f",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def multiply(self, num1: str, num2: str) -> str:\n        zero = ord('0')\n        n, m = len(num1), len(num2)\n        ret = 0\n        for j in range(m-1, -1, -1):\n            jmult = 10**(m-j-1)\n            carry = 0\n            for i in range(n-1, -1, -1):\n                tmp = (ord(num1[i]) - zero) * (ord(num2[j]) - zero) + carry\n                imult = 10**(n-i-1)\n                ret += (tmp % 10) * jmult * imult\n                carry = tmp // 10\n            ret = ret + (carry * jmult * 10**n)\n        return str(ret)\n\nclass TestCaseGenerator:\n\n    def __init__(self):\n        self.max_len = 200\n\n    def generate(self) -> dict:\n        import random\n        len1 = random.randint(1, self.max_len)\n        len2 = random.randint(1, self.max_len)\n        num1 = ''.join([random.choice('123456789') if i == 0 else random.choice('0123456789') for i in range(len1)])\n        num2 = ''.join([random.choice('123456789') if i == 0 else random.choice('0123456789') for i in range(len2)])\n        return {'num1': num1, 'num2': num2}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['num1']},{input_obj['num2']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        num1, num2 = input_str.split(',')\n        return {'num1': num1, 'num2': num2}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.multiply(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.239",
            "memory": 5000,
            "stderr": null,
            "token": "ec4ea6f1-b7f7-4db0-b721-fe674f6f7f6f",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 50,
        "title": "powx-n",
        "token": "b5b1b9de-9b9f-4364-8a7a-00b9296cf34c",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom random import uniform, randint\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def solve(self, a, b):\n        if b == 0:\n            return 1\n        ans = self.solve(a, b // 2)\n        ans *= ans\n        if b & 1:\n            return ans * a\n        else:\n            return ans\n\n    def myPow(self, x: float, n: int) -> float:\n        res = self.solve(x, abs(n))\n        if n < 0:\n            return 1 / res\n        return res\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        return {'x': round(uniform(-99.9, 99.9), 5), 'n': randint(-20, 20)}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['x']},{input_obj['n']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return f'{output_obj:.5f}'\n\n    def decode_input(self, input_str) -> dict:\n        x, n = input_str.split(',')\n        return {'x': float(x), 'n': int(n)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.myPow(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.057",
            "memory": 4764,
            "stderr": null,
            "token": "b5b1b9de-9b9f-4364-8a7a-00b9296cf34c",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 221,
        "title": "maximal-square",
        "token": "62ee5692-2791-4995-862a-82c460bf248c",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\n        R, C = len(matrix), len(matrix[0])\n\n        sums = [[0 for c in range(C + 1)] for r in range(R + 1)]\n\n        for r in range(1, R + 1):\n            for c in range(1, C + 1):\n                sums[r][c] = sums[r][c - 1] + sums[r - 1][c] - sums[r - 1][c - 1] + int(matrix[r - 1][c - 1])\n\n        result = 0\n\n        for r in range(1, R + 1):\n            for c in range(1, C + 1):\n                if matrix[r - 1][c - 1] == \"0\":\n                    continue\n\n                st, en = 1, min(R - r + 1, C - c + 1)\n                while en - st > 1:\n                    md = (st + en) // 2\n                    if sums[r + md - 1][c + md - 1] - sums[r + md - 1][c - 1] - sums[r - 1][c + md - 1] + sums[r - 1][c - 1] == md * md:\n                        st = md\n                    else:\n                        en = md\n                if sums[r + en - 1][c + en - 1] - sums[r + en - 1][c - 1] - sums[r - 1][c + en - 1] + sums[r - 1][c - 1] == en * en:\n                    st = en\n\n                result = max(result, st)\n\n        return result * result\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        m = random.randint(1, 100)\n        n = random.randint(1, 100)\n        matrix = [[random.choice(['0', '1']) for _ in range(n)] for _ in range(m)]\n        return {'matrix': matrix}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['matrix'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        matrix = eval(input_str)\n        return {'matrix': matrix}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.maximalSquare(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.216",
            "memory": 10900,
            "stderr": null,
            "token": "62ee5692-2791-4995-862a-82c460bf248c",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 223,
        "title": "rectangle-area",
        "token": "86e04acb-71f9-40cd-86f0-5a3e7b925f75",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\n\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -> int:\n        int_x = set(range(ax1, ax2)).intersection(range(bx1, bx2))\n        int_y = set(range(ay1, ay2)).intersection(range(by1, by2))\n        return (ax2-ax1)*(ay2-ay1) + (bx2-bx1)*(by2-by1) - len(int_x)*len(int_y)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        \"\"\"\n        Generate a test case input for the problem where two rectangles are defined by their bottom-left \n        and top-right corners.\n        \"\"\"\n        test_cases = [{'ax1': -3, 'ay1': 0, 'ax2': 3, 'ay2': 4, 'bx1': 5, 'by1': 4, 'bx2': 10, 'by2': 8}, {'ax1': 0, 'ay1': 0, 'ax2': 4, 'ay2': 3, 'bx1': 2, 'by1': 2, 'bx2': 6, 'by2': 5}, {'ax1': -2, 'ay1': -2, 'ax2': 2, 'ay2': 2, 'bx1': -2, 'by1': -2, 'bx2': 2, 'by2': 2}, {'ax1': 0, 'ay1': 0, 'ax2': 2, 'ay2': 2, 'bx1': 2, 'by1': 0, 'bx2': 4, 'by2': 2}, {'ax1': 1, 'ay1': 1, 'ax2': 4, 'ay2': 5, 'bx1': 1, 'by1': 1, 'bx2': 4, 'by2': 5}]\n        return test_cases[0]\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\"\n        Encode a test case input dictionary into a string.\n        \"\"\"\n        return ','.join((f'{value}' for value in input_obj.values()))\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\"\n        Encode a test case output integer into a string.\n        \"\"\"\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\"\n        Decode an input string back into a test case input dictionary.\n        \"\"\"\n        values = list(map(int, input_str.split(',')))\n        return {'ax1': values[0], 'ay1': values[1], 'ax2': values[2], 'ay2': values[3], 'bx1': values[4], 'by1': values[5], 'bx2': values[6], 'by2': values[7]}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.computeArea(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.051",
            "memory": 4684,
            "stderr": null,
            "token": "86e04acb-71f9-40cd-86f0-5a3e7b925f75",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "failure",
        "question_id": 107,
        "title": "binary-tree-level-order-traversal-ii",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "success",
        "question_id": 109,
        "title": "convert-sorted-list-to-binary-search-tree",
        "token": "b96f1dd8-54f0-411f-b636-971ad44f44f1",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom collections import deque\nfrom typing import Optional\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def flatList(self, head):\n        flattenList = []\n        while(head):\n            flattenList.append(head.val)\n            head = head.next\n        return flattenList\n    \n    def arrayToBST(self, nums):\n        n = len(nums)\n        if n == 0:\n            return None\n\n        middleIndex = n // 2\n        middleValue = nums.pop(middleIndex)\n        return TreeNode(middleValue, self.arrayToBST(nums[:middleIndex]), self.arrayToBST(nums[middleIndex:]))\n\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        nums = self.flatList(head)\n        return self.arrayToBST(nums)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(0, 20)\n        if n == 0:\n            return {'head': None}\n        sorted_values = sorted(random.sample(range(-100, 100), n))\n        head = ListNode(sorted_values[0])\n        current = head\n        for value in sorted_values[1:]:\n            current.next = ListNode(value)\n            current = current.next\n        return {'head': head}\n\n    def encode_input(self, input_obj) -> str:\n        if input_obj['head'] is None:\n            return '[]'\n        res = []\n        current = input_obj['head']\n        while current is not None:\n            res.append(current.val)\n            current = current.next\n        return str(res)\n\n    def encode_output(self, output_obj) -> str:\n        if not output_obj:\n            return '[]'\n        queue = deque([output_obj])\n        result = []\n        while queue:\n            node = queue.popleft()\n            if node:\n                result.append(node.val)\n                queue.append(node.left)\n                queue.append(node.right)\n            else:\n                result.append(None)\n        while result and result[-1] is None:\n            result.pop()\n        return str(result)\n\n    def decode_input(self, input_str) -> dict:\n        vals = eval(input_str)\n        if not vals:\n            return {'head': None}\n        head = ListNode(vals[0])\n        current = head\n        for value in vals[1:]:\n            current.next = ListNode(value)\n            current = current.next\n        return {'head': head}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.sortedListToBST(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.062",
            "memory": 4864,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 163, in <module>\n    runner.run()\n  File \"script.py\", line 147, in run\n    output = self.solution.sortedListToBST(**input)\n  File \"script.py\", line 79, in sortedListToBST\n    return self.arrayToBST(nums)\n  File \"script.py\", line 75, in arrayToBST\n    return TreeNode(middleValue, self.arrayToBST(nums[:middleIndex]), self.arrayToBST(nums[middleIndex:]))\n  File \"script.py\", line 75, in arrayToBST\n    return TreeNode(middleValue, self.arrayToBST(nums[:middleIndex]), self.arrayToBST(nums[middleIndex:]))\n  File \"script.py\", line 75, in arrayToBST\n    return TreeNode(middleValue, self.arrayToBST(nums[:middleIndex]), self.arrayToBST(nums[middleIndex:]))\n  [Previous line repeated 1 more time]\nTypeError: __init__() takes 2 positional arguments but 4 were given\n",
            "token": "b96f1dd8-54f0-411f-b636-971ad44f44f1",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "failure",
        "question_id": 268,
        "title": "missing-number",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "success",
        "question_id": 172,
        "title": "factorial-trailing-zeroes",
        "token": "1ef4d1cb-16b7-46d2-9d3e-5d60d0fada96",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def trailingZeroes(self, n: int) -> int:\n        value = math.factorial(n)\n        ans = 0\n        while value%10 == 0:\n            ans+=1\n            value = value//10\n        return ans\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(0, 100)\n        return {'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['n'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'n': int(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.trailingZeroes(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.066",
            "memory": 4752,
            "stderr": null,
            "token": "1ef4d1cb-16b7-46d2-9d3e-5d60d0fada96",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 179,
        "title": "largest-number",
        "token": "a19aaaf0-1d0c-4094-838d-3db47eb9588d",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport heapq\nimport random\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\ndef insert (n, l) :\n    l.append (n)\n    i = len (l) - 1\n    while i and str(n) + str(l[i-1]) > str(l[i-1]) + str(n): \n        l[i] = l[i-1]\n        i -= 1\n    l[i] = n\n\nclass Solution:\n    def largestNumber(self, nums: List[int]) -> str:\n        result = []\n        for i in nums :\n            insert (i, result)\n        return str (int (''.join ([str (i) for i in result])))\n\nclass TestCaseGenerator:\n    \"\"\"\n    A helper class to generate test cases, encode/decode inputs and outputs\n    \"\"\"\n\n    def generate(self) -> dict:\n        \"\"\"\n        Generates a random test case input, ensuring scenarios of different input sizes.\n        \"\"\"\n        import random\n        length = random.randint(1, 20)\n        nums = [random.randint(0, 10000) for _ in range(length)]\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\"\n        Converts the test case input into a human-readable string.\n        \"\"\"\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\"\n        Converts the test case output (a string) into a human-readable string format.\n        \"\"\"\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\"\n        Transforms an input string back into a Python dictionary structure.\n        \"\"\"\n        nums = eval(input_str)\n        return {'nums': nums}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.largestNumber(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.06",
            "memory": 4920,
            "stderr": null,
            "token": "a19aaaf0-1d0c-4094-838d-3db47eb9588d",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 187,
        "title": "repeated-dna-sequences",
        "token": "1c5d8fd2-507c-498a-99b3-6e232e35137b",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def findRepeatedDnaSequences(self, s: str) -> List[str]:\n        if len(s) < 10:\n            return []\n\n        mp = {}\n\n        l = 0\n        r = 9\n        currList = collections.deque()\n        for i in range(10):\n            currList.append(s[i])\n\n        mp[tuple(currList)] = 0\n        r = 10\n        ans = []\n\n        while r < len(s):\n            currList.append(s[r])\n            currList.popleft()\n            dna = tuple(currList)\n            if dna in mp and mp[dna]!= 1:\n                ans.append(\"\".join(currList))\n                mp[dna] = 1\n            elif dna not in mp:\n                mp[dna] = 0\n            r+=1\n        return ans\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        nucleotides = ['A', 'C', 'G', 'T']\n        length = random.randint(20, 200)\n        s = ''.join(random.choices(nucleotides, k=length))\n        return {'s': s}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['s']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return '[' + ', '.join((f'\"{seq}\"' for seq in output_obj)) + ']'\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.findRepeatedDnaSequences(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.06",
            "memory": 4912,
            "stderr": null,
            "token": "1c5d8fd2-507c-498a-99b3-6e232e35137b",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 12,
        "title": "integer-to-roman",
        "token": "f61b010f-a4e3-4ba9-a7e0-f260514ea584",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\n\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def intToRoman(self, num: int) -> str:\n        dictionary = {1000:'M', 900:'CM', 500:'D', 400:'CD', 100:'C', 90:'XC', 50:'L', 40:'XL', 10:'X', 9:'IX', 5:'V', 4:'IV', 1:'I'}\n        ans=''\n        for key, val in dictionary.items():\n            while num>=key:\n                ans+=val\n                num-=key\n            if num==0:break\n        return ans\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        return {'num': 3}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['num'])\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        return {'num': int(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.intToRoman(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.055",
            "memory": 4624,
            "stderr": null,
            "token": "f61b010f-a4e3-4ba9-a7e0-f260514ea584",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 13,
        "title": "roman-to-integer",
        "token": "793c3e01-be76-4ee5-bdfe-10bcb5fb998d",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def romanToInt(self, s: str) -> int:\n        m = {\n            'I': 1,\n            'V': 5,\n            'X': 10,\n            'L': 50,\n            'C': 100,\n            'D': 500,\n            'M': 1000\n        }\n        \n        ans = 0\n        \n        for i in range(len(s)):\n            if i < len(s) - 1 and m[s[i]] < m[s[i+1]]:\n                ans -= m[s[i]]\n            else:\n                ans += m[s[i]]\n        \n        return ans\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        \"\"\"\n        Generate a random test case input.\n        Limited range of test cases for simplicity.\n        \"\"\"\n        test_cases = [{'s': 'III'}, {'s': 'IV'}, {'s': 'IX'}, {'s': 'LVIII'}, {'s': 'XLIX'}, {'s': 'XC'}, {'s': 'CCCXC'}, {'s': 'CMXCIX'}, {'s': 'MCMXCIV'}, {'s': 'MMXXII'}]\n        return random.choice(test_cases)\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\"\n        Convert a test case input into a string.\n        \"\"\"\n        return input_obj['s']\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\"\n        Convert a test case output into a string.\n        \"\"\"\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\"\n        Convert a test case input string into a Python dict.\n        \"\"\"\n        return {'s': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.romanToInt(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.07",
            "memory": 4804,
            "stderr": null,
            "token": "793c3e01-be76-4ee5-bdfe-10bcb5fb998d",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "failure",
        "question_id": 113,
        "title": "path-sum-ii",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "failure",
        "question_id": 117,
        "title": "populating-next-right-pointers-in-each-node-ii",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "success",
        "question_id": 118,
        "title": "pascals-triangle",
        "token": "189b9a57-bf74-468f-bd6e-662eb2e59a8e",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def generate(self, numRows: int) -> List[List[int]]:\n        \n        if numRows == 1: return [[1]]\n        if numRows == 2: return [[1], [1, 1]]\n\n        prev_result = self.generate(numRows-1)\n        last_row = prev_result[-1]\n        new_result = [1]\n        for i in range(1, numRows-1):\n            new_result.append(last_row[i] + last_row[i-1])\n        new_result.append(1)\n        prev_result.append(new_result)\n        return prev_result\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        numRows = random.randint(1, 10)\n        return {'numRows': numRows}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['numRows'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'numRows': int(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.generate(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.061",
            "memory": 4788,
            "stderr": null,
            "token": "189b9a57-bf74-468f-bd6e-662eb2e59a8e",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 119,
        "title": "pascals-triangle-ii",
        "token": "332bd61b-c215-4d81-a402-a656a2843d7e",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def getRow(self, rowIndex: int) -> List[int]:\n        # \u5982\u679c\u53ea\u8981\u7b2c0\u5217\n        if rowIndex == 0:\n            return [1]\n\n        # \u5132\u5b58\u73fe\u5728\u9019\u5217\n        rowNums = [1,1]\n\n        for _ in range(1, rowIndex):\n            # \u65b0\u5217\n            newRow = [1]\n            for i in range(1, len(rowNums)):\n                newRow.append(rowNums[i]+rowNums[i-1])\n            rowNums = newRow + [1]\n        return rowNums\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        row_index = random.randint(0, 10)\n        return {'rowIndex': row_index}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['rowIndex']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'rowIndex': int(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.getRow(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.067",
            "memory": 4840,
            "stderr": null,
            "token": "332bd61b-c215-4d81-a402-a656a2843d7e",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 260,
        "title": "single-number-iii",
        "token": "a8a250aa-b361-496f-ab8c-65c8d83c9d5c",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport ast\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def singleNumber(self, nums: List[int]) -> List[int]:\n\n        nums.sort()\n        L = []\n\n        for num in nums:\n            if nums.count(num) == 1:\n                L.append(num)\n\n        return L\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        return {'nums': [4, 2, 2, 1, 4, 5, 1, 6]}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'nums': ast.literal_eval(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.singleNumber(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Input {'nums': [1, 1, 2, 2, 4, 4, 5, 6]}\nExpected Output:  [6, 5]\nActual Output:  [5, 6]\n1 Test Failed!\n",
            "time": "0.057",
            "memory": 4960,
            "stderr": null,
            "token": "a8a250aa-b361-496f-ab8c-65c8d83c9d5c",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 4,
                "description": "Wrong Answer"
            }
        }
    },
    {
        "status": "success",
        "question_id": 264,
        "title": "ugly-number-ii",
        "token": "42728eeb-1e5f-4d13-8598-d35dc5b9e3a9",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def nthUglyNumber(self, n: int) -> int:\n        \n        heap = [1]\n        count=1\n        while count<n:\n            smal = heappop(heap)\n            if smal*2 not in heap:\n                heappush(heap,smal*2)\n            if smal*3 not in heap:\n                heappush(heap,smal*3)\n            if smal*5 not in heap:\n                heappush(heap,smal*5)\n            count+=1\n        return heap[0]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 100)\n        return {'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.nthUglyNumber(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.067",
            "memory": 4848,
            "stderr": null,
            "token": "42728eeb-1e5f-4d13-8598-d35dc5b9e3a9",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 71,
        "title": "simplify-path",
        "token": "0a731bdc-4ab9-4588-8a6f-2482481c9c60",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def simplifyPath(self, path: str) -> str:\n        components = path.split('/')\n        stack = []\n        \n        for component in components:\n            if component == '' or component == '.':\n                continue\n            elif component == '..':\n                if stack:\n                    stack.pop()\n            else:\n                stack.append(component)\n        \n        simplified_path = '/' + '/'.join(stack)\n        return simplified_path\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        paths = ['/home/', '/home//foo/', '/home/user/Documents/../Pictures', '/../', '/.../a/../b/c/../d/./', '/a/b/c/../../', '/a/b//c/.././d', '/a/./b/./c/./d', '/a/b/c/././../..', '/a///b////c/']\n        random_path = random.choice(paths)\n        return {'path': random_path}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['path']\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        return {'path': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.simplifyPath(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.06",
            "memory": 4820,
            "stderr": null,
            "token": "0a731bdc-4ab9-4588-8a6f-2482481c9c60",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "failure",
        "question_id": 75,
        "title": "sort-colors",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "success",
        "question_id": 77,
        "title": "combinations",
        "token": "b243f829-6443-4f51-a736-fe1943bbf711",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def combine(self, n: int, k: int) -> List[List[int]]:\n        self.res = []\n\n        def dfs(tmp: List[int], start: int) -> None:\n            if len(tmp) == k:\n                self.res.append(tmp[::])\n            \n            if len(tmp) > k or start > n:\n                return\n            \n            for i in range(start, n + 1):\n                tmp.append(i)\n                dfs(tmp, i + 1)\n                tmp.pop()\n        \n        dfs([], 1)\n        return self.res\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        n = random.randint(1, 10)\n        k = random.randint(1, n)\n        return {'n': n, 'k': k}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['n']} {input_obj['k']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return ','.join(('[' + ','.join(map(str, combo)) + ']' for combo in output_obj))\n\n    def decode_input(self, input_str) -> dict:\n        n, k = map(int, input_str.split())\n        return {'n': n, 'k': k}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.combine(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.057",
            "memory": 4828,
            "stderr": null,
            "token": "b243f829-6443-4f51-a736-fe1943bbf711",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 80,
        "title": "remove-duplicates-from-sorted-array-ii",
        "token": "117cd138-7a1c-4dbb-9dce-24059606e452",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List, Dict\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        a=1\n        c=1\n        for i in range(1,len(nums)):\n            if(nums[i-1]==nums[i]):\n                if(c<2):\n                    c+=1\n                    nums[a]=nums[i]\n                    a+=1\n\n                else:\n                    continue    \n            else:\n                c=1\n                nums[a]=nums[i]\n                a+=1\n        return a\n\nclass TestCaseGenerator:\n\n    def generate(self) -> Dict[str, List[int]]:\n        \"\"\"\n        Generate a random test case input within a reasonable range\n        (based on the problem constraints) for invoking the entry_point function.\n        \"\"\"\n        length = random.randint(1, 100)\n        nums = []\n        for _ in range(length):\n            if nums and random.random() > 0.5:\n                nums.append(nums[-1])\n            else:\n                nums.append(nums[-1] + random.randint(1, 3) if nums else random.randint(-10, 10))\n        nums = self._limit_duplicates(nums)\n        return {'nums': nums}\n\n    def _limit_duplicates(self, nums: List[int]) -> List[int]:\n        \"\"\"\n        Make sure no number appears more than two times sequentially. Ensures input validity.\n        \"\"\"\n        result = []\n        count, current = (0, None)\n        for num in nums:\n            if num == current:\n                if count < 2:\n                    result.append(num)\n                    count += 1\n            else:\n                result.append(num)\n                current = num\n                count = 1\n        return result\n\n    def encode_input(self, input_obj: Dict[str, List[int]]) -> str:\n        \"\"\"\n        Convert a test case input into a JSON string representation.\n        \"\"\"\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj: int) -> str:\n        \"\"\"\n        Convert a test case output into a string.\n        \"\"\"\n        return str(output_obj)\n\n    def decode_input(self, input_str: str) -> Dict[str, List[int]]:\n        \"\"\"\n        Convert a test case input string into a Python dict with a numerical list.\n        \"\"\"\n        return {'nums': eval(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.removeDuplicates(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.061",
            "memory": 4884,
            "stderr": null,
            "token": "117cd138-7a1c-4dbb-9dce-24059606e452",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 21,
        "title": "merge-two-sorted-lists",
        "token": "52c77c21-721f-43b2-a5cb-7c8d3aa9bfa1",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import Optional\nfrom random import randint, choice\nfrom ast import literal_eval\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\n        cur = ListNode()\n        d = cur\n        while list1 and list2:\n            if list1.val < list2.val:\n                cur.next = list1\n                list1 = list1.next\n            else:\n                cur.next = list2\n                list2 = list2.next\n\n            cur = cur.next\n        if list1:\n            cur.next = list1\n        else:\n            cur.next = list2\n        return d.next\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        from random import randint, choice\n        length1 = randint(0, 10)\n        length2 = randint(0, 10)\n        list1 = sorted((randint(-100, 100) for _ in range(length1)))\n        list2 = sorted((randint(-100, 100) for _ in range(length2)))\n        return {'list1': self.build_linked_list(list1), 'list2': self.build_linked_list(list2)}\n\n    def build_linked_list(self, values):\n        head = ListNode(values[0]) if values else None\n        current = head\n        for val in values[1:]:\n            current.next = ListNode(val)\n            current = current.next\n        return head\n\n    def encode_input(self, input_obj) -> str:\n        return str((self.list_to_array(input_obj['list1']), self.list_to_array(input_obj['list2'])))\n\n    def list_to_array(self, node):\n        array = []\n        while node:\n            array.append(node.val)\n            node = node.next\n        return array\n\n    def encode_output(self, output_obj) -> str:\n        return str(self.list_to_array(output_obj))\n\n    def decode_input(self, input_str) -> dict:\n        from ast import literal_eval\n        list1, list2 = literal_eval(input_str)\n        return {'list1': self.build_linked_list(list1), 'list2': self.build_linked_list(list2)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.mergeTwoLists(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.063",
            "memory": 5172,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 139, in <module>\n    runner.run()\n  File \"script.py\", line 123, in run\n    output = self.solution.mergeTwoLists(**input)\n  File \"script.py\", line 56, in mergeTwoLists\n    cur = ListNode()\nTypeError: __init__() missing 1 required positional argument: 'x'\n",
            "token": "52c77c21-721f-43b2-a5cb-7c8d3aa9bfa1",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "success",
        "question_id": 27,
        "title": "remove-element",
        "token": "05882b69-ec29-4e85-ba58-5761fa32323d",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        if(len(nums) == 0):\n            return 0\n        i = 0\n        j = len(nums) - 1\n        while(i<j):\n            if(nums[j] == val):\n                j-=1\n                continue\n            if(nums[i] == val):\n                nums[i], nums[j] = nums[j], nums[i]\n                j-=1\n            i+=1\n        return i + (0 if nums[i] == val else 1)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        \"\"\"\n        Generate a random test case input to be used for invoking the\n        removeElement function.\n        \"\"\"\n        nums_length = random.randint(1, 100)\n        nums = [random.randint(0, 50) for _ in range(nums_length)]\n        val = random.randint(0, 50)\n        return {'nums': nums, 'val': val}\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\"\n        Convert a test case input dictionary into a string.\n        \"\"\"\n        nums_str = ','.join(map(str, input_obj['nums']))\n        val_str = str(input_obj['val'])\n        return f'nums=[{nums_str}],val={val_str}'\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\"\n        Convert a test case output into a string.\n        \"\"\"\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\"\n        Convert a test case input string into a Python dictionary.\n        \"\"\"\n        nums_part, val_part = input_str.split('],val=')\n        nums_str = nums_part.split('=')[1].strip('[]')\n        nums = list(map(int, nums_str.split(','))) if nums_str else []\n        val = int(val_part)\n        return {'nums': nums, 'val': val}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.removeElement(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.056",
            "memory": 4884,
            "stderr": null,
            "token": "05882b69-ec29-4e85-ba58-5761fa32323d",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 28,
        "title": "find-the-index-of-the-first-occurrence-in-a-string",
        "token": "936115da-1de5-46ec-afa1-ca546e79b8a5",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        for i in range(len(haystack)+1-len(needle)):\n            if haystack[i : i+len(needle)]==needle:\n                return i\n        return -1\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        cases = [{'haystack': 'sadbutsad', 'needle': 'sad'}, {'haystack': 'leetcode', 'needle': 'leeto'}, {'haystack': 'a' * 1000 + 'b', 'needle': 'a' * 500}, {'haystack': 'hello', 'needle': 'll'}, {'haystack': 'aaaaaa', 'needle': 'b'}]\n        return random.choice(cases)\n\n    def encode_input(self, input_obj) -> str:\n        return f\"haystack={input_obj['haystack']}, needle={input_obj['needle']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        parts = input_str.split(', ')\n        haystack = parts[0].split('=')[1]\n        needle = parts[1].split('=')[1]\n        return {'haystack': haystack, 'needle': needle}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.strStr(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.056",
            "memory": 4852,
            "stderr": null,
            "token": "936115da-1de5-46ec-afa1-ca546e79b8a5",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 29,
        "title": "divide-two-integers",
        "token": "7b64a796-a196-47bf-a365-664a0945b945",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def divide(self, dividend: int, divisor: int) -> int:\n        # Constants for 32-bit signed integer limits\n        INT_MAX, INT_MIN = 2**31 - 1, -2**31\n        \n        # Edge case for overflow\n        if dividend == INT_MIN and divisor == -1:\n            return INT_MAX\n        \n        # Determine the sign of the result\n        sign = (dividend < 0)!= (divisor < 0)\n        \n        # Work with absolute values\n        dividend, divisor = abs(dividend), abs(divisor)\n        \n        # Initialize the result\n        quotient = 0\n        \n        # The power of two divisor\n        power = 31\n        # The value of divisor shifted left\n        divisor_power = divisor << power\n        \n        # Subtract divisor multiples from dividend\n        while dividend >= divisor:\n            while divisor_power > dividend:\n                divisor_power >>= 1\n                power -= 1\n            dividend -= divisor_power\n            quotient += 1 << power\n        \n        # Apply the sign\n        if sign:\n            quotient = -quotient\n        \n        # Clamp the result within the 32-bit signed integer range\n        return min(max(quotient, INT_MIN), INT_MAX)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        dividend = random.randint(-1000, 1000)\n        divisor = random.randint(-1000, 1000)\n        while divisor == 0:\n            divisor = random.randint(-1000, 1000)\n        return {'dividend': dividend, 'divisor': divisor}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['dividend']}, {input_obj['divisor']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        dividend, divisor = map(int, input_str.split(','))\n        return {'dividend': dividend, 'divisor': divisor}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.divide(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.058",
            "memory": 4820,
            "stderr": null,
            "token": "7b64a796-a196-47bf-a365-664a0945b945",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 30,
        "title": "substring-with-concatenation-of-all-words",
        "token": "17b9ea6b-6395-4382-889c-6e1054b9413a",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        n = len(words)\n        k = len(words[0])\n        words_counts = Counter(words)\n        l = n * k\n\n        indices = []\n        for i in range(len(s) - l + 1):\n            if Counter(\n                s[i + j * k: i + (j + 1) * k] for j in range(n)\n            ) == words_counts:\n                indices.append(i)\n\n        return indices\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 50)\n        num_words = random.randint(1, 5)\n        word_length = random.randint(1, 5)\n        s = ''.join((random.choice('abcdefghijklmnopqrstuvwxyz') for _ in range(n)))\n        words = [''.join((random.choice('abcdefghijklmnopqrstuvwxyz') for _ in range(word_length))) for _ in range(num_words)]\n        return {'s': s, 'words': words}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"s={input_obj['s']};words={input_obj['words']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return ','.join(map(str, output_obj))\n\n    def decode_input(self, input_str) -> dict:\n        parts = input_str.split(';')\n        s = parts[0].split('=')[1]\n        words = parts[1].split('=')[1].strip('[]').replace('\"', '').split(',')\n        return {'s': s, 'words': words}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.findSubstring(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.064",
            "memory": 4816,
            "stderr": null,
            "token": "17b9ea6b-6395-4382-889c-6e1054b9413a",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 62,
        "title": "unique-paths",
        "token": "881ca5fd-988f-4a23-a241-913d7421c386",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport math\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        numberOfWays = [[0] * n for _ in range(m)]\n        numberOfWays[0][0] = 1\n\n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j == 0:\n                    numberOfWays[i][j] = 1\n                elif i == 0:\n                    numberOfWays[i][j] = numberOfWays[i][j-1]\n                elif j == 0:\n                    numberOfWays[i][j] = numberOfWays[i-1][j]\n                else:\n                    numberOfWays[i][j] = numberOfWays[i-1][j] + numberOfWays[i][j-1]\n    \n        return numberOfWays[-1][-1]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        m = random.randint(1, 100)\n        n = random.randint(1, 100)\n        return {'m': m, 'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['m']} {input_obj['n']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        m, n = map(int, input_str.split())\n        return {'m': m, 'n': n}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.uniquePaths(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.07",
            "memory": 5128,
            "stderr": null,
            "token": "881ca5fd-988f-4a23-a241-913d7421c386",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 64,
        "title": "minimum-path-sum",
        "token": "a23b7e06-480b-496e-a141-362a58df1373",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\nimport json\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        if not grid or not grid[0]:\n            return 0\n        \n        m, n = len(grid), len(grid[0])\n        \n        # Initialize the dp table\n        dp = [[0] * n for _ in range(m)]\n        \n        # Base case: starting point\n        dp[0][0] = grid[0][0]\n        \n        # Fill the first row\n        for j in range(1, n):\n            dp[0][j] = dp[0][j-1] + grid[0][j]\n        \n        # Fill the first column\n        for i in range(1, m):\n            dp[i][0] = dp[i-1][0] + grid[i][0]\n        \n        # Fill the rest of the dp table\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])\n        \n        # The bottom-right corner has the result\n        return dp[m-1][n-1]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        m = random.randint(1, 10)\n        n = random.randint(1, 10)\n        grid = [[random.randint(0, 200) for _ in range(n)] for _ in range(m)]\n        return {'grid': grid}\n\n    def encode_input(self, input_obj) -> str:\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return json.loads(input_str)\n\n    def decode_output(self, output_str) -> int:\n        return int(output_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.minPathSum(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.059",
            "memory": 4864,
            "stderr": null,
            "token": "a23b7e06-480b-496e-a141-362a58df1373",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 65,
        "title": "valid-number",
        "token": "6f8267e6-5e08-48e1-a7b6-dae4c09073dc",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport string\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def isNumber(self, s: str) -> bool:\n        \"\"\"\n        2\n        0089\n        -0.1\n        +3.14\n        4.\n        -.9\n        2e10\n        -90E3\n\n        Integer followed by optional exponent\n        decimal with optional exponent\n        integer is defined wtih - or +\n        followed by digits\n        \n        This is Integer to English words vibe question.\n        all possible characters we have\n        [0-9]\n       .\n        e,E\n        -, +\n\n        [0,9] can occur anywhere.\n       . cannot occur while defining an exponent like 99e2.5\n\n        e/E cannot occur \n            - if there is no num before it \n            - after it there is no {-,+}[0-9]\n        \n        - and + cannot occur if there is a - or + before it or after.\n        anything else is invalid \n\n        but how many cases can we have\n\n        what about 2e2e2? CONFIRMED INVALID\n        - given 2e2.5 is invalid this may also be invalid\n        - it's possible its not tho\n\n        1. splitting at E should give 2 non-empty elements.\n            - it may not matter if its 3 elements\n            - but if its less than 2 its invalid\n            because it's either e3 or 3e. both invalid\n            for each string:\n                check the - and + \n                check the. \n                    this can only happen in the first element.\n                    remember 2.5e is invalid. but 2.5e3 is not\n        \n        and assumption is are we allowed to modify the input?\n        because if we can I can convert it to all lowercase then split at \"e\"\n        otherwise we have to split at either (might be possible)\n\n        \"\"\"\n        s = s.replace(\"E\",\"e\")\n        elems = s.split(\"e\")\n        # FOR THIS CASE \"92e1740e91\"\n        if len(elems) > 2:\n            return False \n    \n        for i in range(len(elems)):\n            cur_num = elems[i]\n            # eitehr e3 or 3e case\n            if cur_num == \"\":\n                return False\n            # check this number\n            found_dot = False\n\n            for j in range(len(cur_num)):\n                # -12-1 also invalid\n                # + by itself is invalid\n                # need to have num after it\n                if cur_num[j] in {\"+\",\"-\"}:\n                    # if its not at the start has to be invalid\n                    if j!= 0 or len(cur_num) == 1: \n                        return False\n                # 2.2.2 also invalid tho\n                #. by itself is invalid\n                #.+ is invalid handled above\n                # +. is invalid\n                #+.8 is valid\n                # if prev is a + or -, next is not a number then invalid\n                elif cur_num[j] == \".\":\n                    if (found_dot or len(cur_num) == 1 or i!= 0):\n                        return False\n                    if j > 0:\n                        prev = cur_num[j-1]\n                        if (prev in {\"+\",\"-\"}):\n                            if j == len(cur_num)-1:\n                                return False\n                            elif not cur_num[j+1].isnumeric():\n                                return False\n                    found_dot = True\n\n\n                elif not cur_num[j].isnumeric():\n                    return False\n            \n        return True\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        import string\n        case_type = random.choice(['valid', 'invalid'])\n        valid_chars = string.digits + '+-' + 'eE' + '.'\n        invalid_chars = string.ascii_letters + ''.join(set(valid_chars) - set(string.digits))\n        if case_type == 'valid':\n            return {'s': random.choice(['', '+', '-']) + str(random.randint(0, 999)) + random.choice(['', '.', '.']) + ''.join(random.choices(string.digits, k=random.randint(0, 3))) + random.choice(['', 'e', 'E']) + random.choice(['', '+', '-']) + ''.join(random.choices(string.digits, k=random.randint(0, 3)))}\n        else:\n            return {'s': ''.join(random.choices(valid_chars + invalid_chars, k=random.randint(1, 20)))}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['s']\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\n    def decode_output(self, output_str) -> bool:\n        return output_str == 'True'\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.isNumber(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.061",
            "memory": 4760,
            "stderr": null,
            "token": "6f8267e6-5e08-48e1-a7b6-dae4c09073dc",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 66,
        "title": "plus-one",
        "token": "3a4ed420-2c3c-4f08-88d8-0282543feb2b",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom ast import literal_eval\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def plusOne(self, digits: List[int]) -> List[int]:\n        n=len(digits)\n        for i  in range(n-1,-1,-1):\n            if digits[i]<9:\n                digits[i]+=1\n                return digits\n            else:\n                digits[i]=0\n        return [1]+digits\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 10)\n        digits = [random.randint(1, 9)] + [random.randint(0, 9) for _ in range(n - 1)]\n        return {'digits': digits}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['digits'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'digits': literal_eval(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.plusOne(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.065",
            "memory": 5140,
            "stderr": null,
            "token": "3a4ed420-2c3c-4f08-88d8-0282543feb2b",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 67,
        "title": "add-binary",
        "token": "780e782f-1491-4a85-9843-851eced446a4",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def addBinary(self, a: str, b: str) -> str:\n        i= len(a)-1\n        j= len(b)-1\n\n        car=0\n        sol=\"\"\n        while i >= 0 or j >= 0 or car:\n            digit_a = int(a[i]) if i >= 0 else 0\n            digit_b = int(b[j]) if j >= 0 else 0\n            \n            total = digit_a + digit_b + car\n            sol+=str(total % 2)\n            car = total // 2  \n\n            i-=1\n            j-=1\n        return sol[::-1]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length_a = random.randint(1, 15)\n        length_b = random.randint(1, 15)\n        a = ''.join((random.choice('01') for _ in range(length_a)))\n        b = ''.join((random.choice('01') for _ in range(length_b)))\n        return {'a': a, 'b': b}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['a']},{input_obj['b']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        a, b = input_str.split(',')\n        return {'a': a, 'b': b}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.addBinary(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Input {'a': '010011110', 'b': '0010111100'}\nExpected Output:  101011010\nActual Output:  0101011010\n4 Test Failed!\n",
            "time": "0.065",
            "memory": 4840,
            "stderr": null,
            "token": "780e782f-1491-4a85-9843-851eced446a4",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 4,
                "description": "Wrong Answer"
            }
        }
    },
    {
        "status": "success",
        "question_id": 69,
        "title": "sqrtx",
        "token": "1097c593-0088-4156-a8d1-5fa75064fbb4",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport json\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def mySqrt(self, x: int) -> int:\n        if x == 0 or x == 1:\n            return x\n        for i in range(1, x+1):\n            if x/i < i:\n                return i-1\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        x = random.randint(0, 1000000)\n        return {'x': x}\n\n    def encode_input(self, input_obj) -> str:\n        import json\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        import json\n        return json.dumps({'result': output_obj})\n\n    def decode_input(self, input_str) -> dict:\n        import json\n        return json.loads(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.mySqrt(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.081",
            "memory": 6992,
            "stderr": null,
            "token": "1097c593-0088-4156-a8d1-5fa75064fbb4",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 70,
        "title": "climbing-stairs",
        "token": "c432c884-1959-4610-8b79-a5e1a8d7a855",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom functools import cache\nimport random\n\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def climbStairs(self, n: int) -> int:\n        return self._dfs(n, {})\n\n    def _dfs(self, n: int, memo: dict[int, int]):\n        if n == 0 or n == 1:\n            return 1\n        if n not in memo:\n            memo[n] = self._dfs(n - 1, memo) + self._dfs(n - 2, memo)\n        return memo[n]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        return {'n': random.randint(1, 10)}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['n'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'n': int(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.climbStairs(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.08",
            "memory": 6428,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 26, in <module>\n    from functools import cache\nImportError: cannot import name 'cache' from 'functools' (/usr/local/python-3.8.1/lib/python3.8/functools.py)\n",
            "token": "c432c884-1959-4610-8b79-a5e1a8d7a855",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "failure",
        "question_id": 51,
        "title": "n-queens",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "success",
        "question_id": 52,
        "title": "n-queens-ii",
        "token": "fe7c9c67-63cd-4e4e-9527-b67fc801479b",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def totalNQueens(self, n: int) -> int:\n        board = [[0] * n for _ in range(n)]\n        count = 0\n\n        def helper(row):\n            nonlocal count\n\n            if row == n:\n                count+=1\n                return\n\n            for c in range(len(board[row])):\n                can = True\n\n                for r in range(row):\n                    for j in range(len(board[r])):\n                        if board[r][j] == 0:\n                            continue\n                        if j == c:\n                            can = False\n                            break\n                        if abs(j-c) == (row - r):\n                            can = False\n                            break\n\n                if can:\n                    board[row][c] = 1\n                    helper(row+1)\n                    board[row][c] = 0\n\n        helper(0)\n        return count\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 9)\n        return {'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['n'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'n': int(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.totalNQueens(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "2.467",
            "memory": 5652,
            "stderr": null,
            "token": "fe7c9c67-63cd-4e4e-9527-b67fc801479b",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 53,
        "title": "maximum-subarray",
        "token": "57b5efa0-5204-4240-8e10-7eb1ed159f55",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        maxSum = float('-inf') # initialize maxSum is -infinity which is the lowest of any number \n        currentSum = 0\n        \n        for num in nums:\n            currentSum += num\n            \n            if currentSum > maxSum:\n                maxSum = currentSum\n            \n            if currentSum < 0:\n                currentSum = 0\n        \n        return maxSum\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        \"\"\"\n        Generate a random test case input for the maxSubArray function.\n        :return: A dictionary with 'nums' as key and list of integers as value.\n        \"\"\"\n        length = random.randint(1, 100)\n        nums = [random.randint(-10000, 10000) for _ in range(length)]\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\"\n        Convert a test case input into a string (JSON-like format).\n        :param input_obj: A dictionary with 'nums' as key.\n        :return: A string representation of 'nums'\n        \"\"\"\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\"\n        Convert a test case output into a string.\n        :param output_obj: The output value to be encoded.\n        :return: A string representation of the output.\n        \"\"\"\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\"\n        Convert a test case input string into a Python dict.\n        :param input_str: The input string to decode.\n        :return: A dictionary with 'nums' as key.\n        \"\"\"\n        nums = eval(input_str)\n        return {'nums': nums}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.maxSubArray(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.077",
            "memory": 6072,
            "stderr": null,
            "token": "57b5efa0-5204-4240-8e10-7eb1ed159f55",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 55,
        "title": "jump-game",
        "token": "f4f10255-4afc-4eae-86d3-66e91ed2abe2",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List, Dict\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def canJump(self, nums: List[int]) -> bool:\n        dp = [0]*len(nums)\n        dp[0] = 1\n        for i in range(len(nums)):\n            if dp[i]==0:\n                return False\n            \n            for j in range(nums[i]):\n                if i+j+1 < len(dp):\n                    dp[i+j+1] = 1\n            \n                if dp[-1]==1:\n                    return True\n        \n        return True\n\nclass TestCaseGenerator:\n\n    def generate(self) -> Dict[str, List[int]]:\n        nums_length = random.randint(1, 20)\n        nums = [random.randint(0, 5) for _ in range(nums_length)]\n        return {'nums': nums}\n\n    def encode_input(self, input_obj: Dict[str, List[int]]) -> str:\n        return ','.join(map(str, input_obj['nums']))\n\n    def encode_output(self, output_obj: bool) -> str:\n        return 'true' if output_obj else 'false'\n\n    def decode_input(self, input_str: str) -> Dict[str, List[int]]:\n        nums = list(map(int, input_str.split(',')))\n        return {'nums': nums}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.canJump(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.064",
            "memory": 4780,
            "stderr": null,
            "token": "f4f10255-4afc-4eae-86d3-66e91ed2abe2",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 58,
        "title": "length-of-last-word",
        "token": "2354fbe2-f6cc-4bd2-8d1a-76212989cfb4",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def lengthOfLastWord(self, s: str) -> int:\n        r=len(s)\n        k=r\n        count=0\n        while(k>0 and s[k-1]==\" \"):\n            k-=1\n        if k==0:\n            return 0\n        for i in range(k-1,-1,-1):\n            if s[i]!=\" \":\n                count+=1\n            else:\n                break\n        return count\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        words = ['abcdefghijklmnopqrstuvwxyz', 'hello', 'world', 'moon', 'joyboy']\n        sentence = ' '.join(random.choices(words, k=random.randint(1, 5)))\n        sentence = sentence.rjust(len(sentence) + random.randint(0, 5))\n        sentence = sentence.ljust(len(sentence) + random.randint(0, 5))\n        return {'s': sentence.strip()}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['s']\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\n    def decode_output(self, output_str) -> int:\n        return int(output_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.lengthOfLastWord(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.069",
            "memory": 4836,
            "stderr": null,
            "token": "2354fbe2-f6cc-4bd2-8d1a-76212989cfb4",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 60,
        "title": "permutation-sequence",
        "token": "009b3bb1-4dd5-424b-b062-901b8891301d",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport math\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def getPermutation(self, n: int, k: int) -> str:\n        def nextPermutation(lst):\n            if len(lst)==1:\n                return lst\n            else:\n                e=len(lst)-1\n                b=[]\n                while (lst[e]<=lst[e-1]):\n                    b.append(lst[e])\n                    e=e-1\n                    if e==0:\n                        return []\n                b.append(lst[e])\n                b.append(lst[e-1])\n                pivot=lst[e-1]\n                min_next=max(lst)+1\n                for element in b:\n                    if element > pivot and element<min_next:\n                        min_next=element\n                m=lst[0:e-1]\n                m.append(min_next)\n                b.remove(min_next)\n                b.sort()\n                for e in b:\n                    m.append(e)\n                return m\n        if n==1:\n            return str(n)\n        else:\n            nums=[]\n            for i in range(1,n+1):\n                nums.append(i)\n            count=1\n            while(count<k):\n                nums=nextPermutation(nums)\n                count+=1\n            s=''\n            for elem in nums:\n                s+=str(elem) \n        return s\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 9)\n        k = random.randint(1, math.factorial(n))\n        return {'n': n, 'k': k}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['n']},{input_obj['k']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        n, k = map(int, input_str.split(','))\n        return {'n': n, 'k': k}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.getPermutation(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.086",
            "memory": 4880,
            "stderr": null,
            "token": "009b3bb1-4dd5-424b-b062-901b8891301d",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 282,
        "title": "expression-add-operators",
        "token": "b67011f8-aeca-4b42-b5f4-062148327d57",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def addOperators(self, num: str, target: int) -> List[str]:\n        def eval_expr(expr: str):\n            s = ''\n            m = 1\n            part_expr = ''\n            for c in expr:\n                if c.isdigit(): \n                    s += c\n                elif c == '+':\n                    part_expr = part_expr + str(int(s)*m) + '+'\n                    s = ''\n                    m = 1\n                elif c == '-': \n                    part_expr = part_expr + str(int(s)*m) + '-'                    \n                    s = ''\n                    m = 1\n                elif c == '*':\n                    m = m * int(s)\n                    s = ''\n                    \n            if s: part_expr = part_expr + str(int(s)*m)\n            \n            i = 0\n            v = 0\n            s = ''\n            last_sign = ''\n            for i in range(len(part_expr)+1):\n                if i < len(part_expr) and part_expr[i].isdigit(): \n                    s += part_expr[i]\n                else: \n                    if not last_sign: \n                        v = int(s)\n                        s = ''\n                    elif last_sign == '+':\n                        v += int(s)\n                        s = ''\n                    else:\n                        v -= int(s)\n                        s = ''\n                    if i < len(part_expr):\n                        last_sign = part_expr[i]\n            return v\n        \n        def validate(expr):\n            prev = ''\n            check = False\n            cnt = 0\n            for v in expr:\n                if not prev.isdigit():\n                    if v == '0': check = True\n                    else: \n                        check = False\n                        cnt = 0\n                if v.isdigit() and check: cnt += 1\n                else:\n                    check = False\n                    cnt = 0\n                if cnt == 2: return False\n                prev = v\n            return True\n        \n        def find_expressions(available):\n            if not available: return ''\n            if len(available) == 1: return available[0]\n            exps = []\n            c = available.pop()\n            for expr in find_expressions(available):\n                exps.append(expr + c)\n                exps.append(expr + '+' + c)\n                exps.append(expr + '-' + c)\n                exps.append(expr + '*' + c)\n            return exps\n\n        ret = []\n        available = list(num)\n        for expr in find_expressions(available):\n            if eval_expr(expr) == target and validate(expr): ret.append(expr)\n\n        return ret\n\nclass TestCaseGenerator:\n    import random\n\n    def generate(self) -> dict:\n        nums = ['123', '232', '3456237490', '105', '00', '9999']\n        targets = [6, 8, 9191, 5, 0, 27]\n        test_index = self.random.randint(0, len(nums) - 1)\n        return {'num': nums[test_index], 'target': targets[test_index]}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"num = '{input_obj['num']}', target = {input_obj['target']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return ', '.join(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        parts = input_str.split(', ')\n        num = parts[0].split('=')[1].strip().strip(\"'\")\n        target = int(parts[1].split('=')[1].strip())\n        return {'num': num, 'target': target}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.addOperators(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "5.017",
            "memory": 32764,
            "stderr": null,
            "token": "b67011f8-aeca-4b42-b5f4-062148327d57",
            "compile_output": null,
            "message": "Time limit exceeded",
            "status": {
                "id": 5,
                "description": "Time Limit Exceeded"
            }
        }
    },
    {
        "status": "success",
        "question_id": 283,
        "title": "move-zeroes",
        "token": "18b35538-13d9-4a78-ba0d-466aa7eecf45",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def moveZeroes(self, nums: List[int]) -> None:\n        n = len(nums)\n        for i in range(n):\n            if nums[i]==0:\n                for j in range(i,n):\n                    if nums[j]!=0:\n                        nums[i],nums[j]=nums[j],nums[i]\n                        break\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        test_case = {'nums': [random.choice(range(-10, 10)) for _ in range(random.randint(1, 20))]}\n        return test_case\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        nums = eval(input_str)\n        return {'nums': nums}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.moveZeroes(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.061",
            "memory": 5180,
            "stderr": null,
            "token": "18b35538-13d9-4a78-ba0d-466aa7eecf45",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "failure",
        "question_id": 336,
        "title": "palindrome-pairs",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "success",
        "question_id": 338,
        "title": "counting-bits",
        "token": "b0ceafb7-0d05-409e-a364-ba60228cc8bd",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def countBits(self, n: int) -> List[int]:\n        answ = []\n        for j in range(n+1):\n            i = j\n            count = 0\n            while i >= 1:\n                if i%2 == 1:\n                    count += 1\n                    i = (i-1)//2\n                else:\n                    i = i // 2\n            answ.append(count)\n        return answ\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(0, 1000)\n        return {'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['n'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        n = int(input_str)\n        return {'n': n}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.countBits(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.085",
            "memory": 5700,
            "stderr": null,
            "token": "b0ceafb7-0d05-409e-a364-ba60228cc8bd",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 342,
        "title": "power-of-four",
        "token": "734fc891-5a2b-46a0-be5d-a8b61c51bc11",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def isPowerOfFour(self, n: int) -> bool:\n        if n<=0:\n            return False\n        while n%4==0:\n            n//=4\n        return n==1\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        test_values = [1, 4, 16, 64, 256, 1024, 5, 12, 20, 50, 100, -4, 0, random.randint(-500, 500)]\n        n = random.choice(test_values)\n        return {'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['n'])\n\n    def encode_output(self, output_obj) -> str:\n        return 'true' if output_obj else 'false'\n\n    def decode_input(self, input_str) -> dict:\n        return {'n': int(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.isPowerOfFour(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.048",
            "memory": 4780,
            "stderr": null,
            "token": "734fc891-5a2b-46a0-be5d-a8b61c51bc11",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 345,
        "title": "reverse-vowels-of-a-string",
        "token": "bd10fad0-9b9c-4aed-b0d2-66d802aa190a",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\n\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def reverseVowels(self, s: str) -> str:\n        buf = list(s)\n        myset = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        vowels = []\n        indexs = []\n\n        for i in range(len(s)):\n            if s[i] in myset:\n                vowels.append(s[i])\n                indexs.insert(0, i)\n        \n        for i in range(len(indexs)):\n            buf[indexs[i]] = vowels[i]\n        \n        answer = ''.join(buf)\n        return answer\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        return {'s': 'ExampleTestString'}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['s']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.reverseVowels(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.052",
            "memory": 4668,
            "stderr": null,
            "token": "bd10fad0-9b9c-4aed-b0d2-66d802aa190a",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 389,
        "title": "find-the-difference",
        "token": "05bb0f1b-4ba7-4a4e-a10f-2f415365aac6",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def findTheDifference(self, s: str, t: str) -> str:\n        s_sum = sum(ord(c) for c in s)\n        t_sum = sum(ord(c) for c in t)\n        return chr(t_sum - s_sum)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        alphabets = 'abcdefghijklmnopqrstuvwxyz'\n        length = random.randint(0, 1000)\n        s = ''.join(random.choices(alphabets, k=length))\n        added_char = random.choice(alphabets)\n        t_list = list(s)\n        random.shuffle(t_list)\n        insert_position = random.randint(0, length)\n        t_list.insert(insert_position, added_char)\n        t = ''.join(t_list)\n        return {'s': s, 't': t}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['s']} {input_obj['t']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        s, t = input_str.split()\n        return {'s': s, 't': t}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.findTheDifference(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.069",
            "memory": 5060,
            "stderr": null,
            "token": "05bb0f1b-4ba7-4a4e-a10f-2f415365aac6",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 391,
        "title": "perfect-rectangle",
        "token": "b4318fde-d0b1-49d6-b3df-a425e7b06130",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport numpy as np\nfrom typing import List\nimport ast\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\n        x1 = y1 = 10 ** 5 + 1\n        x2 = y2 = -10 ** 5 - 1\n        area = 0\n        s = set()\n        for x, y, a, b in rectangles:\n            x1, y1 = min(x1, x), min(y1, y)\n            x2, y2 = max(x2, a), max(y2, b)\n            area += (a - x) * (b - y)\n            \n            for i, j in itertools.product([x, a], [y, b]): s ^= {(i, j)}\n        if (x1, y1) not in s or \\\n            (x1, y2) not in s or \\\n            (x2, y1) not in s or \\\n            (x2, y2) not in s or \\\n            len(s)!= 4 \\\n            or (x2 - x1) * (y2 - y1)!= area: return False\n        return True\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        test_cases = [{'rectangles': [[1, 1, 3, 3], [3, 1, 4, 2], [3, 2, 4, 4], [1, 3, 2, 4], [2, 3, 3, 4]]}, {'rectangles': [[1, 1, 2, 3], [1, 3, 2, 4], [3, 1, 4, 2], [3, 2, 4, 4]]}, {'rectangles': [[1, 1, 3, 3], [3, 1, 4, 2], [1, 3, 2, 4], [2, 2, 4, 4]]}]\n        return test_cases[0]\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        import ast\n        return ast.literal_eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.isRectangleCover(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.064",
            "memory": 4684,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 26, in <module>\n    import numpy as np\nModuleNotFoundError: No module named 'numpy'\n",
            "token": "b4318fde-d0b1-49d6-b3df-a425e7b06130",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "success",
        "question_id": 392,
        "title": "is-subsequence",
        "token": "fa3f9bba-f4b5-46c0-a1af-7430e4cb5cf8",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport string\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def isSubsequence(self, s: str, t: str) -> bool:\n        s_position = 0\n        if len(s) == 0:\n            return True\n        for i in range(len(t)):\n            if t[i] == s[s_position]:\n                s_position += 1\n            if s_position == len(s):\n                return True\n        return False\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        \"\"\"\n        Generates a test case with randomly generated strings s and t.\n        \"\"\"\n        import random\n        import string\n        t = ''.join((random.choice(string.ascii_lowercase) for _ in range(random.randint(1, 1000))))\n        if random.choice([True, False]):\n            s = ''.join(random.sample(t, random.randint(0, len(t))))\n        else:\n            s = ''.join((random.choice(string.ascii_lowercase) for _ in range(random.randint(0, min(100, len(t))))))\n        return {'s': s, 't': t}\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\"\n        Encodes the input dictionary into a string format.\n        \"\"\"\n        return f\"{input_obj['s']}::{input_obj['t']}\"\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\"\n        Encodes the output object into a string format (true/false as a string).\n        \"\"\"\n        return str(output_obj).lower()\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\"\n        Decodes the input string back into a dictionary with keys 's' and 't'.\n        \"\"\"\n        s, t = input_str.split('::')\n        return {'s': s, 't': t}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.isSubsequence(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.066",
            "memory": 5016,
            "stderr": null,
            "token": "fa3f9bba-f4b5-46c0-a1af-7430e4cb5cf8",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 479,
        "title": "largest-palindrome-product",
        "token": "3b19dbfd-e0a4-4a69-9b5d-275a0f5bf7e4",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport math\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def largestPalindrome(self, n: int) -> int:\n        if n == 1: return 9\n        upper = int('9'*n)\n        lower = int('9'*(n-1))\n        \n        firstHalf = upper\n\n        while True:\n            pal = int(str(firstHalf) + str(firstHalf)[::-1])\n            for div in range(upper, lower, -1):\n                if div * div < pal or pal / div > upper:\n                    break\n                if pal % div == 0:\n                    return pal % 1337\n            firstHalf -= 1\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        n = random.randint(1, 8)\n        return {'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['n'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'n': int(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.largestPalindrome(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "1.792",
            "memory": 4848,
            "stderr": null,
            "token": "3b19dbfd-e0a4-4a69-9b5d-275a0f5bf7e4",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 483,
        "title": "smallest-good-base",
        "token": "05b13dda-5578-4262-8610-297a8c84c24b",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport math\nimport time\nfrom fractions import Fraction\nfrom random import randint\n\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def smallestGoodBase(self, n: str) -> str:\n        import math\n        import time\n        from fractions import Fraction\n\n        n = int(n)\n\n        def f(u, n, x):\n            a = 0\n            for i in range(n + 1):\n                a += u**i\n            a -= x\n            return a\n\n        def candidates(x):\n            Z = set()\n            L = 6\n            for m in range(1, L + 1):\n                a = 0\n                b = x\n                z = 0\n                while (True):\n                    z = Fraction(a + b, 2)\n                    if (f(z, m, x) < -0.1):\n                        a = z\n                    elif (f(z, m, x) > 0.1):\n                        b = z\n                    else:\n                        z = int(round(z))\n                        if (f(z, m, x) == 0):\n                            Z.add(z)\n                        break\n            if (min(Z) == 1):\n                Z.pop()\n            return min(Z)\n\n        for b in range(2, 1201):\n            y = n\n            g = 1\n            while (y!= 0):\n                if (y % b!= 1):\n                    g = 0\n                    break\n                else:\n                    y //= b\n            if (g == 1):\n                return str(b)\n\n        return str(candidates(n))\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        \"\"\"Generate a random test case.\"\"\"\n        n = randint(3, 100000)\n        return {'n': str(n)}\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\"\n        Convert a test case input into a string.\n        :param input_obj: Dictionary with the input object.\n        :return: String representation of the input object.\n        \"\"\"\n        return input_obj['n']\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\"\n        Convert a test case output into a string.\n        :param output_obj: The output which is a good base.\n        :return: String representation of the output object.\n        \"\"\"\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\"\n        Convert a test case input string into a dictionary.\n        :param input_str: String representation of the input.\n        :return: Dictionary with the input object.\n        \"\"\"\n        return {'n': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.smallestGoodBase(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.26",
            "memory": 5532,
            "stderr": null,
            "token": "05b13dda-5578-4262-8610-297a8c84c24b",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "failure",
        "question_id": 485,
        "title": "max-consecutive-ones",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "failure",
        "question_id": 410,
        "title": "split-array-largest-sum",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "success",
        "question_id": 414,
        "title": "third-maximum-number",
        "token": "cf6357b7-b7b4-4712-be5b-90d2c3634e93",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport json\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def thirdMax(self, nums: List[int]) -> int:\n        sets=set(nums)\n        nums2=list(sets)\n        if(len(nums2)>=3): \n            nums2.sort()\n            nums2.remove(max(nums2))\n            nums2.remove(max(nums2))\n            x=len(nums2)\n            return nums2[x-1]\n        elif(len(nums2)==2):\n            nums2.sort()\n            x=len(nums2)\n            return nums2[x-1]\n        elif(len(nums2)==1):\n            return nums2[0]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        nums_length = random.randint(1, 100)\n        nums = [random.randint(-2 ** 31, 2 ** 31 - 1) for _ in range(nums_length)]\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return json.loads(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.thirdMax(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.068",
            "memory": 4932,
            "stderr": null,
            "token": "cf6357b7-b7b4-4712-be5b-90d2c3634e93",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 472,
        "title": "concatenated-words",
        "token": "abc145c3-3668-432c-a670-edf5d5b67df4",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nfrom functools import cache\nimport json\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    class Trie:\n        def __init__(self, words):\n            self.root = {}\n            for word in words:\n                curr = self.root\n                for c in word:\n                    if c not in curr:\n                        curr[c] = {}\n                    curr = curr[c]\n                curr[\"$\"] = None\n\n        def dfs_find_compounds(self, word):\n            compounds = []\n\n            def loop(curr, i, word_count):\n                if i >= len(word):\n                    return False\n                if word[i] not in curr:\n                    return False\n                curr = curr[word[i]]\n                if \"$\" in curr:\n                    if word_count >= 1 and i == len(word) - 1:\n                        return True\n\n                    if loop(self.root, i + 1, word_count + 1):\n                        return True\n                return loop(curr, i + 1, word_count)\n\n            return loop(self.root, 0, 0)\n\n    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\n        compounds = {}\n        word_set = set(words)\n\n        def is_compound(word):\n            if word in compounds:\n                return compounds[word]\n            for i in range(1, len(word)):\n                prefix, suffix = word[:i], word[i:]\n                if (prefix in word_set or is_compound(prefix)) and (\n                    suffix in word_set or is_compound(suffix)\n                ):\n                    compounds[word] = True\n                    return True\n            compounds[word] = False\n            return False\n        return [w for w in sorted(words, key=len) if is_compound(w)]\n            \n\n        # words.sort(key=len)\n        # letters = set()\n        # for w in words:\n        #     if len(w) == 1:\n        #         letters.add(w)\n        #         if len(letters) == 26:\n        #             break\n        #     else:\n        #         break\n\n        # if lolz and len(letters) == 25:\n        #     return sorted(w for w in words[25:] if not w.endswith('z'))\n\n        # trie = Solution.Trie(words)\n        # return [w for w in words if trie.dfs_find_compounds(w)]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        test_cases = [{'words': ['cat', 'cats', 'catsdogcats', 'dog', 'dogcatsdog', 'hippopotamuses', 'rat', 'ratcatdogcat']}, {'words': ['cat', 'dog', 'catdog']}, {'words': ['apple', 'banana', 'applebanana', 'bananaapple']}, {'words': ['a', 'b', 'c', 'abc', 'bc', 'cab', 'ac', 'abcab']}]\n        return test_cases[0]\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\" Convert a test case input into a JSON string \"\"\"\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\" Convert a test case output into a JSON string \"\"\"\n        return json.dumps(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\" Convert a test case input string back into a Python dict \"\"\"\n        return json.loads(input_str)\n\n    def decode_output(self, output_str) -> list:\n        \"\"\" Convert a test case output string back into a Python list \"\"\"\n        return json.loads(output_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.findAllConcatenatedWordsInADict(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.055",
            "memory": 4684,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 27, in <module>\n    from functools import cache\nImportError: cannot import name 'cache' from 'functools' (/usr/local/python-3.8.1/lib/python3.8/functools.py)\n",
            "token": "abc145c3-3668-432c-a670-edf5d5b67df4",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "success",
        "question_id": 476,
        "title": "number-complement",
        "token": "84862d5b-9449-4d0d-972d-00b40bd4aa7c",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution(object):\n    def findComplement(self, num):\n        \n        compliment = 1\n        while compliment <= num:\n            compliment = compliment << 1\n        \n        leftCompliment=compliment - 1\n        compliment=(leftCompliment) ^ num\n        \n        return compliment\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        num = random.randint(1, 10 ** 5)\n        return {'num': num}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['num'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'num': int(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.findComplement(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.053",
            "memory": 4828,
            "stderr": null,
            "token": "84862d5b-9449-4d0d-972d-00b40bd4aa7c",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 440,
        "title": "k-th-smallest-in-lexicographical-order",
        "token": "d5809818-6ce8-412f-a739-936e2983a9cb",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution(object):\n    def findKthNumber(self, n, k):\n        curr = 1\n        k -= 1\n        \n        while k > 0:\n            step = self.countSteps(n, curr, curr + 1)\n            # If the steps are less than or equal to k, we skip this prefix's subtree\n            if step <= k:\n                # Move to the next prefix and decrease k by the number of steps we skip\n                curr += 1\n                k -= step\n            else:\n                # Move to the next level of the tree and decrement k by 1\n                curr *= 10\n                k -= 1\n\n        return curr\n\n    # To count how many numbers exist between prefix1 and prefix2\n    def countSteps(self, n, prefix1, prefix2):\n        steps = 0\n        while prefix1 <= n:\n            steps += min(n + 1, prefix2) - prefix1\n            prefix1 *= 10\n            prefix2 *= 10\n        return steps\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 1000)\n        k = random.randint(1, n)\n        return {'n': n, 'k': k}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{input_obj['n']} {input_obj['k']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        n, k = map(int, input_str.split())\n        return {'n': n, 'k': k}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.findKthNumber(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.067",
            "memory": 4796,
            "stderr": null,
            "token": "d5809818-6ce8-412f-a739-936e2983a9cb",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 441,
        "title": "arranging-coins",
        "token": "703ca3c8-5a65-44b6-94a6-368a35545a24",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def arrangeCoins(self, n: int) -> int:\n        res = 0\n        step = 1\n        \n        while n >= step:\n            res += 1\n            n -= step\n            step += 1\n        \n        return res\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 100)\n        return {'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['n'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        n = int(input_str)\n        return {'n': n}\n\n    def decode_output(self, output_str) -> int:\n        return int(output_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.arrangeCoins(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.072",
            "memory": 5092,
            "stderr": null,
            "token": "703ca3c8-5a65-44b6-94a6-368a35545a24",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "failure",
        "question_id": 401,
        "title": "binary-watch",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "success",
        "question_id": 404,
        "title": "sum-of-left-leaves",
        "token": "ecd28cd5-8c43-4aba-89c7-2e64546fd82f",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom collections import deque\nfrom typing import Optional\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sumOfLeftLeaves(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        res = 0\n        if root.left:\n            if not root.left.left and not root.left.right:\n                res += root.left.val\n            else:\n                res += self.sumOfLeftLeaves(root.left)\n        res += self.sumOfLeftLeaves(root.right)\n        return res\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        single_node_tree = {'root': TreeNode(1)}\n        left_leaf_tree = {'root': TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7)))}\n        no_left_leaf_tree = {'root': TreeNode(1, None, TreeNode(2, None, TreeNode(3)))}\n        return no_left_leaf_tree\n\n    def encode_input(self, input_obj) -> str:\n\n        def serialize_tree(node):\n            if not node:\n                return 'null'\n            return f'{node.val}, {serialize_tree(node.left)}, {serialize_tree(node.right)}'\n        root = input_obj['root']\n        return f'[{serialize_tree(root)}]'\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n\n        def deserialize_tree(data_list):\n            if not data_list:\n                return None\n            val = data_list.pop(0)\n            if val == 'null':\n                return None\n            node = TreeNode(val=int(val))\n            node.left = deserialize_tree(data_list)\n            node.right = deserialize_tree(data_list)\n            return node\n        elements = input_str.strip('[]').split(', ')\n        root = deserialize_tree(elements)\n        return {'root': root}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.sumOfLeftLeaves(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.057",
            "memory": 4716,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 133, in <module>\n    runner.run()\n  File \"script.py\", line 114, in run\n    input = self.test.decode_input(test_case['input'])\n  File \"script.py\", line 100, in decode_input\n    root = deserialize_tree(elements)\n  File \"script.py\", line 95, in deserialize_tree\n    node = TreeNode(val=int(val))\nTypeError: __init__() got an unexpected keyword argument 'val'\n",
            "token": "ecd28cd5-8c43-4aba-89c7-2e64546fd82f",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "success",
        "question_id": 363,
        "title": "max-sum-of-rectangle-no-larger-than-k",
        "token": "7f8d2be9-27ac-448c-a0d4-0f5355557a81",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport math\nfrom sortedcontainers import SortedList\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nimport numpy as np\nfrom sortedcontainers import SortedList\nfrom typing import List\n\nclass Solution:\n    def helper(self, a_list: List[int], k: int) -> int:\n        prefix_sums = SortedList([0])\n        cur_sum = 0\n        max_sum = float('-inf')\n        \n        for num in a_list:\n            cur_sum += num\n            # \u67e5\u627e\u5c0f\u4e8e\u7b49\u4e8e cur_sum - k \u7684\u524d\u7f00\u548c\n            target = cur_sum - k\n            pos = prefix_sums.bisect_left(target)\n            if pos < len(prefix_sums):\n                max_sum = max(max_sum, cur_sum - prefix_sums[pos])\n            prefix_sums.add(cur_sum)\n            \n            if max_sum == k:\n                return k\n        \n        return max_sum\n\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\n        mtx = matrix = np.array(matrix)\n        M, N = len(matrix), len(matrix[0])\n        max_sum = float('-inf')\n        sums = []\n\n        cursums = np.array([0] * N)\n        for i in range(M): \n            cur = mtx[i]\n            cursums += cur\n            sums.append(cursums.copy())\n        sums = np.array(sums)\n\n        for i in range(M): \n            for j in range(i, M): \n                nowsums = sums[j] - sums[i] + mtx[i]\n                max_sum = max(self.helper(nowsums, k), max_sum)\n        \n        return max_sum\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        m = random.randint(1, 10)\n        n = random.randint(1, 10)\n        k = random.randint(-1000, 1000)\n        matrix = [[random.randint(-100, 100) for _ in range(n)] for _ in range(m)]\n        return {'matrix': matrix, 'k': k}\n\n    def encode_input(self, input_obj: dict) -> str:\n        matrix_str = str(input_obj['matrix'])\n        k_str = str(input_obj['k'])\n        return f\"{{'matrix': {matrix_str}, 'k': {k_str}}}\"\n\n    def encode_output(self, output_obj: int) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str: str) -> dict:\n        return eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.maxSumSubmatrix(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.047",
            "memory": 4692,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 27, in <module>\n    from sortedcontainers import SortedList\nModuleNotFoundError: No module named 'sortedcontainers'\n",
            "token": "7f8d2be9-27ac-448c-a0d4-0f5355557a81",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "success",
        "question_id": 459,
        "title": "repeated-substring-pattern",
        "token": "2291c81d-0856-455d-b356-32637bc18295",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nimport numpy as np\nclass Solution:\n    def repeatedSubstringPattern(self, s: str) -> bool:\n        beg, end = 0, 1\n        while end <= len(s)-1:\n            sub = s[beg:end]\n            k = int(np.ceil(len(s)/len(sub)))\n            new = sub*k\n            if new==s:\n                return True\n            end+=1\n        return False\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(2, 20)\n        s = ''.join(random.choices('abcdefghijklmnopqrstuvwxyz', k=length))\n        return {'s': s}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['s']\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj).lower()\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.repeatedSubstringPattern(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.059",
            "memory": 4768,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 47, in <module>\n    import numpy as np\nModuleNotFoundError: No module named 'numpy'\n",
            "token": "2291c81d-0856-455d-b356-32637bc18295",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "success",
        "question_id": 461,
        "title": "hamming-distance",
        "token": "d5515a72-77ee-495f-86fc-5490249bee6f",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def hammingDistance(self, x: int, y: int) -> int:\n        bin_x = bin(x)[::-1][:-2]\n        bin_y = bin(y)[::-1][:-2]\n\n        last_ix = len(bin_x) - 1\n        last_iy = len(bin_y) - 1\n\n        hamming_distance = 0\n        for i in range(max(len(bin_x), len(bin_y))):\n            if i > last_ix:\n                return hamming_distance + bin_y[i:].count('1')\n            if i > last_iy:\n                return hamming_distance + bin_x[i:].count('1')\n            hamming_distance += (bin_x[i]!= bin_y[i])\n            \n        return hamming_distance\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        x = random.randint(0, 2 ** 31 - 1)\n        y = random.randint(0, 2 ** 31 - 1)\n        return {'x': x, 'y': y}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{{'x': {input_obj['x']}, 'y': {input_obj['y']}}}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        input_parts = input_str.strip('{}').split(', ')\n        x = int(input_parts[0].split(': ')[1])\n        y = int(input_parts[1].split(': ')[1])\n        return {'x': x, 'y': y}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.hammingDistance(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.051",
            "memory": 4852,
            "stderr": null,
            "token": "d5515a72-77ee-495f-86fc-5490249bee6f",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 463,
        "title": "island-perimeter",
        "token": "33b2cac5-1de2-491d-909f-4dea38cd19ca",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List\nimport ast\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def count_perimeter_at(self, neiboughr_matrix, grid, i, j):\n        counter = 0\n        for step in neiboughr_matrix:\n            new_step = [step[0] + i, step[1] + j]\n            if not (0 <= new_step[0] < len(grid)):\n                counter += 1\n                continue\n            elif not (0 <= new_step[1] < len(grid[0])):\n                counter += 1\n                continue\n            elif grid[new_step[0]][new_step[1]] == 0:\n                counter += 1\n        return counter\n\n    def islandPerimeter(self, grid: List[List[int]]) -> int:\n        neiboughr_matrix = [[1, 0], [0, 1], [-1, 0], [0, -1]]\n        counter = 0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 1:\n                    counter += self.count_perimeter_at(neiboughr_matrix, grid, i, j)\n        return counter\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        height = random.randint(1, 10)\n        width = random.randint(1, 10)\n        grid = [[0 for _ in range(width)] for _ in range(height)]\n        start_x = random.randint(0, height - 1)\n        start_y = random.randint(0, width - 1)\n        grid[start_x][start_y] = 1\n        for _ in range(int(height * width / 4)):\n            direction = random.choice(['up', 'down', 'left', 'right'])\n            if direction == 'up' and start_x - 1 >= 0:\n                start_x -= 1\n            elif direction == 'down' and start_x + 1 < height:\n                start_x += 1\n            elif direction == 'left' and start_y - 1 >= 0:\n                start_y -= 1\n            elif direction == 'right' and start_y + 1 < width:\n                start_y += 1\n            grid[start_x][start_y] = 1\n        return {'grid': grid}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['grid'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        grid = ast.literal_eval(input_str)\n        return {'grid': grid}\n\n    def decode_output(self, output_str) -> int:\n        return int(output_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.islandPerimeter(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.066",
            "memory": 5196,
            "stderr": null,
            "token": "33b2cac5-1de2-491d-909f-4dea38cd19ca",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 685,
        "title": "redundant-connection-ii",
        "token": "dac9b353-cb3f-4be2-b384-afd363b4e420",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nfrom collections import defaultdict\n\nclass Solution:\n    def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:\n        graph = defaultdict(lambda: set())\n        num_incoming_edges = defaultdict(lambda: 0)\n\n        for edge in edges:\n            a, b = edge[0], edge[1]\n            graph[a].add(b)\n            num_incoming_edges[b] += 1\n\n        def findCyclesDfs(root, curr, history, visited):\n            if curr == root:\n                return history\n            if curr in visited:\n                return\n            visited.add(curr)\n            for node in graph[curr]:\n                history.add((curr, node))\n                result = findCyclesDfs(root, node, history, visited)\n                if result is not None:\n                    return result\n                history.remove((curr, node))\n\n        redundant_edge = None\n        known_cycle_edges = None\n\n        for edge in edges:\n            a, b = edge[0], edge[1]\n            known_cycle_edges = findCyclesDfs(a, b, {(a, b)}, set()) if known_cycle_edges is None else known_cycle_edges\n\n            if num_incoming_edges[b] > 1:\n                redundant_edge = edge\n            if known_cycle_edges and (a, b) in known_cycle_edges:\n                if edge == redundant_edge:\n                    return edge\n                else:\n                    redundant_edge = edge\n        \n        return redundant_edge\n\nclass TestCaseGenerator:\n\n    def __init__(self, nodes_range=(3, 6)):\n        self.nodes_range = nodes_range\n\n    def generate(self) -> dict:\n        n = random.randint(*self.nodes_range)\n        edges = []\n        for i in range(1, n):\n            edges.append([i, i + 1])\n        a = random.randint(1, n - 1)\n        b = random.randint(a + 1, n)\n        edges.append([b, a])\n        random.shuffle(edges)\n        return {'edges': edges}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['edges'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'edges': eval(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.findRedundantDirectedConnection(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.057",
            "memory": 4864,
            "stderr": null,
            "token": "dac9b353-cb3f-4be2-b384-afd363b4e420",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 736,
        "title": "parse-lisp-expression",
        "token": "4b48c25a-972c-454b-bd5c-376bc677c8dc",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List, Dict\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def evaluate(self, expression: str) -> int:\n        \"\"\"\n        expr := (let [string expr]*)\n        expr := (add  expr expr)\n        expr := (mult expr expr)\n        expr := var \n        \"\"\"\n\n        def tokenize(s):\n            Q = deque()\n            cur = 0\n            n = len(s)\n            while cur < n:\n                c = s[cur]\n                if c in ('(', ')'):\n                    Q.append(c)\n                    cur += 1\n                    continue\n                if c.isdigit() or c == '-':\n                    res = 0\n                    sign = 1\n                    if c == '-':\n                        sign = -1\n                        cur += 1\n                    while cur < n and s[cur].isdigit():\n                        res = res*10 + int(s[cur])\n                        cur += 1\n                    Q.append(sign * res)\n                    continue\n                if c.isalpha():\n                    res = []\n                    while cur < n and (s[cur].isalpha() or s[cur].isdigit()):\n                        res.append(s[cur])\n                        cur += 1\n                    Q.append(''.join(res))\n                    continue\n                cur += 1\n            return Q\n\n        tokens = tokenize(expression)  #TODO\n\n        def string():\n            return tokens.popleft()\n\n        def var(mp):\n            s = tokens.popleft()\n            if mp.get(s)!= None:\n                return mp[s]\n            return s\n\n        def expr(_mp):\n            mp = copy.copy(_mp)\n            if tokens[0] == '(':\n                assert tokens.popleft() == '('\n                op = tokens.popleft()\n                if op == 'let':\n                    while tokens[0]!= '(' and tokens[1]!= ')':\n                        variable_name = string()\n                        expression = expr(mp)\n                        mp[variable_name] = expression\n                    expression = expr(mp)\n                elif op =='mult':\n                    expr1 = expr(mp)\n                    expr2 = expr(mp)\n                    expression = expr1 * expr2\n                elif op == 'add':\n                    expr1 = expr(mp)\n                    expr2 = expr(mp)\n                    expression = expr1 + expr2\n                assert tokens.popleft() == ')'\n                return expression\n            else:\n                return var(mp)\n\n        return expr({})\n\nclass TestCaseGenerator:\n\n    def generate(self) -> Dict:\n        test_cases = [{'expression': '(let x 2 (mult x (let x 3 y 4 (add x y))))'}, {'expression': '(let x 3 x 2 x )'}, {'expression': '(let x 1 y 2 x (add x y) (add x y))'}, {'expression': '(add 1 2)'}, {'expression': '(mult (add 1 2) 3)'}]\n        return random.choice(test_cases)\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['expression']\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> Dict:\n        return {'expression': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.evaluate(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.056",
            "memory": 4908,
            "stderr": null,
            "token": "4b48c25a-972c-454b-bd5c-376bc677c8dc",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 973,
        "title": "stamping-the-sequence",
        "token": "17317f4f-821d-44e7-b8c4-acbcb926b0c3",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        def can_stamp(i):\n            changed = False\n            for j in range(len(stamp)):\n                if target[i + j] == '?':\n                    continue\n                if target[i + j]!= stamp[j]:\n                    return False\n                changed = True\n            return changed\n\n        def do_stamp(i):\n            for j in range(len(stamp)):\n                if target[i + j]!= '?':\n                    target[i + j] = '?'\n                    result.append(i)\n\n        target = list(target)\n        result = []\n        done = False\n        while not done:\n            done = True\n            for i in range(len(target) - len(stamp) + 1):\n                if can_stamp(i):\n                    do_stamp(i)\n                    done = False\n                    break\n\n        return result[::-1] if all(c == '?' for c in target) else []\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        stamp = 'abc'\n        target = 'ababc'\n        return {'stamp': stamp, 'target': target}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{{'stamp': '{input_obj['stamp']}', 'target': '{input_obj['target']}'}}\"\n\n    def encode_output(self, output_obj) -> str:\n        return f'{output_obj}'\n\n    def decode_input(self, input_str) -> dict:\n        import ast\n        return ast.literal_eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.movesToStamp(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Input {'stamp': 'abc', 'target': 'ababc'}\nExpected Output:  [0, 2]\nActual Output:  [0, 0, 2, 2, 2]\n1 Test Failed!\n",
            "time": "0.061",
            "memory": 4932,
            "stderr": null,
            "token": "17317f4f-821d-44e7-b8c4-acbcb926b0c3",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 4,
                "description": "Wrong Answer"
            }
        }
    },
    {
        "status": "failure",
        "question_id": 975,
        "title": "range-sum-of-bst",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "failure",
        "question_id": 977,
        "title": "distinct-subsequences-ii",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "success",
        "question_id": 1013,
        "title": "fibonacci-number",
        "token": "4f6ababf-60a9-42b4-9009-408b73ba162d",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def fib(self, n: int) -> int:\n        if n < 2: \n            return n\n        \n        return self.fib(n-2) + self.fib(n-1)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        from random import randint\n        return {'n': randint(0, 30)}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['n'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'n': int(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.fib(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "1.036",
            "memory": 4864,
            "stderr": null,
            "token": "4f6ababf-60a9-42b4-9009-408b73ba162d",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 514,
        "title": "freedom-trail",
        "token": "50c1f405-4b09-4b3d-8868-278da6d0d17e",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nfrom collections import defaultdict\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def findRotateSteps(self, ring: str, key: str) -> int:\n        dp = [0] * len(ring)\n\n        for k in reversed(range(len(key))):\n            nextDP = [inf] * len(ring)\n            for r in range(len(ring)):\n                for i, c in enumerate(ring):\n                    if c == key[k]:\n                        minDist = min(abs(r-i), len(ring)-abs(r-i))\n                        nextDP[r] = min(nextDP[r], 1+minDist+dp[i])\n            dp = nextDP\n\n        return dp[0]\n\nclass TestCaseGenerator:\n    \"\"\"\n    Generates test case inputs for the \"Road to Freedom\" problem where a ring needs to be rotated to match a given key string.\n    \"\"\"\n\n    def generate(self) -> dict:\n        random.seed(0)\n        ring_length = random.randint(1, 100)\n        key_length = random.randint(1, 100)\n        alphabet = 'abcdefghijklmnopqrstuvwxyz'\n        ring = ''.join(random.choices(alphabet, k=ring_length))\n        key = ''.join(random.choices(alphabet, k=key_length))\n        return {'ring': ring, 'key': key}\n\n    def encode_input(self, input_obj: dict) -> str:\n        return f\"ring={input_obj['ring']},key={input_obj['key']}\"\n\n    def encode_output(self, output_obj: int) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str: str) -> dict:\n        parts = input_str.split(',')\n        ring = parts[0].split('=')[1]\n        key = parts[1].split('=')[1]\n        return {'ring': ring, 'key': key}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.findRotateSteps(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.535",
            "memory": 4908,
            "stderr": null,
            "token": "50c1f405-4b09-4b3d-8868-278da6d0d17e",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 920,
        "title": "uncommon-words-from-two-sentences",
        "token": "ee847197-372e-4770-bb3c-247094e9f18f",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nfrom collections import Counter\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def uncommonFromSentences(self, s1: str, s2: str) -> List[str]:\n        d=Counter(s1.split())+Counter(s2.split())\n        return [x for x in d if d[x]==1]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        test_cases = [('this apple is sweet', 'this apple is sour'), ('apple apple', 'banana'), ('orange', 'apple orange'), ('dog cat', 'cat dog'), ('unique words', 'unique unique words'), ('a quick brown fox', 'jumps over the lazy dog')]\n        s1, s2 = random.choice(test_cases)\n        return {'s1': s1, 's2': s2}\n\n    def encode_input(self, input_obj: dict) -> str:\n        return f\"{input_obj['s1']}|{input_obj['s2']}\"\n\n    def encode_output(self, output_obj: List[str]) -> str:\n        return ','.join(output_obj)\n\n    def decode_input(self, input_str: str) -> dict:\n        s1, s2 = input_str.split('|')\n        return {'s1': s1, 's2': s2}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.uncommonFromSentences(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.067",
            "memory": 4828,
            "stderr": null,
            "token": "ee847197-372e-4770-bb3c-247094e9f18f",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "failure",
        "question_id": 35,
        "title": "search-insert-position",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "failure",
        "question_id": 10,
        "title": "regular-expression-matching",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "success",
        "question_id": 218,
        "title": "the-skyline-problem",
        "token": "55bd0eb7-5147-4714-93c9-e673604abe1c",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport heapq\nimport random\nimport ast\n\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def getSkyline(self, buildings: List[List[int]]) -> List[List[int]]:\n        # Sort the unique positions of all the edges.\n        positions = sorted(list(set([x for building in buildings for x in building[:2]])))\n        \n        # Hast table 'edge_index_map' to record every {position : index} pairs in edges.\n        edge_index_map = {x : i for i, x in enumerate(positions)}\n\n        # Initialize 'heights' to record maximum height at each index.\n        heights = [0] * len(positions)\n        \n        # Iterate over all the buildings.\n        for left, right, height in buildings:\n            # For each building, find the indexes of its left\n            # and right edges.\n            left_idx = edge_index_map[left]\n            right_idx = edge_index_map[right]\n\n            # Update the maximum height within the range [left_idx, right_idx)\n            for i in range(left_idx, right_idx):\n                heights[i] = max(heights[i], height)\n\n        answer = []\n\n        # Iterate over 'heights'.\n        for i in range(len(heights)):\n            curr_height = heights[i]\n            curr_x = positions[i]\n\n            # Add all the positions where the height changes to 'answer'.\n            if not answer or answer[-1][1]!= curr_height:\n                answer.append([curr_x, curr_height])\n        return answer\n\nclass TestCaseGenerator:\n\n    def __init__(self):\n        self.min_height = 1\n        self.max_height = 20\n        self.max_x_coord = 100\n\n    def generate(self) -> dict:\n        num_buildings = random.randint(1, 100)\n        buildings = []\n        current_x = 0\n        for _ in range(num_buildings):\n            left = current_x\n            right = left + random.randint(1, 10)\n            height = random.randint(self.min_height, self.max_height)\n            buildings.append([left, right, height])\n            current_x = right + random.randint(0, 5)\n        return {'buildings': buildings}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return ast.literal_eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.getSkyline(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.075",
            "memory": 5796,
            "stderr": null,
            "token": "55bd0eb7-5147-4714-93c9-e673604abe1c",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "failure",
        "question_id": 226,
        "title": "invert-binary-tree",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "success",
        "question_id": 273,
        "title": "integer-to-english-words",
        "token": "ef314a49-c838-468b-8ed2-aae3738879c4",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def numberToWords(self, num: int) -> str:\n        if num == 0:\n            return \"Zero\"\n        \n        converter = {1:\"One\",2:'Two',3:'Three',4:'Four',5:'Five',6:'Six',7:'Seven', 8:\"Eight\", 9:'Nine',10:'Ten',11:\"Eleven\",12:'Twelve',13:'Thirteen',14:'Fourteen',15:'Fifteen',16:\"Sixteen\",17:'Seventeen',18:\"Eighteen\",19:\"Nineteen\",20:\"Twenty\",30:\"Thirty\",40:\"Forty\",50:\"Fifty\",60:\"Sixty\",70:\"Seventy\", 80:\"Eighty\",90:\"Ninety\"}\n        \n        def hundreds(number):\n            ans = []\n            if number >= 100:\n                hundreds_digit,number = divmod(number,100)\n                ans.append(converter[hundreds_digit])\n                ans.append(\"Hundred\")\n            if number > 20:\n                tens_digit,number = divmod(number,10)\n                ans.append(converter[tens_digit*10])\n            if number > 0:\n                ans.append(converter[number])\n            return \" \".join(ans)\n        sol = []\n        digit,num = divmod(num,10**9)\n        \n        if digit:\n            sol.append(hundreds(digit))\n            sol.append(\"Billion\")\n        \n        digit,num = divmod(num,10**6)\n        \n        if digit:\n            sol.append(hundreds(digit))\n            sol.append(\"Million\")\n        \n        digit,num = divmod(num,10**3)\n        \n        if digit:\n            sol.append(hundreds(digit))\n            sol.append(\"Thousand\")\n        if num:\n            sol.append(hundreds(num))\n        return \" \".join(sol)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        \"\"\"\n        Generates a random test case input within the range of the problem's constraints.\n        \"\"\"\n        num = random.randint(0, 2 ** 31 - 1)\n        return {'num': num}\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\"\n        Convert a test case input into a string suitable for passing to the function.\n        \"\"\"\n        return str(input_obj['num'])\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\"\n        Convert a test case output into a string representation.\n        \"\"\"\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\"\n        Convert a test case input string into a Python dict.\n        \"\"\"\n        return {'num': int(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.numberToWords(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.066",
            "memory": 4820,
            "stderr": null,
            "token": "ef314a49-c838-468b-8ed2-aae3738879c4",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 14,
        "title": "longest-common-prefix",
        "token": "bfc7b96e-f13b-4978-8012-83977c5c6a80",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def longestCommonPrefix(self, strs: List[str]) -> str:\n        strs.sort(key=len)\n        pf = ''\n        for i,l in enumerate(strs[0]):\n            for word in strs[1:]:\n                    if word[i]!= l:\n                        return pf\n            pf += l\n        return pf\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        num_strings = random.randint(1, 10)\n        strs = []\n        for _ in range(num_strings):\n            str_length = random.randint(0, 10)\n            random_str = ''.join(random.choices('abcdefghijklmnopqrstuvwxyz', k=str_length))\n            strs.append(random_str)\n        return {'strs': strs}\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\"Convert a test case input into a string for transport.\"\"\"\n        return str(input_obj['strs'])\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\"Convert a test case output into a string for transport.\"\"\"\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\"Convert a test case input string back into a dictionary.\"\"\"\n        strs = eval(input_str[1:-1])\n        return {'strs': strs}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.longestCommonPrefix(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.059",
            "memory": 4872,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 114, in <module>\n    runner.run()\n  File \"script.py\", line 98, in run\n    output = self.solution.longestCommonPrefix(**input)\n  File \"script.py\", line 51, in longestCommonPrefix\n    strs.sort(key=len)\nAttributeError: 'str' object has no attribute 'sort'\n",
            "token": "bfc7b96e-f13b-4978-8012-83977c5c6a80",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "success",
        "question_id": 258,
        "title": "add-digits",
        "token": "bc5c64d4-2efc-426e-b91a-5ca9a02ea88a",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def addDigits(self, num: int) -> int:\n        if num == 0: \n            return 0\n        mod = num % 9 \n        if mod == 0:\n            return 9 \n        else: return mod\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        num = random.randint(0, 1000)\n        return {'num': num}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['num'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        try:\n            num = int(input_str)\n            return {'num': num}\n        except ValueError:\n            raise ValueError('Invalid input string for conversion to integer')\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.addDigits(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.058",
            "memory": 4800,
            "stderr": null,
            "token": "bc5c64d4-2efc-426e-b91a-5ca9a02ea88a",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 76,
        "title": "minimum-window-substring",
        "token": "c69a73dd-de73-4969-823d-e06deb1b0e76",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        n = len(s)\n        t_counter = Counter(t)\n        curr_counter = t_counter.copy()\n        for key in curr_counter:\n            curr_counter[key] = 0\n        left, right = 0, 0\n        minimum_window = ''\n        length = n + 1\n        while right < n:\n            curr_counter[s[right]] += 1\n            t_counter[s[right]] += 0\n            valid = True\n            for key in t_counter:\n                if curr_counter[key] < t_counter[key]:\n                    valid = False\n            if valid:\n                while True:\n                    if curr_counter[s[left]] - 1 >= t_counter[s[left]]:\n                        curr_counter[s[left]] -= 1\n                        left += 1\n                    else:\n                        break\n                if right - left + 1 < length:\n                    minimum_window = s[left:right+1]\n                    length = len(minimum_window)\n            right += 1\n        return minimum_window\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        possible_cases = [{'s': 'ADOBECODEBANC', 't': 'ABC'}, {'s': 'a', 't': 'a'}, {'s': 'a', 't': 'aa'}, {'s': 'MANGROVESANDMONOGRAMS', 't': 'GMSA'}]\n        return random.choice(possible_cases)\n\n    def encode_input(self, input_obj) -> str:\n        return f\"s={input_obj['s']},t={input_obj['t']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        values = input_str.split(',')\n        return {'s': values[0].split('=')[1], 't': values[1].split('=')[1]}\n\n    def decode_output(self, output_str) -> str:\n        return output_str\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.minWindow(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.066",
            "memory": 4800,
            "stderr": null,
            "token": "c69a73dd-de73-4969-823d-e06deb1b0e76",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 68,
        "title": "text-justification",
        "token": "79791555-0d3f-47e6-a0ab-c45f0f9bede0",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport json\nfrom math import ceil\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\n        \n        n=len(words)\n        output,line,width=[],[],0\n        \n        for w in words:\n            if width + len(w) +len(line) > maxWidth:\n                for i in range(maxWidth-width):\n                    line[i%(len(line) - 1 or 1)] +=''\n                output += [''.join(line)]\n                line=[]\n                width=0\n            line += [w]\n            width += len(w)\n        \n        return output + [' '.join(line).ljust(maxWidth)]\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        test_cases = [{'words': ['This', 'is', 'an', 'example', 'of', 'text', 'justification.'], 'maxWidth': 16}, {'words': ['What', 'must', 'be', 'acknowledgment', 'shall', 'be'], 'maxWidth': 16}, {'words': ['Science', 'is', 'what', 'we', 'understand', 'well', 'enough', 'to', 'explain', 'to', 'a', 'computer.', 'Art', 'is', 'everything', 'else', 'we', 'do'], 'maxWidth': 20}, {'words': ['Lorem', 'ipsum', 'dolor', 'sit', 'amet'], 'maxWidth': 14}, {'words': ['A', 'test', 'case', 'with'], 'maxWidth': 12}]\n        return random.choice(test_cases)\n\n    def encode_input(self, input_obj) -> str:\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return json.dumps(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return json.loads(input_str)\n\n    def decode_output(self, output_str) -> list:\n        return json.loads(output_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.fullJustify(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Input {'words': ['What', 'must', 'be', 'acknowledgment', 'shall', 'be'], 'maxWidth': 16}\nExpected Output:  [\"What   must   be\", \"acknowledgment  \", \"shall be        \"]\nActual Output:  [\"Whatmustbe\", \"acknowledgment\", \"shall be        \"]\n1 Test Failed!\n",
            "time": "0.055",
            "memory": 4804,
            "stderr": null,
            "token": "79791555-0d3f-47e6-a0ab-c45f0f9bede0",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 4,
                "description": "Wrong Answer"
            }
        }
    },
    {
        "status": "success",
        "question_id": 332,
        "title": "reconstruct-itinerary",
        "token": "1f362785-3365-4620-aeff-4d06a2f80872",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport collections\nimport random\nimport ast\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\n        self.graph = {}\n        for src, dst in tickets:\n            self.graph[src] = self.graph.get(src, []) + [dst]\n        \n        for src_dst in self.graph.values():\n            src_dst.sort(reverse=True) # sort destinations by *decreasing* lexical order\n        \n        self.res = []\n        self.dfs(\"JFK\")\n        return self.res[::-1]\n    \n    def dfs(self, src):\n        #\u00a0destinations = self.graph.get(src, [])\n        while self.graph.get(src, []):\n            dst = self.graph[src].pop(-1)\n            self.dfs(dst)\n        self.res.append(src)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        airports = ['JFK', 'SFO', 'ATL', 'LHR', 'MUC', 'SJC', 'LGB']\n        tickets = [['JFK', random.choice(airports[1:])]]\n        for _ in range(random.randint(1, 10)):\n            from_airport = random.choice(airports)\n            to_airport = random.choice([airport for airport in airports if airport != from_airport])\n            tickets.append([from_airport, to_airport])\n        return {'tickets': tickets}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['tickets'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        input_list = ast.literal_eval(input_str)\n        return {'tickets': input_list}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.findItinerary(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.063",
            "memory": 5140,
            "stderr": null,
            "token": "1f362785-3365-4620-aeff-4d06a2f80872",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 689,
        "title": "maximum-sum-of-3-non-overlapping-subarrays",
        "token": "f81085bc-0823-4c25-92f9-3198a83d52d1",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\nimport json\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def maxSumOfThreeSubarrays(self, nums: List[int], k: int) -> List[int]:\n        sums = []\n        n = len(nums)\n        for i in range(n-k+1):\n            sums.append(sum(nums[i:i+k]))\n        best = 0\n        left = [0]*(n-k+1)\n        for i in range(n-k+1):\n            if sums[i] > sums[best]:\n                best = i\n            left[i] = best\n        \n        best = n-k\n        right = [0]*(n-k+1)\n        for i in range(n-k, -1, -1):\n            if sums[i] >= sums[best]:\n                best = i\n            right[i] = best\n\n        result = []\n        max_sum = 0\n        for mid in range(k, n-2*k+1):\n            l, r = left[mid-k], right[mid+k]\n            cur_sum = sums[l] + sums[r] + sums[mid]\n            if cur_sum > max_sum:\n                max_sum = cur_sum\n                result = [l, mid, r]\n        return result\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(3, 30)\n        k = random.randint(1, n // 3)\n        nums = [random.randint(1, 100) for _ in range(n)]\n        return {'nums': nums, 'k': k}\n\n    def encode_input(self, input_obj) -> str:\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return json.dumps(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return json.loads(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.maxSumOfThreeSubarrays(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.054",
            "memory": 4892,
            "stderr": null,
            "token": "f81085bc-0823-4c25-92f9-3198a83d52d1",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 953,
        "title": "reverse-only-letters",
        "token": "14fab1b9-1445-4987-aa8a-d1be9873ff0c",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport string\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n\n\n    def reverseOnlyLetters(self, s: str) -> str:\n        left = 0\n        right = len(s) - 1\n        s_list = list(s)\n        while (left < right):\n            if not s_list[left].isalpha():\n                left += 1\n                continue\n            if not s_list[right].isalpha():\n                right -= 1\n                continue\n            temp = s_list[left]\n            s_list[left] = s_list[right]\n            s_list[right] = temp\n            left += 1\n            right -=1\n        \n        return \"\".join(s_list)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random, string\n        letters = ''.join(random.choices(string.ascii_letters, k=random.randint(1, 50)))\n        non_letters = ''.join(random.choices('!@#$%^&*()-_1234567890:=', k=50 - len(letters)))\n        string_list = list(letters + non_letters)\n        random.shuffle(string_list)\n        generated_string = ''.join(string_list)\n        return {'s': generated_string}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['s']\n\n    def encode_output(self, output_obj) -> str:\n        return output_obj\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.reverseOnlyLetters(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.065",
            "memory": 4828,
            "stderr": null,
            "token": "14fab1b9-1445-4987-aa8a-d1be9873ff0c",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 923,
        "title": "super-egg-drop",
        "token": "2903c895-c329-4718-a2fb-2ae0df7d91c1",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom functools import cache\nfrom random import randint\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    @cache\n    def superEggDrop(self, k: int, n: int) -> int:\n        \n        # base condition\n\n        if n==0:\n            return 0\n        if n==1:\n            return 1\n        if k==1:\n            return n\n        ans = float('inf')\n        s, e = 1, n\n        while (s <= e):\n            x = (s+e)//2\n            if self.superEggDrop(k-1, x-1) >= self.superEggDrop(k, n-x):\n                ans = min(ans,self.superEggDrop(k-1, x-1) )\n                e = x-1\n            else:\n                ans = min(ans,self.superEggDrop(k, n-x) )\n                s = x+1\n        # for x in range(1, n+1):\n        #     ans  = min(ans, max(self.superEggDrop(k-1, x-1), self.superEggDrop(k, n-x)))\n        \n        return ans +1\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        from random import randint\n        k = randint(1, 10)\n        n = randint(1, 100)\n        return {'k': k, 'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{{'k': {input_obj['k']}, 'n': {input_obj['n']}}}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        input_obj = eval(input_str)\n        return input_obj\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.superEggDrop(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.054",
            "memory": 4588,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 26, in <module>\n    from functools import cache\nImportError: cannot import name 'cache' from 'functools' (/usr/local/python-3.8.1/lib/python3.8/functools.py)\n",
            "token": "2903c895-c329-4718-a2fb-2ae0df7d91c1",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "failure",
        "question_id": 924,
        "title": "fair-candy-swap",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "success",
        "question_id": 632,
        "title": "smallest-range-covering-elements-from-k-lists",
        "token": "4e546416-40f5-4026-a965-72ff80d2a624",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom collections import defaultdict\nimport heapq\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def smallestRange(self, nums: List[List[int]]) -> List[int]:\n        all_nums = []\n        for i, lst in enumerate(nums):\n            for n in lst:\n                all_nums.append((n, i))\n        all_nums.sort()\n        output = [float(\"-inf\"), float(\"inf\")]\n        included = {}\n        l, r = 0, 0\n        last_used_l = -1\n        while r < len(all_nums):\n            if all_nums[r][1] not in included:\n                included[all_nums[r][1]] = deque()\n            included[all_nums[r][1]].append(all_nums[r][0])\n            while len(included) == len(nums) and len(included[all_nums[l][1]]) > 1:\n                included[all_nums[l][1]].popleft()\n                l += 1\n            if len(included) == len(nums) and l!= last_used_l:\n                min_num = float(\"inf\")\n                max_num = float(\"-inf\")\n                for q in included.values():\n                    min_num = min(q[0], min_num)\n                    max_num = max(q[-1], max_num)\n                if max_num - min_num < output[1] - output[0]:\n                    output = [min_num, max_num]\n                last_used_l = l\n            r += 1\n        return output\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        k = random.randint(1, 10)\n        nums = []\n        for _ in range(k):\n            size_of_list = random.randint(1, 10)\n            start_value = random.randint(-100, 100)\n            num_list = sorted((random.randint(start_value, start_value + 20) for _ in range(size_of_list)))\n            nums.append(num_list)\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'nums': eval(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.smallestRange(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.058",
            "memory": 4880,
            "stderr": null,
            "token": "4e546416-40f5-4026-a965-72ff80d2a624",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 637,
        "title": "average-of-levels-in-binary-tree",
        "token": "47a3aa77-d09b-4ed3-a8c3-2e102b534d05",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom collections import deque\nfrom typing import List, Optional\nimport json\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nfrom collections import deque\nclass Solution:\n    def averageOfLevels(self, root: Optional[TreeNode]) -> List[float]:\n        levelsAverageList = []\n        if root!= None:\n            queue = deque()\n            queue.append(root)\n            while queue:\n                size = len(queue)\n                levels = []\n                for start in range(size):\n                    treeNode = queue.popleft()\n                    levels.append(float(treeNode.val))\n                    if treeNode.left!= None:\n                        queue.append(treeNode.left)\n                    if treeNode.right!= None:\n                        queue.append(treeNode.right)\n                levelsAverageList.append(float(sum(levels)/len(levels)))\n        return levelsAverageList\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        \"\"\"Generates a sample tree for testing purposes.\"\"\"\n        root = TreeNode(3)\n        root.left = TreeNode(9)\n        root.right = TreeNode(20, TreeNode(15), TreeNode(7))\n        return {'root': root}\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\"Encodes a tree structure into a JSON-compatible string.\"\"\"\n\n        def serialize(root):\n            values = []\n            queue = [root]\n            while queue:\n                node = queue.pop(0)\n                if node:\n                    values.append(node.val)\n                    queue.append(node.left)\n                    queue.append(node.right)\n                else:\n                    values.append(None)\n            return json.dumps(values)\n        return serialize(input_obj['root'])\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\"Converts the result into a JSON string.\"\"\"\n        return json.dumps(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\"Decodes a JSON string back into a tree structure.\"\"\"\n\n        def deserialize(data):\n            data = json.loads(data)\n            if not data or data[0] is None:\n                return None\n            root = TreeNode(data[0])\n            queue = [root]\n            i = 1\n            while queue and i < len(data):\n                node = queue.pop(0)\n                if data[i] is not None:\n                    node.left = TreeNode(data[i])\n                    queue.append(node.left)\n                i += 1\n                if i < len(data) and data[i] is not None:\n                    node.right = TreeNode(data[i])\n                    queue.append(node.right)\n                i += 1\n            return root\n        return {'root': deserialize(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.averageOfLevels(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.046",
            "memory": 4712,
            "stderr": null,
            "token": "47a3aa77-d09b-4ed3-a8c3-2e102b534d05",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 979,
        "title": "di-string-match",
        "token": "dfe7575f-9602-497f-b2b3-7f824a515052",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\nimport ast\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def diStringMatch(self, s: str) -> List[int]:\n        # x is less than y\n        greaterthan = {}\n        lessthan = {}\n        for i, c in enumerate(s):\n            a, b = i, i+1\n            if c == \"D\":\n                a, b = b, a\n                \n            # a < b\n            if a not in greaterthan:\n                greaterthan[a] = set()\n            if b not in lessthan:\n                lessthan[b] = set()\n            greaterthan[a].add(b)\n            lessthan[b].add(a)\n        \n            \n        \n        n = len(s)\n        zero_candidates = [x for x in range(n+1) if x not in lessthan]\n        \n        q = list(zero_candidates)\n        assignments = [-1] * (n+1)\n        counter = 0\n        while q:\n            curr = q.pop()\n            assignments[curr] = counter\n            counter += 1\n            if curr not in greaterthan:\n                continue\n            for bigger in greaterthan[curr]:\n                lessthan[bigger].remove(curr)\n                if len(lessthan[bigger]) == 0:\n                    q.append(bigger)\n        return assignments\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(1, 20)\n        s = ''.join((random.choice(['I', 'D']) for _ in range(length)))\n        return {'s': s}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"{{'s': '{input_obj['s']}'}}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return ast.literal_eval(input_str)\n\n    def decode_output(self, output_str) -> list:\n        return eval(output_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.diStringMatch(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Input {'s': 'DIDDDIIIDDIIDDDDI'}\nExpected Output:  [1, 0, 5, 4, 3, 2, 6, 7, 10, 9, 8, 11, 16, 15, 14, 13, 12, 17]\nActual Output:  [17, 15, 16, 14, 13, 9, 10, 11, 12, 8, 5, 6, 7, 3, 2, 1, 0, 4]\n1 Test Failed!\n",
            "time": "0.069",
            "memory": 5068,
            "stderr": null,
            "token": "dfe7575f-9602-497f-b2b3-7f824a515052",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 4,
                "description": "Wrong Answer"
            }
        }
    },
    {
        "status": "success",
        "question_id": 981,
        "title": "delete-columns-to-make-sorted",
        "token": "3fb85587-6c45-456a-8b9a-d39aa023614e",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def minDeletionSize(self, strs: List[str]) -> int:\n        count = 0\n        for col in range(len(strs[0])):\n            last = -1\n            for row in range(len(strs)):\n                if ord(strs[row][col]) < last:\n                    count+=1\n                    break\n                last = ord(strs[row][col])\n        return count\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 100)\n        m = random.randint(1, 1000)\n        strs = [''.join(random.choices('abcdefghijklmnopqrstuvwxyz', k=m)) for _ in range(n)]\n        return {'strs': strs}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.minDeletionSize(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.089",
            "memory": 11844,
            "stderr": null,
            "token": "3fb85587-6c45-456a-8b9a-d39aa023614e",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 927,
        "title": "sum-of-subsequence-widths",
        "token": "22a98aee-ff18-4f86-a9d7-a358e2122f32",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def sumSubseqWidths(self, nums: List[int]) -> int:\n        nums = sorted(nums)\n        total = 0\n        n = len(nums)\n        mod = 10**9 + 7\n        forward = 1\n        for i in range(n):\n            total += (forward - 1) * nums[i]\n            forward *= 2\n            total %= mod\n            forward %= mod\n        backward = 1\n        for i in reversed(range(n)):\n            total -= (backward - 1) * nums[i]\n            backward *= 2\n            total %= mod\n        return total\n\nclass TestCaseGenerator:\n\n    def __init__(self):\n        self.random = random\n\n    def generate(self) -> dict:\n        \"\"\" Generate a random test case within reasonable constraints. \"\"\"\n        length = self.random.randint(1, 10)\n        nums = [self.random.randint(1, 100) for _ in range(length)]\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        \"\"\" Convert the dict input into a JSON-like string format. \"\"\"\n        return str(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        \"\"\" The output is an integer so we convert it to a string directly. \"\"\"\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        \"\"\" Convert the input string back to a dictionary object. \"\"\"\n        return eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.sumSubseqWidths(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.06",
            "memory": 4772,
            "stderr": null,
            "token": "22a98aee-ff18-4f86-a9d7-a358e2122f32",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "failure",
        "question_id": 933,
        "title": "increasing-order-search-tree",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "success",
        "question_id": 488,
        "title": "zuma-game",
        "token": "605598aa-063c-4d9a-9717-1824ba8baf2f",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom functools import cache\nfrom itertools import groupby\nimport random\nfrom math import inf\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    @cache\n    def compress(self, s):\n        stack = []\n        for c in s:\n            if stack and stack[-1][0]!= c and stack[-1][1] >= 3:\n                stack.pop()\n            if not stack or stack[-1][0]!= c:\n                stack.append([c, 1])\n            else:\n                stack[-1][1] += 1\n        if stack and stack[-1][1] >= 3:\n            stack.pop()\n        return ''.join(a*b for a, b in stack)\n\n    def findMinStep(self, board: str, hand: str) -> int:\n        n = len(hand)\n        hand = ''.join(sorted(hand))\n        @cache\n        def solve(board, hand):\n            board = self.compress(board)\n            if board == '': return n - len(hand)\n            if hand == '': return 1e9\n\n            ans = 1e9\n            for i in range(len(hand)):\n                if i > 0 and hand[i] == hand[i-1]: continue\n    \n                for j in range(len(board)):\n                    if board[j] == hand[i] or j > 0 and board[j] == board[j-1] and board[j]!= hand[i]:\n                        ans = min(ans, solve(board[0:j] + hand[i] + board[j:], hand[0:i] + hand[i+1:]))\n            return ans\n        \n        res = solve(board, hand)\n        if res == 1e9: return -1\n        else: return res\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        import random\n        colors = ['R', 'Y', 'B', 'G', 'W']\n        board_length = random.randint(1, 16)\n        hand_length = random.randint(1, 5)\n        board = ''.join((random.choice(colors) for _ in range(board_length)))\n        hand = ''.join((random.choice(colors) for _ in range(hand_length)))\n        return {'board': board, 'hand': hand}\n\n    def encode_input(self, input_obj) -> str:\n        return f\"board={input_obj['board']},hand={input_obj['hand']}\"\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        parts = input_str.split(',')\n        board_part = parts[0].split('=')[1]\n        hand_part = parts[1].split('=')[1]\n        return {'board': board_part, 'hand': hand_part}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.findMinStep(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.066",
            "memory": 4592,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 26, in <module>\n    from functools import cache\nImportError: cannot import name 'cache' from 'functools' (/usr/local/python-3.8.1/lib/python3.8/functools.py)\n",
            "token": "605598aa-063c-4d9a-9717-1824ba8baf2f",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "success",
        "question_id": 493,
        "title": "reverse-pairs",
        "token": "e16debed-f962-4c5f-a6ab-9aeac3c02d28",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nfrom random import randint\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass BIT:\n\n    def __init__(self, n):\n        self.n = n+1\n        self.lt = [0]*self.n\n\n    def search(self, indx):\n        res = 0\n        while indx<self.n:\n            res += self.lt[indx]\n            indx += indx&(-indx)\n        return res\n\n    def update(self, indx):\n        while indx>0:\n            self.lt[indx] += 1\n            indx -= indx&(-indx)\n\n\nclass Solution:\n    # https://leetcode.com/problems/reverse-pairs/solutions/97268/general-principles-behind-problems-similar-to-reverse-pairs/\n    def reversePairs(self, nums: List[int]) -> int:\n        res = 0\n        bit = BIT(len(nums)+1)\n\n        def binary_search(lt, target):\n            l, r = 0, len(lt)\n            while l<r:\n                m = l + ((r-l)>>1)\n                if target<=lt[m]:\n                    r = m\n                else:\n                    l = m+1\n            return l\n\n        new = sorted(nums)\n        for x in nums:\n            indx = binary_search(new, 2*x+1)+1\n            res += bit.search(indx)\n            indx = binary_search(new, x)+1\n            bit.update(indx)\n        return res\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = randint(1, 100)\n        nums = [randint(-2 ** 31, 2 ** 31 - 1) for _ in range(n)]\n        return {'nums': nums}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['nums'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'nums': eval(input_str)}\n\n    def decode_output(self, output_str) -> int:\n        return int(output_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.reversePairs(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.065",
            "memory": 5112,
            "stderr": null,
            "token": "e16debed-f962-4c5f-a6ab-9aeac3c02d28",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 495,
        "title": "teemo-attacking",
        "token": "deb42094-78c2-4c90-b577-7a99a713a77e",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\nfrom ast import literal_eval\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def findPoisonedDuration(self, timeSeries: List[int], duration: int) -> int:\n        n = len(timeSeries)\n        res = 0\n        if n == 0:\n            return 0\n        \n        for i in range(n - 1):\n            res += min(duration, timeSeries[i + 1] - timeSeries[i])\n        return res + duration\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(1, 20)\n        time_series = sorted(random.sample(range(1, 100), length))\n        duration = random.randint(1, 10)\n        return {'timeSeries': time_series, 'duration': duration}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return literal_eval(input_str)\n\n    def decode_output(self, output_str) -> int:\n        return int(output_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.findPoisonedDuration(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.057",
            "memory": 5104,
            "stderr": null,
            "token": "deb42094-78c2-4c90-b577-7a99a713a77e",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 496,
        "title": "next-greater-element-i",
        "token": "11fba045-86e7-4ea7-9b6a-d3e861f7a022",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        res_out = []\n        for i in nums1:\n            target = nums2[(nums2.index(i)+1) : ]\n            found = [j for j in target if j > i]\n            if len(found) == 0:\n                res = -1\n            else:\n                res = found[0]\n            res_out.append(res)\n        return res_out\n\nclass TestCaseGenerator:\n\n    def __init__(self):\n        pass\n\n    @staticmethod\n    def generate() -> dict:\n        nums2_length = random.randint(2, 10)\n        nums2 = random.sample(range(0, 1000), nums2_length)\n        nums1_length = random.randint(1, nums2_length)\n        nums1 = random.sample(nums2, nums1_length)\n        return {'nums1': nums1, 'nums2': nums2}\n\n    @staticmethod\n    def encode_input(input_obj) -> str:\n        return f\"{input_obj['nums1']}, {input_obj['nums2']}\"\n\n    @staticmethod\n    def encode_output(output_obj) -> str:\n        return f'{output_obj}'\n\n    @staticmethod\n    def decode_input(input_str) -> dict:\n        nums1_str, nums2_str = input_str.split('],')\n        nums1 = list(map(int, nums1_str.strip('[] ').split(',')))\n        nums2 = list(map(int, nums2_str.strip('[] ').strip().split(',')))\n        return {'nums1': nums1, 'nums2': nums2}\n\n    @staticmethod\n    def decode_output(output_str) -> list:\n        return list(map(int, output_str.strip('[] ').split(',')))\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.nextGreaterElement(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.056",
            "memory": 4792,
            "stderr": null,
            "token": "11fba045-86e7-4ea7-9b6a-d3e861f7a022",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 830,
        "title": "largest-triangle-area",
        "token": "3b4dc6a3-c562-4174-a62f-295fb31a8d80",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\nimport ast\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\n        res = 0\n        for x1, y1 in points:\n            for x2, y2 in points:\n                for x3, y3 in points:\n                    u1, v1 = x2 - x1, y2 - y1\n                    u2, v2 = x3 - x1, y3 - y1\n                    area = abs(u1 * v2 - u2 * v1) / 2\n                    res = max(res, area)\n        return res\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        num_points = random.randint(3, 50)\n        points = [[random.randint(-50, 50), random.randint(-50, 50)] for _ in range(num_points)]\n        points = list(map(list, set(map(tuple, points))))\n        return {'points': points}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['points'])\n\n    def encode_output(self, output_obj) -> str:\n        return f'{output_obj:.5f}'\n\n    def decode_input(self, input_str) -> dict:\n        return {'points': ast.literal_eval(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.largestTriangleArea(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.394",
            "memory": 5292,
            "stderr": null,
            "token": "3b4dc6a3-c562-4174-a62f-295fb31a8d80",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 861,
        "title": "flipping-an-image",
        "token": "479eab4a-db5c-4778-b22f-cd8b47c14454",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\n        for i in range(len(image)):\n            image[i] = (image[i][::-1])\n        for j in range(0, len(image)):\n            for k in range(0, len(image[j])):\n                if image[j][k] == 0:\n                    image[j][k] = 1 \n                else:\n                    image[j][k] = 0\n        return image\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 5)\n        image = [[random.choice([0, 1]) for _ in range(n)] for _ in range(n)]\n        return {'image': image}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['image'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'image': eval(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.flipAndInvertImage(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.068",
            "memory": 4776,
            "stderr": null,
            "token": "479eab4a-db5c-4778-b22f-cd8b47c14454",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 741,
        "title": "cherry-pickup",
        "token": "11f68839-b181-4d86-9267-07a0986b08fe",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\nimport json\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def cherryPickup(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        dp = [[[-float('inf')] * n for _ in range(n)] for _ in range(2 * n - 1)]\n        dp[0][0][0] = grid[0][0]  # Base case\n\n        for k in range(1, 2 * n - 1):\n            for x1 in range(max(0, k - (n - 1)), min(n, k + 1)):\n                for x2 in range(max(0, k - (n - 1)), min(n, k + 1)):\n                    y1, y2 = k - x1, k - x2\n                    if grid[x1][y1] == -1 or grid[x2][y2] == -1:\n                        continue\n\n                    best = -float('inf')\n                    for d1 in [0, 1]:\n                        for d2 in [0, 1]:\n                            px1, px2 = x1 - d1, x2 - d2\n                            if px1 >= 0 and px2 >= 0:\n                                best = max(best, dp[k-1][px1][px2])\n\n                    if best == -float('inf'):\n                        continue\n                    \n                    dp[k][x1][x2] = best + grid[x1][y1]\n                    if x1!= x2:\n                        dp[k][x1][x2] += grid[x2][y2]\n\n        return max(0, dp[2*n-2][n-1][n-1])\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 6)\n        grid = [[random.choice([0, 1, -1]) for _ in range(n)] for _ in range(n)]\n        grid[0][0] = random.choice([0, 1])\n        grid[n - 1][n - 1] = random.choice([0, 1])\n        for i in range(n):\n            grid[i][0] = random.choice([0, 1])\n        for j in range(n):\n            grid[n - 1][j] = random.choice([0, 1])\n        return {'grid': grid}\n\n    def encode_input(self, input_obj) -> str:\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return json.loads(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.cherryPickup(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.075",
            "memory": 4804,
            "stderr": null,
            "token": "11f68839-b181-4d86-9267-07a0986b08fe",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 750,
        "title": "contain-virus",
        "token": "e7a6bcb5-21d4-4657-9374-1417cc7dda12",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def containVirus(self, mat: List[List[int]]) -> int:\n        m, n = len(mat), len(mat[0])\n        DIRECTIONS = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        \n        def dfs(i, j, visited):\n            if not (0 <= i < m and 0 <= j < n) or (i, j) in visited:\n                return set(), 0\n            if mat[i][j] == 2:\n                return set(), 0\n            elif mat[i][j] == 0:\n                return {(i, j)}, 1\n            \n            visited.add((i, j))\n            infected, walls = set(), 0\n            for dx, dy in DIRECTIONS:\n                ni, nj = i + dx, j + dy\n                next_infected, next_walls = dfs(ni, nj, visited)\n                infected |= next_infected\n                walls += next_walls\n            return infected, walls\n        \n        def quarantine(i, j):\n            if 0 <= i < m and 0 <= j < n and mat[i][j] == 1:\n                mat[i][j] = 2\n                for dx, dy in DIRECTIONS:\n                    quarantine(i + dx, j + dy)\n        \n        ans = 0\n        while True:\n            visited, regions = set(), []\n            for i in range(m):\n                for j in range(n):\n                    if mat[i][j] == 1 and (i, j) not in visited:\n                        infected, walls = dfs(i, j, visited)\n                        if infected:\n                            regions.append((infected, walls, (i, j)))\n            \n            if not regions:\n                break\n            \n            regions.sort(key=lambda x: (-len(x[0]), x[1]))\n            max_infected, max_walls, start = regions[0]\n            ans += max_walls\n            quarantine(*start)\n            \n            for region in regions[1:]:\n                for i, j in region[0]:\n                    mat[i][j] = 1\n        \n        return ans\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        m = random.randint(1, 50)\n        n = random.randint(1, 50)\n        isInfected = [[random.choice([0, 1]) for _ in range(n)] for _ in range(m)]\n        return {'isInfected': isInfected}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return eval(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.containVirus(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": null,
            "time": "0.072",
            "memory": 5480,
            "stderr": "Traceback (most recent call last):\n  File \"script.py\", line 147, in <module>\n    runner.run()\n  File \"script.py\", line 131, in run\n    output = self.solution.containVirus(**input)\nTypeError: containVirus() got an unexpected keyword argument 'isInfected'\n",
            "token": "e7a6bcb5-21d4-4657-9374-1417cc7dda12",
            "compile_output": null,
            "message": "Exited with error status 1",
            "status": {
                "id": 11,
                "description": "Runtime Error (NZEC)"
            }
        }
    },
    {
        "status": "success",
        "question_id": 699,
        "title": "falling-squares",
        "token": "80e4a33c-9868-4dc4-9954-3b77f480e1dc",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom bisect import bisect_right, bisect_left\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Node:\n    def __init__(self, l, r):\n        self.l = l\n        self.r = r\n        self.mid = (l + r) // 2\n        self.v = 0\n        self.add = 0\n        self.left = None\n        self.right = None\n\nclass SegmentTree:\n    def __init__(self):\n        self.root = Node(1, int(1e9))\n\n    def modify(self, l, r, v, node=None):\n        if node is None:\n            node = self.root\n        if l > r:\n            return\n        if node.l >= l and node.r <= r:\n            node.v = v\n            node.add = v\n            return\n        self.pushdown(node)\n        if l <= node.mid:\n            self.modify(l, r, v, node.left)\n        if r > node.mid:\n            self.modify(l, r, v, node.right)\n        self.pushup(node)\n\n    def query(self, l, r, node=None):\n        if node is None:\n            node = self.root\n        if l > r:\n            return 0\n        if node.l >= l and node.r <= r:\n            return node.v\n        self.pushdown(node)\n        v = 0\n        if l <= node.mid:\n            v = max(v, self.query(l, r, node.left))\n        if r > node.mid:\n            v = max(v, self.query(l, r, node.right))\n        return v\n\n    def pushup(self, node):\n        if node.left and node.right:\n            node.v = max(node.left.v, node.right.v)\n\n    def pushdown(self, node):\n        if node.left is None:\n            node.left = Node(node.l, node.mid)\n        if node.right is None:\n            node.right = Node(node.mid + 1, node.r)\n        if node.add!= 0:\n            node.left.add = node.add\n            node.right.add = node.add\n            node.left.v = node.add\n            node.right.v = node.add\n            node.add = 0\n\nclass Solution:\n    def fallingSquares(self, positions):\n        ans = []\n        tree = SegmentTree()\n        mx = 0\n        for pos in positions:\n            l, w = pos\n            r = l + w - 1\n            h = tree.query(l, r) + w\n            mx = max(mx, h)\n            ans.append(mx)\n            tree.modify(l, r, h)\n        return ans\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        n = random.randint(1, 10)\n        positions = [[random.randint(1, 100), random.randint(1, 10)] for _ in range(n)]\n        return {'positions': positions}\n\n    def encode_input(self, input_obj) -> str:\n        return str(input_obj['positions'])\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'positions': eval(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.fallingSquares(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.067",
            "memory": 4968,
            "stderr": null,
            "token": "80e4a33c-9868-4dc4-9954-3b77f480e1dc",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 779,
        "title": "max-chunks-to-make-sorted-ii",
        "token": "dee8e439-1eb9-4110-8fc8-85a6b9c5e3c1",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List\nimport random\nimport json\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nfrom bisect import insort\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        st=sorted(arr)\n        ans=0\n        res=[]\n        for n in arr:\n            insort(res,n)\n            if res==st[:len(res)]:\n                ans += 1\n        return ans\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(1, 10)\n        arr = [random.randint(0, 100) for _ in range(length)]\n        return {'arr': arr}\n\n    def encode_input(self, input_obj) -> str:\n        return json.dumps(input_obj)\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return json.loads(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.maxChunksToSorted(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.064",
            "memory": 4760,
            "stderr": null,
            "token": "dee8e439-1eb9-4110-8fc8-85a6b9c5e3c1",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 759,
        "title": "set-intersection-size-at-least-two",
        "token": "50349d37-701a-459a-ba18-886160de16d5",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nfrom typing import List, Dict\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def intersectionSizeTwo(self, intervals: List[List[int]]) -> int:\n        # [1, 2, 3] 0  0  0  0  0  0\n        #  0  0 [3, 4, 5, 6, 7] 0  0\n        #  0  0  0  0  0  0  0 [8, 9]\n\n        # [1, 2, 3] 0  0\n        # [1, 2, 3, 4] 0\n        #  0 [2, 3, 4, 5]\n        #  0  0 [3, 4, 5]\n\n        # dependent on ends of intervals -> anything between two extremes will always be included\n        # need to find where to start set\n        intervals.sort(key = lambda x:x[1])\n        size = 0\n        prev_start = -1\n        prev_end = -1\n\n        for curr_start, curr_end in intervals:\n            if prev_start == -1 or prev_end < curr_start: #if intervals do not overlap\n                size += 2\n                prev_start = curr_end-1\n                prev_end = curr_end\n\n            elif prev_start < curr_start: #if intervals overlap\n                if prev_end!= curr_end:\n                    prev_start = prev_end\n                    prev_end = curr_end\n                    \n                else:\n                    prev_start = curr_end-1\n                    prev_end = curr_end\n\n                size += 1\n\n        return size\n\nclass TestCaseGenerator:\n\n    def generate(self) -> Dict[str, List[List[int]]]:\n        return {'intervals': [[1, 3], [3, 7], [8, 9]]}\n\n    def encode_input(self, input_obj: Dict[str, List[List[int]]]) -> str:\n        return str(input_obj['intervals'])\n\n    def encode_output(self, output_obj: int) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str: str) -> Dict[str, List[List[int]]]:\n        return {'intervals': eval(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.intersectionSizeTwo(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.065",
            "memory": 4732,
            "stderr": null,
            "token": "50349d37-701a-459a-ba18-886160de16d5",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 854,
        "title": "making-a-large-island",
        "token": "3c22a139-9be4-48c5-90bc-6671fb939385",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nfrom typing import List, Dict, Any\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def largestIsland(self, grid: List[List[int]]) -> int:\n        \n        directions = {(-1, 0), (1, 0), (0, -1), (0, 1)}\n        uniqueKey = 0\n        positionToArea = {}\n        def findAndSetArea(row, col):\n            queue = [(row, col)]\n            visited = set()\n            visited.add((row, col))\n\n            area = 0\n            while queue:\n                row, col = queue.pop(0)\n                area += 1\n\n                for direction in directions:\n                    nextRow, nextCol = row + direction[0], col + direction[1]\n                    if ( 0 <= nextRow < len(grid) and \n                         0 <= nextCol < len(grid[0]) and \n                         grid[nextRow][nextCol] and \n                         (nextRow, nextCol) not in visited\n                    ): \n                        queue.append((nextRow, nextCol))\n                        grid[nextRow][nextCol] = -1\n                        visited.add((nextRow, nextCol))\n            \n            for r, c in visited:\n                positionToArea[(r, c)] = [uniqueKey, area]\n            return area\n\n        maxArea = 0\n        zeroPositions = set()\n        for row in range(len(grid)):\n            for col in range(len(grid[0])):\n                if grid[row][col] == 1: \n                    area = findAndSetArea(row, col)\n                    uniqueKey += 1\n                    maxArea = max(maxArea, area)\n                elif grid[row][col] == 0: zeroPositions.add((row, col))\n        \n        for row, col in zeroPositions:\n            areaWithThis0 = 1\n            keys = set()\n            for direction in directions:\n                nextRow, nextCol = row + direction[0], col + direction[1]\n                key, area = positionToArea.get((nextRow, nextCol), [-1, 0])\n                if key not in keys:\n                    keys.add(key)\n                    areaWithThis0 += area\n            maxArea = max(maxArea, areaWithThis0)\n        \n        return maxArea\n\nclass TestCaseGenerator:\n\n    def generate(self) -> Dict[str, Any]:\n        grid_variants = [[[1, 0], [0, 1]], [[1, 1], [1, 0]], [[1, 1], [1, 1]], [[0, 0, 1], [0, 1, 0], [0, 0, 0]], [[1]], [[0]]]\n        grid = random.choice(grid_variants)\n        return {'grid': grid}\n\n    def encode_input(self, input_obj: Dict[str, Any]) -> str:\n        return str(input_obj['grid'])\n\n    def encode_output(self, output_obj: int) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str: str) -> Dict[str, List[List[int]]]:\n        import ast\n        return {'grid': ast.literal_eval(input_str)}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.largestIsland(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.078",
            "memory": 5076,
            "stderr": null,
            "token": "3c22a139-9be4-48c5-90bc-6671fb939385",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 855,
        "title": "count-unique-characters-of-all-substrings-of-a-given-string",
        "token": "594283f3-97c0-4487-a117-e63003a46ac3",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def uniqueLetterString(self, s: str) -> int:\n        last_exists = collections.defaultdict(lambda: [-1, -1])\n        res = 0\n        for i, c in enumerate(s):\n            last_exists[c][0], last_exists[c][1] = i, last_exists[c][0]\n            for _, exists in last_exists.items(): res += exists[0] - exists[1]\n        return res\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(1, 10 ** 5)\n        s = ''.join(random.choices('ABCDEFGHIJKLMNOPQRSTUVWXYZ', k=length))\n        return {'s': s}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['s']\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.uniqueLetterString(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "2.196",
            "memory": 19364,
            "stderr": null,
            "token": "594283f3-97c0-4487-a117-e63003a46ac3",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "success",
        "question_id": 856,
        "title": "consecutive-numbers-sum",
        "token": "0f2bea21-f5c9-41b0-ad5a-bf069e743b65",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport random\nimport json \n\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def consecutiveNumbersSum(self, n: int) -> int:\n        w = 0\n        k = 1\n        while k * (k + 1) / 2 <= n:\n            if (n - k * (k - 1) / 2) % k == 0:\n                w += 1\n            k += 1\n\n        return w\n\nclass TestCaseGenerator:\n\n    def __init__(self):\n        pass\n\n    def generate(self) -> dict:\n        n = random.randint(1, 1000)\n        return {'n': n}\n\n    def encode_input(self, input_obj) -> str:\n        return '{\"n\": %d}' % input_obj['n']\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        from json import loads\n        return loads(input_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.consecutiveNumbersSum(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Tests Passed!\n",
            "time": "0.061",
            "memory": 4840,
            "stderr": null,
            "token": "0f2bea21-f5c9-41b0-ad5a-bf069e743b65",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 3,
                "description": "Accepted"
            }
        }
    },
    {
        "status": "failure",
        "question_id": 552,
        "title": "student-attendance-record-ii",
        "token": null,
        "error": "No test case decoder found",
        "code": null
    },
    {
        "status": "success",
        "question_id": 939,
        "title": "valid-permutations-for-di-sequence",
        "token": "5425f922-a10d-4224-ae22-caa1ad5855c3",
        "error": null,
        "code": "\nimport json\nimport itertools\nimport collections\nimport heapq\nimport bisect\nimport string\nimport sys\nimport functools\nimport math\nimport copy\nimport re\n# import numpy as np\n# import pandas as pd\n\nfrom math import floor, ceil, factorial, sqrt, inf\nfrom sys import maxsize, stdin\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, zip_longest\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom typing import List, Optional, Tuple\nfrom functools import lru_cache\n# from sortedcontainers import SortedList\n\nimport hashlib\nimport random\n\n### LC DATA STRUCTURES START ###\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n### LC DATA STRUCTURES END ###\n\nclass Solution:\n    def numPermsDISequence(self, s: str) -> int:\n        mem=defaultdict(int)\n        def dfs(i,val=0):\n            if i==len(s):\n                return 1\n            if (i,val) in mem:\n                return mem[i,val]\n            p=0\n            if s[i]==\"D\":\n                for ind in range(0,val+1):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            else:\n                for ind in range(val+1,i+2):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            mem[i,val]=p\n            return p\n        return dfs(0)\n\nclass TestCaseGenerator:\n\n    def generate(self) -> dict:\n        length = random.randint(1, 200)\n        pattern = ''.join((random.choice('DI') for _ in range(length)))\n        return {'s': pattern}\n\n    def encode_input(self, input_obj) -> str:\n        return input_obj['s']\n\n    def encode_output(self, output_obj) -> str:\n        return str(output_obj)\n\n    def decode_input(self, input_str) -> dict:\n        return {'s': input_str}\n\n    def decode_output(self, output_str) -> int:\n        return int(output_str)\n\nclass Runner:\n    def __init__(self, solution: Solution):\n        self.solution: Solution = solution\n        self.test = TestCaseGenerator()\n        self.num_tests = 10 # Change dynamically\n    \n    def run(self):\n        test_cases = json.loads(sys.stdin.read().strip())\n\n        for i in range(min(self.num_tests,len(test_cases))):\n            test_case = test_cases[i]\n            input = self.test.decode_input(test_case['input'])\n            expected_output = test_case['output']\n            \n            output = self.solution.numPermsDISequence(**input)\n            actual_output = self.test.encode_output(output)\n            \n            if actual_output != expected_output:\n                print(\"Input\", input)\n                print(\"Expected Output: \", expected_output)\n                print(\"Actual Output: \", actual_output)\n                print(f\"{i+1} Test Failed!\")\n                return\n        \n        #print metadata to stderr\n        print(\"Tests Passed!\")\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    runner = Runner(solution)\n    runner.run()\n",
        "submission_details": {
            "stdout": "Input {'s': 'DDDIIDIIIIDIDIDIIIDIDDIIIDDDDIIIDDIIIIDDIDIIDIIIIIDDIIDIIDIIDIIIIDIIDIDIIIDIIIDIIIIIDDIDIIIDIDIDDIDIIDIDDIIDIIDDDDIDIIIID'}\nExpected Output:  []\nActual Output:  463618668\n1 Test Failed!\n",
            "time": "0.301",
            "memory": 7112,
            "stderr": null,
            "token": "5425f922-a10d-4224-ae22-caa1ad5855c3",
            "compile_output": null,
            "message": null,
            "status": {
                "id": 4,
                "description": "Wrong Answer"
            }
        }
    }
]